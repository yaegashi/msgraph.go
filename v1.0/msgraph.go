// Code generated by msgraph-generate.go DO NOT EDIT.

package msgraph

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"time"
)

const (
	defaultBaseURL = "https://graph.microsoft.com/v1.0"
)

// Binary undocumented
type Binary []byte

// Stream undocumented
type Stream []byte

// UUID undocumented
type UUID string

// Paging undocumented
type Paging struct {
	NextLink string          `json:"@odata.nextLink"`
	Value    json.RawMessage `json:"value"`
}

// ServiceBase undocumented
type ServiceBase struct {
	baseURL string
	client  *http.Client
}

// URL undocumented
func (s *ServiceBase) URL() string {
	return s.baseURL
}

// Client undocumented
func (s *ServiceBase) Client() *http.Client {
	return s.client
}

// Service undocumented
type Service struct {
	ServiceBase
}

// NewService undocumented
func NewService(cli *http.Client) *Service {
	return &Service{
		ServiceBase: ServiceBase{
			baseURL: defaultBaseURL,
			client:  cli,
		},
	}
}

// ActionState undocumented
type ActionState int

const (
	// ActionState_None undocumented
	ActionState_None ActionState = 0
	// ActionState_Pending undocumented
	ActionState_Pending ActionState = 1
	// ActionState_Canceled undocumented
	ActionState_Canceled ActionState = 2
	// ActionState_Active undocumented
	ActionState_Active ActionState = 3
	// ActionState_Done undocumented
	ActionState_Done ActionState = 4
	// ActionState_Failed undocumented
	ActionState_Failed ActionState = 5
	// ActionState_NotSupported undocumented
	ActionState_NotSupported ActionState = 6
)

// ActivityDomain undocumented
type ActivityDomain int

const (
	// ActivityDomain_Unknown undocumented
	ActivityDomain_Unknown ActivityDomain = 0
	// ActivityDomain_Work undocumented
	ActivityDomain_Work ActivityDomain = 1
	// ActivityDomain_Personal undocumented
	ActivityDomain_Personal ActivityDomain = 2
	// ActivityDomain_Unrestricted undocumented
	ActivityDomain_Unrestricted ActivityDomain = 3
)

// AlertFeedback undocumented
type AlertFeedback int

const (
	// AlertFeedback_Unknown undocumented
	AlertFeedback_Unknown AlertFeedback = 0
	// AlertFeedback_TruePositive undocumented
	AlertFeedback_TruePositive AlertFeedback = 1
	// AlertFeedback_FalsePositive undocumented
	AlertFeedback_FalsePositive AlertFeedback = 2
	// AlertFeedback_BenignPositive undocumented
	AlertFeedback_BenignPositive AlertFeedback = 3
	// AlertFeedback_UnknownFutureValue undocumented
	AlertFeedback_UnknownFutureValue AlertFeedback = 127
)

// AlertSeverity undocumented
type AlertSeverity int

const (
	// AlertSeverity_Unknown undocumented
	AlertSeverity_Unknown AlertSeverity = 0
	// AlertSeverity_Informational undocumented
	AlertSeverity_Informational AlertSeverity = 1
	// AlertSeverity_Low undocumented
	AlertSeverity_Low AlertSeverity = 2
	// AlertSeverity_Medium undocumented
	AlertSeverity_Medium AlertSeverity = 3
	// AlertSeverity_High undocumented
	AlertSeverity_High AlertSeverity = 4
	// AlertSeverity_UnknownFutureValue undocumented
	AlertSeverity_UnknownFutureValue AlertSeverity = 127
)

// AlertStatus undocumented
type AlertStatus int

const (
	// AlertStatus_Unknown undocumented
	AlertStatus_Unknown AlertStatus = 0
	// AlertStatus_NewAlert undocumented
	AlertStatus_NewAlert AlertStatus = 1
	// AlertStatus_InProgress undocumented
	AlertStatus_InProgress AlertStatus = 2
	// AlertStatus_Resolved undocumented
	AlertStatus_Resolved AlertStatus = 3
	// AlertStatus_Dismissed undocumented
	AlertStatus_Dismissed AlertStatus = 4
	// AlertStatus_UnknownFutureValue undocumented
	AlertStatus_UnknownFutureValue AlertStatus = 127
)

// AndroidRequiredPasswordType undocumented
type AndroidRequiredPasswordType int

const (
	// AndroidRequiredPasswordType_DeviceDefault undocumented
	AndroidRequiredPasswordType_DeviceDefault AndroidRequiredPasswordType = 0
	// AndroidRequiredPasswordType_Alphabetic undocumented
	AndroidRequiredPasswordType_Alphabetic AndroidRequiredPasswordType = 1
	// AndroidRequiredPasswordType_Alphanumeric undocumented
	AndroidRequiredPasswordType_Alphanumeric AndroidRequiredPasswordType = 2
	// AndroidRequiredPasswordType_AlphanumericWithSymbols undocumented
	AndroidRequiredPasswordType_AlphanumericWithSymbols AndroidRequiredPasswordType = 3
	// AndroidRequiredPasswordType_LowSecurityBiometric undocumented
	AndroidRequiredPasswordType_LowSecurityBiometric AndroidRequiredPasswordType = 4
	// AndroidRequiredPasswordType_Numeric undocumented
	AndroidRequiredPasswordType_Numeric AndroidRequiredPasswordType = 5
	// AndroidRequiredPasswordType_NumericComplex undocumented
	AndroidRequiredPasswordType_NumericComplex AndroidRequiredPasswordType = 6
	// AndroidRequiredPasswordType_Any undocumented
	AndroidRequiredPasswordType_Any AndroidRequiredPasswordType = 7
)

// AndroidWorkProfileCrossProfileDataSharingType undocumented
type AndroidWorkProfileCrossProfileDataSharingType int

const (
	// AndroidWorkProfileCrossProfileDataSharingType_DeviceDefault undocumented
	AndroidWorkProfileCrossProfileDataSharingType_DeviceDefault AndroidWorkProfileCrossProfileDataSharingType = 0
	// AndroidWorkProfileCrossProfileDataSharingType_PreventAny undocumented
	AndroidWorkProfileCrossProfileDataSharingType_PreventAny AndroidWorkProfileCrossProfileDataSharingType = 1
	// AndroidWorkProfileCrossProfileDataSharingType_AllowPersonalToWork undocumented
	AndroidWorkProfileCrossProfileDataSharingType_AllowPersonalToWork AndroidWorkProfileCrossProfileDataSharingType = 2
	// AndroidWorkProfileCrossProfileDataSharingType_NoRestrictions undocumented
	AndroidWorkProfileCrossProfileDataSharingType_NoRestrictions AndroidWorkProfileCrossProfileDataSharingType = 3
)

// AndroidWorkProfileDefaultAppPermissionPolicyType undocumented
type AndroidWorkProfileDefaultAppPermissionPolicyType int

const (
	// AndroidWorkProfileDefaultAppPermissionPolicyType_DeviceDefault undocumented
	AndroidWorkProfileDefaultAppPermissionPolicyType_DeviceDefault AndroidWorkProfileDefaultAppPermissionPolicyType = 0
	// AndroidWorkProfileDefaultAppPermissionPolicyType_Prompt undocumented
	AndroidWorkProfileDefaultAppPermissionPolicyType_Prompt AndroidWorkProfileDefaultAppPermissionPolicyType = 1
	// AndroidWorkProfileDefaultAppPermissionPolicyType_AutoGrant undocumented
	AndroidWorkProfileDefaultAppPermissionPolicyType_AutoGrant AndroidWorkProfileDefaultAppPermissionPolicyType = 2
	// AndroidWorkProfileDefaultAppPermissionPolicyType_AutoDeny undocumented
	AndroidWorkProfileDefaultAppPermissionPolicyType_AutoDeny AndroidWorkProfileDefaultAppPermissionPolicyType = 3
)

// AndroidWorkProfileRequiredPasswordType undocumented
type AndroidWorkProfileRequiredPasswordType int

const (
	// AndroidWorkProfileRequiredPasswordType_DeviceDefault undocumented
	AndroidWorkProfileRequiredPasswordType_DeviceDefault AndroidWorkProfileRequiredPasswordType = 0
	// AndroidWorkProfileRequiredPasswordType_LowSecurityBiometric undocumented
	AndroidWorkProfileRequiredPasswordType_LowSecurityBiometric AndroidWorkProfileRequiredPasswordType = 1
	// AndroidWorkProfileRequiredPasswordType_Required undocumented
	AndroidWorkProfileRequiredPasswordType_Required AndroidWorkProfileRequiredPasswordType = 2
	// AndroidWorkProfileRequiredPasswordType_AtLeastNumeric undocumented
	AndroidWorkProfileRequiredPasswordType_AtLeastNumeric AndroidWorkProfileRequiredPasswordType = 3
	// AndroidWorkProfileRequiredPasswordType_NumericComplex undocumented
	AndroidWorkProfileRequiredPasswordType_NumericComplex AndroidWorkProfileRequiredPasswordType = 4
	// AndroidWorkProfileRequiredPasswordType_AtLeastAlphabetic undocumented
	AndroidWorkProfileRequiredPasswordType_AtLeastAlphabetic AndroidWorkProfileRequiredPasswordType = 5
	// AndroidWorkProfileRequiredPasswordType_AtLeastAlphanumeric undocumented
	AndroidWorkProfileRequiredPasswordType_AtLeastAlphanumeric AndroidWorkProfileRequiredPasswordType = 6
	// AndroidWorkProfileRequiredPasswordType_AlphanumericWithSymbols undocumented
	AndroidWorkProfileRequiredPasswordType_AlphanumericWithSymbols AndroidWorkProfileRequiredPasswordType = 7
)

// AppListType undocumented
type AppListType int

const (
	// AppListType_None undocumented
	AppListType_None AppListType = 0
	// AppListType_AppsInListCompliant undocumented
	AppListType_AppsInListCompliant AppListType = 1
	// AppListType_AppsNotInListCompliant undocumented
	AppListType_AppsNotInListCompliant AppListType = 2
)

// AppLockerApplicationControlType undocumented
type AppLockerApplicationControlType int

const (
	// AppLockerApplicationControlType_NotConfigured undocumented
	AppLockerApplicationControlType_NotConfigured AppLockerApplicationControlType = 0
	// AppLockerApplicationControlType_EnforceComponentsAndStoreApps undocumented
	AppLockerApplicationControlType_EnforceComponentsAndStoreApps AppLockerApplicationControlType = 1
	// AppLockerApplicationControlType_AuditComponentsAndStoreApps undocumented
	AppLockerApplicationControlType_AuditComponentsAndStoreApps AppLockerApplicationControlType = 2
	// AppLockerApplicationControlType_EnforceComponentsStoreAppsAndSmartlocker undocumented
	AppLockerApplicationControlType_EnforceComponentsStoreAppsAndSmartlocker AppLockerApplicationControlType = 3
	// AppLockerApplicationControlType_AuditComponentsStoreAppsAndSmartlocker undocumented
	AppLockerApplicationControlType_AuditComponentsStoreAppsAndSmartlocker AppLockerApplicationControlType = 4
)

// ApplicationGuardBlockClipboardSharingType undocumented
type ApplicationGuardBlockClipboardSharingType int

const (
	// ApplicationGuardBlockClipboardSharingType_NotConfigured undocumented
	ApplicationGuardBlockClipboardSharingType_NotConfigured ApplicationGuardBlockClipboardSharingType = 0
	// ApplicationGuardBlockClipboardSharingType_BlockBoth undocumented
	ApplicationGuardBlockClipboardSharingType_BlockBoth ApplicationGuardBlockClipboardSharingType = 1
	// ApplicationGuardBlockClipboardSharingType_BlockHostToContainer undocumented
	ApplicationGuardBlockClipboardSharingType_BlockHostToContainer ApplicationGuardBlockClipboardSharingType = 2
	// ApplicationGuardBlockClipboardSharingType_BlockContainerToHost undocumented
	ApplicationGuardBlockClipboardSharingType_BlockContainerToHost ApplicationGuardBlockClipboardSharingType = 3
	// ApplicationGuardBlockClipboardSharingType_BlockNone undocumented
	ApplicationGuardBlockClipboardSharingType_BlockNone ApplicationGuardBlockClipboardSharingType = 4
)

// ApplicationGuardBlockFileTransferType undocumented
type ApplicationGuardBlockFileTransferType int

const (
	// ApplicationGuardBlockFileTransferType_NotConfigured undocumented
	ApplicationGuardBlockFileTransferType_NotConfigured ApplicationGuardBlockFileTransferType = 0
	// ApplicationGuardBlockFileTransferType_BlockImageAndTextFile undocumented
	ApplicationGuardBlockFileTransferType_BlockImageAndTextFile ApplicationGuardBlockFileTransferType = 1
	// ApplicationGuardBlockFileTransferType_BlockImageFile undocumented
	ApplicationGuardBlockFileTransferType_BlockImageFile ApplicationGuardBlockFileTransferType = 2
	// ApplicationGuardBlockFileTransferType_BlockNone undocumented
	ApplicationGuardBlockFileTransferType_BlockNone ApplicationGuardBlockFileTransferType = 3
	// ApplicationGuardBlockFileTransferType_BlockTextFile undocumented
	ApplicationGuardBlockFileTransferType_BlockTextFile ApplicationGuardBlockFileTransferType = 4
)

// ApplicationType undocumented
type ApplicationType int

const (
	// ApplicationType_Universal undocumented
	ApplicationType_Universal ApplicationType = 1
	// ApplicationType_Desktop undocumented
	ApplicationType_Desktop ApplicationType = 2
)

// AppliedConditionalAccessPolicyResult undocumented
type AppliedConditionalAccessPolicyResult int

const (
	// AppliedConditionalAccessPolicyResult_Success undocumented
	AppliedConditionalAccessPolicyResult_Success AppliedConditionalAccessPolicyResult = 0
	// AppliedConditionalAccessPolicyResult_Failure undocumented
	AppliedConditionalAccessPolicyResult_Failure AppliedConditionalAccessPolicyResult = 1
	// AppliedConditionalAccessPolicyResult_NotApplied undocumented
	AppliedConditionalAccessPolicyResult_NotApplied AppliedConditionalAccessPolicyResult = 2
	// AppliedConditionalAccessPolicyResult_NotEnabled undocumented
	AppliedConditionalAccessPolicyResult_NotEnabled AppliedConditionalAccessPolicyResult = 3
	// AppliedConditionalAccessPolicyResult_Unknown undocumented
	AppliedConditionalAccessPolicyResult_Unknown AppliedConditionalAccessPolicyResult = 4
	// AppliedConditionalAccessPolicyResult_UnknownFutureValue undocumented
	AppliedConditionalAccessPolicyResult_UnknownFutureValue AppliedConditionalAccessPolicyResult = 5
)

// AttendeeType undocumented
type AttendeeType int

const (
	// AttendeeType_Required undocumented
	AttendeeType_Required AttendeeType = 0
	// AttendeeType_Optional undocumented
	AttendeeType_Optional AttendeeType = 1
	// AttendeeType_Resource undocumented
	AttendeeType_Resource AttendeeType = 2
)

// AutomaticRepliesStatus undocumented
type AutomaticRepliesStatus int

const (
	// AutomaticRepliesStatus_Disabled undocumented
	AutomaticRepliesStatus_Disabled AutomaticRepliesStatus = 0
	// AutomaticRepliesStatus_AlwaysEnabled undocumented
	AutomaticRepliesStatus_AlwaysEnabled AutomaticRepliesStatus = 1
	// AutomaticRepliesStatus_Scheduled undocumented
	AutomaticRepliesStatus_Scheduled AutomaticRepliesStatus = 2
)

// AutomaticUpdateMode undocumented
type AutomaticUpdateMode int

const (
	// AutomaticUpdateMode_UserDefined undocumented
	AutomaticUpdateMode_UserDefined AutomaticUpdateMode = 0
	// AutomaticUpdateMode_NotifyDownload undocumented
	AutomaticUpdateMode_NotifyDownload AutomaticUpdateMode = 1
	// AutomaticUpdateMode_AutoInstallAtMaintenanceTime undocumented
	AutomaticUpdateMode_AutoInstallAtMaintenanceTime AutomaticUpdateMode = 2
	// AutomaticUpdateMode_AutoInstallAndRebootAtMaintenanceTime undocumented
	AutomaticUpdateMode_AutoInstallAndRebootAtMaintenanceTime AutomaticUpdateMode = 3
	// AutomaticUpdateMode_AutoInstallAndRebootAtScheduledTime undocumented
	AutomaticUpdateMode_AutoInstallAndRebootAtScheduledTime AutomaticUpdateMode = 4
	// AutomaticUpdateMode_AutoInstallAndRebootWithoutEndUserControl undocumented
	AutomaticUpdateMode_AutoInstallAndRebootWithoutEndUserControl AutomaticUpdateMode = 5
)

// BitLockerEncryptionMethod undocumented
type BitLockerEncryptionMethod int

const (
	// BitLockerEncryptionMethod_AesCbc128 undocumented
	BitLockerEncryptionMethod_AesCbc128 BitLockerEncryptionMethod = 3
	// BitLockerEncryptionMethod_AesCbc256 undocumented
	BitLockerEncryptionMethod_AesCbc256 BitLockerEncryptionMethod = 4
	// BitLockerEncryptionMethod_XtsAes128 undocumented
	BitLockerEncryptionMethod_XtsAes128 BitLockerEncryptionMethod = 6
	// BitLockerEncryptionMethod_XtsAes256 undocumented
	BitLockerEncryptionMethod_XtsAes256 BitLockerEncryptionMethod = 7
)

// BodyType undocumented
type BodyType int

const (
	// BodyType_Text undocumented
	BodyType_Text BodyType = 0
	// BodyType_Html undocumented
	BodyType_Html BodyType = 1
)

// CalendarColor undocumented
type CalendarColor int

const (
	// CalendarColor_LightBlue undocumented
	CalendarColor_LightBlue CalendarColor = 0
	// CalendarColor_LightGreen undocumented
	CalendarColor_LightGreen CalendarColor = 1
	// CalendarColor_LightOrange undocumented
	CalendarColor_LightOrange CalendarColor = 2
	// CalendarColor_LightGray undocumented
	CalendarColor_LightGray CalendarColor = 3
	// CalendarColor_LightYellow undocumented
	CalendarColor_LightYellow CalendarColor = 4
	// CalendarColor_LightTeal undocumented
	CalendarColor_LightTeal CalendarColor = 5
	// CalendarColor_LightPink undocumented
	CalendarColor_LightPink CalendarColor = 6
	// CalendarColor_LightBrown undocumented
	CalendarColor_LightBrown CalendarColor = 7
	// CalendarColor_LightRed undocumented
	CalendarColor_LightRed CalendarColor = 8
	// CalendarColor_MaxColor undocumented
	CalendarColor_MaxColor CalendarColor = 9
	// CalendarColor_Auto undocumented
	CalendarColor_Auto CalendarColor = -1
)

// CategoryColor undocumented
type CategoryColor int

const (
	// CategoryColor_Preset0 undocumented
	CategoryColor_Preset0 CategoryColor = 0
	// CategoryColor_Preset1 undocumented
	CategoryColor_Preset1 CategoryColor = 1
	// CategoryColor_Preset2 undocumented
	CategoryColor_Preset2 CategoryColor = 2
	// CategoryColor_Preset3 undocumented
	CategoryColor_Preset3 CategoryColor = 3
	// CategoryColor_Preset4 undocumented
	CategoryColor_Preset4 CategoryColor = 4
	// CategoryColor_Preset5 undocumented
	CategoryColor_Preset5 CategoryColor = 5
	// CategoryColor_Preset6 undocumented
	CategoryColor_Preset6 CategoryColor = 6
	// CategoryColor_Preset7 undocumented
	CategoryColor_Preset7 CategoryColor = 7
	// CategoryColor_Preset8 undocumented
	CategoryColor_Preset8 CategoryColor = 8
	// CategoryColor_Preset9 undocumented
	CategoryColor_Preset9 CategoryColor = 9
	// CategoryColor_Preset10 undocumented
	CategoryColor_Preset10 CategoryColor = 10
	// CategoryColor_Preset11 undocumented
	CategoryColor_Preset11 CategoryColor = 11
	// CategoryColor_Preset12 undocumented
	CategoryColor_Preset12 CategoryColor = 12
	// CategoryColor_Preset13 undocumented
	CategoryColor_Preset13 CategoryColor = 13
	// CategoryColor_Preset14 undocumented
	CategoryColor_Preset14 CategoryColor = 14
	// CategoryColor_Preset15 undocumented
	CategoryColor_Preset15 CategoryColor = 15
	// CategoryColor_Preset16 undocumented
	CategoryColor_Preset16 CategoryColor = 16
	// CategoryColor_Preset17 undocumented
	CategoryColor_Preset17 CategoryColor = 17
	// CategoryColor_Preset18 undocumented
	CategoryColor_Preset18 CategoryColor = 18
	// CategoryColor_Preset19 undocumented
	CategoryColor_Preset19 CategoryColor = 19
	// CategoryColor_Preset20 undocumented
	CategoryColor_Preset20 CategoryColor = 20
	// CategoryColor_Preset21 undocumented
	CategoryColor_Preset21 CategoryColor = 21
	// CategoryColor_Preset22 undocumented
	CategoryColor_Preset22 CategoryColor = 22
	// CategoryColor_Preset23 undocumented
	CategoryColor_Preset23 CategoryColor = 23
	// CategoryColor_Preset24 undocumented
	CategoryColor_Preset24 CategoryColor = 24
	// CategoryColor_None undocumented
	CategoryColor_None CategoryColor = -1
)

// ClonableTeamParts undocumented
type ClonableTeamParts int

const (
	// ClonableTeamParts_Apps undocumented
	ClonableTeamParts_Apps ClonableTeamParts = 1
	// ClonableTeamParts_Tabs undocumented
	ClonableTeamParts_Tabs ClonableTeamParts = 2
	// ClonableTeamParts_Settings undocumented
	ClonableTeamParts_Settings ClonableTeamParts = 4
	// ClonableTeamParts_Channels undocumented
	ClonableTeamParts_Channels ClonableTeamParts = 8
	// ClonableTeamParts_Members undocumented
	ClonableTeamParts_Members ClonableTeamParts = 16
)

// ComplianceState undocumented
type ComplianceState int

const (
	// ComplianceState_Unknown undocumented
	ComplianceState_Unknown ComplianceState = 0
	// ComplianceState_Compliant undocumented
	ComplianceState_Compliant ComplianceState = 1
	// ComplianceState_Noncompliant undocumented
	ComplianceState_Noncompliant ComplianceState = 2
	// ComplianceState_Conflict undocumented
	ComplianceState_Conflict ComplianceState = 3
	// ComplianceState_Error undocumented
	ComplianceState_Error ComplianceState = 4
	// ComplianceState_InGracePeriod undocumented
	ComplianceState_InGracePeriod ComplianceState = 254
	// ComplianceState_ConfigManager undocumented
	ComplianceState_ConfigManager ComplianceState = 255
)

// ComplianceStatus undocumented
type ComplianceStatus int

const (
	// ComplianceStatus_Unknown undocumented
	ComplianceStatus_Unknown ComplianceStatus = 0
	// ComplianceStatus_NotApplicable undocumented
	ComplianceStatus_NotApplicable ComplianceStatus = 1
	// ComplianceStatus_Compliant undocumented
	ComplianceStatus_Compliant ComplianceStatus = 2
	// ComplianceStatus_Remediated undocumented
	ComplianceStatus_Remediated ComplianceStatus = 3
	// ComplianceStatus_NonCompliant undocumented
	ComplianceStatus_NonCompliant ComplianceStatus = 4
	// ComplianceStatus_Error undocumented
	ComplianceStatus_Error ComplianceStatus = 5
	// ComplianceStatus_Conflict undocumented
	ComplianceStatus_Conflict ComplianceStatus = 6
	// ComplianceStatus_NotAssigned undocumented
	ComplianceStatus_NotAssigned ComplianceStatus = 7
)

// ConditionalAccessStatus undocumented
type ConditionalAccessStatus int

const (
	// ConditionalAccessStatus_Success undocumented
	ConditionalAccessStatus_Success ConditionalAccessStatus = 0
	// ConditionalAccessStatus_Failure undocumented
	ConditionalAccessStatus_Failure ConditionalAccessStatus = 1
	// ConditionalAccessStatus_NotApplied undocumented
	ConditionalAccessStatus_NotApplied ConditionalAccessStatus = 2
	// ConditionalAccessStatus_UnknownFutureValue undocumented
	ConditionalAccessStatus_UnknownFutureValue ConditionalAccessStatus = 3
)

// ConnectionDirection undocumented
type ConnectionDirection int

const (
	// ConnectionDirection_Unknown undocumented
	ConnectionDirection_Unknown ConnectionDirection = 0
	// ConnectionDirection_Inbound undocumented
	ConnectionDirection_Inbound ConnectionDirection = 1
	// ConnectionDirection_Outbound undocumented
	ConnectionDirection_Outbound ConnectionDirection = 2
	// ConnectionDirection_UnknownFutureValue undocumented
	ConnectionDirection_UnknownFutureValue ConnectionDirection = 127
)

// ConnectionStatus undocumented
type ConnectionStatus int

const (
	// ConnectionStatus_Unknown undocumented
	ConnectionStatus_Unknown ConnectionStatus = 0
	// ConnectionStatus_Attempted undocumented
	ConnectionStatus_Attempted ConnectionStatus = 1
	// ConnectionStatus_Succeeded undocumented
	ConnectionStatus_Succeeded ConnectionStatus = 2
	// ConnectionStatus_Blocked undocumented
	ConnectionStatus_Blocked ConnectionStatus = 3
	// ConnectionStatus_Failed undocumented
	ConnectionStatus_Failed ConnectionStatus = 4
	// ConnectionStatus_UnknownFutureValue undocumented
	ConnectionStatus_UnknownFutureValue ConnectionStatus = 127
)

// DataPolicyOperationStatus undocumented
type DataPolicyOperationStatus int

const (
	// DataPolicyOperationStatus_NotStarted undocumented
	DataPolicyOperationStatus_NotStarted DataPolicyOperationStatus = 0
	// DataPolicyOperationStatus_Running undocumented
	DataPolicyOperationStatus_Running DataPolicyOperationStatus = 1
	// DataPolicyOperationStatus_Complete undocumented
	DataPolicyOperationStatus_Complete DataPolicyOperationStatus = 2
	// DataPolicyOperationStatus_Failed undocumented
	DataPolicyOperationStatus_Failed DataPolicyOperationStatus = 3
	// DataPolicyOperationStatus_UnknownFutureValue undocumented
	DataPolicyOperationStatus_UnknownFutureValue DataPolicyOperationStatus = 4
)

// DayOfWeek undocumented
type DayOfWeek int

const (
	// DayOfWeek_Sunday undocumented
	DayOfWeek_Sunday DayOfWeek = 0
	// DayOfWeek_Monday undocumented
	DayOfWeek_Monday DayOfWeek = 1
	// DayOfWeek_Tuesday undocumented
	DayOfWeek_Tuesday DayOfWeek = 2
	// DayOfWeek_Wednesday undocumented
	DayOfWeek_Wednesday DayOfWeek = 3
	// DayOfWeek_Thursday undocumented
	DayOfWeek_Thursday DayOfWeek = 4
	// DayOfWeek_Friday undocumented
	DayOfWeek_Friday DayOfWeek = 5
	// DayOfWeek_Saturday undocumented
	DayOfWeek_Saturday DayOfWeek = 6
)

// DefenderCloudBlockLevelType undocumented
type DefenderCloudBlockLevelType int

const (
	// DefenderCloudBlockLevelType_NotConfigured undocumented
	DefenderCloudBlockLevelType_NotConfigured DefenderCloudBlockLevelType = 0
	// DefenderCloudBlockLevelType_High undocumented
	DefenderCloudBlockLevelType_High DefenderCloudBlockLevelType = 1
	// DefenderCloudBlockLevelType_HighPlus undocumented
	DefenderCloudBlockLevelType_HighPlus DefenderCloudBlockLevelType = 2
	// DefenderCloudBlockLevelType_ZeroTolerance undocumented
	DefenderCloudBlockLevelType_ZeroTolerance DefenderCloudBlockLevelType = 3
)

// DefenderMonitorFileActivity undocumented
type DefenderMonitorFileActivity int

const (
	// DefenderMonitorFileActivity_UserDefined undocumented
	DefenderMonitorFileActivity_UserDefined DefenderMonitorFileActivity = 0
	// DefenderMonitorFileActivity_Disable undocumented
	DefenderMonitorFileActivity_Disable DefenderMonitorFileActivity = 1
	// DefenderMonitorFileActivity_MonitorAllFiles undocumented
	DefenderMonitorFileActivity_MonitorAllFiles DefenderMonitorFileActivity = 2
	// DefenderMonitorFileActivity_MonitorIncomingFilesOnly undocumented
	DefenderMonitorFileActivity_MonitorIncomingFilesOnly DefenderMonitorFileActivity = 3
	// DefenderMonitorFileActivity_MonitorOutgoingFilesOnly undocumented
	DefenderMonitorFileActivity_MonitorOutgoingFilesOnly DefenderMonitorFileActivity = 4
)

// DefenderPromptForSampleSubmission undocumented
type DefenderPromptForSampleSubmission int

const (
	// DefenderPromptForSampleSubmission_UserDefined undocumented
	DefenderPromptForSampleSubmission_UserDefined DefenderPromptForSampleSubmission = 0
	// DefenderPromptForSampleSubmission_AlwaysPrompt undocumented
	DefenderPromptForSampleSubmission_AlwaysPrompt DefenderPromptForSampleSubmission = 1
	// DefenderPromptForSampleSubmission_PromptBeforeSendingPersonalData undocumented
	DefenderPromptForSampleSubmission_PromptBeforeSendingPersonalData DefenderPromptForSampleSubmission = 2
	// DefenderPromptForSampleSubmission_NeverSendData undocumented
	DefenderPromptForSampleSubmission_NeverSendData DefenderPromptForSampleSubmission = 3
	// DefenderPromptForSampleSubmission_SendAllDataWithoutPrompting undocumented
	DefenderPromptForSampleSubmission_SendAllDataWithoutPrompting DefenderPromptForSampleSubmission = 4
)

// DefenderScanType undocumented
type DefenderScanType int

const (
	// DefenderScanType_UserDefined undocumented
	DefenderScanType_UserDefined DefenderScanType = 0
	// DefenderScanType_Disabled undocumented
	DefenderScanType_Disabled DefenderScanType = 1
	// DefenderScanType_Quick undocumented
	DefenderScanType_Quick DefenderScanType = 2
	// DefenderScanType_Full undocumented
	DefenderScanType_Full DefenderScanType = 3
)

// DefenderThreatAction undocumented
type DefenderThreatAction int

const (
	// DefenderThreatAction_DeviceDefault undocumented
	DefenderThreatAction_DeviceDefault DefenderThreatAction = 0
	// DefenderThreatAction_Clean undocumented
	DefenderThreatAction_Clean DefenderThreatAction = 1
	// DefenderThreatAction_Quarantine undocumented
	DefenderThreatAction_Quarantine DefenderThreatAction = 2
	// DefenderThreatAction_Remove undocumented
	DefenderThreatAction_Remove DefenderThreatAction = 3
	// DefenderThreatAction_Allow undocumented
	DefenderThreatAction_Allow DefenderThreatAction = 4
	// DefenderThreatAction_UserDefined undocumented
	DefenderThreatAction_UserDefined DefenderThreatAction = 5
	// DefenderThreatAction_Block undocumented
	DefenderThreatAction_Block DefenderThreatAction = 6
)

// DeviceComplianceActionType undocumented
type DeviceComplianceActionType int

const (
	// DeviceComplianceActionType_NoAction undocumented
	DeviceComplianceActionType_NoAction DeviceComplianceActionType = 0
	// DeviceComplianceActionType_Notification undocumented
	DeviceComplianceActionType_Notification DeviceComplianceActionType = 1
	// DeviceComplianceActionType_Block undocumented
	DeviceComplianceActionType_Block DeviceComplianceActionType = 2
	// DeviceComplianceActionType_Retire undocumented
	DeviceComplianceActionType_Retire DeviceComplianceActionType = 3
	// DeviceComplianceActionType_Wipe undocumented
	DeviceComplianceActionType_Wipe DeviceComplianceActionType = 4
	// DeviceComplianceActionType_RemoveResourceAccessProfiles undocumented
	DeviceComplianceActionType_RemoveResourceAccessProfiles DeviceComplianceActionType = 5
	// DeviceComplianceActionType_PushNotification undocumented
	DeviceComplianceActionType_PushNotification DeviceComplianceActionType = 9
)

// DeviceEnrollmentFailureReason undocumented
type DeviceEnrollmentFailureReason int

const (
	// DeviceEnrollmentFailureReason_Unknown undocumented
	DeviceEnrollmentFailureReason_Unknown DeviceEnrollmentFailureReason = 0
	// DeviceEnrollmentFailureReason_Authentication undocumented
	DeviceEnrollmentFailureReason_Authentication DeviceEnrollmentFailureReason = 1
	// DeviceEnrollmentFailureReason_Authorization undocumented
	DeviceEnrollmentFailureReason_Authorization DeviceEnrollmentFailureReason = 2
	// DeviceEnrollmentFailureReason_AccountValidation undocumented
	DeviceEnrollmentFailureReason_AccountValidation DeviceEnrollmentFailureReason = 3
	// DeviceEnrollmentFailureReason_UserValidation undocumented
	DeviceEnrollmentFailureReason_UserValidation DeviceEnrollmentFailureReason = 4
	// DeviceEnrollmentFailureReason_DeviceNotSupported undocumented
	DeviceEnrollmentFailureReason_DeviceNotSupported DeviceEnrollmentFailureReason = 5
	// DeviceEnrollmentFailureReason_InMaintenance undocumented
	DeviceEnrollmentFailureReason_InMaintenance DeviceEnrollmentFailureReason = 6
	// DeviceEnrollmentFailureReason_BadRequest undocumented
	DeviceEnrollmentFailureReason_BadRequest DeviceEnrollmentFailureReason = 7
	// DeviceEnrollmentFailureReason_FeatureNotSupported undocumented
	DeviceEnrollmentFailureReason_FeatureNotSupported DeviceEnrollmentFailureReason = 8
	// DeviceEnrollmentFailureReason_EnrollmentRestrictionsEnforced undocumented
	DeviceEnrollmentFailureReason_EnrollmentRestrictionsEnforced DeviceEnrollmentFailureReason = 9
	// DeviceEnrollmentFailureReason_ClientDisconnected undocumented
	DeviceEnrollmentFailureReason_ClientDisconnected DeviceEnrollmentFailureReason = 10
	// DeviceEnrollmentFailureReason_UserAbandonment undocumented
	DeviceEnrollmentFailureReason_UserAbandonment DeviceEnrollmentFailureReason = 11
)

// DeviceEnrollmentType undocumented
type DeviceEnrollmentType int

const (
	// DeviceEnrollmentType_Unknown undocumented
	DeviceEnrollmentType_Unknown DeviceEnrollmentType = 0
	// DeviceEnrollmentType_UserEnrollment undocumented
	DeviceEnrollmentType_UserEnrollment DeviceEnrollmentType = 1
	// DeviceEnrollmentType_DeviceEnrollmentManager undocumented
	DeviceEnrollmentType_DeviceEnrollmentManager DeviceEnrollmentType = 2
	// DeviceEnrollmentType_AppleBulkWithUser undocumented
	DeviceEnrollmentType_AppleBulkWithUser DeviceEnrollmentType = 3
	// DeviceEnrollmentType_AppleBulkWithoutUser undocumented
	DeviceEnrollmentType_AppleBulkWithoutUser DeviceEnrollmentType = 4
	// DeviceEnrollmentType_WindowsAzureADJoin undocumented
	DeviceEnrollmentType_WindowsAzureADJoin DeviceEnrollmentType = 5
	// DeviceEnrollmentType_WindowsBulkUserless undocumented
	DeviceEnrollmentType_WindowsBulkUserless DeviceEnrollmentType = 6
	// DeviceEnrollmentType_WindowsAutoEnrollment undocumented
	DeviceEnrollmentType_WindowsAutoEnrollment DeviceEnrollmentType = 7
	// DeviceEnrollmentType_WindowsBulkAzureDomainJoin undocumented
	DeviceEnrollmentType_WindowsBulkAzureDomainJoin DeviceEnrollmentType = 8
	// DeviceEnrollmentType_WindowsCoManagement undocumented
	DeviceEnrollmentType_WindowsCoManagement DeviceEnrollmentType = 9
)

// DeviceManagementExchangeAccessState undocumented
type DeviceManagementExchangeAccessState int

const (
	// DeviceManagementExchangeAccessState_None undocumented
	DeviceManagementExchangeAccessState_None DeviceManagementExchangeAccessState = 0
	// DeviceManagementExchangeAccessState_Unknown undocumented
	DeviceManagementExchangeAccessState_Unknown DeviceManagementExchangeAccessState = 1
	// DeviceManagementExchangeAccessState_Allowed undocumented
	DeviceManagementExchangeAccessState_Allowed DeviceManagementExchangeAccessState = 2
	// DeviceManagementExchangeAccessState_Blocked undocumented
	DeviceManagementExchangeAccessState_Blocked DeviceManagementExchangeAccessState = 3
	// DeviceManagementExchangeAccessState_Quarantined undocumented
	DeviceManagementExchangeAccessState_Quarantined DeviceManagementExchangeAccessState = 4
)

// DeviceManagementExchangeAccessStateReason undocumented
type DeviceManagementExchangeAccessStateReason int

const (
	// DeviceManagementExchangeAccessStateReason_None undocumented
	DeviceManagementExchangeAccessStateReason_None DeviceManagementExchangeAccessStateReason = 0
	// DeviceManagementExchangeAccessStateReason_Unknown undocumented
	DeviceManagementExchangeAccessStateReason_Unknown DeviceManagementExchangeAccessStateReason = 1
	// DeviceManagementExchangeAccessStateReason_ExchangeGlobalRule undocumented
	DeviceManagementExchangeAccessStateReason_ExchangeGlobalRule DeviceManagementExchangeAccessStateReason = 2
	// DeviceManagementExchangeAccessStateReason_ExchangeIndividualRule undocumented
	DeviceManagementExchangeAccessStateReason_ExchangeIndividualRule DeviceManagementExchangeAccessStateReason = 3
	// DeviceManagementExchangeAccessStateReason_ExchangeDeviceRule undocumented
	DeviceManagementExchangeAccessStateReason_ExchangeDeviceRule DeviceManagementExchangeAccessStateReason = 4
	// DeviceManagementExchangeAccessStateReason_ExchangeUpgrade undocumented
	DeviceManagementExchangeAccessStateReason_ExchangeUpgrade DeviceManagementExchangeAccessStateReason = 5
	// DeviceManagementExchangeAccessStateReason_ExchangeMailboxPolicy undocumented
	DeviceManagementExchangeAccessStateReason_ExchangeMailboxPolicy DeviceManagementExchangeAccessStateReason = 6
	// DeviceManagementExchangeAccessStateReason_Other undocumented
	DeviceManagementExchangeAccessStateReason_Other DeviceManagementExchangeAccessStateReason = 7
	// DeviceManagementExchangeAccessStateReason_Compliant undocumented
	DeviceManagementExchangeAccessStateReason_Compliant DeviceManagementExchangeAccessStateReason = 8
	// DeviceManagementExchangeAccessStateReason_NotCompliant undocumented
	DeviceManagementExchangeAccessStateReason_NotCompliant DeviceManagementExchangeAccessStateReason = 9
	// DeviceManagementExchangeAccessStateReason_NotEnrolled undocumented
	DeviceManagementExchangeAccessStateReason_NotEnrolled DeviceManagementExchangeAccessStateReason = 10
	// DeviceManagementExchangeAccessStateReason_UnknownLocation undocumented
	DeviceManagementExchangeAccessStateReason_UnknownLocation DeviceManagementExchangeAccessStateReason = 12
	// DeviceManagementExchangeAccessStateReason_MfaRequired undocumented
	DeviceManagementExchangeAccessStateReason_MfaRequired DeviceManagementExchangeAccessStateReason = 13
	// DeviceManagementExchangeAccessStateReason_AzureADBlockDueToAccessPolicy undocumented
	DeviceManagementExchangeAccessStateReason_AzureADBlockDueToAccessPolicy DeviceManagementExchangeAccessStateReason = 14
	// DeviceManagementExchangeAccessStateReason_CompromisedPassword undocumented
	DeviceManagementExchangeAccessStateReason_CompromisedPassword DeviceManagementExchangeAccessStateReason = 15
	// DeviceManagementExchangeAccessStateReason_DeviceNotKnownWithManagedApp undocumented
	DeviceManagementExchangeAccessStateReason_DeviceNotKnownWithManagedApp DeviceManagementExchangeAccessStateReason = 16
)

// DeviceManagementExchangeConnectorStatus undocumented
type DeviceManagementExchangeConnectorStatus int

const (
	// DeviceManagementExchangeConnectorStatus_None undocumented
	DeviceManagementExchangeConnectorStatus_None DeviceManagementExchangeConnectorStatus = 0
	// DeviceManagementExchangeConnectorStatus_ConnectionPending undocumented
	DeviceManagementExchangeConnectorStatus_ConnectionPending DeviceManagementExchangeConnectorStatus = 1
	// DeviceManagementExchangeConnectorStatus_Connected undocumented
	DeviceManagementExchangeConnectorStatus_Connected DeviceManagementExchangeConnectorStatus = 2
	// DeviceManagementExchangeConnectorStatus_Disconnected undocumented
	DeviceManagementExchangeConnectorStatus_Disconnected DeviceManagementExchangeConnectorStatus = 3
)

// DeviceManagementExchangeConnectorSyncType undocumented
type DeviceManagementExchangeConnectorSyncType int

const (
	// DeviceManagementExchangeConnectorSyncType_FullSync undocumented
	DeviceManagementExchangeConnectorSyncType_FullSync DeviceManagementExchangeConnectorSyncType = 0
	// DeviceManagementExchangeConnectorSyncType_DeltaSync undocumented
	DeviceManagementExchangeConnectorSyncType_DeltaSync DeviceManagementExchangeConnectorSyncType = 1
)

// DeviceManagementExchangeConnectorType undocumented
type DeviceManagementExchangeConnectorType int

const (
	// DeviceManagementExchangeConnectorType_OnPremises undocumented
	DeviceManagementExchangeConnectorType_OnPremises DeviceManagementExchangeConnectorType = 0
	// DeviceManagementExchangeConnectorType_Hosted undocumented
	DeviceManagementExchangeConnectorType_Hosted DeviceManagementExchangeConnectorType = 1
	// DeviceManagementExchangeConnectorType_ServiceToService undocumented
	DeviceManagementExchangeConnectorType_ServiceToService DeviceManagementExchangeConnectorType = 2
	// DeviceManagementExchangeConnectorType_Dedicated undocumented
	DeviceManagementExchangeConnectorType_Dedicated DeviceManagementExchangeConnectorType = 3
)

// DeviceManagementPartnerAppType undocumented
type DeviceManagementPartnerAppType int

const (
	// DeviceManagementPartnerAppType_Unknown undocumented
	DeviceManagementPartnerAppType_Unknown DeviceManagementPartnerAppType = 0
	// DeviceManagementPartnerAppType_SingleTenantApp undocumented
	DeviceManagementPartnerAppType_SingleTenantApp DeviceManagementPartnerAppType = 1
	// DeviceManagementPartnerAppType_MultiTenantApp undocumented
	DeviceManagementPartnerAppType_MultiTenantApp DeviceManagementPartnerAppType = 2
)

// DeviceManagementPartnerTenantState undocumented
type DeviceManagementPartnerTenantState int

const (
	// DeviceManagementPartnerTenantState_Unknown undocumented
	DeviceManagementPartnerTenantState_Unknown DeviceManagementPartnerTenantState = 0
	// DeviceManagementPartnerTenantState_Unavailable undocumented
	DeviceManagementPartnerTenantState_Unavailable DeviceManagementPartnerTenantState = 1
	// DeviceManagementPartnerTenantState_Enabled undocumented
	DeviceManagementPartnerTenantState_Enabled DeviceManagementPartnerTenantState = 2
	// DeviceManagementPartnerTenantState_Terminated undocumented
	DeviceManagementPartnerTenantState_Terminated DeviceManagementPartnerTenantState = 3
	// DeviceManagementPartnerTenantState_Rejected undocumented
	DeviceManagementPartnerTenantState_Rejected DeviceManagementPartnerTenantState = 4
	// DeviceManagementPartnerTenantState_Unresponsive undocumented
	DeviceManagementPartnerTenantState_Unresponsive DeviceManagementPartnerTenantState = 5
)

// DeviceManagementSubscriptionState undocumented
type DeviceManagementSubscriptionState int

const (
	// DeviceManagementSubscriptionState_Pending undocumented
	DeviceManagementSubscriptionState_Pending DeviceManagementSubscriptionState = 0
	// DeviceManagementSubscriptionState_Active undocumented
	DeviceManagementSubscriptionState_Active DeviceManagementSubscriptionState = 1
	// DeviceManagementSubscriptionState_Warning undocumented
	DeviceManagementSubscriptionState_Warning DeviceManagementSubscriptionState = 2
	// DeviceManagementSubscriptionState_Disabled undocumented
	DeviceManagementSubscriptionState_Disabled DeviceManagementSubscriptionState = 3
	// DeviceManagementSubscriptionState_Deleted undocumented
	DeviceManagementSubscriptionState_Deleted DeviceManagementSubscriptionState = 4
	// DeviceManagementSubscriptionState_Blocked undocumented
	DeviceManagementSubscriptionState_Blocked DeviceManagementSubscriptionState = 5
	// DeviceManagementSubscriptionState_LockedOut undocumented
	DeviceManagementSubscriptionState_LockedOut DeviceManagementSubscriptionState = 8
)

// DeviceRegistrationState undocumented
type DeviceRegistrationState int

const (
	// DeviceRegistrationState_NotRegistered undocumented
	DeviceRegistrationState_NotRegistered DeviceRegistrationState = 0
	// DeviceRegistrationState_Registered undocumented
	DeviceRegistrationState_Registered DeviceRegistrationState = 2
	// DeviceRegistrationState_Revoked undocumented
	DeviceRegistrationState_Revoked DeviceRegistrationState = 3
	// DeviceRegistrationState_KeyConflict undocumented
	DeviceRegistrationState_KeyConflict DeviceRegistrationState = 4
	// DeviceRegistrationState_ApprovalPending undocumented
	DeviceRegistrationState_ApprovalPending DeviceRegistrationState = 5
	// DeviceRegistrationState_CertificateReset undocumented
	DeviceRegistrationState_CertificateReset DeviceRegistrationState = 6
	// DeviceRegistrationState_NotRegisteredPendingEnrollment undocumented
	DeviceRegistrationState_NotRegisteredPendingEnrollment DeviceRegistrationState = 7
	// DeviceRegistrationState_Unknown undocumented
	DeviceRegistrationState_Unknown DeviceRegistrationState = 8
)

// DeviceThreatProtectionLevel undocumented
type DeviceThreatProtectionLevel int

const (
	// DeviceThreatProtectionLevel_Unavailable undocumented
	DeviceThreatProtectionLevel_Unavailable DeviceThreatProtectionLevel = 0
	// DeviceThreatProtectionLevel_Secured undocumented
	DeviceThreatProtectionLevel_Secured DeviceThreatProtectionLevel = 1
	// DeviceThreatProtectionLevel_Low undocumented
	DeviceThreatProtectionLevel_Low DeviceThreatProtectionLevel = 2
	// DeviceThreatProtectionLevel_Medium undocumented
	DeviceThreatProtectionLevel_Medium DeviceThreatProtectionLevel = 3
	// DeviceThreatProtectionLevel_High undocumented
	DeviceThreatProtectionLevel_High DeviceThreatProtectionLevel = 4
	// DeviceThreatProtectionLevel_NotSet undocumented
	DeviceThreatProtectionLevel_NotSet DeviceThreatProtectionLevel = 10
)

// DiagnosticDataSubmissionMode undocumented
type DiagnosticDataSubmissionMode int

const (
	// DiagnosticDataSubmissionMode_UserDefined undocumented
	DiagnosticDataSubmissionMode_UserDefined DiagnosticDataSubmissionMode = 0
	// DiagnosticDataSubmissionMode_None undocumented
	DiagnosticDataSubmissionMode_None DiagnosticDataSubmissionMode = 1
	// DiagnosticDataSubmissionMode_Basic undocumented
	DiagnosticDataSubmissionMode_Basic DiagnosticDataSubmissionMode = 2
	// DiagnosticDataSubmissionMode_Enhanced undocumented
	DiagnosticDataSubmissionMode_Enhanced DiagnosticDataSubmissionMode = 3
	// DiagnosticDataSubmissionMode_Full undocumented
	DiagnosticDataSubmissionMode_Full DiagnosticDataSubmissionMode = 4
)

// EdgeCookiePolicy undocumented
type EdgeCookiePolicy int

const (
	// EdgeCookiePolicy_UserDefined undocumented
	EdgeCookiePolicy_UserDefined EdgeCookiePolicy = 0
	// EdgeCookiePolicy_Allow undocumented
	EdgeCookiePolicy_Allow EdgeCookiePolicy = 1
	// EdgeCookiePolicy_BlockThirdParty undocumented
	EdgeCookiePolicy_BlockThirdParty EdgeCookiePolicy = 2
	// EdgeCookiePolicy_BlockAll undocumented
	EdgeCookiePolicy_BlockAll EdgeCookiePolicy = 3
)

// EdgeSearchEngineType undocumented
type EdgeSearchEngineType int

const (
	// EdgeSearchEngineType_Default undocumented
	EdgeSearchEngineType_Default EdgeSearchEngineType = 0
	// EdgeSearchEngineType_Bing undocumented
	EdgeSearchEngineType_Bing EdgeSearchEngineType = 1
)

// EditionUpgradeLicenseType undocumented
type EditionUpgradeLicenseType int

const (
	// EditionUpgradeLicenseType_ProductKey undocumented
	EditionUpgradeLicenseType_ProductKey EditionUpgradeLicenseType = 0
	// EditionUpgradeLicenseType_LicenseFile undocumented
	EditionUpgradeLicenseType_LicenseFile EditionUpgradeLicenseType = 1
)

// EducationExternalSource undocumented
type EducationExternalSource int

const (
	// EducationExternalSource_Sis undocumented
	EducationExternalSource_Sis EducationExternalSource = 0
	// EducationExternalSource_Manual undocumented
	EducationExternalSource_Manual EducationExternalSource = 1
	// EducationExternalSource_UnknownFutureValue undocumented
	EducationExternalSource_UnknownFutureValue EducationExternalSource = 2
)

// EducationGender undocumented
type EducationGender int

const (
	// EducationGender_Female undocumented
	EducationGender_Female EducationGender = 0
	// EducationGender_Male undocumented
	EducationGender_Male EducationGender = 1
	// EducationGender_Other undocumented
	EducationGender_Other EducationGender = 2
	// EducationGender_UnknownFutureValue undocumented
	EducationGender_UnknownFutureValue EducationGender = 3
)

// EducationUserRole undocumented
type EducationUserRole int

const (
	// EducationUserRole_Student undocumented
	EducationUserRole_Student EducationUserRole = 0
	// EducationUserRole_Teacher undocumented
	EducationUserRole_Teacher EducationUserRole = 1
	// EducationUserRole_None undocumented
	EducationUserRole_None EducationUserRole = 2
	// EducationUserRole_UnknownFutureValue undocumented
	EducationUserRole_UnknownFutureValue EducationUserRole = 3
)

// EmailRole undocumented
type EmailRole int

const (
	// EmailRole_Unknown undocumented
	EmailRole_Unknown EmailRole = 0
	// EmailRole_Sender undocumented
	EmailRole_Sender EmailRole = 1
	// EmailRole_Recipient undocumented
	EmailRole_Recipient EmailRole = 2
	// EmailRole_UnknownFutureValue undocumented
	EmailRole_UnknownFutureValue EmailRole = 127
)

// Enablement undocumented
type Enablement int

const (
	// Enablement_NotConfigured undocumented
	Enablement_NotConfigured Enablement = 0
	// Enablement_Enabled undocumented
	Enablement_Enabled Enablement = 1
	// Enablement_Disabled undocumented
	Enablement_Disabled Enablement = 2
)

// EventType undocumented
type EventType int

const (
	// EventType_SingleInstance undocumented
	EventType_SingleInstance EventType = 0
	// EventType_Occurrence undocumented
	EventType_Occurrence EventType = 1
	// EventType_Exception undocumented
	EventType_Exception EventType = 2
	// EventType_SeriesMaster undocumented
	EventType_SeriesMaster EventType = 3
)

// ExchangeIdFormat undocumented
type ExchangeIdFormat int

const (
	// ExchangeIdFormat_EntryId undocumented
	ExchangeIdFormat_EntryId ExchangeIdFormat = 0
	// ExchangeIdFormat_EwsId undocumented
	ExchangeIdFormat_EwsId ExchangeIdFormat = 1
	// ExchangeIdFormat_ImmutableEntryId undocumented
	ExchangeIdFormat_ImmutableEntryId ExchangeIdFormat = 2
	// ExchangeIdFormat_RestId undocumented
	ExchangeIdFormat_RestId ExchangeIdFormat = 3
	// ExchangeIdFormat_RestImmutableEntryId undocumented
	ExchangeIdFormat_RestImmutableEntryId ExchangeIdFormat = 4
)

// ExternalAudienceScope undocumented
type ExternalAudienceScope int

const (
	// ExternalAudienceScope_None undocumented
	ExternalAudienceScope_None ExternalAudienceScope = 0
	// ExternalAudienceScope_ContactsOnly undocumented
	ExternalAudienceScope_ContactsOnly ExternalAudienceScope = 1
	// ExternalAudienceScope_All undocumented
	ExternalAudienceScope_All ExternalAudienceScope = 2
)

// FileHashType undocumented
type FileHashType int

const (
	// FileHashType_Unknown undocumented
	FileHashType_Unknown FileHashType = 0
	// FileHashType_Sha1 undocumented
	FileHashType_Sha1 FileHashType = 1
	// FileHashType_Sha256 undocumented
	FileHashType_Sha256 FileHashType = 2
	// FileHashType_Md5 undocumented
	FileHashType_Md5 FileHashType = 3
	// FileHashType_AuthenticodeHash256 undocumented
	FileHashType_AuthenticodeHash256 FileHashType = 4
	// FileHashType_LsHash undocumented
	FileHashType_LsHash FileHashType = 5
	// FileHashType_Ctph undocumented
	FileHashType_Ctph FileHashType = 6
	// FileHashType_UnknownFutureValue undocumented
	FileHashType_UnknownFutureValue FileHashType = 127
)

// FirewallCertificateRevocationListCheckMethodType undocumented
type FirewallCertificateRevocationListCheckMethodType int

const (
	// FirewallCertificateRevocationListCheckMethodType_DeviceDefault undocumented
	FirewallCertificateRevocationListCheckMethodType_DeviceDefault FirewallCertificateRevocationListCheckMethodType = 0
	// FirewallCertificateRevocationListCheckMethodType_None undocumented
	FirewallCertificateRevocationListCheckMethodType_None FirewallCertificateRevocationListCheckMethodType = 1
	// FirewallCertificateRevocationListCheckMethodType_Attempt undocumented
	FirewallCertificateRevocationListCheckMethodType_Attempt FirewallCertificateRevocationListCheckMethodType = 2
	// FirewallCertificateRevocationListCheckMethodType_Require undocumented
	FirewallCertificateRevocationListCheckMethodType_Require FirewallCertificateRevocationListCheckMethodType = 3
)

// FirewallPacketQueueingMethodType undocumented
type FirewallPacketQueueingMethodType int

const (
	// FirewallPacketQueueingMethodType_DeviceDefault undocumented
	FirewallPacketQueueingMethodType_DeviceDefault FirewallPacketQueueingMethodType = 0
	// FirewallPacketQueueingMethodType_Disabled undocumented
	FirewallPacketQueueingMethodType_Disabled FirewallPacketQueueingMethodType = 1
	// FirewallPacketQueueingMethodType_QueueInbound undocumented
	FirewallPacketQueueingMethodType_QueueInbound FirewallPacketQueueingMethodType = 2
	// FirewallPacketQueueingMethodType_QueueOutbound undocumented
	FirewallPacketQueueingMethodType_QueueOutbound FirewallPacketQueueingMethodType = 3
	// FirewallPacketQueueingMethodType_QueueBoth undocumented
	FirewallPacketQueueingMethodType_QueueBoth FirewallPacketQueueingMethodType = 4
)

// FirewallPreSharedKeyEncodingMethodType undocumented
type FirewallPreSharedKeyEncodingMethodType int

const (
	// FirewallPreSharedKeyEncodingMethodType_DeviceDefault undocumented
	FirewallPreSharedKeyEncodingMethodType_DeviceDefault FirewallPreSharedKeyEncodingMethodType = 0
	// FirewallPreSharedKeyEncodingMethodType_None undocumented
	FirewallPreSharedKeyEncodingMethodType_None FirewallPreSharedKeyEncodingMethodType = 1
	// FirewallPreSharedKeyEncodingMethodType_UtF8 undocumented
	FirewallPreSharedKeyEncodingMethodType_UtF8 FirewallPreSharedKeyEncodingMethodType = 2
)

// FollowupFlagStatus undocumented
type FollowupFlagStatus int

const (
	// FollowupFlagStatus_NotFlagged undocumented
	FollowupFlagStatus_NotFlagged FollowupFlagStatus = 0
	// FollowupFlagStatus_Complete undocumented
	FollowupFlagStatus_Complete FollowupFlagStatus = 1
	// FollowupFlagStatus_Flagged undocumented
	FollowupFlagStatus_Flagged FollowupFlagStatus = 2
)

// FreeBusyStatus undocumented
type FreeBusyStatus int

const (
	// FreeBusyStatus_Free undocumented
	FreeBusyStatus_Free FreeBusyStatus = 0
	// FreeBusyStatus_Tentative undocumented
	FreeBusyStatus_Tentative FreeBusyStatus = 1
	// FreeBusyStatus_Busy undocumented
	FreeBusyStatus_Busy FreeBusyStatus = 2
	// FreeBusyStatus_Oof undocumented
	FreeBusyStatus_Oof FreeBusyStatus = 3
	// FreeBusyStatus_WorkingElsewhere undocumented
	FreeBusyStatus_WorkingElsewhere FreeBusyStatus = 4
	// FreeBusyStatus_Unknown undocumented
	FreeBusyStatus_Unknown FreeBusyStatus = -1
)

// GiphyRatingType undocumented
type GiphyRatingType int

const (
	// GiphyRatingType_Moderate undocumented
	GiphyRatingType_Moderate GiphyRatingType = 0
	// GiphyRatingType_Strict undocumented
	GiphyRatingType_Strict GiphyRatingType = 1
	// GiphyRatingType_UnknownFutureValue undocumented
	GiphyRatingType_UnknownFutureValue GiphyRatingType = 2
)

// GroupType undocumented
type GroupType int

const (
	// GroupType_UnifiedGroups undocumented
	GroupType_UnifiedGroups GroupType = 0
	// GroupType_AzureAD undocumented
	GroupType_AzureAD GroupType = 1
	// GroupType_UnknownFutureValue undocumented
	GroupType_UnknownFutureValue GroupType = 2
)

// Importance undocumented
type Importance int

const (
	// Importance_Low undocumented
	Importance_Low Importance = 0
	// Importance_Normal undocumented
	Importance_Normal Importance = 1
	// Importance_High undocumented
	Importance_High Importance = 2
)

// InferenceClassificationType undocumented
type InferenceClassificationType int

const (
	// InferenceClassificationType_Focused undocumented
	InferenceClassificationType_Focused InferenceClassificationType = 0
	// InferenceClassificationType_Other undocumented
	InferenceClassificationType_Other InferenceClassificationType = 1
)

// InstallIntent undocumented
type InstallIntent int

const (
	// InstallIntent_Available undocumented
	InstallIntent_Available InstallIntent = 0
	// InstallIntent_Required undocumented
	InstallIntent_Required InstallIntent = 1
	// InstallIntent_Uninstall undocumented
	InstallIntent_Uninstall InstallIntent = 2
	// InstallIntent_AvailableWithoutEnrollment undocumented
	InstallIntent_AvailableWithoutEnrollment InstallIntent = 3
)

// InstallState undocumented
type InstallState int

const (
	// InstallState_NotApplicable undocumented
	InstallState_NotApplicable InstallState = 0
	// InstallState_Installed undocumented
	InstallState_Installed InstallState = 1
	// InstallState_Failed undocumented
	InstallState_Failed InstallState = 2
	// InstallState_NotInstalled undocumented
	InstallState_NotInstalled InstallState = 3
	// InstallState_UninstallFailed undocumented
	InstallState_UninstallFailed InstallState = 4
	// InstallState_Unknown undocumented
	InstallState_Unknown InstallState = 5
)

// InternetSiteSecurityLevel undocumented
type InternetSiteSecurityLevel int

const (
	// InternetSiteSecurityLevel_UserDefined undocumented
	InternetSiteSecurityLevel_UserDefined InternetSiteSecurityLevel = 0
	// InternetSiteSecurityLevel_Medium undocumented
	InternetSiteSecurityLevel_Medium InternetSiteSecurityLevel = 1
	// InternetSiteSecurityLevel_MediumHigh undocumented
	InternetSiteSecurityLevel_MediumHigh InternetSiteSecurityLevel = 2
	// InternetSiteSecurityLevel_High undocumented
	InternetSiteSecurityLevel_High InternetSiteSecurityLevel = 3
)

// IosNotificationAlertType undocumented
type IosNotificationAlertType int

const (
	// IosNotificationAlertType_DeviceDefault undocumented
	IosNotificationAlertType_DeviceDefault IosNotificationAlertType = 0
	// IosNotificationAlertType_Banner undocumented
	IosNotificationAlertType_Banner IosNotificationAlertType = 1
	// IosNotificationAlertType_Modal undocumented
	IosNotificationAlertType_Modal IosNotificationAlertType = 2
	// IosNotificationAlertType_None undocumented
	IosNotificationAlertType_None IosNotificationAlertType = 3
)

// IosUpdatesInstallStatus undocumented
type IosUpdatesInstallStatus int

const (
	// IosUpdatesInstallStatus_Success undocumented
	IosUpdatesInstallStatus_Success IosUpdatesInstallStatus = 0
	// IosUpdatesInstallStatus_Available undocumented
	IosUpdatesInstallStatus_Available IosUpdatesInstallStatus = 1
	// IosUpdatesInstallStatus_Idle undocumented
	IosUpdatesInstallStatus_Idle IosUpdatesInstallStatus = 2
	// IosUpdatesInstallStatus_Unknown undocumented
	IosUpdatesInstallStatus_Unknown IosUpdatesInstallStatus = 3
	// IosUpdatesInstallStatus_Downloading undocumented
	IosUpdatesInstallStatus_Downloading IosUpdatesInstallStatus = -2016330712
	// IosUpdatesInstallStatus_DownloadFailed undocumented
	IosUpdatesInstallStatus_DownloadFailed IosUpdatesInstallStatus = -2016330711
	// IosUpdatesInstallStatus_DownloadRequiresComputer undocumented
	IosUpdatesInstallStatus_DownloadRequiresComputer IosUpdatesInstallStatus = -2016330710
	// IosUpdatesInstallStatus_DownloadInsufficientSpace undocumented
	IosUpdatesInstallStatus_DownloadInsufficientSpace IosUpdatesInstallStatus = -2016330709
	// IosUpdatesInstallStatus_DownloadInsufficientPower undocumented
	IosUpdatesInstallStatus_DownloadInsufficientPower IosUpdatesInstallStatus = -2016330708
	// IosUpdatesInstallStatus_DownloadInsufficientNetwork undocumented
	IosUpdatesInstallStatus_DownloadInsufficientNetwork IosUpdatesInstallStatus = -2016330707
	// IosUpdatesInstallStatus_Installing undocumented
	IosUpdatesInstallStatus_Installing IosUpdatesInstallStatus = -2016330706
	// IosUpdatesInstallStatus_InstallInsufficientSpace undocumented
	IosUpdatesInstallStatus_InstallInsufficientSpace IosUpdatesInstallStatus = -2016330705
	// IosUpdatesInstallStatus_InstallInsufficientPower undocumented
	IosUpdatesInstallStatus_InstallInsufficientPower IosUpdatesInstallStatus = -2016330704
	// IosUpdatesInstallStatus_InstallPhoneCallInProgress undocumented
	IosUpdatesInstallStatus_InstallPhoneCallInProgress IosUpdatesInstallStatus = -2016330703
	// IosUpdatesInstallStatus_InstallFailed undocumented
	IosUpdatesInstallStatus_InstallFailed IosUpdatesInstallStatus = -2016330702
	// IosUpdatesInstallStatus_NotSupportedOperation undocumented
	IosUpdatesInstallStatus_NotSupportedOperation IosUpdatesInstallStatus = -2016330701
	// IosUpdatesInstallStatus_SharedDeviceUserLoggedInError undocumented
	IosUpdatesInstallStatus_SharedDeviceUserLoggedInError IosUpdatesInstallStatus = -2016330699
)

// LocationType undocumented
type LocationType int

const (
	// LocationType_Default undocumented
	LocationType_Default LocationType = 0
	// LocationType_ConferenceRoom undocumented
	LocationType_ConferenceRoom LocationType = 1
	// LocationType_HomeAddress undocumented
	LocationType_HomeAddress LocationType = 2
	// LocationType_BusinessAddress undocumented
	LocationType_BusinessAddress LocationType = 3
	// LocationType_GeoCoordinates undocumented
	LocationType_GeoCoordinates LocationType = 4
	// LocationType_StreetAddress undocumented
	LocationType_StreetAddress LocationType = 5
	// LocationType_Hotel undocumented
	LocationType_Hotel LocationType = 6
	// LocationType_Restaurant undocumented
	LocationType_Restaurant LocationType = 7
	// LocationType_LocalBusiness undocumented
	LocationType_LocalBusiness LocationType = 8
	// LocationType_PostalAddress undocumented
	LocationType_PostalAddress LocationType = 9
)

// LocationUniqueIdType undocumented
type LocationUniqueIdType int

const (
	// LocationUniqueIdType_Unknown undocumented
	LocationUniqueIdType_Unknown LocationUniqueIdType = 0
	// LocationUniqueIdType_LocationStore undocumented
	LocationUniqueIdType_LocationStore LocationUniqueIdType = 1
	// LocationUniqueIdType_Directory undocumented
	LocationUniqueIdType_Directory LocationUniqueIdType = 2
	// LocationUniqueIdType_Private undocumented
	LocationUniqueIdType_Private LocationUniqueIdType = 3
	// LocationUniqueIdType_Bing undocumented
	LocationUniqueIdType_Bing LocationUniqueIdType = 4
)

// LogonType undocumented
type LogonType int

const (
	// LogonType_Unknown undocumented
	LogonType_Unknown LogonType = 0
	// LogonType_Interactive undocumented
	LogonType_Interactive LogonType = 1
	// LogonType_RemoteInteractive undocumented
	LogonType_RemoteInteractive LogonType = 2
	// LogonType_Network undocumented
	LogonType_Network LogonType = 3
	// LogonType_Batch undocumented
	LogonType_Batch LogonType = 4
	// LogonType_Service undocumented
	LogonType_Service LogonType = 5
	// LogonType_UnknownFutureValue undocumented
	LogonType_UnknownFutureValue LogonType = 127
)

// MailTipsType undocumented
type MailTipsType int

const (
	// MailTipsType_AutomaticReplies undocumented
	MailTipsType_AutomaticReplies MailTipsType = 1
	// MailTipsType_MailboxFullStatus undocumented
	MailTipsType_MailboxFullStatus MailTipsType = 2
	// MailTipsType_CustomMailTip undocumented
	MailTipsType_CustomMailTip MailTipsType = 4
	// MailTipsType_ExternalMemberCount undocumented
	MailTipsType_ExternalMemberCount MailTipsType = 8
	// MailTipsType_TotalMemberCount undocumented
	MailTipsType_TotalMemberCount MailTipsType = 16
	// MailTipsType_MaxMessageSize undocumented
	MailTipsType_MaxMessageSize MailTipsType = 32
	// MailTipsType_DeliveryRestriction undocumented
	MailTipsType_DeliveryRestriction MailTipsType = 64
	// MailTipsType_ModerationStatus undocumented
	MailTipsType_ModerationStatus MailTipsType = 128
	// MailTipsType_RecipientScope undocumented
	MailTipsType_RecipientScope MailTipsType = 256
	// MailTipsType_RecipientSuggestions undocumented
	MailTipsType_RecipientSuggestions MailTipsType = 512
)

// ManagedAppAvailability undocumented
type ManagedAppAvailability int

const (
	// ManagedAppAvailability_Global undocumented
	ManagedAppAvailability_Global ManagedAppAvailability = 0
	// ManagedAppAvailability_LineOfBusiness undocumented
	ManagedAppAvailability_LineOfBusiness ManagedAppAvailability = 1
)

// ManagedAppClipboardSharingLevel undocumented
type ManagedAppClipboardSharingLevel int

const (
	// ManagedAppClipboardSharingLevel_AllApps undocumented
	ManagedAppClipboardSharingLevel_AllApps ManagedAppClipboardSharingLevel = 0
	// ManagedAppClipboardSharingLevel_ManagedAppsWithPasteIn undocumented
	ManagedAppClipboardSharingLevel_ManagedAppsWithPasteIn ManagedAppClipboardSharingLevel = 1
	// ManagedAppClipboardSharingLevel_ManagedApps undocumented
	ManagedAppClipboardSharingLevel_ManagedApps ManagedAppClipboardSharingLevel = 2
	// ManagedAppClipboardSharingLevel_Blocked undocumented
	ManagedAppClipboardSharingLevel_Blocked ManagedAppClipboardSharingLevel = 3
)

// ManagedAppDataEncryptionType undocumented
type ManagedAppDataEncryptionType int

const (
	// ManagedAppDataEncryptionType_UseDeviceSettings undocumented
	ManagedAppDataEncryptionType_UseDeviceSettings ManagedAppDataEncryptionType = 0
	// ManagedAppDataEncryptionType_AfterDeviceRestart undocumented
	ManagedAppDataEncryptionType_AfterDeviceRestart ManagedAppDataEncryptionType = 1
	// ManagedAppDataEncryptionType_WhenDeviceLockedExceptOpenFiles undocumented
	ManagedAppDataEncryptionType_WhenDeviceLockedExceptOpenFiles ManagedAppDataEncryptionType = 2
	// ManagedAppDataEncryptionType_WhenDeviceLocked undocumented
	ManagedAppDataEncryptionType_WhenDeviceLocked ManagedAppDataEncryptionType = 3
)

// ManagedAppDataStorageLocation undocumented
type ManagedAppDataStorageLocation int

const (
	// ManagedAppDataStorageLocation_OneDriveForBusiness undocumented
	ManagedAppDataStorageLocation_OneDriveForBusiness ManagedAppDataStorageLocation = 1
	// ManagedAppDataStorageLocation_SharePoint undocumented
	ManagedAppDataStorageLocation_SharePoint ManagedAppDataStorageLocation = 2
	// ManagedAppDataStorageLocation_LocalStorage undocumented
	ManagedAppDataStorageLocation_LocalStorage ManagedAppDataStorageLocation = 6
)

// ManagedAppDataTransferLevel undocumented
type ManagedAppDataTransferLevel int

const (
	// ManagedAppDataTransferLevel_AllApps undocumented
	ManagedAppDataTransferLevel_AllApps ManagedAppDataTransferLevel = 0
	// ManagedAppDataTransferLevel_ManagedApps undocumented
	ManagedAppDataTransferLevel_ManagedApps ManagedAppDataTransferLevel = 1
	// ManagedAppDataTransferLevel_None undocumented
	ManagedAppDataTransferLevel_None ManagedAppDataTransferLevel = 2
)

// ManagedAppFlaggedReason undocumented
type ManagedAppFlaggedReason int

const (
	// ManagedAppFlaggedReason_None undocumented
	ManagedAppFlaggedReason_None ManagedAppFlaggedReason = 0
	// ManagedAppFlaggedReason_RootedDevice undocumented
	ManagedAppFlaggedReason_RootedDevice ManagedAppFlaggedReason = 1
)

// ManagedAppPinCharacterSet undocumented
type ManagedAppPinCharacterSet int

const (
	// ManagedAppPinCharacterSet_Numeric undocumented
	ManagedAppPinCharacterSet_Numeric ManagedAppPinCharacterSet = 0
	// ManagedAppPinCharacterSet_AlphanumericAndSymbol undocumented
	ManagedAppPinCharacterSet_AlphanumericAndSymbol ManagedAppPinCharacterSet = 1
)

// ManagedDeviceOwnerType undocumented
type ManagedDeviceOwnerType int

const (
	// ManagedDeviceOwnerType_Unknown undocumented
	ManagedDeviceOwnerType_Unknown ManagedDeviceOwnerType = 0
	// ManagedDeviceOwnerType_Company undocumented
	ManagedDeviceOwnerType_Company ManagedDeviceOwnerType = 1
	// ManagedDeviceOwnerType_Personal undocumented
	ManagedDeviceOwnerType_Personal ManagedDeviceOwnerType = 2
)

// ManagedDevicePartnerReportedHealthState undocumented
type ManagedDevicePartnerReportedHealthState int

const (
	// ManagedDevicePartnerReportedHealthState_Unknown undocumented
	ManagedDevicePartnerReportedHealthState_Unknown ManagedDevicePartnerReportedHealthState = 0
	// ManagedDevicePartnerReportedHealthState_Activated undocumented
	ManagedDevicePartnerReportedHealthState_Activated ManagedDevicePartnerReportedHealthState = 1
	// ManagedDevicePartnerReportedHealthState_Deactivated undocumented
	ManagedDevicePartnerReportedHealthState_Deactivated ManagedDevicePartnerReportedHealthState = 2
	// ManagedDevicePartnerReportedHealthState_Secured undocumented
	ManagedDevicePartnerReportedHealthState_Secured ManagedDevicePartnerReportedHealthState = 3
	// ManagedDevicePartnerReportedHealthState_LowSeverity undocumented
	ManagedDevicePartnerReportedHealthState_LowSeverity ManagedDevicePartnerReportedHealthState = 4
	// ManagedDevicePartnerReportedHealthState_MediumSeverity undocumented
	ManagedDevicePartnerReportedHealthState_MediumSeverity ManagedDevicePartnerReportedHealthState = 5
	// ManagedDevicePartnerReportedHealthState_HighSeverity undocumented
	ManagedDevicePartnerReportedHealthState_HighSeverity ManagedDevicePartnerReportedHealthState = 6
	// ManagedDevicePartnerReportedHealthState_Unresponsive undocumented
	ManagedDevicePartnerReportedHealthState_Unresponsive ManagedDevicePartnerReportedHealthState = 7
	// ManagedDevicePartnerReportedHealthState_Compromised undocumented
	ManagedDevicePartnerReportedHealthState_Compromised ManagedDevicePartnerReportedHealthState = 8
	// ManagedDevicePartnerReportedHealthState_Misconfigured undocumented
	ManagedDevicePartnerReportedHealthState_Misconfigured ManagedDevicePartnerReportedHealthState = 9
)

// ManagementAgentType undocumented
type ManagementAgentType int

const (
	// ManagementAgentType_Eas undocumented
	ManagementAgentType_Eas ManagementAgentType = 1
	// ManagementAgentType_Mdm undocumented
	ManagementAgentType_Mdm ManagementAgentType = 2
	// ManagementAgentType_EasMdm undocumented
	ManagementAgentType_EasMdm ManagementAgentType = 3
	// ManagementAgentType_IntuneClient undocumented
	ManagementAgentType_IntuneClient ManagementAgentType = 4
	// ManagementAgentType_EasIntuneClient undocumented
	ManagementAgentType_EasIntuneClient ManagementAgentType = 5
	// ManagementAgentType_ConfigurationManagerClient undocumented
	ManagementAgentType_ConfigurationManagerClient ManagementAgentType = 8
	// ManagementAgentType_ConfigurationManagerClientMdm undocumented
	ManagementAgentType_ConfigurationManagerClientMdm ManagementAgentType = 10
	// ManagementAgentType_ConfigurationManagerClientMdmEas undocumented
	ManagementAgentType_ConfigurationManagerClientMdmEas ManagementAgentType = 11
	// ManagementAgentType_Unknown undocumented
	ManagementAgentType_Unknown ManagementAgentType = 16
	// ManagementAgentType_Jamf undocumented
	ManagementAgentType_Jamf ManagementAgentType = 32
	// ManagementAgentType_GoogleCloudDevicePolicyController undocumented
	ManagementAgentType_GoogleCloudDevicePolicyController ManagementAgentType = 64
)

// MdmAppConfigKeyType undocumented
type MdmAppConfigKeyType int

const (
	// MdmAppConfigKeyType_StringType undocumented
	MdmAppConfigKeyType_StringType MdmAppConfigKeyType = 0
	// MdmAppConfigKeyType_IntegerType undocumented
	MdmAppConfigKeyType_IntegerType MdmAppConfigKeyType = 1
	// MdmAppConfigKeyType_RealType undocumented
	MdmAppConfigKeyType_RealType MdmAppConfigKeyType = 2
	// MdmAppConfigKeyType_BooleanType undocumented
	MdmAppConfigKeyType_BooleanType MdmAppConfigKeyType = 3
	// MdmAppConfigKeyType_TokenType undocumented
	MdmAppConfigKeyType_TokenType MdmAppConfigKeyType = 4
)

// MdmAuthority undocumented
type MdmAuthority int

const (
	// MdmAuthority_Unknown undocumented
	MdmAuthority_Unknown MdmAuthority = 0
	// MdmAuthority_Intune undocumented
	MdmAuthority_Intune MdmAuthority = 1
	// MdmAuthority_Sccm undocumented
	MdmAuthority_Sccm MdmAuthority = 2
	// MdmAuthority_Office365 undocumented
	MdmAuthority_Office365 MdmAuthority = 3
)

// MeetingMessageType undocumented
type MeetingMessageType int

const (
	// MeetingMessageType_None undocumented
	MeetingMessageType_None MeetingMessageType = 0
	// MeetingMessageType_MeetingRequest undocumented
	MeetingMessageType_MeetingRequest MeetingMessageType = 1
	// MeetingMessageType_MeetingCancelled undocumented
	MeetingMessageType_MeetingCancelled MeetingMessageType = 2
	// MeetingMessageType_MeetingAccepted undocumented
	MeetingMessageType_MeetingAccepted MeetingMessageType = 3
	// MeetingMessageType_MeetingTenativelyAccepted undocumented
	MeetingMessageType_MeetingTenativelyAccepted MeetingMessageType = 4
	// MeetingMessageType_MeetingDeclined undocumented
	MeetingMessageType_MeetingDeclined MeetingMessageType = 5
)

// MessageActionFlag undocumented
type MessageActionFlag int

const (
	// MessageActionFlag_Any undocumented
	MessageActionFlag_Any MessageActionFlag = 0
	// MessageActionFlag_Call undocumented
	MessageActionFlag_Call MessageActionFlag = 1
	// MessageActionFlag_DoNotForward undocumented
	MessageActionFlag_DoNotForward MessageActionFlag = 2
	// MessageActionFlag_FollowUp undocumented
	MessageActionFlag_FollowUp MessageActionFlag = 3
	// MessageActionFlag_Fyi undocumented
	MessageActionFlag_Fyi MessageActionFlag = 4
	// MessageActionFlag_Forward undocumented
	MessageActionFlag_Forward MessageActionFlag = 5
	// MessageActionFlag_NoResponseNecessary undocumented
	MessageActionFlag_NoResponseNecessary MessageActionFlag = 6
	// MessageActionFlag_Read undocumented
	MessageActionFlag_Read MessageActionFlag = 7
	// MessageActionFlag_Reply undocumented
	MessageActionFlag_Reply MessageActionFlag = 8
	// MessageActionFlag_ReplyToAll undocumented
	MessageActionFlag_ReplyToAll MessageActionFlag = 9
	// MessageActionFlag_Review undocumented
	MessageActionFlag_Review MessageActionFlag = 10
)

// MicrosoftStoreForBusinessLicenseType undocumented
type MicrosoftStoreForBusinessLicenseType int

const (
	// MicrosoftStoreForBusinessLicenseType_Offline undocumented
	MicrosoftStoreForBusinessLicenseType_Offline MicrosoftStoreForBusinessLicenseType = 0
	// MicrosoftStoreForBusinessLicenseType_Online undocumented
	MicrosoftStoreForBusinessLicenseType_Online MicrosoftStoreForBusinessLicenseType = 1
)

// MiracastChannel undocumented
type MiracastChannel int

const (
	// MiracastChannel_UserDefined undocumented
	MiracastChannel_UserDefined MiracastChannel = 0
	// MiracastChannel_One undocumented
	MiracastChannel_One MiracastChannel = 1
	// MiracastChannel_Two undocumented
	MiracastChannel_Two MiracastChannel = 2
	// MiracastChannel_Three undocumented
	MiracastChannel_Three MiracastChannel = 3
	// MiracastChannel_Four undocumented
	MiracastChannel_Four MiracastChannel = 4
	// MiracastChannel_Five undocumented
	MiracastChannel_Five MiracastChannel = 5
	// MiracastChannel_Six undocumented
	MiracastChannel_Six MiracastChannel = 6
	// MiracastChannel_Seven undocumented
	MiracastChannel_Seven MiracastChannel = 7
	// MiracastChannel_Eight undocumented
	MiracastChannel_Eight MiracastChannel = 8
	// MiracastChannel_Nine undocumented
	MiracastChannel_Nine MiracastChannel = 9
	// MiracastChannel_Ten undocumented
	MiracastChannel_Ten MiracastChannel = 10
	// MiracastChannel_Eleven undocumented
	MiracastChannel_Eleven MiracastChannel = 11
	// MiracastChannel_ThirtySix undocumented
	MiracastChannel_ThirtySix MiracastChannel = 36
	// MiracastChannel_Forty undocumented
	MiracastChannel_Forty MiracastChannel = 40
	// MiracastChannel_FortyFour undocumented
	MiracastChannel_FortyFour MiracastChannel = 44
	// MiracastChannel_FortyEight undocumented
	MiracastChannel_FortyEight MiracastChannel = 48
	// MiracastChannel_OneHundredFortyNine undocumented
	MiracastChannel_OneHundredFortyNine MiracastChannel = 149
	// MiracastChannel_OneHundredFiftyThree undocumented
	MiracastChannel_OneHundredFiftyThree MiracastChannel = 153
	// MiracastChannel_OneHundredFiftySeven undocumented
	MiracastChannel_OneHundredFiftySeven MiracastChannel = 157
	// MiracastChannel_OneHundredSixtyOne undocumented
	MiracastChannel_OneHundredSixtyOne MiracastChannel = 161
	// MiracastChannel_OneHundredSixtyFive undocumented
	MiracastChannel_OneHundredSixtyFive MiracastChannel = 165
)

// MobileAppContentFileUploadState undocumented
type MobileAppContentFileUploadState int

const (
	// MobileAppContentFileUploadState_Success undocumented
	MobileAppContentFileUploadState_Success MobileAppContentFileUploadState = 0
	// MobileAppContentFileUploadState_TransientError undocumented
	MobileAppContentFileUploadState_TransientError MobileAppContentFileUploadState = 1
	// MobileAppContentFileUploadState_Error undocumented
	MobileAppContentFileUploadState_Error MobileAppContentFileUploadState = 2
	// MobileAppContentFileUploadState_Unknown undocumented
	MobileAppContentFileUploadState_Unknown MobileAppContentFileUploadState = 3
	// MobileAppContentFileUploadState_AzureStorageUriRequestSuccess undocumented
	MobileAppContentFileUploadState_AzureStorageUriRequestSuccess MobileAppContentFileUploadState = 100
	// MobileAppContentFileUploadState_AzureStorageUriRequestPending undocumented
	MobileAppContentFileUploadState_AzureStorageUriRequestPending MobileAppContentFileUploadState = 101
	// MobileAppContentFileUploadState_AzureStorageUriRequestFailed undocumented
	MobileAppContentFileUploadState_AzureStorageUriRequestFailed MobileAppContentFileUploadState = 102
	// MobileAppContentFileUploadState_AzureStorageUriRequestTimedOut undocumented
	MobileAppContentFileUploadState_AzureStorageUriRequestTimedOut MobileAppContentFileUploadState = 103
	// MobileAppContentFileUploadState_AzureStorageUriRenewalSuccess undocumented
	MobileAppContentFileUploadState_AzureStorageUriRenewalSuccess MobileAppContentFileUploadState = 200
	// MobileAppContentFileUploadState_AzureStorageUriRenewalPending undocumented
	MobileAppContentFileUploadState_AzureStorageUriRenewalPending MobileAppContentFileUploadState = 201
	// MobileAppContentFileUploadState_AzureStorageUriRenewalFailed undocumented
	MobileAppContentFileUploadState_AzureStorageUriRenewalFailed MobileAppContentFileUploadState = 202
	// MobileAppContentFileUploadState_AzureStorageUriRenewalTimedOut undocumented
	MobileAppContentFileUploadState_AzureStorageUriRenewalTimedOut MobileAppContentFileUploadState = 203
	// MobileAppContentFileUploadState_CommitFileSuccess undocumented
	MobileAppContentFileUploadState_CommitFileSuccess MobileAppContentFileUploadState = 300
	// MobileAppContentFileUploadState_CommitFilePending undocumented
	MobileAppContentFileUploadState_CommitFilePending MobileAppContentFileUploadState = 301
	// MobileAppContentFileUploadState_CommitFileFailed undocumented
	MobileAppContentFileUploadState_CommitFileFailed MobileAppContentFileUploadState = 302
	// MobileAppContentFileUploadState_CommitFileTimedOut undocumented
	MobileAppContentFileUploadState_CommitFileTimedOut MobileAppContentFileUploadState = 303
)

// MobileAppPublishingState undocumented
type MobileAppPublishingState int

const (
	// MobileAppPublishingState_NotPublished undocumented
	MobileAppPublishingState_NotPublished MobileAppPublishingState = 0
	// MobileAppPublishingState_Processing undocumented
	MobileAppPublishingState_Processing MobileAppPublishingState = 1
	// MobileAppPublishingState_Published undocumented
	MobileAppPublishingState_Published MobileAppPublishingState = 2
)

// MobileThreatPartnerTenantState undocumented
type MobileThreatPartnerTenantState int

const (
	// MobileThreatPartnerTenantState_Unavailable undocumented
	MobileThreatPartnerTenantState_Unavailable MobileThreatPartnerTenantState = 0
	// MobileThreatPartnerTenantState_Available undocumented
	MobileThreatPartnerTenantState_Available MobileThreatPartnerTenantState = 1
	// MobileThreatPartnerTenantState_Enabled undocumented
	MobileThreatPartnerTenantState_Enabled MobileThreatPartnerTenantState = 2
	// MobileThreatPartnerTenantState_Unresponsive undocumented
	MobileThreatPartnerTenantState_Unresponsive MobileThreatPartnerTenantState = 3
)

// NotificationTemplateBrandingOptions undocumented
type NotificationTemplateBrandingOptions int

const (
	// NotificationTemplateBrandingOptions_None undocumented
	NotificationTemplateBrandingOptions_None NotificationTemplateBrandingOptions = 0
	// NotificationTemplateBrandingOptions_IncludeCompanyLogo undocumented
	NotificationTemplateBrandingOptions_IncludeCompanyLogo NotificationTemplateBrandingOptions = 1
	// NotificationTemplateBrandingOptions_IncludeCompanyName undocumented
	NotificationTemplateBrandingOptions_IncludeCompanyName NotificationTemplateBrandingOptions = 2
	// NotificationTemplateBrandingOptions_IncludeContactInformation undocumented
	NotificationTemplateBrandingOptions_IncludeContactInformation NotificationTemplateBrandingOptions = 4
)

// OnenotePatchActionType undocumented
type OnenotePatchActionType int

const (
	// OnenotePatchActionType_Replace undocumented
	OnenotePatchActionType_Replace OnenotePatchActionType = 0
	// OnenotePatchActionType_Append undocumented
	OnenotePatchActionType_Append OnenotePatchActionType = 1
	// OnenotePatchActionType_Delete undocumented
	OnenotePatchActionType_Delete OnenotePatchActionType = 2
	// OnenotePatchActionType_Insert undocumented
	OnenotePatchActionType_Insert OnenotePatchActionType = 3
	// OnenotePatchActionType_Prepend undocumented
	OnenotePatchActionType_Prepend OnenotePatchActionType = 4
)

// OnenotePatchInsertPosition undocumented
type OnenotePatchInsertPosition int

const (
	// OnenotePatchInsertPosition_After undocumented
	OnenotePatchInsertPosition_After OnenotePatchInsertPosition = 0
	// OnenotePatchInsertPosition_Before undocumented
	OnenotePatchInsertPosition_Before OnenotePatchInsertPosition = 1
)

// OnenoteSourceService undocumented
type OnenoteSourceService int

const (
	// OnenoteSourceService_Unknown undocumented
	OnenoteSourceService_Unknown OnenoteSourceService = 0
	// OnenoteSourceService_OneDrive undocumented
	OnenoteSourceService_OneDrive OnenoteSourceService = 1
	// OnenoteSourceService_OneDriveForBusiness undocumented
	OnenoteSourceService_OneDriveForBusiness OnenoteSourceService = 2
	// OnenoteSourceService_OnPremOneDriveForBusiness undocumented
	OnenoteSourceService_OnPremOneDriveForBusiness OnenoteSourceService = 3
)

// OnenoteUserRole undocumented
type OnenoteUserRole int

const (
	// OnenoteUserRole_Owner undocumented
	OnenoteUserRole_Owner OnenoteUserRole = 0
	// OnenoteUserRole_Contributor undocumented
	OnenoteUserRole_Contributor OnenoteUserRole = 1
	// OnenoteUserRole_Reader undocumented
	OnenoteUserRole_Reader OnenoteUserRole = 2
	// OnenoteUserRole_None undocumented
	OnenoteUserRole_None OnenoteUserRole = -1
)

// OperationResult undocumented
type OperationResult int

const (
	// OperationResult_Success undocumented
	OperationResult_Success OperationResult = 0
	// OperationResult_Failure undocumented
	OperationResult_Failure OperationResult = 1
	// OperationResult_Timeout undocumented
	OperationResult_Timeout OperationResult = 2
	// OperationResult_UnknownFutureValue undocumented
	OperationResult_UnknownFutureValue OperationResult = 3
)

// OperationStatus undocumented
type OperationStatus int

const (
	// OperationStatus_NotStarted undocumented
	OperationStatus_NotStarted OperationStatus = 0
	// OperationStatus_Running undocumented
	OperationStatus_Running OperationStatus = 1
	// OperationStatus_Completed undocumented
	OperationStatus_Completed OperationStatus = 2
	// OperationStatus_Failed undocumented
	OperationStatus_Failed OperationStatus = 3
)

// PhoneType undocumented
type PhoneType int

const (
	// PhoneType_Home undocumented
	PhoneType_Home PhoneType = 0
	// PhoneType_Business undocumented
	PhoneType_Business PhoneType = 1
	// PhoneType_Mobile undocumented
	PhoneType_Mobile PhoneType = 2
	// PhoneType_Other undocumented
	PhoneType_Other PhoneType = 3
	// PhoneType_Assistant undocumented
	PhoneType_Assistant PhoneType = 4
	// PhoneType_HomeFax undocumented
	PhoneType_HomeFax PhoneType = 5
	// PhoneType_BusinessFax undocumented
	PhoneType_BusinessFax PhoneType = 6
	// PhoneType_OtherFax undocumented
	PhoneType_OtherFax PhoneType = 7
	// PhoneType_Pager undocumented
	PhoneType_Pager PhoneType = 8
	// PhoneType_Radio undocumented
	PhoneType_Radio PhoneType = 9
)

// PhysicalAddressType undocumented
type PhysicalAddressType int

const (
	// PhysicalAddressType_Unknown undocumented
	PhysicalAddressType_Unknown PhysicalAddressType = 0
	// PhysicalAddressType_Home undocumented
	PhysicalAddressType_Home PhysicalAddressType = 1
	// PhysicalAddressType_Business undocumented
	PhysicalAddressType_Business PhysicalAddressType = 2
	// PhysicalAddressType_Other undocumented
	PhysicalAddressType_Other PhysicalAddressType = 3
)

// PlannerPreviewType undocumented
type PlannerPreviewType int

const (
	// PlannerPreviewType_Automatic undocumented
	PlannerPreviewType_Automatic PlannerPreviewType = 0
	// PlannerPreviewType_NoPreview undocumented
	PlannerPreviewType_NoPreview PlannerPreviewType = 1
	// PlannerPreviewType_Checklist undocumented
	PlannerPreviewType_Checklist PlannerPreviewType = 2
	// PlannerPreviewType_Description undocumented
	PlannerPreviewType_Description PlannerPreviewType = 3
	// PlannerPreviewType_Reference undocumented
	PlannerPreviewType_Reference PlannerPreviewType = 4
)

// PolicyPlatformType undocumented
type PolicyPlatformType int

const (
	// PolicyPlatformType_Android undocumented
	PolicyPlatformType_Android PolicyPlatformType = 0
	// PolicyPlatformType_IOS undocumented
	PolicyPlatformType_IOS PolicyPlatformType = 2
	// PolicyPlatformType_MacOS undocumented
	PolicyPlatformType_MacOS PolicyPlatformType = 3
	// PolicyPlatformType_WindowsPhone81 undocumented
	PolicyPlatformType_WindowsPhone81 PolicyPlatformType = 4
	// PolicyPlatformType_Windows81AndLater undocumented
	PolicyPlatformType_Windows81AndLater PolicyPlatformType = 5
	// PolicyPlatformType_Windows10AndLater undocumented
	PolicyPlatformType_Windows10AndLater PolicyPlatformType = 6
	// PolicyPlatformType_AndroidWorkProfile undocumented
	PolicyPlatformType_AndroidWorkProfile PolicyPlatformType = 7
	// PolicyPlatformType_All undocumented
	PolicyPlatformType_All PolicyPlatformType = 100
)

// PrereleaseFeatures undocumented
type PrereleaseFeatures int

const (
	// PrereleaseFeatures_UserDefined undocumented
	PrereleaseFeatures_UserDefined PrereleaseFeatures = 0
	// PrereleaseFeatures_SettingsOnly undocumented
	PrereleaseFeatures_SettingsOnly PrereleaseFeatures = 1
	// PrereleaseFeatures_SettingsAndExperimentations undocumented
	PrereleaseFeatures_SettingsAndExperimentations PrereleaseFeatures = 2
	// PrereleaseFeatures_NotAllowed undocumented
	PrereleaseFeatures_NotAllowed PrereleaseFeatures = 3
)

// ProcessIntegrityLevel undocumented
type ProcessIntegrityLevel int

const (
	// ProcessIntegrityLevel_Unknown undocumented
	ProcessIntegrityLevel_Unknown ProcessIntegrityLevel = 0
	// ProcessIntegrityLevel_Untrusted undocumented
	ProcessIntegrityLevel_Untrusted ProcessIntegrityLevel = 1
	// ProcessIntegrityLevel_Low undocumented
	ProcessIntegrityLevel_Low ProcessIntegrityLevel = 2
	// ProcessIntegrityLevel_Medium undocumented
	ProcessIntegrityLevel_Medium ProcessIntegrityLevel = 3
	// ProcessIntegrityLevel_High undocumented
	ProcessIntegrityLevel_High ProcessIntegrityLevel = 4
	// ProcessIntegrityLevel_System undocumented
	ProcessIntegrityLevel_System ProcessIntegrityLevel = 5
	// ProcessIntegrityLevel_UnknownFutureValue undocumented
	ProcessIntegrityLevel_UnknownFutureValue ProcessIntegrityLevel = 127
)

// RatingAppsType undocumented
type RatingAppsType int

const (
	// RatingAppsType_AllAllowed undocumented
	RatingAppsType_AllAllowed RatingAppsType = 0
	// RatingAppsType_AllBlocked undocumented
	RatingAppsType_AllBlocked RatingAppsType = 1
	// RatingAppsType_AgesAbove4 undocumented
	RatingAppsType_AgesAbove4 RatingAppsType = 2
	// RatingAppsType_AgesAbove9 undocumented
	RatingAppsType_AgesAbove9 RatingAppsType = 3
	// RatingAppsType_AgesAbove12 undocumented
	RatingAppsType_AgesAbove12 RatingAppsType = 4
	// RatingAppsType_AgesAbove17 undocumented
	RatingAppsType_AgesAbove17 RatingAppsType = 5
)

// RatingAustraliaMoviesType undocumented
type RatingAustraliaMoviesType int

const (
	// RatingAustraliaMoviesType_AllAllowed undocumented
	RatingAustraliaMoviesType_AllAllowed RatingAustraliaMoviesType = 0
	// RatingAustraliaMoviesType_AllBlocked undocumented
	RatingAustraliaMoviesType_AllBlocked RatingAustraliaMoviesType = 1
	// RatingAustraliaMoviesType_General undocumented
	RatingAustraliaMoviesType_General RatingAustraliaMoviesType = 2
	// RatingAustraliaMoviesType_ParentalGuidance undocumented
	RatingAustraliaMoviesType_ParentalGuidance RatingAustraliaMoviesType = 3
	// RatingAustraliaMoviesType_Mature undocumented
	RatingAustraliaMoviesType_Mature RatingAustraliaMoviesType = 4
	// RatingAustraliaMoviesType_AgesAbove15 undocumented
	RatingAustraliaMoviesType_AgesAbove15 RatingAustraliaMoviesType = 5
	// RatingAustraliaMoviesType_AgesAbove18 undocumented
	RatingAustraliaMoviesType_AgesAbove18 RatingAustraliaMoviesType = 6
)

// RatingAustraliaTelevisionType undocumented
type RatingAustraliaTelevisionType int

const (
	// RatingAustraliaTelevisionType_AllAllowed undocumented
	RatingAustraliaTelevisionType_AllAllowed RatingAustraliaTelevisionType = 0
	// RatingAustraliaTelevisionType_AllBlocked undocumented
	RatingAustraliaTelevisionType_AllBlocked RatingAustraliaTelevisionType = 1
	// RatingAustraliaTelevisionType_Preschoolers undocumented
	RatingAustraliaTelevisionType_Preschoolers RatingAustraliaTelevisionType = 2
	// RatingAustraliaTelevisionType_Children undocumented
	RatingAustraliaTelevisionType_Children RatingAustraliaTelevisionType = 3
	// RatingAustraliaTelevisionType_General undocumented
	RatingAustraliaTelevisionType_General RatingAustraliaTelevisionType = 4
	// RatingAustraliaTelevisionType_ParentalGuidance undocumented
	RatingAustraliaTelevisionType_ParentalGuidance RatingAustraliaTelevisionType = 5
	// RatingAustraliaTelevisionType_Mature undocumented
	RatingAustraliaTelevisionType_Mature RatingAustraliaTelevisionType = 6
	// RatingAustraliaTelevisionType_AgesAbove15 undocumented
	RatingAustraliaTelevisionType_AgesAbove15 RatingAustraliaTelevisionType = 7
	// RatingAustraliaTelevisionType_AgesAbove15AdultViolence undocumented
	RatingAustraliaTelevisionType_AgesAbove15AdultViolence RatingAustraliaTelevisionType = 8
)

// RatingCanadaMoviesType undocumented
type RatingCanadaMoviesType int

const (
	// RatingCanadaMoviesType_AllAllowed undocumented
	RatingCanadaMoviesType_AllAllowed RatingCanadaMoviesType = 0
	// RatingCanadaMoviesType_AllBlocked undocumented
	RatingCanadaMoviesType_AllBlocked RatingCanadaMoviesType = 1
	// RatingCanadaMoviesType_General undocumented
	RatingCanadaMoviesType_General RatingCanadaMoviesType = 2
	// RatingCanadaMoviesType_ParentalGuidance undocumented
	RatingCanadaMoviesType_ParentalGuidance RatingCanadaMoviesType = 3
	// RatingCanadaMoviesType_AgesAbove14 undocumented
	RatingCanadaMoviesType_AgesAbove14 RatingCanadaMoviesType = 4
	// RatingCanadaMoviesType_AgesAbove18 undocumented
	RatingCanadaMoviesType_AgesAbove18 RatingCanadaMoviesType = 5
	// RatingCanadaMoviesType_Restricted undocumented
	RatingCanadaMoviesType_Restricted RatingCanadaMoviesType = 6
)

// RatingCanadaTelevisionType undocumented
type RatingCanadaTelevisionType int

const (
	// RatingCanadaTelevisionType_AllAllowed undocumented
	RatingCanadaTelevisionType_AllAllowed RatingCanadaTelevisionType = 0
	// RatingCanadaTelevisionType_AllBlocked undocumented
	RatingCanadaTelevisionType_AllBlocked RatingCanadaTelevisionType = 1
	// RatingCanadaTelevisionType_Children undocumented
	RatingCanadaTelevisionType_Children RatingCanadaTelevisionType = 2
	// RatingCanadaTelevisionType_ChildrenAbove8 undocumented
	RatingCanadaTelevisionType_ChildrenAbove8 RatingCanadaTelevisionType = 3
	// RatingCanadaTelevisionType_General undocumented
	RatingCanadaTelevisionType_General RatingCanadaTelevisionType = 4
	// RatingCanadaTelevisionType_ParentalGuidance undocumented
	RatingCanadaTelevisionType_ParentalGuidance RatingCanadaTelevisionType = 5
	// RatingCanadaTelevisionType_AgesAbove14 undocumented
	RatingCanadaTelevisionType_AgesAbove14 RatingCanadaTelevisionType = 6
	// RatingCanadaTelevisionType_AgesAbove18 undocumented
	RatingCanadaTelevisionType_AgesAbove18 RatingCanadaTelevisionType = 7
)

// RatingFranceMoviesType undocumented
type RatingFranceMoviesType int

const (
	// RatingFranceMoviesType_AllAllowed undocumented
	RatingFranceMoviesType_AllAllowed RatingFranceMoviesType = 0
	// RatingFranceMoviesType_AllBlocked undocumented
	RatingFranceMoviesType_AllBlocked RatingFranceMoviesType = 1
	// RatingFranceMoviesType_AgesAbove10 undocumented
	RatingFranceMoviesType_AgesAbove10 RatingFranceMoviesType = 2
	// RatingFranceMoviesType_AgesAbove12 undocumented
	RatingFranceMoviesType_AgesAbove12 RatingFranceMoviesType = 3
	// RatingFranceMoviesType_AgesAbove16 undocumented
	RatingFranceMoviesType_AgesAbove16 RatingFranceMoviesType = 4
	// RatingFranceMoviesType_AgesAbove18 undocumented
	RatingFranceMoviesType_AgesAbove18 RatingFranceMoviesType = 5
)

// RatingFranceTelevisionType undocumented
type RatingFranceTelevisionType int

const (
	// RatingFranceTelevisionType_AllAllowed undocumented
	RatingFranceTelevisionType_AllAllowed RatingFranceTelevisionType = 0
	// RatingFranceTelevisionType_AllBlocked undocumented
	RatingFranceTelevisionType_AllBlocked RatingFranceTelevisionType = 1
	// RatingFranceTelevisionType_AgesAbove10 undocumented
	RatingFranceTelevisionType_AgesAbove10 RatingFranceTelevisionType = 2
	// RatingFranceTelevisionType_AgesAbove12 undocumented
	RatingFranceTelevisionType_AgesAbove12 RatingFranceTelevisionType = 3
	// RatingFranceTelevisionType_AgesAbove16 undocumented
	RatingFranceTelevisionType_AgesAbove16 RatingFranceTelevisionType = 4
	// RatingFranceTelevisionType_AgesAbove18 undocumented
	RatingFranceTelevisionType_AgesAbove18 RatingFranceTelevisionType = 5
)

// RatingGermanyMoviesType undocumented
type RatingGermanyMoviesType int

const (
	// RatingGermanyMoviesType_AllAllowed undocumented
	RatingGermanyMoviesType_AllAllowed RatingGermanyMoviesType = 0
	// RatingGermanyMoviesType_AllBlocked undocumented
	RatingGermanyMoviesType_AllBlocked RatingGermanyMoviesType = 1
	// RatingGermanyMoviesType_General undocumented
	RatingGermanyMoviesType_General RatingGermanyMoviesType = 2
	// RatingGermanyMoviesType_AgesAbove6 undocumented
	RatingGermanyMoviesType_AgesAbove6 RatingGermanyMoviesType = 3
	// RatingGermanyMoviesType_AgesAbove12 undocumented
	RatingGermanyMoviesType_AgesAbove12 RatingGermanyMoviesType = 4
	// RatingGermanyMoviesType_AgesAbove16 undocumented
	RatingGermanyMoviesType_AgesAbove16 RatingGermanyMoviesType = 5
	// RatingGermanyMoviesType_Adults undocumented
	RatingGermanyMoviesType_Adults RatingGermanyMoviesType = 6
)

// RatingGermanyTelevisionType undocumented
type RatingGermanyTelevisionType int

const (
	// RatingGermanyTelevisionType_AllAllowed undocumented
	RatingGermanyTelevisionType_AllAllowed RatingGermanyTelevisionType = 0
	// RatingGermanyTelevisionType_AllBlocked undocumented
	RatingGermanyTelevisionType_AllBlocked RatingGermanyTelevisionType = 1
	// RatingGermanyTelevisionType_General undocumented
	RatingGermanyTelevisionType_General RatingGermanyTelevisionType = 2
	// RatingGermanyTelevisionType_AgesAbove6 undocumented
	RatingGermanyTelevisionType_AgesAbove6 RatingGermanyTelevisionType = 3
	// RatingGermanyTelevisionType_AgesAbove12 undocumented
	RatingGermanyTelevisionType_AgesAbove12 RatingGermanyTelevisionType = 4
	// RatingGermanyTelevisionType_AgesAbove16 undocumented
	RatingGermanyTelevisionType_AgesAbove16 RatingGermanyTelevisionType = 5
	// RatingGermanyTelevisionType_Adults undocumented
	RatingGermanyTelevisionType_Adults RatingGermanyTelevisionType = 6
)

// RatingIrelandMoviesType undocumented
type RatingIrelandMoviesType int

const (
	// RatingIrelandMoviesType_AllAllowed undocumented
	RatingIrelandMoviesType_AllAllowed RatingIrelandMoviesType = 0
	// RatingIrelandMoviesType_AllBlocked undocumented
	RatingIrelandMoviesType_AllBlocked RatingIrelandMoviesType = 1
	// RatingIrelandMoviesType_General undocumented
	RatingIrelandMoviesType_General RatingIrelandMoviesType = 2
	// RatingIrelandMoviesType_ParentalGuidance undocumented
	RatingIrelandMoviesType_ParentalGuidance RatingIrelandMoviesType = 3
	// RatingIrelandMoviesType_AgesAbove12 undocumented
	RatingIrelandMoviesType_AgesAbove12 RatingIrelandMoviesType = 4
	// RatingIrelandMoviesType_AgesAbove15 undocumented
	RatingIrelandMoviesType_AgesAbove15 RatingIrelandMoviesType = 5
	// RatingIrelandMoviesType_AgesAbove16 undocumented
	RatingIrelandMoviesType_AgesAbove16 RatingIrelandMoviesType = 6
	// RatingIrelandMoviesType_Adults undocumented
	RatingIrelandMoviesType_Adults RatingIrelandMoviesType = 7
)

// RatingIrelandTelevisionType undocumented
type RatingIrelandTelevisionType int

const (
	// RatingIrelandTelevisionType_AllAllowed undocumented
	RatingIrelandTelevisionType_AllAllowed RatingIrelandTelevisionType = 0
	// RatingIrelandTelevisionType_AllBlocked undocumented
	RatingIrelandTelevisionType_AllBlocked RatingIrelandTelevisionType = 1
	// RatingIrelandTelevisionType_General undocumented
	RatingIrelandTelevisionType_General RatingIrelandTelevisionType = 2
	// RatingIrelandTelevisionType_Children undocumented
	RatingIrelandTelevisionType_Children RatingIrelandTelevisionType = 3
	// RatingIrelandTelevisionType_YoungAdults undocumented
	RatingIrelandTelevisionType_YoungAdults RatingIrelandTelevisionType = 4
	// RatingIrelandTelevisionType_ParentalSupervision undocumented
	RatingIrelandTelevisionType_ParentalSupervision RatingIrelandTelevisionType = 5
	// RatingIrelandTelevisionType_Mature undocumented
	RatingIrelandTelevisionType_Mature RatingIrelandTelevisionType = 6
)

// RatingJapanMoviesType undocumented
type RatingJapanMoviesType int

const (
	// RatingJapanMoviesType_AllAllowed undocumented
	RatingJapanMoviesType_AllAllowed RatingJapanMoviesType = 0
	// RatingJapanMoviesType_AllBlocked undocumented
	RatingJapanMoviesType_AllBlocked RatingJapanMoviesType = 1
	// RatingJapanMoviesType_General undocumented
	RatingJapanMoviesType_General RatingJapanMoviesType = 2
	// RatingJapanMoviesType_ParentalGuidance undocumented
	RatingJapanMoviesType_ParentalGuidance RatingJapanMoviesType = 3
	// RatingJapanMoviesType_AgesAbove15 undocumented
	RatingJapanMoviesType_AgesAbove15 RatingJapanMoviesType = 4
	// RatingJapanMoviesType_AgesAbove18 undocumented
	RatingJapanMoviesType_AgesAbove18 RatingJapanMoviesType = 5
)

// RatingJapanTelevisionType undocumented
type RatingJapanTelevisionType int

const (
	// RatingJapanTelevisionType_AllAllowed undocumented
	RatingJapanTelevisionType_AllAllowed RatingJapanTelevisionType = 0
	// RatingJapanTelevisionType_AllBlocked undocumented
	RatingJapanTelevisionType_AllBlocked RatingJapanTelevisionType = 1
	// RatingJapanTelevisionType_ExplicitAllowed undocumented
	RatingJapanTelevisionType_ExplicitAllowed RatingJapanTelevisionType = 2
)

// RatingNewZealandMoviesType undocumented
type RatingNewZealandMoviesType int

const (
	// RatingNewZealandMoviesType_AllAllowed undocumented
	RatingNewZealandMoviesType_AllAllowed RatingNewZealandMoviesType = 0
	// RatingNewZealandMoviesType_AllBlocked undocumented
	RatingNewZealandMoviesType_AllBlocked RatingNewZealandMoviesType = 1
	// RatingNewZealandMoviesType_General undocumented
	RatingNewZealandMoviesType_General RatingNewZealandMoviesType = 2
	// RatingNewZealandMoviesType_ParentalGuidance undocumented
	RatingNewZealandMoviesType_ParentalGuidance RatingNewZealandMoviesType = 3
	// RatingNewZealandMoviesType_Mature undocumented
	RatingNewZealandMoviesType_Mature RatingNewZealandMoviesType = 4
	// RatingNewZealandMoviesType_AgesAbove13 undocumented
	RatingNewZealandMoviesType_AgesAbove13 RatingNewZealandMoviesType = 5
	// RatingNewZealandMoviesType_AgesAbove15 undocumented
	RatingNewZealandMoviesType_AgesAbove15 RatingNewZealandMoviesType = 6
	// RatingNewZealandMoviesType_AgesAbove16 undocumented
	RatingNewZealandMoviesType_AgesAbove16 RatingNewZealandMoviesType = 7
	// RatingNewZealandMoviesType_AgesAbove18 undocumented
	RatingNewZealandMoviesType_AgesAbove18 RatingNewZealandMoviesType = 8
	// RatingNewZealandMoviesType_Restricted undocumented
	RatingNewZealandMoviesType_Restricted RatingNewZealandMoviesType = 9
	// RatingNewZealandMoviesType_AgesAbove16Restricted undocumented
	RatingNewZealandMoviesType_AgesAbove16Restricted RatingNewZealandMoviesType = 10
)

// RatingNewZealandTelevisionType undocumented
type RatingNewZealandTelevisionType int

const (
	// RatingNewZealandTelevisionType_AllAllowed undocumented
	RatingNewZealandTelevisionType_AllAllowed RatingNewZealandTelevisionType = 0
	// RatingNewZealandTelevisionType_AllBlocked undocumented
	RatingNewZealandTelevisionType_AllBlocked RatingNewZealandTelevisionType = 1
	// RatingNewZealandTelevisionType_General undocumented
	RatingNewZealandTelevisionType_General RatingNewZealandTelevisionType = 2
	// RatingNewZealandTelevisionType_ParentalGuidance undocumented
	RatingNewZealandTelevisionType_ParentalGuidance RatingNewZealandTelevisionType = 3
	// RatingNewZealandTelevisionType_Adults undocumented
	RatingNewZealandTelevisionType_Adults RatingNewZealandTelevisionType = 4
)

// RatingUnitedKingdomMoviesType undocumented
type RatingUnitedKingdomMoviesType int

const (
	// RatingUnitedKingdomMoviesType_AllAllowed undocumented
	RatingUnitedKingdomMoviesType_AllAllowed RatingUnitedKingdomMoviesType = 0
	// RatingUnitedKingdomMoviesType_AllBlocked undocumented
	RatingUnitedKingdomMoviesType_AllBlocked RatingUnitedKingdomMoviesType = 1
	// RatingUnitedKingdomMoviesType_General undocumented
	RatingUnitedKingdomMoviesType_General RatingUnitedKingdomMoviesType = 2
	// RatingUnitedKingdomMoviesType_UniversalChildren undocumented
	RatingUnitedKingdomMoviesType_UniversalChildren RatingUnitedKingdomMoviesType = 3
	// RatingUnitedKingdomMoviesType_ParentalGuidance undocumented
	RatingUnitedKingdomMoviesType_ParentalGuidance RatingUnitedKingdomMoviesType = 4
	// RatingUnitedKingdomMoviesType_AgesAbove12Video undocumented
	RatingUnitedKingdomMoviesType_AgesAbove12Video RatingUnitedKingdomMoviesType = 5
	// RatingUnitedKingdomMoviesType_AgesAbove12Cinema undocumented
	RatingUnitedKingdomMoviesType_AgesAbove12Cinema RatingUnitedKingdomMoviesType = 6
	// RatingUnitedKingdomMoviesType_AgesAbove15 undocumented
	RatingUnitedKingdomMoviesType_AgesAbove15 RatingUnitedKingdomMoviesType = 7
	// RatingUnitedKingdomMoviesType_Adults undocumented
	RatingUnitedKingdomMoviesType_Adults RatingUnitedKingdomMoviesType = 8
)

// RatingUnitedKingdomTelevisionType undocumented
type RatingUnitedKingdomTelevisionType int

const (
	// RatingUnitedKingdomTelevisionType_AllAllowed undocumented
	RatingUnitedKingdomTelevisionType_AllAllowed RatingUnitedKingdomTelevisionType = 0
	// RatingUnitedKingdomTelevisionType_AllBlocked undocumented
	RatingUnitedKingdomTelevisionType_AllBlocked RatingUnitedKingdomTelevisionType = 1
	// RatingUnitedKingdomTelevisionType_Caution undocumented
	RatingUnitedKingdomTelevisionType_Caution RatingUnitedKingdomTelevisionType = 2
)

// RatingUnitedStatesMoviesType undocumented
type RatingUnitedStatesMoviesType int

const (
	// RatingUnitedStatesMoviesType_AllAllowed undocumented
	RatingUnitedStatesMoviesType_AllAllowed RatingUnitedStatesMoviesType = 0
	// RatingUnitedStatesMoviesType_AllBlocked undocumented
	RatingUnitedStatesMoviesType_AllBlocked RatingUnitedStatesMoviesType = 1
	// RatingUnitedStatesMoviesType_General undocumented
	RatingUnitedStatesMoviesType_General RatingUnitedStatesMoviesType = 2
	// RatingUnitedStatesMoviesType_ParentalGuidance undocumented
	RatingUnitedStatesMoviesType_ParentalGuidance RatingUnitedStatesMoviesType = 3
	// RatingUnitedStatesMoviesType_ParentalGuidance13 undocumented
	RatingUnitedStatesMoviesType_ParentalGuidance13 RatingUnitedStatesMoviesType = 4
	// RatingUnitedStatesMoviesType_Restricted undocumented
	RatingUnitedStatesMoviesType_Restricted RatingUnitedStatesMoviesType = 5
	// RatingUnitedStatesMoviesType_Adults undocumented
	RatingUnitedStatesMoviesType_Adults RatingUnitedStatesMoviesType = 6
)

// RatingUnitedStatesTelevisionType undocumented
type RatingUnitedStatesTelevisionType int

const (
	// RatingUnitedStatesTelevisionType_AllAllowed undocumented
	RatingUnitedStatesTelevisionType_AllAllowed RatingUnitedStatesTelevisionType = 0
	// RatingUnitedStatesTelevisionType_AllBlocked undocumented
	RatingUnitedStatesTelevisionType_AllBlocked RatingUnitedStatesTelevisionType = 1
	// RatingUnitedStatesTelevisionType_ChildrenAll undocumented
	RatingUnitedStatesTelevisionType_ChildrenAll RatingUnitedStatesTelevisionType = 2
	// RatingUnitedStatesTelevisionType_ChildrenAbove7 undocumented
	RatingUnitedStatesTelevisionType_ChildrenAbove7 RatingUnitedStatesTelevisionType = 3
	// RatingUnitedStatesTelevisionType_General undocumented
	RatingUnitedStatesTelevisionType_General RatingUnitedStatesTelevisionType = 4
	// RatingUnitedStatesTelevisionType_ParentalGuidance undocumented
	RatingUnitedStatesTelevisionType_ParentalGuidance RatingUnitedStatesTelevisionType = 5
	// RatingUnitedStatesTelevisionType_ChildrenAbove14 undocumented
	RatingUnitedStatesTelevisionType_ChildrenAbove14 RatingUnitedStatesTelevisionType = 6
	// RatingUnitedStatesTelevisionType_Adults undocumented
	RatingUnitedStatesTelevisionType_Adults RatingUnitedStatesTelevisionType = 7
)

// RecipientScopeType undocumented
type RecipientScopeType int

const (
	// RecipientScopeType_None undocumented
	RecipientScopeType_None RecipientScopeType = 0
	// RecipientScopeType_Internal undocumented
	RecipientScopeType_Internal RecipientScopeType = 1
	// RecipientScopeType_External undocumented
	RecipientScopeType_External RecipientScopeType = 2
	// RecipientScopeType_ExternalPartner undocumented
	RecipientScopeType_ExternalPartner RecipientScopeType = 4
	// RecipientScopeType_ExternalNonPartner undocumented
	RecipientScopeType_ExternalNonPartner RecipientScopeType = 8
)

// RecurrencePatternType undocumented
type RecurrencePatternType int

const (
	// RecurrencePatternType_Daily undocumented
	RecurrencePatternType_Daily RecurrencePatternType = 0
	// RecurrencePatternType_Weekly undocumented
	RecurrencePatternType_Weekly RecurrencePatternType = 1
	// RecurrencePatternType_AbsoluteMonthly undocumented
	RecurrencePatternType_AbsoluteMonthly RecurrencePatternType = 2
	// RecurrencePatternType_RelativeMonthly undocumented
	RecurrencePatternType_RelativeMonthly RecurrencePatternType = 3
	// RecurrencePatternType_AbsoluteYearly undocumented
	RecurrencePatternType_AbsoluteYearly RecurrencePatternType = 4
	// RecurrencePatternType_RelativeYearly undocumented
	RecurrencePatternType_RelativeYearly RecurrencePatternType = 5
)

// RecurrenceRangeType undocumented
type RecurrenceRangeType int

const (
	// RecurrenceRangeType_EndDate undocumented
	RecurrenceRangeType_EndDate RecurrenceRangeType = 0
	// RecurrenceRangeType_NoEnd undocumented
	RecurrenceRangeType_NoEnd RecurrenceRangeType = 1
	// RecurrenceRangeType_Numbered undocumented
	RecurrenceRangeType_Numbered RecurrenceRangeType = 2
)

// RegistryHive undocumented
type RegistryHive int

const (
	// RegistryHive_Unknown undocumented
	RegistryHive_Unknown RegistryHive = 0
	// RegistryHive_CurrentConfig undocumented
	RegistryHive_CurrentConfig RegistryHive = 1
	// RegistryHive_CurrentUser undocumented
	RegistryHive_CurrentUser RegistryHive = 2
	// RegistryHive_LocalMachineSam undocumented
	RegistryHive_LocalMachineSam RegistryHive = 3
	// RegistryHive_LocalMachineSecurity undocumented
	RegistryHive_LocalMachineSecurity RegistryHive = 4
	// RegistryHive_LocalMachineSoftware undocumented
	RegistryHive_LocalMachineSoftware RegistryHive = 5
	// RegistryHive_LocalMachineSystem undocumented
	RegistryHive_LocalMachineSystem RegistryHive = 6
	// RegistryHive_UsersDefault undocumented
	RegistryHive_UsersDefault RegistryHive = 7
	// RegistryHive_UnknownFutureValue undocumented
	RegistryHive_UnknownFutureValue RegistryHive = 127
)

// RegistryOperation undocumented
type RegistryOperation int

const (
	// RegistryOperation_Unknown undocumented
	RegistryOperation_Unknown RegistryOperation = 0
	// RegistryOperation_Create undocumented
	RegistryOperation_Create RegistryOperation = 1
	// RegistryOperation_Modify undocumented
	RegistryOperation_Modify RegistryOperation = 2
	// RegistryOperation_Delete undocumented
	RegistryOperation_Delete RegistryOperation = 3
	// RegistryOperation_UnknownFutureValue undocumented
	RegistryOperation_UnknownFutureValue RegistryOperation = 127
)

// RegistryValueType undocumented
type RegistryValueType int

const (
	// RegistryValueType_Unknown undocumented
	RegistryValueType_Unknown RegistryValueType = 0
	// RegistryValueType_Binary undocumented
	RegistryValueType_Binary RegistryValueType = 1
	// RegistryValueType_Dword undocumented
	RegistryValueType_Dword RegistryValueType = 2
	// RegistryValueType_DwordLittleEndian undocumented
	RegistryValueType_DwordLittleEndian RegistryValueType = 3
	// RegistryValueType_DwordBigEndian undocumented
	RegistryValueType_DwordBigEndian RegistryValueType = 4
	// RegistryValueType_ExpandSz undocumented
	RegistryValueType_ExpandSz RegistryValueType = 5
	// RegistryValueType_Link undocumented
	RegistryValueType_Link RegistryValueType = 6
	// RegistryValueType_MultiSz undocumented
	RegistryValueType_MultiSz RegistryValueType = 7
	// RegistryValueType_None undocumented
	RegistryValueType_None RegistryValueType = 8
	// RegistryValueType_Qword undocumented
	RegistryValueType_Qword RegistryValueType = 9
	// RegistryValueType_QwordlittleEndian undocumented
	RegistryValueType_QwordlittleEndian RegistryValueType = 10
	// RegistryValueType_Sz undocumented
	RegistryValueType_Sz RegistryValueType = 11
	// RegistryValueType_UnknownFutureValue undocumented
	RegistryValueType_UnknownFutureValue RegistryValueType = 127
)

// RemoteAssistanceOnboardingStatus undocumented
type RemoteAssistanceOnboardingStatus int

const (
	// RemoteAssistanceOnboardingStatus_NotOnboarded undocumented
	RemoteAssistanceOnboardingStatus_NotOnboarded RemoteAssistanceOnboardingStatus = 0
	// RemoteAssistanceOnboardingStatus_Onboarding undocumented
	RemoteAssistanceOnboardingStatus_Onboarding RemoteAssistanceOnboardingStatus = 1
	// RemoteAssistanceOnboardingStatus_Onboarded undocumented
	RemoteAssistanceOnboardingStatus_Onboarded RemoteAssistanceOnboardingStatus = 2
)

// RequiredPasswordType undocumented
type RequiredPasswordType int

const (
	// RequiredPasswordType_DeviceDefault undocumented
	RequiredPasswordType_DeviceDefault RequiredPasswordType = 0
	// RequiredPasswordType_Alphanumeric undocumented
	RequiredPasswordType_Alphanumeric RequiredPasswordType = 1
	// RequiredPasswordType_Numeric undocumented
	RequiredPasswordType_Numeric RequiredPasswordType = 2
)

// ResponseType undocumented
type ResponseType int

const (
	// ResponseType_None undocumented
	ResponseType_None ResponseType = 0
	// ResponseType_Organizer undocumented
	ResponseType_Organizer ResponseType = 1
	// ResponseType_TentativelyAccepted undocumented
	ResponseType_TentativelyAccepted ResponseType = 2
	// ResponseType_Accepted undocumented
	ResponseType_Accepted ResponseType = 3
	// ResponseType_Declined undocumented
	ResponseType_Declined ResponseType = 4
	// ResponseType_NotResponded undocumented
	ResponseType_NotResponded ResponseType = 5
)

// RiskDetail undocumented
type RiskDetail int

const (
	// RiskDetail_None undocumented
	RiskDetail_None RiskDetail = 0
	// RiskDetail_AdminGeneratedTemporaryPassword undocumented
	RiskDetail_AdminGeneratedTemporaryPassword RiskDetail = 1
	// RiskDetail_UserPerformedSecuredPasswordChange undocumented
	RiskDetail_UserPerformedSecuredPasswordChange RiskDetail = 2
	// RiskDetail_UserPerformedSecuredPasswordReset undocumented
	RiskDetail_UserPerformedSecuredPasswordReset RiskDetail = 3
	// RiskDetail_AdminConfirmedSigninSafe undocumented
	RiskDetail_AdminConfirmedSigninSafe RiskDetail = 4
	// RiskDetail_AiConfirmedSigninSafe undocumented
	RiskDetail_AiConfirmedSigninSafe RiskDetail = 5
	// RiskDetail_UserPassedMFADrivenByRiskBasedPolicy undocumented
	RiskDetail_UserPassedMFADrivenByRiskBasedPolicy RiskDetail = 6
	// RiskDetail_AdminDismissedAllRiskForUser undocumented
	RiskDetail_AdminDismissedAllRiskForUser RiskDetail = 7
	// RiskDetail_AdminConfirmedSigninCompromised undocumented
	RiskDetail_AdminConfirmedSigninCompromised RiskDetail = 8
	// RiskDetail_Hidden undocumented
	RiskDetail_Hidden RiskDetail = 9
	// RiskDetail_AdminConfirmedUserCompromised undocumented
	RiskDetail_AdminConfirmedUserCompromised RiskDetail = 10
	// RiskDetail_UnknownFutureValue undocumented
	RiskDetail_UnknownFutureValue RiskDetail = 11
)

// RiskEventType undocumented
type RiskEventType int

const (
	// RiskEventType_UnlikelyTravel undocumented
	RiskEventType_UnlikelyTravel RiskEventType = 0
	// RiskEventType_AnonymizedIPAddress undocumented
	RiskEventType_AnonymizedIPAddress RiskEventType = 1
	// RiskEventType_MaliciousIPAddress undocumented
	RiskEventType_MaliciousIPAddress RiskEventType = 2
	// RiskEventType_UnfamiliarFeatures undocumented
	RiskEventType_UnfamiliarFeatures RiskEventType = 3
	// RiskEventType_MalwareInfectedIPAddress undocumented
	RiskEventType_MalwareInfectedIPAddress RiskEventType = 4
	// RiskEventType_SuspiciousIPAddress undocumented
	RiskEventType_SuspiciousIPAddress RiskEventType = 5
	// RiskEventType_LeakedCredentials undocumented
	RiskEventType_LeakedCredentials RiskEventType = 6
	// RiskEventType_InvestigationsThreatIntelligence undocumented
	RiskEventType_InvestigationsThreatIntelligence RiskEventType = 7
	// RiskEventType_Generic undocumented
	RiskEventType_Generic RiskEventType = 8
	// RiskEventType_AdminConfirmedUserCompromised undocumented
	RiskEventType_AdminConfirmedUserCompromised RiskEventType = 9
	// RiskEventType_McasImpossibleTravel undocumented
	RiskEventType_McasImpossibleTravel RiskEventType = 10
	// RiskEventType_McasSuspiciousInboxManipulationRules undocumented
	RiskEventType_McasSuspiciousInboxManipulationRules RiskEventType = 11
	// RiskEventType_InvestigationsThreatIntelligenceSigninLinked undocumented
	RiskEventType_InvestigationsThreatIntelligenceSigninLinked RiskEventType = 12
	// RiskEventType_MaliciousIPAddressValidCredentialsBlockedIP undocumented
	RiskEventType_MaliciousIPAddressValidCredentialsBlockedIP RiskEventType = 13
	// RiskEventType_UnknownFutureValue undocumented
	RiskEventType_UnknownFutureValue RiskEventType = 14
)

// RiskLevel undocumented
type RiskLevel int

const (
	// RiskLevel_Low undocumented
	RiskLevel_Low RiskLevel = 0
	// RiskLevel_Medium undocumented
	RiskLevel_Medium RiskLevel = 1
	// RiskLevel_High undocumented
	RiskLevel_High RiskLevel = 2
	// RiskLevel_Hidden undocumented
	RiskLevel_Hidden RiskLevel = 3
	// RiskLevel_None undocumented
	RiskLevel_None RiskLevel = 4
	// RiskLevel_UnknownFutureValue undocumented
	RiskLevel_UnknownFutureValue RiskLevel = 5
)

// RiskState undocumented
type RiskState int

const (
	// RiskState_None undocumented
	RiskState_None RiskState = 0
	// RiskState_ConfirmedSafe undocumented
	RiskState_ConfirmedSafe RiskState = 1
	// RiskState_Remediated undocumented
	RiskState_Remediated RiskState = 2
	// RiskState_Dismissed undocumented
	RiskState_Dismissed RiskState = 3
	// RiskState_AtRisk undocumented
	RiskState_AtRisk RiskState = 4
	// RiskState_ConfirmedCompromised undocumented
	RiskState_ConfirmedCompromised RiskState = 5
	// RiskState_UnknownFutureValue undocumented
	RiskState_UnknownFutureValue RiskState = 6
)

// SafeSearchFilterType undocumented
type SafeSearchFilterType int

const (
	// SafeSearchFilterType_UserDefined undocumented
	SafeSearchFilterType_UserDefined SafeSearchFilterType = 0
	// SafeSearchFilterType_Strict undocumented
	SafeSearchFilterType_Strict SafeSearchFilterType = 1
	// SafeSearchFilterType_Moderate undocumented
	SafeSearchFilterType_Moderate SafeSearchFilterType = 2
)

// SecurityNetworkProtocol undocumented
type SecurityNetworkProtocol int

const (
	// SecurityNetworkProtocol_Ip undocumented
	SecurityNetworkProtocol_Ip SecurityNetworkProtocol = 0
	// SecurityNetworkProtocol_Icmp undocumented
	SecurityNetworkProtocol_Icmp SecurityNetworkProtocol = 1
	// SecurityNetworkProtocol_Igmp undocumented
	SecurityNetworkProtocol_Igmp SecurityNetworkProtocol = 2
	// SecurityNetworkProtocol_Ggp undocumented
	SecurityNetworkProtocol_Ggp SecurityNetworkProtocol = 3
	// SecurityNetworkProtocol_Ipv4 undocumented
	SecurityNetworkProtocol_Ipv4 SecurityNetworkProtocol = 4
	// SecurityNetworkProtocol_Tcp undocumented
	SecurityNetworkProtocol_Tcp SecurityNetworkProtocol = 6
	// SecurityNetworkProtocol_Pup undocumented
	SecurityNetworkProtocol_Pup SecurityNetworkProtocol = 12
	// SecurityNetworkProtocol_Udp undocumented
	SecurityNetworkProtocol_Udp SecurityNetworkProtocol = 17
	// SecurityNetworkProtocol_Idp undocumented
	SecurityNetworkProtocol_Idp SecurityNetworkProtocol = 22
	// SecurityNetworkProtocol_Ipv6 undocumented
	SecurityNetworkProtocol_Ipv6 SecurityNetworkProtocol = 41
	// SecurityNetworkProtocol_Ipv6RoutingHeader undocumented
	SecurityNetworkProtocol_Ipv6RoutingHeader SecurityNetworkProtocol = 43
	// SecurityNetworkProtocol_Ipv6FragmentHeader undocumented
	SecurityNetworkProtocol_Ipv6FragmentHeader SecurityNetworkProtocol = 44
	// SecurityNetworkProtocol_IpSecEncapsulatingSecurityPayload undocumented
	SecurityNetworkProtocol_IpSecEncapsulatingSecurityPayload SecurityNetworkProtocol = 50
	// SecurityNetworkProtocol_IpSecAuthenticationHeader undocumented
	SecurityNetworkProtocol_IpSecAuthenticationHeader SecurityNetworkProtocol = 51
	// SecurityNetworkProtocol_IcmpV6 undocumented
	SecurityNetworkProtocol_IcmpV6 SecurityNetworkProtocol = 58
	// SecurityNetworkProtocol_Ipv6NoNextHeader undocumented
	SecurityNetworkProtocol_Ipv6NoNextHeader SecurityNetworkProtocol = 59
	// SecurityNetworkProtocol_Ipv6DestinationOptions undocumented
	SecurityNetworkProtocol_Ipv6DestinationOptions SecurityNetworkProtocol = 60
	// SecurityNetworkProtocol_Nd undocumented
	SecurityNetworkProtocol_Nd SecurityNetworkProtocol = 77
	// SecurityNetworkProtocol_Raw undocumented
	SecurityNetworkProtocol_Raw SecurityNetworkProtocol = 255
	// SecurityNetworkProtocol_Ipx undocumented
	SecurityNetworkProtocol_Ipx SecurityNetworkProtocol = 1000
	// SecurityNetworkProtocol_Spx undocumented
	SecurityNetworkProtocol_Spx SecurityNetworkProtocol = 1256
	// SecurityNetworkProtocol_SpxII undocumented
	SecurityNetworkProtocol_SpxII SecurityNetworkProtocol = 1257
	// SecurityNetworkProtocol_UnknownFutureValue undocumented
	SecurityNetworkProtocol_UnknownFutureValue SecurityNetworkProtocol = 32767
	// SecurityNetworkProtocol_Unknown undocumented
	SecurityNetworkProtocol_Unknown SecurityNetworkProtocol = -1
)

// SelectionLikelihoodInfo undocumented
type SelectionLikelihoodInfo int

const (
	// SelectionLikelihoodInfo_NotSpecified undocumented
	SelectionLikelihoodInfo_NotSpecified SelectionLikelihoodInfo = 0
	// SelectionLikelihoodInfo_High undocumented
	SelectionLikelihoodInfo_High SelectionLikelihoodInfo = 1
)

// Sensitivity undocumented
type Sensitivity int

const (
	// Sensitivity_Normal undocumented
	Sensitivity_Normal Sensitivity = 0
	// Sensitivity_Personal undocumented
	Sensitivity_Personal Sensitivity = 1
	// Sensitivity_Private undocumented
	Sensitivity_Private Sensitivity = 2
	// Sensitivity_Confidential undocumented
	Sensitivity_Confidential Sensitivity = 3
)

// SharedPCAccountDeletionPolicyType undocumented
type SharedPCAccountDeletionPolicyType int

const (
	// SharedPCAccountDeletionPolicyType_Immediate undocumented
	SharedPCAccountDeletionPolicyType_Immediate SharedPCAccountDeletionPolicyType = 0
	// SharedPCAccountDeletionPolicyType_DiskSpaceThreshold undocumented
	SharedPCAccountDeletionPolicyType_DiskSpaceThreshold SharedPCAccountDeletionPolicyType = 1
	// SharedPCAccountDeletionPolicyType_DiskSpaceThresholdOrInactiveThreshold undocumented
	SharedPCAccountDeletionPolicyType_DiskSpaceThresholdOrInactiveThreshold SharedPCAccountDeletionPolicyType = 2
)

// SharedPCAllowedAccountType undocumented
type SharedPCAllowedAccountType int

const (
	// SharedPCAllowedAccountType_Guest undocumented
	SharedPCAllowedAccountType_Guest SharedPCAllowedAccountType = 1
	// SharedPCAllowedAccountType_Domain undocumented
	SharedPCAllowedAccountType_Domain SharedPCAllowedAccountType = 2
)

// SiteSecurityLevel undocumented
type SiteSecurityLevel int

const (
	// SiteSecurityLevel_UserDefined undocumented
	SiteSecurityLevel_UserDefined SiteSecurityLevel = 0
	// SiteSecurityLevel_Low undocumented
	SiteSecurityLevel_Low SiteSecurityLevel = 1
	// SiteSecurityLevel_MediumLow undocumented
	SiteSecurityLevel_MediumLow SiteSecurityLevel = 2
	// SiteSecurityLevel_Medium undocumented
	SiteSecurityLevel_Medium SiteSecurityLevel = 3
	// SiteSecurityLevel_MediumHigh undocumented
	SiteSecurityLevel_MediumHigh SiteSecurityLevel = 4
	// SiteSecurityLevel_High undocumented
	SiteSecurityLevel_High SiteSecurityLevel = 5
)

// StateManagementSetting undocumented
type StateManagementSetting int

const (
	// StateManagementSetting_NotConfigured undocumented
	StateManagementSetting_NotConfigured StateManagementSetting = 0
	// StateManagementSetting_Blocked undocumented
	StateManagementSetting_Blocked StateManagementSetting = 1
	// StateManagementSetting_Allowed undocumented
	StateManagementSetting_Allowed StateManagementSetting = 2
)

// Status undocumented
type Status int

const (
	// Status_Active undocumented
	Status_Active Status = 0
	// Status_Updated undocumented
	Status_Updated Status = 1
	// Status_Deleted undocumented
	Status_Deleted Status = 2
	// Status_Ignored undocumented
	Status_Ignored Status = 3
	// Status_UnknownFutureValue undocumented
	Status_UnknownFutureValue Status = 4
)

// TeamVisibilityType undocumented
type TeamVisibilityType int

const (
	// TeamVisibilityType_Private undocumented
	TeamVisibilityType_Private TeamVisibilityType = 0
	// TeamVisibilityType_Public undocumented
	TeamVisibilityType_Public TeamVisibilityType = 1
	// TeamVisibilityType_HiddenMembership undocumented
	TeamVisibilityType_HiddenMembership TeamVisibilityType = 2
	// TeamVisibilityType_UnknownFutureValue undocumented
	TeamVisibilityType_UnknownFutureValue TeamVisibilityType = 3
)

// TeamsAppDistributionMethod undocumented
type TeamsAppDistributionMethod int

const (
	// TeamsAppDistributionMethod_Store undocumented
	TeamsAppDistributionMethod_Store TeamsAppDistributionMethod = 0
	// TeamsAppDistributionMethod_Organization undocumented
	TeamsAppDistributionMethod_Organization TeamsAppDistributionMethod = 1
	// TeamsAppDistributionMethod_Sideloaded undocumented
	TeamsAppDistributionMethod_Sideloaded TeamsAppDistributionMethod = 2
	// TeamsAppDistributionMethod_UnknownFutureValue undocumented
	TeamsAppDistributionMethod_UnknownFutureValue TeamsAppDistributionMethod = 3
)

// TeamsAsyncOperationStatus undocumented
type TeamsAsyncOperationStatus int

const (
	// TeamsAsyncOperationStatus_Invalid undocumented
	TeamsAsyncOperationStatus_Invalid TeamsAsyncOperationStatus = 0
	// TeamsAsyncOperationStatus_NotStarted undocumented
	TeamsAsyncOperationStatus_NotStarted TeamsAsyncOperationStatus = 1
	// TeamsAsyncOperationStatus_InProgress undocumented
	TeamsAsyncOperationStatus_InProgress TeamsAsyncOperationStatus = 2
	// TeamsAsyncOperationStatus_Succeeded undocumented
	TeamsAsyncOperationStatus_Succeeded TeamsAsyncOperationStatus = 3
	// TeamsAsyncOperationStatus_Failed undocumented
	TeamsAsyncOperationStatus_Failed TeamsAsyncOperationStatus = 4
	// TeamsAsyncOperationStatus_UnknownFutureValue undocumented
	TeamsAsyncOperationStatus_UnknownFutureValue TeamsAsyncOperationStatus = 5
)

// TeamsAsyncOperationType undocumented
type TeamsAsyncOperationType int

const (
	// TeamsAsyncOperationType_Invalid undocumented
	TeamsAsyncOperationType_Invalid TeamsAsyncOperationType = 0
	// TeamsAsyncOperationType_CloneTeam undocumented
	TeamsAsyncOperationType_CloneTeam TeamsAsyncOperationType = 1
	// TeamsAsyncOperationType_ArchiveTeam undocumented
	TeamsAsyncOperationType_ArchiveTeam TeamsAsyncOperationType = 2
	// TeamsAsyncOperationType_UnarchiveTeam undocumented
	TeamsAsyncOperationType_UnarchiveTeam TeamsAsyncOperationType = 3
	// TeamsAsyncOperationType_CreateTeam undocumented
	TeamsAsyncOperationType_CreateTeam TeamsAsyncOperationType = 4
	// TeamsAsyncOperationType_UnknownFutureValue undocumented
	TeamsAsyncOperationType_UnknownFutureValue TeamsAsyncOperationType = 5
)

// TimeZoneStandard undocumented
type TimeZoneStandard int

const (
	// TimeZoneStandard_Windows undocumented
	TimeZoneStandard_Windows TimeZoneStandard = 0
	// TimeZoneStandard_Iana undocumented
	TimeZoneStandard_Iana TimeZoneStandard = 1
)

// UserAccountSecurityType undocumented
type UserAccountSecurityType int

const (
	// UserAccountSecurityType_Unknown undocumented
	UserAccountSecurityType_Unknown UserAccountSecurityType = 0
	// UserAccountSecurityType_Standard undocumented
	UserAccountSecurityType_Standard UserAccountSecurityType = 1
	// UserAccountSecurityType_Power undocumented
	UserAccountSecurityType_Power UserAccountSecurityType = 2
	// UserAccountSecurityType_Administrator undocumented
	UserAccountSecurityType_Administrator UserAccountSecurityType = 3
	// UserAccountSecurityType_UnknownFutureValue undocumented
	UserAccountSecurityType_UnknownFutureValue UserAccountSecurityType = 127
)

// VisibilitySetting undocumented
type VisibilitySetting int

const (
	// VisibilitySetting_NotConfigured undocumented
	VisibilitySetting_NotConfigured VisibilitySetting = 0
	// VisibilitySetting_Hide undocumented
	VisibilitySetting_Hide VisibilitySetting = 1
	// VisibilitySetting_Show undocumented
	VisibilitySetting_Show VisibilitySetting = 2
)

// VppTokenAccountType undocumented
type VppTokenAccountType int

const (
	// VppTokenAccountType_Business undocumented
	VppTokenAccountType_Business VppTokenAccountType = 0
	// VppTokenAccountType_Education undocumented
	VppTokenAccountType_Education VppTokenAccountType = 1
)

// VppTokenState undocumented
type VppTokenState int

const (
	// VppTokenState_Unknown undocumented
	VppTokenState_Unknown VppTokenState = 0
	// VppTokenState_Valid undocumented
	VppTokenState_Valid VppTokenState = 1
	// VppTokenState_Expired undocumented
	VppTokenState_Expired VppTokenState = 2
	// VppTokenState_Invalid undocumented
	VppTokenState_Invalid VppTokenState = 3
	// VppTokenState_AssignedToExternalMDM undocumented
	VppTokenState_AssignedToExternalMDM VppTokenState = 4
)

// VppTokenSyncStatus undocumented
type VppTokenSyncStatus int

const (
	// VppTokenSyncStatus_None undocumented
	VppTokenSyncStatus_None VppTokenSyncStatus = 0
	// VppTokenSyncStatus_InProgress undocumented
	VppTokenSyncStatus_InProgress VppTokenSyncStatus = 1
	// VppTokenSyncStatus_Completed undocumented
	VppTokenSyncStatus_Completed VppTokenSyncStatus = 2
	// VppTokenSyncStatus_Failed undocumented
	VppTokenSyncStatus_Failed VppTokenSyncStatus = 3
)

// WebBrowserCookieSettings undocumented
type WebBrowserCookieSettings int

const (
	// WebBrowserCookieSettings_BrowserDefault undocumented
	WebBrowserCookieSettings_BrowserDefault WebBrowserCookieSettings = 0
	// WebBrowserCookieSettings_BlockAlways undocumented
	WebBrowserCookieSettings_BlockAlways WebBrowserCookieSettings = 1
	// WebBrowserCookieSettings_AllowCurrentWebSite undocumented
	WebBrowserCookieSettings_AllowCurrentWebSite WebBrowserCookieSettings = 2
	// WebBrowserCookieSettings_AllowFromWebsitesVisited undocumented
	WebBrowserCookieSettings_AllowFromWebsitesVisited WebBrowserCookieSettings = 3
	// WebBrowserCookieSettings_AllowAlways undocumented
	WebBrowserCookieSettings_AllowAlways WebBrowserCookieSettings = 4
)

// WebsiteType undocumented
type WebsiteType int

const (
	// WebsiteType_Other undocumented
	WebsiteType_Other WebsiteType = 0
	// WebsiteType_Home undocumented
	WebsiteType_Home WebsiteType = 1
	// WebsiteType_Work undocumented
	WebsiteType_Work WebsiteType = 2
	// WebsiteType_Blog undocumented
	WebsiteType_Blog WebsiteType = 3
	// WebsiteType_Profile undocumented
	WebsiteType_Profile WebsiteType = 4
)

// WeekIndex undocumented
type WeekIndex int

const (
	// WeekIndex_First undocumented
	WeekIndex_First WeekIndex = 0
	// WeekIndex_Second undocumented
	WeekIndex_Second WeekIndex = 1
	// WeekIndex_Third undocumented
	WeekIndex_Third WeekIndex = 2
	// WeekIndex_Fourth undocumented
	WeekIndex_Fourth WeekIndex = 3
	// WeekIndex_Last undocumented
	WeekIndex_Last WeekIndex = 4
)

// WeeklySchedule undocumented
type WeeklySchedule int

const (
	// WeeklySchedule_UserDefined undocumented
	WeeklySchedule_UserDefined WeeklySchedule = 0
	// WeeklySchedule_Everyday undocumented
	WeeklySchedule_Everyday WeeklySchedule = 1
	// WeeklySchedule_Sunday undocumented
	WeeklySchedule_Sunday WeeklySchedule = 2
	// WeeklySchedule_Monday undocumented
	WeeklySchedule_Monday WeeklySchedule = 3
	// WeeklySchedule_Tuesday undocumented
	WeeklySchedule_Tuesday WeeklySchedule = 4
	// WeeklySchedule_Wednesday undocumented
	WeeklySchedule_Wednesday WeeklySchedule = 5
	// WeeklySchedule_Thursday undocumented
	WeeklySchedule_Thursday WeeklySchedule = 6
	// WeeklySchedule_Friday undocumented
	WeeklySchedule_Friday WeeklySchedule = 7
	// WeeklySchedule_Saturday undocumented
	WeeklySchedule_Saturday WeeklySchedule = 8
)

// WelcomeScreenMeetingInformation undocumented
type WelcomeScreenMeetingInformation int

const (
	// WelcomeScreenMeetingInformation_UserDefined undocumented
	WelcomeScreenMeetingInformation_UserDefined WelcomeScreenMeetingInformation = 0
	// WelcomeScreenMeetingInformation_ShowOrganizerAndTimeOnly undocumented
	WelcomeScreenMeetingInformation_ShowOrganizerAndTimeOnly WelcomeScreenMeetingInformation = 1
	// WelcomeScreenMeetingInformation_ShowOrganizerAndTimeAndSubject undocumented
	WelcomeScreenMeetingInformation_ShowOrganizerAndTimeAndSubject WelcomeScreenMeetingInformation = 2
)

// Windows10EditionType undocumented
type Windows10EditionType int

const (
	// Windows10EditionType_Windows10Enterprise undocumented
	Windows10EditionType_Windows10Enterprise Windows10EditionType = 0
	// Windows10EditionType_Windows10EnterpriseN undocumented
	Windows10EditionType_Windows10EnterpriseN Windows10EditionType = 1
	// Windows10EditionType_Windows10Education undocumented
	Windows10EditionType_Windows10Education Windows10EditionType = 2
	// Windows10EditionType_Windows10EducationN undocumented
	Windows10EditionType_Windows10EducationN Windows10EditionType = 3
	// Windows10EditionType_Windows10MobileEnterprise undocumented
	Windows10EditionType_Windows10MobileEnterprise Windows10EditionType = 4
	// Windows10EditionType_Windows10HolographicEnterprise undocumented
	Windows10EditionType_Windows10HolographicEnterprise Windows10EditionType = 5
	// Windows10EditionType_Windows10Professional undocumented
	Windows10EditionType_Windows10Professional Windows10EditionType = 6
	// Windows10EditionType_Windows10ProfessionalN undocumented
	Windows10EditionType_Windows10ProfessionalN Windows10EditionType = 7
	// Windows10EditionType_Windows10ProfessionalEducation undocumented
	Windows10EditionType_Windows10ProfessionalEducation Windows10EditionType = 8
	// Windows10EditionType_Windows10ProfessionalEducationN undocumented
	Windows10EditionType_Windows10ProfessionalEducationN Windows10EditionType = 9
	// Windows10EditionType_Windows10ProfessionalWorkstation undocumented
	Windows10EditionType_Windows10ProfessionalWorkstation Windows10EditionType = 10
	// Windows10EditionType_Windows10ProfessionalWorkstationN undocumented
	Windows10EditionType_Windows10ProfessionalWorkstationN Windows10EditionType = 11
)

// WindowsArchitecture undocumented
type WindowsArchitecture int

const (
	// WindowsArchitecture_None undocumented
	WindowsArchitecture_None WindowsArchitecture = 0
	// WindowsArchitecture_X86 undocumented
	WindowsArchitecture_X86 WindowsArchitecture = 1
	// WindowsArchitecture_X64 undocumented
	WindowsArchitecture_X64 WindowsArchitecture = 2
	// WindowsArchitecture_Arm undocumented
	WindowsArchitecture_Arm WindowsArchitecture = 4
	// WindowsArchitecture_Neutral undocumented
	WindowsArchitecture_Neutral WindowsArchitecture = 8
)

// WindowsDeliveryOptimizationMode undocumented
type WindowsDeliveryOptimizationMode int

const (
	// WindowsDeliveryOptimizationMode_UserDefined undocumented
	WindowsDeliveryOptimizationMode_UserDefined WindowsDeliveryOptimizationMode = 0
	// WindowsDeliveryOptimizationMode_HttpOnly undocumented
	WindowsDeliveryOptimizationMode_HttpOnly WindowsDeliveryOptimizationMode = 1
	// WindowsDeliveryOptimizationMode_HttpWithPeeringNat undocumented
	WindowsDeliveryOptimizationMode_HttpWithPeeringNat WindowsDeliveryOptimizationMode = 2
	// WindowsDeliveryOptimizationMode_HttpWithPeeringPrivateGroup undocumented
	WindowsDeliveryOptimizationMode_HttpWithPeeringPrivateGroup WindowsDeliveryOptimizationMode = 3
	// WindowsDeliveryOptimizationMode_HttpWithInternetPeering undocumented
	WindowsDeliveryOptimizationMode_HttpWithInternetPeering WindowsDeliveryOptimizationMode = 4
	// WindowsDeliveryOptimizationMode_SimpleDownload undocumented
	WindowsDeliveryOptimizationMode_SimpleDownload WindowsDeliveryOptimizationMode = 99
	// WindowsDeliveryOptimizationMode_BypassMode undocumented
	WindowsDeliveryOptimizationMode_BypassMode WindowsDeliveryOptimizationMode = 100
)

// WindowsDeviceType undocumented
type WindowsDeviceType int

const (
	// WindowsDeviceType_None undocumented
	WindowsDeviceType_None WindowsDeviceType = 0
	// WindowsDeviceType_Desktop undocumented
	WindowsDeviceType_Desktop WindowsDeviceType = 1
	// WindowsDeviceType_Mobile undocumented
	WindowsDeviceType_Mobile WindowsDeviceType = 2
	// WindowsDeviceType_Holographic undocumented
	WindowsDeviceType_Holographic WindowsDeviceType = 4
	// WindowsDeviceType_Team undocumented
	WindowsDeviceType_Team WindowsDeviceType = 8
)

// WindowsHelloForBusinessPinUsage undocumented
type WindowsHelloForBusinessPinUsage int

const (
	// WindowsHelloForBusinessPinUsage_Allowed undocumented
	WindowsHelloForBusinessPinUsage_Allowed WindowsHelloForBusinessPinUsage = 0
	// WindowsHelloForBusinessPinUsage_Required undocumented
	WindowsHelloForBusinessPinUsage_Required WindowsHelloForBusinessPinUsage = 1
	// WindowsHelloForBusinessPinUsage_Disallowed undocumented
	WindowsHelloForBusinessPinUsage_Disallowed WindowsHelloForBusinessPinUsage = 2
)

// WindowsInformationProtectionEnforcementLevel undocumented
type WindowsInformationProtectionEnforcementLevel int

const (
	// WindowsInformationProtectionEnforcementLevel_NoProtection undocumented
	WindowsInformationProtectionEnforcementLevel_NoProtection WindowsInformationProtectionEnforcementLevel = 0
	// WindowsInformationProtectionEnforcementLevel_EncryptAndAuditOnly undocumented
	WindowsInformationProtectionEnforcementLevel_EncryptAndAuditOnly WindowsInformationProtectionEnforcementLevel = 1
	// WindowsInformationProtectionEnforcementLevel_EncryptAuditAndPrompt undocumented
	WindowsInformationProtectionEnforcementLevel_EncryptAuditAndPrompt WindowsInformationProtectionEnforcementLevel = 2
	// WindowsInformationProtectionEnforcementLevel_EncryptAuditAndBlock undocumented
	WindowsInformationProtectionEnforcementLevel_EncryptAuditAndBlock WindowsInformationProtectionEnforcementLevel = 3
)

// WindowsInformationProtectionPinCharacterRequirements undocumented
type WindowsInformationProtectionPinCharacterRequirements int

const (
	// WindowsInformationProtectionPinCharacterRequirements_NotAllow undocumented
	WindowsInformationProtectionPinCharacterRequirements_NotAllow WindowsInformationProtectionPinCharacterRequirements = 0
	// WindowsInformationProtectionPinCharacterRequirements_RequireAtLeastOne undocumented
	WindowsInformationProtectionPinCharacterRequirements_RequireAtLeastOne WindowsInformationProtectionPinCharacterRequirements = 1
	// WindowsInformationProtectionPinCharacterRequirements_Allow undocumented
	WindowsInformationProtectionPinCharacterRequirements_Allow WindowsInformationProtectionPinCharacterRequirements = 2
)

// WindowsSpotlightEnablementSettings undocumented
type WindowsSpotlightEnablementSettings int

const (
	// WindowsSpotlightEnablementSettings_NotConfigured undocumented
	WindowsSpotlightEnablementSettings_NotConfigured WindowsSpotlightEnablementSettings = 0
	// WindowsSpotlightEnablementSettings_Disabled undocumented
	WindowsSpotlightEnablementSettings_Disabled WindowsSpotlightEnablementSettings = 1
	// WindowsSpotlightEnablementSettings_Enabled undocumented
	WindowsSpotlightEnablementSettings_Enabled WindowsSpotlightEnablementSettings = 2
)

// WindowsStartMenuAppListVisibilityType undocumented
type WindowsStartMenuAppListVisibilityType int

const (
	// WindowsStartMenuAppListVisibilityType_UserDefined undocumented
	WindowsStartMenuAppListVisibilityType_UserDefined WindowsStartMenuAppListVisibilityType = 0
	// WindowsStartMenuAppListVisibilityType_Collapse undocumented
	WindowsStartMenuAppListVisibilityType_Collapse WindowsStartMenuAppListVisibilityType = 1
	// WindowsStartMenuAppListVisibilityType_Remove undocumented
	WindowsStartMenuAppListVisibilityType_Remove WindowsStartMenuAppListVisibilityType = 2
	// WindowsStartMenuAppListVisibilityType_DisableSettingsApp undocumented
	WindowsStartMenuAppListVisibilityType_DisableSettingsApp WindowsStartMenuAppListVisibilityType = 4
)

// WindowsStartMenuModeType undocumented
type WindowsStartMenuModeType int

const (
	// WindowsStartMenuModeType_UserDefined undocumented
	WindowsStartMenuModeType_UserDefined WindowsStartMenuModeType = 0
	// WindowsStartMenuModeType_FullScreen undocumented
	WindowsStartMenuModeType_FullScreen WindowsStartMenuModeType = 1
	// WindowsStartMenuModeType_NonFullScreen undocumented
	WindowsStartMenuModeType_NonFullScreen WindowsStartMenuModeType = 2
)

// WindowsUpdateType undocumented
type WindowsUpdateType int

const (
	// WindowsUpdateType_UserDefined undocumented
	WindowsUpdateType_UserDefined WindowsUpdateType = 0
	// WindowsUpdateType_All undocumented
	WindowsUpdateType_All WindowsUpdateType = 1
	// WindowsUpdateType_BusinessReadyOnly undocumented
	WindowsUpdateType_BusinessReadyOnly WindowsUpdateType = 2
	// WindowsUpdateType_WindowsInsiderBuildFast undocumented
	WindowsUpdateType_WindowsInsiderBuildFast WindowsUpdateType = 3
	// WindowsUpdateType_WindowsInsiderBuildSlow undocumented
	WindowsUpdateType_WindowsInsiderBuildSlow WindowsUpdateType = 4
	// WindowsUpdateType_WindowsInsiderBuildRelease undocumented
	WindowsUpdateType_WindowsInsiderBuildRelease WindowsUpdateType = 5
)

// WindowsUserAccountControlSettings undocumented
type WindowsUserAccountControlSettings int

const (
	// WindowsUserAccountControlSettings_UserDefined undocumented
	WindowsUserAccountControlSettings_UserDefined WindowsUserAccountControlSettings = 0
	// WindowsUserAccountControlSettings_AlwaysNotify undocumented
	WindowsUserAccountControlSettings_AlwaysNotify WindowsUserAccountControlSettings = 1
	// WindowsUserAccountControlSettings_NotifyOnAppChanges undocumented
	WindowsUserAccountControlSettings_NotifyOnAppChanges WindowsUserAccountControlSettings = 2
	// WindowsUserAccountControlSettings_NotifyOnAppChangesWithoutDimming undocumented
	WindowsUserAccountControlSettings_NotifyOnAppChangesWithoutDimming WindowsUserAccountControlSettings = 3
	// WindowsUserAccountControlSettings_NeverNotify undocumented
	WindowsUserAccountControlSettings_NeverNotify WindowsUserAccountControlSettings = 4
)

// ComplexExtensionValue undocumented
type ComplexExtensionValue struct {
}

// IComplexExtensionValue interface type for ComplexExtensionValue
type IComplexExtensionValue interface {
	PComplexExtensionValue() *ComplexExtensionValue
}

// PComplexExtensionValue pointer method for ComplexExtensionValue
func (p *ComplexExtensionValue) PComplexExtensionValue() *ComplexExtensionValue { return p }

// CopyNotebookModel undocumented
type CopyNotebookModel struct {
	// IsDefault undocumented
	IsDefault *bool `json:"isDefault,omitempty"`
	// UserRole undocumented
	UserRole *OnenoteUserRole `json:"userRole,omitempty"`
	// IsShared undocumented
	IsShared *bool `json:"isShared,omitempty"`
	// SectionsUrl undocumented
	SectionsUrl *string `json:"sectionsUrl,omitempty"`
	// SectionGroupsUrl undocumented
	SectionGroupsUrl *string `json:"sectionGroupsUrl,omitempty"`
	// Links undocumented
	Links *NotebookLinks `json:"links,omitempty"`
	// Name undocumented
	Name *string `json:"name,omitempty"`
	// CreatedBy undocumented
	CreatedBy *string `json:"createdBy,omitempty"`
	// CreatedByIdentity undocumented
	CreatedByIdentity *IdentitySet `json:"createdByIdentity,omitempty"`
	// LastModifiedBy undocumented
	LastModifiedBy *string `json:"lastModifiedBy,omitempty"`
	// LastModifiedByIdentity undocumented
	LastModifiedByIdentity *IdentitySet `json:"lastModifiedByIdentity,omitempty"`
	// LastModifiedTime undocumented
	LastModifiedTime *time.Time `json:"lastModifiedTime,omitempty"`
	// Id undocumented
	Id *string `json:"id,omitempty"`
	// Self undocumented
	Self *string `json:"self,omitempty"`
	// CreatedTime undocumented
	CreatedTime *time.Time `json:"createdTime,omitempty"`
}

// ICopyNotebookModel interface type for CopyNotebookModel
type ICopyNotebookModel interface {
	PCopyNotebookModel() *CopyNotebookModel
}

// PCopyNotebookModel pointer method for CopyNotebookModel
func (p *CopyNotebookModel) PCopyNotebookModel() *CopyNotebookModel { return p }

// Json undocumented
type Json struct {
}

// IJson interface type for Json
type IJson interface {
	PJson() *Json
}

// PJson pointer method for Json
func (p *Json) PJson() *Json { return p }

// AccessAction undocumented
type AccessAction struct {
}

// IAccessAction interface type for accessAction
type IAccessAction interface {
	PAccessAction() *AccessAction
}

// PAccessAction pointer method for accessAction
func (p *AccessAction) PAccessAction() *AccessAction { return p }

// ActivityHistoryItem undocumented
type ActivityHistoryItem struct {
	Entity
	// Status undocumented
	Status *Status `json:"status,omitempty"`
	// ActiveDurationSeconds undocumented
	ActiveDurationSeconds *int `json:"activeDurationSeconds,omitempty"`
	// CreatedDateTime undocumented
	CreatedDateTime *time.Time `json:"createdDateTime,omitempty"`
	// LastActiveDateTime undocumented
	LastActiveDateTime *time.Time `json:"lastActiveDateTime,omitempty"`
	// LastModifiedDateTime undocumented
	LastModifiedDateTime *time.Time `json:"lastModifiedDateTime,omitempty"`
	// ExpirationDateTime undocumented
	ExpirationDateTime *time.Time `json:"expirationDateTime,omitempty"`
	// StartedDateTime undocumented
	StartedDateTime *time.Time `json:"startedDateTime,omitempty"`
	// UserTimezone undocumented
	UserTimezone *string `json:"userTimezone,omitempty"`
}

// IActivityHistoryItem interface type for activityHistoryItem
type IActivityHistoryItem interface {
	PActivityHistoryItem() *ActivityHistoryItem
}

// PActivityHistoryItem pointer method for activityHistoryItem
func (p *ActivityHistoryItem) PActivityHistoryItem() *ActivityHistoryItem { return p }

// AdministrativeUnit undocumented
type AdministrativeUnit struct {
	DirectoryObject
}

// IAdministrativeUnit interface type for administrativeUnit
type IAdministrativeUnit interface {
	PAdministrativeUnit() *AdministrativeUnit
}

// PAdministrativeUnit pointer method for administrativeUnit
func (p *AdministrativeUnit) PAdministrativeUnit() *AdministrativeUnit { return p }

// Alert undocumented
type Alert struct {
	Entity
	// ActivityGroupName undocumented
	ActivityGroupName *string `json:"activityGroupName,omitempty"`
	// AssignedTo undocumented
	AssignedTo *string `json:"assignedTo,omitempty"`
	// AzureSubscriptionId undocumented
	AzureSubscriptionId *string `json:"azureSubscriptionId,omitempty"`
	// AzureTenantId undocumented
	AzureTenantId *string `json:"azureTenantId,omitempty"`
	// Category undocumented
	Category *string `json:"category,omitempty"`
	// ClosedDateTime undocumented
	ClosedDateTime *time.Time `json:"closedDateTime,omitempty"`
	// CloudAppStates undocumented
	CloudAppStates []CloudAppSecurityState `json:"cloudAppStates,omitempty"`
	// Comments undocumented
	Comments []string `json:"comments,omitempty"`
	// Confidence undocumented
	Confidence *int `json:"confidence,omitempty"`
	// CreatedDateTime undocumented
	CreatedDateTime *time.Time `json:"createdDateTime,omitempty"`
	// Description undocumented
	Description *string `json:"description,omitempty"`
	// DetectionIds undocumented
	DetectionIds []string `json:"detectionIds,omitempty"`
	// EventDateTime undocumented
	EventDateTime *time.Time `json:"eventDateTime,omitempty"`
	// Feedback undocumented
	Feedback *AlertFeedback `json:"feedback,omitempty"`
	// FileStates undocumented
	FileStates []FileSecurityState `json:"fileStates,omitempty"`
	// HistoryStates undocumented
	HistoryStates []AlertHistoryState `json:"historyStates,omitempty"`
	// HostStates undocumented
	HostStates []HostSecurityState `json:"hostStates,omitempty"`
	// LastModifiedDateTime undocumented
	LastModifiedDateTime *time.Time `json:"lastModifiedDateTime,omitempty"`
	// MalwareStates undocumented
	MalwareStates []MalwareState `json:"malwareStates,omitempty"`
	// NetworkConnections undocumented
	NetworkConnections []NetworkConnection `json:"networkConnections,omitempty"`
	// Processes undocumented
	Processes []Process `json:"processes,omitempty"`
	// RecommendedActions undocumented
	RecommendedActions []string `json:"recommendedActions,omitempty"`
	// RegistryKeyStates undocumented
	RegistryKeyStates []RegistryKeyState `json:"registryKeyStates,omitempty"`
	// Severity undocumented
	Severity *AlertSeverity `json:"severity,omitempty"`
	// SourceMaterials undocumented
	SourceMaterials []string `json:"sourceMaterials,omitempty"`
	// Status undocumented
	Status *AlertStatus `json:"status,omitempty"`
	// Tags undocumented
	Tags []string `json:"tags,omitempty"`
	// Title undocumented
	Title *string `json:"title,omitempty"`
	// Triggers undocumented
	Triggers []AlertTrigger `json:"triggers,omitempty"`
	// UserStates undocumented
	UserStates []UserSecurityState `json:"userStates,omitempty"`
	// VendorInformation undocumented
	VendorInformation *SecurityVendorInformation `json:"vendorInformation,omitempty"`
	// VulnerabilityStates undocumented
	VulnerabilityStates []VulnerabilityState `json:"vulnerabilityStates,omitempty"`
}

// IAlert interface type for alert
type IAlert interface {
	PAlert() *Alert
}

// PAlert pointer method for alert
func (p *Alert) PAlert() *Alert { return p }

// AlertHistoryState undocumented
type AlertHistoryState struct {
	// AppId undocumented
	AppId *string `json:"appId,omitempty"`
	// AssignedTo undocumented
	AssignedTo *string `json:"assignedTo,omitempty"`
	// Comments undocumented
	Comments []string `json:"comments,omitempty"`
	// Feedback undocumented
	Feedback *AlertFeedback `json:"feedback,omitempty"`
	// Status undocumented
	Status *AlertStatus `json:"status,omitempty"`
	// UpdatedDateTime undocumented
	UpdatedDateTime *time.Time `json:"updatedDateTime,omitempty"`
	// User undocumented
	User *string `json:"user,omitempty"`
}

// IAlertHistoryState interface type for alertHistoryState
type IAlertHistoryState interface {
	PAlertHistoryState() *AlertHistoryState
}

// PAlertHistoryState pointer method for alertHistoryState
func (p *AlertHistoryState) PAlertHistoryState() *AlertHistoryState { return p }

// AlertTrigger undocumented
type AlertTrigger struct {
	// Name undocumented
	Name *string `json:"name,omitempty"`
	// Type undocumented
	Type *string `json:"type,omitempty"`
	// Value undocumented
	Value *string `json:"value,omitempty"`
}

// IAlertTrigger interface type for alertTrigger
type IAlertTrigger interface {
	PAlertTrigger() *AlertTrigger
}

// PAlertTrigger pointer method for alertTrigger
func (p *AlertTrigger) PAlertTrigger() *AlertTrigger { return p }

// AllDevicesAssignmentTarget undocumented
type AllDevicesAssignmentTarget struct {
	DeviceAndAppManagementAssignmentTarget
}

// IAllDevicesAssignmentTarget interface type for allDevicesAssignmentTarget
type IAllDevicesAssignmentTarget interface {
	PAllDevicesAssignmentTarget() *AllDevicesAssignmentTarget
}

// PAllDevicesAssignmentTarget pointer method for allDevicesAssignmentTarget
func (p *AllDevicesAssignmentTarget) PAllDevicesAssignmentTarget() *AllDevicesAssignmentTarget {
	return p
}

// AllLicensedUsersAssignmentTarget undocumented
type AllLicensedUsersAssignmentTarget struct {
	DeviceAndAppManagementAssignmentTarget
}

// IAllLicensedUsersAssignmentTarget interface type for allLicensedUsersAssignmentTarget
type IAllLicensedUsersAssignmentTarget interface {
	PAllLicensedUsersAssignmentTarget() *AllLicensedUsersAssignmentTarget
}

// PAllLicensedUsersAssignmentTarget pointer method for allLicensedUsersAssignmentTarget
func (p *AllLicensedUsersAssignmentTarget) PAllLicensedUsersAssignmentTarget() *AllLicensedUsersAssignmentTarget {
	return p
}

// AlternativeSecurityId undocumented
type AlternativeSecurityId struct {
	// Type undocumented
	Type *int `json:"type,omitempty"`
	// IdentityProvider undocumented
	IdentityProvider *string `json:"identityProvider,omitempty"`
	// Key undocumented
	Key *Binary `json:"key,omitempty"`
}

// IAlternativeSecurityId interface type for alternativeSecurityId
type IAlternativeSecurityId interface {
	PAlternativeSecurityId() *AlternativeSecurityId
}

// PAlternativeSecurityId pointer method for alternativeSecurityId
func (p *AlternativeSecurityId) PAlternativeSecurityId() *AlternativeSecurityId { return p }

// AndroidCompliancePolicy This class contains compliance settings for Android.
type AndroidCompliancePolicy struct {
	DeviceCompliancePolicy
	// PasswordRequired Require a password to unlock device.
	PasswordRequired *bool `json:"passwordRequired,omitempty"`
	// PasswordMinimumLength Minimum password length. Valid values 4 to 16
	PasswordMinimumLength *int `json:"passwordMinimumLength,omitempty"`
	// PasswordRequiredType Type of characters in password
	PasswordRequiredType *AndroidRequiredPasswordType `json:"passwordRequiredType,omitempty"`
	// PasswordMinutesOfInactivityBeforeLock Minutes of inactivity before a password is required.
	PasswordMinutesOfInactivityBeforeLock *int `json:"passwordMinutesOfInactivityBeforeLock,omitempty"`
	// PasswordExpirationDays Number of days before the password expires. Valid values 1 to 365
	PasswordExpirationDays *int `json:"passwordExpirationDays,omitempty"`
	// PasswordPreviousPasswordBlockCount Number of previous passwords to block. Valid values 1 to 24
	PasswordPreviousPasswordBlockCount *int `json:"passwordPreviousPasswordBlockCount,omitempty"`
	// SecurityPreventInstallAppsFromUnknownSources Require that devices disallow installation of apps from unknown sources.
	SecurityPreventInstallAppsFromUnknownSources *bool `json:"securityPreventInstallAppsFromUnknownSources,omitempty"`
	// SecurityDisableUsbDebugging Disable USB debugging on Android devices.
	SecurityDisableUsbDebugging *bool `json:"securityDisableUsbDebugging,omitempty"`
	// SecurityRequireVerifyApps Require the Android Verify apps feature is turned on.
	SecurityRequireVerifyApps *bool `json:"securityRequireVerifyApps,omitempty"`
	// DeviceThreatProtectionEnabled Require that devices have enabled device threat protection.
	DeviceThreatProtectionEnabled *bool `json:"deviceThreatProtectionEnabled,omitempty"`
	// DeviceThreatProtectionRequiredSecurityLevel Require Mobile Threat Protection minimum risk level to report noncompliance.
	DeviceThreatProtectionRequiredSecurityLevel *DeviceThreatProtectionLevel `json:"deviceThreatProtectionRequiredSecurityLevel,omitempty"`
	// SecurityBlockJailbrokenDevices Devices must not be jailbroken or rooted.
	SecurityBlockJailbrokenDevices *bool `json:"securityBlockJailbrokenDevices,omitempty"`
	// OsMinimumVersion Minimum Android version.
	OsMinimumVersion *string `json:"osMinimumVersion,omitempty"`
	// OsMaximumVersion Maximum Android version.
	OsMaximumVersion *string `json:"osMaximumVersion,omitempty"`
	// MinAndroidSecurityPatchLevel Minimum Android security patch level.
	MinAndroidSecurityPatchLevel *string `json:"minAndroidSecurityPatchLevel,omitempty"`
	// StorageRequireEncryption Require encryption on Android devices.
	StorageRequireEncryption *bool `json:"storageRequireEncryption,omitempty"`
	// SecurityRequireSafetyNetAttestationBasicIntegrity Require the device to pass the SafetyNet basic integrity check.
	SecurityRequireSafetyNetAttestationBasicIntegrity *bool `json:"securityRequireSafetyNetAttestationBasicIntegrity,omitempty"`
	// SecurityRequireSafetyNetAttestationCertifiedDevice Require the device to pass the SafetyNet certified device check.
	SecurityRequireSafetyNetAttestationCertifiedDevice *bool `json:"securityRequireSafetyNetAttestationCertifiedDevice,omitempty"`
	// SecurityRequireGooglePlayServices Require Google Play Services to be installed and enabled on the device.
	SecurityRequireGooglePlayServices *bool `json:"securityRequireGooglePlayServices,omitempty"`
	// SecurityRequireUpToDateSecurityProviders Require the device to have up to date security providers. The device will require Google Play Services to be enabled and up to date.
	SecurityRequireUpToDateSecurityProviders *bool `json:"securityRequireUpToDateSecurityProviders,omitempty"`
	// SecurityRequireCompanyPortalAppIntegrity Require the device to pass the Company Portal client app runtime integrity check.
	SecurityRequireCompanyPortalAppIntegrity *bool `json:"securityRequireCompanyPortalAppIntegrity,omitempty"`
}

// IAndroidCompliancePolicy interface type for androidCompliancePolicy
type IAndroidCompliancePolicy interface {
	PAndroidCompliancePolicy() *AndroidCompliancePolicy
}

// PAndroidCompliancePolicy pointer method for androidCompliancePolicy
func (p *AndroidCompliancePolicy) PAndroidCompliancePolicy() *AndroidCompliancePolicy { return p }

// AndroidCustomConfiguration This topic provides descriptions of the declared methods, properties and relationships exposed by the androidCustomConfiguration resource.
type AndroidCustomConfiguration struct {
	DeviceConfiguration
	// OmaSettings OMA settings. This collection can contain a maximum of 1000 elements.
	OmaSettings []OmaSetting `json:"omaSettings,omitempty"`
}

// IAndroidCustomConfiguration interface type for androidCustomConfiguration
type IAndroidCustomConfiguration interface {
	PAndroidCustomConfiguration() *AndroidCustomConfiguration
}

// PAndroidCustomConfiguration pointer method for androidCustomConfiguration
func (p *AndroidCustomConfiguration) PAndroidCustomConfiguration() *AndroidCustomConfiguration {
	return p
}

// AndroidGeneralDeviceConfiguration This topic provides descriptions of the declared methods, properties and relationships exposed by the androidGeneralDeviceConfiguration resource.
type AndroidGeneralDeviceConfiguration struct {
	DeviceConfiguration
	// AppsBlockClipboardSharing Indicates whether or not to block clipboard sharing to copy and paste between applications.
	AppsBlockClipboardSharing *bool `json:"appsBlockClipboardSharing,omitempty"`
	// AppsBlockCopyPaste Indicates whether or not to block copy and paste within applications.
	AppsBlockCopyPaste *bool `json:"appsBlockCopyPaste,omitempty"`
	// AppsBlockYouTube Indicates whether or not to block the YouTube app.
	AppsBlockYouTube *bool `json:"appsBlockYouTube,omitempty"`
	// BluetoothBlocked Indicates whether or not to block Bluetooth.
	BluetoothBlocked *bool `json:"bluetoothBlocked,omitempty"`
	// CameraBlocked Indicates whether or not to block the use of the camera.
	CameraBlocked *bool `json:"cameraBlocked,omitempty"`
	// CellularBlockDataRoaming Indicates whether or not to block data roaming.
	CellularBlockDataRoaming *bool `json:"cellularBlockDataRoaming,omitempty"`
	// CellularBlockMessaging Indicates whether or not to block SMS/MMS messaging.
	CellularBlockMessaging *bool `json:"cellularBlockMessaging,omitempty"`
	// CellularBlockVoiceRoaming Indicates whether or not to block voice roaming.
	CellularBlockVoiceRoaming *bool `json:"cellularBlockVoiceRoaming,omitempty"`
	// CellularBlockWiFiTethering Indicates whether or not to block syncing Wi-Fi tethering.
	CellularBlockWiFiTethering *bool `json:"cellularBlockWiFiTethering,omitempty"`
	// CompliantAppsList List of apps in the compliance (either allow list or block list, controlled by CompliantAppListType). This collection can contain a maximum of 10000 elements.
	CompliantAppsList []AppListItem `json:"compliantAppsList,omitempty"`
	// CompliantAppListType Type of list that is in the CompliantAppsList.
	CompliantAppListType *AppListType `json:"compliantAppListType,omitempty"`
	// DiagnosticDataBlockSubmission Indicates whether or not to block diagnostic data submission.
	DiagnosticDataBlockSubmission *bool `json:"diagnosticDataBlockSubmission,omitempty"`
	// LocationServicesBlocked Indicates whether or not to block location services.
	LocationServicesBlocked *bool `json:"locationServicesBlocked,omitempty"`
	// GoogleAccountBlockAutoSync Indicates whether or not to block Google account auto sync.
	GoogleAccountBlockAutoSync *bool `json:"googleAccountBlockAutoSync,omitempty"`
	// GooglePlayStoreBlocked Indicates whether or not to block the Google Play store.
	GooglePlayStoreBlocked *bool `json:"googlePlayStoreBlocked,omitempty"`
	// KioskModeBlockSleepButton Indicates whether or not to block the screen sleep button while in Kiosk Mode.
	KioskModeBlockSleepButton *bool `json:"kioskModeBlockSleepButton,omitempty"`
	// KioskModeBlockVolumeButtons Indicates whether or not to block the volume buttons while in Kiosk Mode.
	KioskModeBlockVolumeButtons *bool `json:"kioskModeBlockVolumeButtons,omitempty"`
	// KioskModeApps A list of apps that will be allowed to run when the device is in Kiosk Mode. This collection can contain a maximum of 500 elements.
	KioskModeApps []AppListItem `json:"kioskModeApps,omitempty"`
	// NfcBlocked Indicates whether or not to block Near-Field Communication.
	NfcBlocked *bool `json:"nfcBlocked,omitempty"`
	// PasswordBlockFingerprintUnlock Indicates whether or not to block fingerprint unlock.
	PasswordBlockFingerprintUnlock *bool `json:"passwordBlockFingerprintUnlock,omitempty"`
	// PasswordBlockTrustAgents Indicates whether or not to block Smart Lock and other trust agents.
	PasswordBlockTrustAgents *bool `json:"passwordBlockTrustAgents,omitempty"`
	// PasswordExpirationDays Number of days before the password expires. Valid values 1 to 365
	PasswordExpirationDays *int `json:"passwordExpirationDays,omitempty"`
	// PasswordMinimumLength Minimum length of passwords. Valid values 4 to 16
	PasswordMinimumLength *int `json:"passwordMinimumLength,omitempty"`
	// PasswordMinutesOfInactivityBeforeScreenTimeout Minutes of inactivity before the screen times out.
	PasswordMinutesOfInactivityBeforeScreenTimeout *int `json:"passwordMinutesOfInactivityBeforeScreenTimeout,omitempty"`
	// PasswordPreviousPasswordBlockCount Number of previous passwords to block. Valid values 0 to 24
	PasswordPreviousPasswordBlockCount *int `json:"passwordPreviousPasswordBlockCount,omitempty"`
	// PasswordSignInFailureCountBeforeFactoryReset Number of sign in failures allowed before factory reset. Valid values 1 to 16
	PasswordSignInFailureCountBeforeFactoryReset *int `json:"passwordSignInFailureCountBeforeFactoryReset,omitempty"`
	// PasswordRequiredType Type of password that is required.
	PasswordRequiredType *AndroidRequiredPasswordType `json:"passwordRequiredType,omitempty"`
	// PasswordRequired Indicates whether or not to require a password.
	PasswordRequired *bool `json:"passwordRequired,omitempty"`
	// PowerOffBlocked Indicates whether or not to block powering off the device.
	PowerOffBlocked *bool `json:"powerOffBlocked,omitempty"`
	// FactoryResetBlocked Indicates whether or not to block user performing a factory reset.
	FactoryResetBlocked *bool `json:"factoryResetBlocked,omitempty"`
	// ScreenCaptureBlocked Indicates whether or not to block screenshots.
	ScreenCaptureBlocked *bool `json:"screenCaptureBlocked,omitempty"`
	// DeviceSharingAllowed Indicates whether or not to allow device sharing mode.
	DeviceSharingAllowed *bool `json:"deviceSharingAllowed,omitempty"`
	// StorageBlockGoogleBackup Indicates whether or not to block Google Backup.
	StorageBlockGoogleBackup *bool `json:"storageBlockGoogleBackup,omitempty"`
	// StorageBlockRemovableStorage Indicates whether or not to block removable storage usage.
	StorageBlockRemovableStorage *bool `json:"storageBlockRemovableStorage,omitempty"`
	// StorageRequireDeviceEncryption Indicates whether or not to require device encryption.
	StorageRequireDeviceEncryption *bool `json:"storageRequireDeviceEncryption,omitempty"`
	// StorageRequireRemovableStorageEncryption Indicates whether or not to require removable storage encryption.
	StorageRequireRemovableStorageEncryption *bool `json:"storageRequireRemovableStorageEncryption,omitempty"`
	// VoiceAssistantBlocked Indicates whether or not to block the use of the Voice Assistant.
	VoiceAssistantBlocked *bool `json:"voiceAssistantBlocked,omitempty"`
	// VoiceDialingBlocked Indicates whether or not to block voice dialing.
	VoiceDialingBlocked *bool `json:"voiceDialingBlocked,omitempty"`
	// WebBrowserBlockPopups Indicates whether or not to block popups within the web browser.
	WebBrowserBlockPopups *bool `json:"webBrowserBlockPopups,omitempty"`
	// WebBrowserBlockAutofill Indicates whether or not to block the web browser's auto fill feature.
	WebBrowserBlockAutofill *bool `json:"webBrowserBlockAutofill,omitempty"`
	// WebBrowserBlockJavaScript Indicates whether or not to block JavaScript within the web browser.
	WebBrowserBlockJavaScript *bool `json:"webBrowserBlockJavaScript,omitempty"`
	// WebBrowserBlocked Indicates whether or not to block the web browser.
	WebBrowserBlocked *bool `json:"webBrowserBlocked,omitempty"`
	// WebBrowserCookieSettings Cookie settings within the web browser.
	WebBrowserCookieSettings *WebBrowserCookieSettings `json:"webBrowserCookieSettings,omitempty"`
	// WiFiBlocked Indicates whether or not to block syncing Wi-Fi.
	WiFiBlocked *bool `json:"wiFiBlocked,omitempty"`
	// AppsInstallAllowList List of apps which can be installed on the KNOX device. This collection can contain a maximum of 500 elements.
	AppsInstallAllowList []AppListItem `json:"appsInstallAllowList,omitempty"`
	// AppsLaunchBlockList List of apps which are blocked from being launched on the KNOX device. This collection can contain a maximum of 500 elements.
	AppsLaunchBlockList []AppListItem `json:"appsLaunchBlockList,omitempty"`
	// AppsHideList List of apps to be hidden on the KNOX device. This collection can contain a maximum of 500 elements.
	AppsHideList []AppListItem `json:"appsHideList,omitempty"`
	// SecurityRequireVerifyApps Require the Android Verify apps feature is turned on.
	SecurityRequireVerifyApps *bool `json:"securityRequireVerifyApps,omitempty"`
}

// IAndroidGeneralDeviceConfiguration interface type for androidGeneralDeviceConfiguration
type IAndroidGeneralDeviceConfiguration interface {
	PAndroidGeneralDeviceConfiguration() *AndroidGeneralDeviceConfiguration
}

// PAndroidGeneralDeviceConfiguration pointer method for androidGeneralDeviceConfiguration
func (p *AndroidGeneralDeviceConfiguration) PAndroidGeneralDeviceConfiguration() *AndroidGeneralDeviceConfiguration {
	return p
}

// AndroidLobApp Contains properties and inherited properties for Android Line Of Business apps.
type AndroidLobApp struct {
	MobileLobApp
	// PackageId The package identifier.
	PackageId *string `json:"packageId,omitempty"`
	// MinimumSupportedOperatingSystem The value for the minimum applicable operating system.
	MinimumSupportedOperatingSystem *AndroidMinimumOperatingSystem `json:"minimumSupportedOperatingSystem,omitempty"`
	// VersionName The version name of Android Line of Business (LoB) app.
	VersionName *string `json:"versionName,omitempty"`
	// VersionCode The version code of Android Line of Business (LoB) app.
	VersionCode *string `json:"versionCode,omitempty"`
}

// IAndroidLobApp interface type for androidLobApp
type IAndroidLobApp interface {
	PAndroidLobApp() *AndroidLobApp
}

// PAndroidLobApp pointer method for androidLobApp
func (p *AndroidLobApp) PAndroidLobApp() *AndroidLobApp { return p }

// AndroidManagedAppProtection Policy used to configure detailed management settings targeted to specific security groups and for a specified set of apps on an Android device
type AndroidManagedAppProtection struct {
	TargetedManagedAppProtection
	// ScreenCaptureBlocked Indicates whether a managed user can take screen captures of managed apps
	ScreenCaptureBlocked *bool `json:"screenCaptureBlocked,omitempty"`
	// DisableAppEncryptionIfDeviceEncryptionIsEnabled When this setting is enabled, app level encryption is disabled if device level encryption is enabled
	DisableAppEncryptionIfDeviceEncryptionIsEnabled *bool `json:"disableAppEncryptionIfDeviceEncryptionIsEnabled,omitempty"`
	// EncryptAppData Indicates whether application data for managed apps should be encrypted
	EncryptAppData *bool `json:"encryptAppData,omitempty"`
	// DeployedAppCount Count of apps to which the current policy is deployed.
	DeployedAppCount *int `json:"deployedAppCount,omitempty"`
	// MinimumRequiredPatchVersion Define the oldest required Android security patch level a user can have to gain secure access to the app.
	MinimumRequiredPatchVersion *string `json:"minimumRequiredPatchVersion,omitempty"`
	// MinimumWarningPatchVersion Define the oldest recommended Android security patch level a user can have for secure access to the app.
	MinimumWarningPatchVersion *string `json:"minimumWarningPatchVersion,omitempty"`
}

// IAndroidManagedAppProtection interface type for androidManagedAppProtection
type IAndroidManagedAppProtection interface {
	PAndroidManagedAppProtection() *AndroidManagedAppProtection
}

// PAndroidManagedAppProtection pointer method for androidManagedAppProtection
func (p *AndroidManagedAppProtection) PAndroidManagedAppProtection() *AndroidManagedAppProtection {
	return p
}

// AndroidManagedAppRegistration Represents the synchronization details of an android app, with management capabilities, for a specific user.
type AndroidManagedAppRegistration struct {
	ManagedAppRegistration
}

// IAndroidManagedAppRegistration interface type for androidManagedAppRegistration
type IAndroidManagedAppRegistration interface {
	PAndroidManagedAppRegistration() *AndroidManagedAppRegistration
}

// PAndroidManagedAppRegistration pointer method for androidManagedAppRegistration
func (p *AndroidManagedAppRegistration) PAndroidManagedAppRegistration() *AndroidManagedAppRegistration {
	return p
}

// AndroidMinimumOperatingSystem undocumented
type AndroidMinimumOperatingSystem struct {
	// V4_0 Version 4.0 or later.
	V4_0 *bool `json:"v4_0,omitempty"`
	// V4_0_3 Version 4.0.3 or later.
	V4_0_3 *bool `json:"v4_0_3,omitempty"`
	// V4_1 Version 4.1 or later.
	V4_1 *bool `json:"v4_1,omitempty"`
	// V4_2 Version 4.2 or later.
	V4_2 *bool `json:"v4_2,omitempty"`
	// V4_3 Version 4.3 or later.
	V4_3 *bool `json:"v4_3,omitempty"`
	// V4_4 Version 4.4 or later.
	V4_4 *bool `json:"v4_4,omitempty"`
	// V5_0 Version 5.0 or later.
	V5_0 *bool `json:"v5_0,omitempty"`
	// V5_1 Version 5.1 or later.
	V5_1 *bool `json:"v5_1,omitempty"`
}

// IAndroidMinimumOperatingSystem interface type for androidMinimumOperatingSystem
type IAndroidMinimumOperatingSystem interface {
	PAndroidMinimumOperatingSystem() *AndroidMinimumOperatingSystem
}

// PAndroidMinimumOperatingSystem pointer method for androidMinimumOperatingSystem
func (p *AndroidMinimumOperatingSystem) PAndroidMinimumOperatingSystem() *AndroidMinimumOperatingSystem {
	return p
}

// AndroidMobileAppIdentifier undocumented
type AndroidMobileAppIdentifier struct {
	MobileAppIdentifier
	// PackageId The identifier for an app, as specified in the play store.
	PackageId *string `json:"packageId,omitempty"`
}

// IAndroidMobileAppIdentifier interface type for androidMobileAppIdentifier
type IAndroidMobileAppIdentifier interface {
	PAndroidMobileAppIdentifier() *AndroidMobileAppIdentifier
}

// PAndroidMobileAppIdentifier pointer method for androidMobileAppIdentifier
func (p *AndroidMobileAppIdentifier) PAndroidMobileAppIdentifier() *AndroidMobileAppIdentifier {
	return p
}

// AndroidStoreApp Contains properties and inherited properties for Android store apps.
type AndroidStoreApp struct {
	MobileApp
	// PackageId The package identifier.
	PackageId *string `json:"packageId,omitempty"`
	// AppStoreUrl The Android app store URL.
	AppStoreUrl *string `json:"appStoreUrl,omitempty"`
	// MinimumSupportedOperatingSystem The value for the minimum applicable operating system.
	MinimumSupportedOperatingSystem *AndroidMinimumOperatingSystem `json:"minimumSupportedOperatingSystem,omitempty"`
}

// IAndroidStoreApp interface type for androidStoreApp
type IAndroidStoreApp interface {
	PAndroidStoreApp() *AndroidStoreApp
}

// PAndroidStoreApp pointer method for androidStoreApp
func (p *AndroidStoreApp) PAndroidStoreApp() *AndroidStoreApp { return p }

// AndroidWorkProfileCompliancePolicy This class contains compliance settings for Android Work Profile.
type AndroidWorkProfileCompliancePolicy struct {
	DeviceCompliancePolicy
	// PasswordRequired Require a password to unlock device.
	PasswordRequired *bool `json:"passwordRequired,omitempty"`
	// PasswordMinimumLength Minimum password length. Valid values 4 to 16
	PasswordMinimumLength *int `json:"passwordMinimumLength,omitempty"`
	// PasswordRequiredType Type of characters in password
	PasswordRequiredType *AndroidRequiredPasswordType `json:"passwordRequiredType,omitempty"`
	// PasswordMinutesOfInactivityBeforeLock Minutes of inactivity before a password is required.
	PasswordMinutesOfInactivityBeforeLock *int `json:"passwordMinutesOfInactivityBeforeLock,omitempty"`
	// PasswordExpirationDays Number of days before the password expires. Valid values 1 to 365
	PasswordExpirationDays *int `json:"passwordExpirationDays,omitempty"`
	// PasswordPreviousPasswordBlockCount Number of previous passwords to block. Valid values 1 to 24
	PasswordPreviousPasswordBlockCount *int `json:"passwordPreviousPasswordBlockCount,omitempty"`
	// SecurityPreventInstallAppsFromUnknownSources Require that devices disallow installation of apps from unknown sources.
	SecurityPreventInstallAppsFromUnknownSources *bool `json:"securityPreventInstallAppsFromUnknownSources,omitempty"`
	// SecurityDisableUsbDebugging Disable USB debugging on Android devices.
	SecurityDisableUsbDebugging *bool `json:"securityDisableUsbDebugging,omitempty"`
	// SecurityRequireVerifyApps Require the Android Verify apps feature is turned on.
	SecurityRequireVerifyApps *bool `json:"securityRequireVerifyApps,omitempty"`
	// DeviceThreatProtectionEnabled Require that devices have enabled device threat protection.
	DeviceThreatProtectionEnabled *bool `json:"deviceThreatProtectionEnabled,omitempty"`
	// DeviceThreatProtectionRequiredSecurityLevel Require Mobile Threat Protection minimum risk level to report noncompliance.
	DeviceThreatProtectionRequiredSecurityLevel *DeviceThreatProtectionLevel `json:"deviceThreatProtectionRequiredSecurityLevel,omitempty"`
	// SecurityBlockJailbrokenDevices Devices must not be jailbroken or rooted.
	SecurityBlockJailbrokenDevices *bool `json:"securityBlockJailbrokenDevices,omitempty"`
	// OsMinimumVersion Minimum Android version.
	OsMinimumVersion *string `json:"osMinimumVersion,omitempty"`
	// OsMaximumVersion Maximum Android version.
	OsMaximumVersion *string `json:"osMaximumVersion,omitempty"`
	// MinAndroidSecurityPatchLevel Minimum Android security patch level.
	MinAndroidSecurityPatchLevel *string `json:"minAndroidSecurityPatchLevel,omitempty"`
	// StorageRequireEncryption Require encryption on Android devices.
	StorageRequireEncryption *bool `json:"storageRequireEncryption,omitempty"`
	// SecurityRequireSafetyNetAttestationBasicIntegrity Require the device to pass the SafetyNet basic integrity check.
	SecurityRequireSafetyNetAttestationBasicIntegrity *bool `json:"securityRequireSafetyNetAttestationBasicIntegrity,omitempty"`
	// SecurityRequireSafetyNetAttestationCertifiedDevice Require the device to pass the SafetyNet certified device check.
	SecurityRequireSafetyNetAttestationCertifiedDevice *bool `json:"securityRequireSafetyNetAttestationCertifiedDevice,omitempty"`
	// SecurityRequireGooglePlayServices Require Google Play Services to be installed and enabled on the device.
	SecurityRequireGooglePlayServices *bool `json:"securityRequireGooglePlayServices,omitempty"`
	// SecurityRequireUpToDateSecurityProviders Require the device to have up to date security providers. The device will require Google Play Services to be enabled and up to date.
	SecurityRequireUpToDateSecurityProviders *bool `json:"securityRequireUpToDateSecurityProviders,omitempty"`
	// SecurityRequireCompanyPortalAppIntegrity Require the device to pass the Company Portal client app runtime integrity check.
	SecurityRequireCompanyPortalAppIntegrity *bool `json:"securityRequireCompanyPortalAppIntegrity,omitempty"`
}

// IAndroidWorkProfileCompliancePolicy interface type for androidWorkProfileCompliancePolicy
type IAndroidWorkProfileCompliancePolicy interface {
	PAndroidWorkProfileCompliancePolicy() *AndroidWorkProfileCompliancePolicy
}

// PAndroidWorkProfileCompliancePolicy pointer method for androidWorkProfileCompliancePolicy
func (p *AndroidWorkProfileCompliancePolicy) PAndroidWorkProfileCompliancePolicy() *AndroidWorkProfileCompliancePolicy {
	return p
}

// AndroidWorkProfileCustomConfiguration Android Work Profile custom configuration
type AndroidWorkProfileCustomConfiguration struct {
	DeviceConfiguration
	// OmaSettings OMA settings. This collection can contain a maximum of 500 elements.
	OmaSettings []OmaSetting `json:"omaSettings,omitempty"`
}

// IAndroidWorkProfileCustomConfiguration interface type for androidWorkProfileCustomConfiguration
type IAndroidWorkProfileCustomConfiguration interface {
	PAndroidWorkProfileCustomConfiguration() *AndroidWorkProfileCustomConfiguration
}

// PAndroidWorkProfileCustomConfiguration pointer method for androidWorkProfileCustomConfiguration
func (p *AndroidWorkProfileCustomConfiguration) PAndroidWorkProfileCustomConfiguration() *AndroidWorkProfileCustomConfiguration {
	return p
}

// AndroidWorkProfileGeneralDeviceConfiguration Android Work Profile general device configuration.
type AndroidWorkProfileGeneralDeviceConfiguration struct {
	DeviceConfiguration
	// PasswordBlockFingerprintUnlock Indicates whether or not to block fingerprint unlock.
	PasswordBlockFingerprintUnlock *bool `json:"passwordBlockFingerprintUnlock,omitempty"`
	// PasswordBlockTrustAgents Indicates whether or not to block Smart Lock and other trust agents.
	PasswordBlockTrustAgents *bool `json:"passwordBlockTrustAgents,omitempty"`
	// PasswordExpirationDays Number of days before the password expires. Valid values 1 to 365
	PasswordExpirationDays *int `json:"passwordExpirationDays,omitempty"`
	// PasswordMinimumLength Minimum length of passwords. Valid values 4 to 16
	PasswordMinimumLength *int `json:"passwordMinimumLength,omitempty"`
	// PasswordMinutesOfInactivityBeforeScreenTimeout Minutes of inactivity before the screen times out.
	PasswordMinutesOfInactivityBeforeScreenTimeout *int `json:"passwordMinutesOfInactivityBeforeScreenTimeout,omitempty"`
	// PasswordPreviousPasswordBlockCount Number of previous passwords to block. Valid values 0 to 24
	PasswordPreviousPasswordBlockCount *int `json:"passwordPreviousPasswordBlockCount,omitempty"`
	// PasswordSignInFailureCountBeforeFactoryReset Number of sign in failures allowed before factory reset. Valid values 1 to 16
	PasswordSignInFailureCountBeforeFactoryReset *int `json:"passwordSignInFailureCountBeforeFactoryReset,omitempty"`
	// PasswordRequiredType Type of password that is required.
	PasswordRequiredType *AndroidWorkProfileRequiredPasswordType `json:"passwordRequiredType,omitempty"`
	// WorkProfileDataSharingType Type of data sharing that is allowed.
	WorkProfileDataSharingType *AndroidWorkProfileCrossProfileDataSharingType `json:"workProfileDataSharingType,omitempty"`
	// WorkProfileBlockNotificationsWhileDeviceLocked Indicates whether or not to block notifications while device locked.
	WorkProfileBlockNotificationsWhileDeviceLocked *bool `json:"workProfileBlockNotificationsWhileDeviceLocked,omitempty"`
	// WorkProfileBlockAddingAccounts Block users from adding/removing accounts in work profile.
	WorkProfileBlockAddingAccounts *bool `json:"workProfileBlockAddingAccounts,omitempty"`
	// WorkProfileBluetoothEnableContactSharing Allow bluetooth devices to access enterprise contacts.
	WorkProfileBluetoothEnableContactSharing *bool `json:"workProfileBluetoothEnableContactSharing,omitempty"`
	// WorkProfileBlockScreenCapture Block screen capture in work profile.
	WorkProfileBlockScreenCapture *bool `json:"workProfileBlockScreenCapture,omitempty"`
	// WorkProfileBlockCrossProfileCallerId Block display work profile caller ID in personal profile.
	WorkProfileBlockCrossProfileCallerId *bool `json:"workProfileBlockCrossProfileCallerId,omitempty"`
	// WorkProfileBlockCamera Block work profile camera.
	WorkProfileBlockCamera *bool `json:"workProfileBlockCamera,omitempty"`
	// WorkProfileBlockCrossProfileContactsSearch Block work profile contacts availability in personal profile.
	WorkProfileBlockCrossProfileContactsSearch *bool `json:"workProfileBlockCrossProfileContactsSearch,omitempty"`
	// WorkProfileBlockCrossProfileCopyPaste Boolean that indicates if the setting disallow cross profile copy/paste is enabled.
	WorkProfileBlockCrossProfileCopyPaste *bool `json:"workProfileBlockCrossProfileCopyPaste,omitempty"`
	// WorkProfileDefaultAppPermissionPolicy Type of password that is required.
	WorkProfileDefaultAppPermissionPolicy *AndroidWorkProfileDefaultAppPermissionPolicyType `json:"workProfileDefaultAppPermissionPolicy,omitempty"`
	// WorkProfilePasswordBlockFingerprintUnlock Indicates whether or not to block fingerprint unlock for work profile.
	WorkProfilePasswordBlockFingerprintUnlock *bool `json:"workProfilePasswordBlockFingerprintUnlock,omitempty"`
	// WorkProfilePasswordBlockTrustAgents Indicates whether or not to block Smart Lock and other trust agents for work profile.
	WorkProfilePasswordBlockTrustAgents *bool `json:"workProfilePasswordBlockTrustAgents,omitempty"`
	// WorkProfilePasswordExpirationDays Number of days before the work profile password expires. Valid values 1 to 365
	WorkProfilePasswordExpirationDays *int `json:"workProfilePasswordExpirationDays,omitempty"`
	// WorkProfilePasswordMinimumLength Minimum length of work profile password. Valid values 4 to 16
	WorkProfilePasswordMinimumLength *int `json:"workProfilePasswordMinimumLength,omitempty"`
	// WorkProfilePasswordMinNumericCharacters Minimum # of numeric characters required in work profile password. Valid values 1 to 10
	WorkProfilePasswordMinNumericCharacters *int `json:"workProfilePasswordMinNumericCharacters,omitempty"`
	// WorkProfilePasswordMinNonLetterCharacters Minimum # of non-letter characters required in work profile password. Valid values 1 to 10
	WorkProfilePasswordMinNonLetterCharacters *int `json:"workProfilePasswordMinNonLetterCharacters,omitempty"`
	// WorkProfilePasswordMinLetterCharacters Minimum # of letter characters required in work profile password. Valid values 1 to 10
	WorkProfilePasswordMinLetterCharacters *int `json:"workProfilePasswordMinLetterCharacters,omitempty"`
	// WorkProfilePasswordMinLowerCaseCharacters Minimum # of lower-case characters required in work profile password. Valid values 1 to 10
	WorkProfilePasswordMinLowerCaseCharacters *int `json:"workProfilePasswordMinLowerCaseCharacters,omitempty"`
	// WorkProfilePasswordMinUpperCaseCharacters Minimum # of upper-case characters required in work profile password. Valid values 1 to 10
	WorkProfilePasswordMinUpperCaseCharacters *int `json:"workProfilePasswordMinUpperCaseCharacters,omitempty"`
	// WorkProfilePasswordMinSymbolCharacters Minimum # of symbols required in work profile password. Valid values 1 to 10
	WorkProfilePasswordMinSymbolCharacters *int `json:"workProfilePasswordMinSymbolCharacters,omitempty"`
	// WorkProfilePasswordMinutesOfInactivityBeforeScreenTimeout Minutes of inactivity before the screen times out.
	WorkProfilePasswordMinutesOfInactivityBeforeScreenTimeout *int `json:"workProfilePasswordMinutesOfInactivityBeforeScreenTimeout,omitempty"`
	// WorkProfilePasswordPreviousPasswordBlockCount Number of previous work profile passwords to block. Valid values 0 to 24
	WorkProfilePasswordPreviousPasswordBlockCount *int `json:"workProfilePasswordPreviousPasswordBlockCount,omitempty"`
	// WorkProfilePasswordSignInFailureCountBeforeFactoryReset Number of sign in failures allowed before work profile is removed and all corporate data deleted. Valid values 1 to 16
	WorkProfilePasswordSignInFailureCountBeforeFactoryReset *int `json:"workProfilePasswordSignInFailureCountBeforeFactoryReset,omitempty"`
	// WorkProfilePasswordRequiredType Type of work profile password that is required.
	WorkProfilePasswordRequiredType *AndroidWorkProfileRequiredPasswordType `json:"workProfilePasswordRequiredType,omitempty"`
	// WorkProfileRequirePassword Password is required or not for work profile
	WorkProfileRequirePassword *bool `json:"workProfileRequirePassword,omitempty"`
	// SecurityRequireVerifyApps Require the Android Verify apps feature is turned on.
	SecurityRequireVerifyApps *bool `json:"securityRequireVerifyApps,omitempty"`
}

// IAndroidWorkProfileGeneralDeviceConfiguration interface type for androidWorkProfileGeneralDeviceConfiguration
type IAndroidWorkProfileGeneralDeviceConfiguration interface {
	PAndroidWorkProfileGeneralDeviceConfiguration() *AndroidWorkProfileGeneralDeviceConfiguration
}

// PAndroidWorkProfileGeneralDeviceConfiguration pointer method for androidWorkProfileGeneralDeviceConfiguration
func (p *AndroidWorkProfileGeneralDeviceConfiguration) PAndroidWorkProfileGeneralDeviceConfiguration() *AndroidWorkProfileGeneralDeviceConfiguration {
	return p
}

// AppCatalogs undocumented
type AppCatalogs struct {
	Entity
}

// IAppCatalogs interface type for appCatalogs
type IAppCatalogs interface {
	PAppCatalogs() *AppCatalogs
}

// PAppCatalogs pointer method for appCatalogs
func (p *AppCatalogs) PAppCatalogs() *AppCatalogs { return p }

// AppConfigurationSettingItem undocumented
type AppConfigurationSettingItem struct {
	// AppConfigKey app configuration key.
	AppConfigKey *string `json:"appConfigKey,omitempty"`
	// AppConfigKeyType app configuration key type.
	AppConfigKeyType *MdmAppConfigKeyType `json:"appConfigKeyType,omitempty"`
	// AppConfigKeyValue app configuration key value.
	AppConfigKeyValue *string `json:"appConfigKeyValue,omitempty"`
}

// IAppConfigurationSettingItem interface type for appConfigurationSettingItem
type IAppConfigurationSettingItem interface {
	PAppConfigurationSettingItem() *AppConfigurationSettingItem
}

// PAppConfigurationSettingItem pointer method for appConfigurationSettingItem
func (p *AppConfigurationSettingItem) PAppConfigurationSettingItem() *AppConfigurationSettingItem {
	return p
}

// AppIdentity undocumented
type AppIdentity struct {
	// AppId undocumented
	AppId *string `json:"appId,omitempty"`
	// DisplayName undocumented
	DisplayName *string `json:"displayName,omitempty"`
	// ServicePrincipalId undocumented
	ServicePrincipalId *string `json:"servicePrincipalId,omitempty"`
	// ServicePrincipalName undocumented
	ServicePrincipalName *string `json:"servicePrincipalName,omitempty"`
}

// IAppIdentity interface type for appIdentity
type IAppIdentity interface {
	PAppIdentity() *AppIdentity
}

// PAppIdentity pointer method for appIdentity
func (p *AppIdentity) PAppIdentity() *AppIdentity { return p }

// AppListItem undocumented
type AppListItem struct {
	// Name The application name
	Name *string `json:"name,omitempty"`
	// Publisher The publisher of the application
	Publisher *string `json:"publisher,omitempty"`
	// AppStoreUrl The Store URL of the application
	AppStoreUrl *string `json:"appStoreUrl,omitempty"`
	// AppId The application or bundle identifier of the application
	AppId *string `json:"appId,omitempty"`
}

// IAppListItem interface type for appListItem
type IAppListItem interface {
	PAppListItem() *AppListItem
}

// PAppListItem pointer method for appListItem
func (p *AppListItem) PAppListItem() *AppListItem { return p }

// AppleDeviceFeaturesConfigurationBase Apple device features configuration profile.
type AppleDeviceFeaturesConfigurationBase struct {
	DeviceConfiguration
}

// IAppleDeviceFeaturesConfigurationBase interface type for appleDeviceFeaturesConfigurationBase
type IAppleDeviceFeaturesConfigurationBase interface {
	PAppleDeviceFeaturesConfigurationBase() *AppleDeviceFeaturesConfigurationBase
}

// PAppleDeviceFeaturesConfigurationBase pointer method for appleDeviceFeaturesConfigurationBase
func (p *AppleDeviceFeaturesConfigurationBase) PAppleDeviceFeaturesConfigurationBase() *AppleDeviceFeaturesConfigurationBase {
	return p
}

// ApplePushNotificationCertificate Apple push notification certificate.
type ApplePushNotificationCertificate struct {
	Entity
	// AppleIdentifier Apple Id of the account used to create the MDM push certificate.
	AppleIdentifier *string `json:"appleIdentifier,omitempty"`
	// TopicIdentifier Topic Id.
	TopicIdentifier *string `json:"topicIdentifier,omitempty"`
	// LastModifiedDateTime Last modified date and time for Apple push notification certificate.
	LastModifiedDateTime *time.Time `json:"lastModifiedDateTime,omitempty"`
	// ExpirationDateTime The expiration date and time for Apple push notification certificate.
	ExpirationDateTime *time.Time `json:"expirationDateTime,omitempty"`
	// Certificate undocumented
	Certificate *string `json:"certificate,omitempty"`
}

// IApplePushNotificationCertificate interface type for applePushNotificationCertificate
type IApplePushNotificationCertificate interface {
	PApplePushNotificationCertificate() *ApplePushNotificationCertificate
}

// PApplePushNotificationCertificate pointer method for applePushNotificationCertificate
func (p *ApplePushNotificationCertificate) PApplePushNotificationCertificate() *ApplePushNotificationCertificate {
	return p
}

// AppliedConditionalAccessPolicy undocumented
type AppliedConditionalAccessPolicy struct {
	// Id undocumented
	Id *string `json:"id,omitempty"`
	// DisplayName undocumented
	DisplayName *string `json:"displayName,omitempty"`
	// EnforcedGrantControls undocumented
	EnforcedGrantControls []string `json:"enforcedGrantControls,omitempty"`
	// EnforcedSessionControls undocumented
	EnforcedSessionControls []string `json:"enforcedSessionControls,omitempty"`
	// Result undocumented
	Result *AppliedConditionalAccessPolicyResult `json:"result,omitempty"`
}

// IAppliedConditionalAccessPolicy interface type for appliedConditionalAccessPolicy
type IAppliedConditionalAccessPolicy interface {
	PAppliedConditionalAccessPolicy() *AppliedConditionalAccessPolicy
}

// PAppliedConditionalAccessPolicy pointer method for appliedConditionalAccessPolicy
func (p *AppliedConditionalAccessPolicy) PAppliedConditionalAccessPolicy() *AppliedConditionalAccessPolicy {
	return p
}

// AssignedLicense undocumented
type AssignedLicense struct {
	// DisabledPlans undocumented
	DisabledPlans []UUID `json:"disabledPlans,omitempty"`
	// SkuId undocumented
	SkuId *UUID `json:"skuId,omitempty"`
}

// IAssignedLicense interface type for assignedLicense
type IAssignedLicense interface {
	PAssignedLicense() *AssignedLicense
}

// PAssignedLicense pointer method for assignedLicense
func (p *AssignedLicense) PAssignedLicense() *AssignedLicense { return p }

// AssignedPlan undocumented
type AssignedPlan struct {
	// AssignedDateTime undocumented
	AssignedDateTime *time.Time `json:"assignedDateTime,omitempty"`
	// CapabilityStatus undocumented
	CapabilityStatus *string `json:"capabilityStatus,omitempty"`
	// Service undocumented
	Service *string `json:"service,omitempty"`
	// ServicePlanId undocumented
	ServicePlanId *UUID `json:"servicePlanId,omitempty"`
}

// IAssignedPlan interface type for assignedPlan
type IAssignedPlan interface {
	PAssignedPlan() *AssignedPlan
}

// PAssignedPlan pointer method for assignedPlan
func (p *AssignedPlan) PAssignedPlan() *AssignedPlan { return p }

// Attachment undocumented
type Attachment struct {
	Entity
	// LastModifiedDateTime undocumented
	LastModifiedDateTime *time.Time `json:"lastModifiedDateTime,omitempty"`
	// Name undocumented
	Name *string `json:"name,omitempty"`
	// ContentType undocumented
	ContentType *string `json:"contentType,omitempty"`
	// Size undocumented
	Size *int `json:"size,omitempty"`
	// IsInline undocumented
	IsInline *bool `json:"isInline,omitempty"`
}

// IAttachment interface type for attachment
type IAttachment interface {
	PAttachment() *Attachment
}

// PAttachment pointer method for attachment
func (p *Attachment) PAttachment() *Attachment { return p }

// Attendee undocumented
type Attendee struct {
	AttendeeBase
	// Status undocumented
	Status *ResponseStatus `json:"status,omitempty"`
}

// IAttendee interface type for attendee
type IAttendee interface {
	PAttendee() *Attendee
}

// PAttendee pointer method for attendee
func (p *Attendee) PAttendee() *Attendee { return p }

// AttendeeAvailability undocumented
type AttendeeAvailability struct {
	// Attendee undocumented
	Attendee *AttendeeBase `json:"attendee,omitempty"`
	// Availability undocumented
	Availability *FreeBusyStatus `json:"availability,omitempty"`
}

// IAttendeeAvailability interface type for attendeeAvailability
type IAttendeeAvailability interface {
	PAttendeeAvailability() *AttendeeAvailability
}

// PAttendeeAvailability pointer method for attendeeAvailability
func (p *AttendeeAvailability) PAttendeeAvailability() *AttendeeAvailability { return p }

// AttendeeBase undocumented
type AttendeeBase struct {
	Recipient
	// Type undocumented
	Type *AttendeeType `json:"type,omitempty"`
}

// IAttendeeBase interface type for attendeeBase
type IAttendeeBase interface {
	PAttendeeBase() *AttendeeBase
}

// PAttendeeBase pointer method for attendeeBase
func (p *AttendeeBase) PAttendeeBase() *AttendeeBase { return p }

// Audio undocumented
type Audio struct {
	// Album undocumented
	Album *string `json:"album,omitempty"`
	// AlbumArtist undocumented
	AlbumArtist *string `json:"albumArtist,omitempty"`
	// Artist undocumented
	Artist *string `json:"artist,omitempty"`
	// Bitrate undocumented
	Bitrate *int `json:"bitrate,omitempty"`
	// Composers undocumented
	Composers *string `json:"composers,omitempty"`
	// Copyright undocumented
	Copyright *string `json:"copyright,omitempty"`
	// Disc undocumented
	Disc *int `json:"disc,omitempty"`
	// DiscCount undocumented
	DiscCount *int `json:"discCount,omitempty"`
	// Duration undocumented
	Duration *int `json:"duration,omitempty"`
	// Genre undocumented
	Genre *string `json:"genre,omitempty"`
	// HasDrm undocumented
	HasDrm *bool `json:"hasDrm,omitempty"`
	// IsVariableBitrate undocumented
	IsVariableBitrate *bool `json:"isVariableBitrate,omitempty"`
	// Title undocumented
	Title *string `json:"title,omitempty"`
	// Track undocumented
	Track *int `json:"track,omitempty"`
	// TrackCount undocumented
	TrackCount *int `json:"trackCount,omitempty"`
	// Year undocumented
	Year *int `json:"year,omitempty"`
}

// IAudio interface type for audio
type IAudio interface {
	PAudio() *Audio
}

// PAudio pointer method for audio
func (p *Audio) PAudio() *Audio { return p }

// AuditActivityInitiator undocumented
type AuditActivityInitiator struct {
	// User undocumented
	User *UserIdentity `json:"user,omitempty"`
	// App undocumented
	App *AppIdentity `json:"app,omitempty"`
}

// IAuditActivityInitiator interface type for auditActivityInitiator
type IAuditActivityInitiator interface {
	PAuditActivityInitiator() *AuditActivityInitiator
}

// PAuditActivityInitiator pointer method for auditActivityInitiator
func (p *AuditActivityInitiator) PAuditActivityInitiator() *AuditActivityInitiator { return p }

// AuditLogRoot undocumented
type AuditLogRoot struct {
	Entity
}

// IAuditLogRoot interface type for auditLogRoot
type IAuditLogRoot interface {
	PAuditLogRoot() *AuditLogRoot
}

// PAuditLogRoot pointer method for auditLogRoot
func (p *AuditLogRoot) PAuditLogRoot() *AuditLogRoot { return p }

// AutomaticRepliesMailTips undocumented
type AutomaticRepliesMailTips struct {
	// Message undocumented
	Message *string `json:"message,omitempty"`
	// MessageLanguage undocumented
	MessageLanguage *LocaleInfo `json:"messageLanguage,omitempty"`
	// ScheduledStartTime undocumented
	ScheduledStartTime *DateTimeTimeZone `json:"scheduledStartTime,omitempty"`
	// ScheduledEndTime undocumented
	ScheduledEndTime *DateTimeTimeZone `json:"scheduledEndTime,omitempty"`
}

// IAutomaticRepliesMailTips interface type for automaticRepliesMailTips
type IAutomaticRepliesMailTips interface {
	PAutomaticRepliesMailTips() *AutomaticRepliesMailTips
}

// PAutomaticRepliesMailTips pointer method for automaticRepliesMailTips
func (p *AutomaticRepliesMailTips) PAutomaticRepliesMailTips() *AutomaticRepliesMailTips { return p }

// AutomaticRepliesSetting undocumented
type AutomaticRepliesSetting struct {
	// Status undocumented
	Status *AutomaticRepliesStatus `json:"status,omitempty"`
	// ExternalAudience undocumented
	ExternalAudience *ExternalAudienceScope `json:"externalAudience,omitempty"`
	// ScheduledStartDateTime undocumented
	ScheduledStartDateTime *DateTimeTimeZone `json:"scheduledStartDateTime,omitempty"`
	// ScheduledEndDateTime undocumented
	ScheduledEndDateTime *DateTimeTimeZone `json:"scheduledEndDateTime,omitempty"`
	// InternalReplyMessage undocumented
	InternalReplyMessage *string `json:"internalReplyMessage,omitempty"`
	// ExternalReplyMessage undocumented
	ExternalReplyMessage *string `json:"externalReplyMessage,omitempty"`
}

// IAutomaticRepliesSetting interface type for automaticRepliesSetting
type IAutomaticRepliesSetting interface {
	PAutomaticRepliesSetting() *AutomaticRepliesSetting
}

// PAutomaticRepliesSetting pointer method for automaticRepliesSetting
func (p *AutomaticRepliesSetting) PAutomaticRepliesSetting() *AutomaticRepliesSetting { return p }

// AverageComparativeScore undocumented
type AverageComparativeScore struct {
	// AverageScore undocumented
	AverageScore *float64 `json:"averageScore,omitempty"`
	// Basis undocumented
	Basis *string `json:"basis,omitempty"`
}

// IAverageComparativeScore interface type for averageComparativeScore
type IAverageComparativeScore interface {
	PAverageComparativeScore() *AverageComparativeScore
}

// PAverageComparativeScore pointer method for averageComparativeScore
func (p *AverageComparativeScore) PAverageComparativeScore() *AverageComparativeScore { return p }

// BaseItem undocumented
type BaseItem struct {
	Entity
	// CreatedBy undocumented
	CreatedBy *IdentitySet `json:"createdBy,omitempty"`
	// CreatedDateTime undocumented
	CreatedDateTime *time.Time `json:"createdDateTime,omitempty"`
	// Description undocumented
	Description *string `json:"description,omitempty"`
	// ETag undocumented
	ETag *string `json:"eTag,omitempty"`
	// LastModifiedBy undocumented
	LastModifiedBy *IdentitySet `json:"lastModifiedBy,omitempty"`
	// LastModifiedDateTime undocumented
	LastModifiedDateTime *time.Time `json:"lastModifiedDateTime,omitempty"`
	// Name undocumented
	Name *string `json:"name,omitempty"`
	// ParentReference undocumented
	ParentReference *ItemReference `json:"parentReference,omitempty"`
	// WebUrl undocumented
	WebUrl *string `json:"webUrl,omitempty"`
}

// IBaseItem interface type for baseItem
type IBaseItem interface {
	PBaseItem() *BaseItem
}

// PBaseItem pointer method for baseItem
func (p *BaseItem) PBaseItem() *BaseItem { return p }

// BaseItemVersion undocumented
type BaseItemVersion struct {
	Entity
	// LastModifiedBy undocumented
	LastModifiedBy *IdentitySet `json:"lastModifiedBy,omitempty"`
	// LastModifiedDateTime undocumented
	LastModifiedDateTime *time.Time `json:"lastModifiedDateTime,omitempty"`
	// Publication undocumented
	Publication *PublicationFacet `json:"publication,omitempty"`
}

// IBaseItemVersion interface type for baseItemVersion
type IBaseItemVersion interface {
	PBaseItemVersion() *BaseItemVersion
}

// PBaseItemVersion pointer method for baseItemVersion
func (p *BaseItemVersion) PBaseItemVersion() *BaseItemVersion { return p }

// BitLockerRemovableDrivePolicy undocumented
type BitLockerRemovableDrivePolicy struct {
	// EncryptionMethod Select the encryption method for removable  drives.
	EncryptionMethod *BitLockerEncryptionMethod `json:"encryptionMethod,omitempty"`
	// RequireEncryptionForWriteAccess Indicates whether to block write access to devices configured in another organization.  If requireEncryptionForWriteAccess is false, this value does not affect.
	RequireEncryptionForWriteAccess *bool `json:"requireEncryptionForWriteAccess,omitempty"`
	// BlockCrossOrganizationWriteAccess This policy setting determines whether BitLocker protection is required for removable data drives to be writable on a computer.
	BlockCrossOrganizationWriteAccess *bool `json:"blockCrossOrganizationWriteAccess,omitempty"`
}

// IBitLockerRemovableDrivePolicy interface type for bitLockerRemovableDrivePolicy
type IBitLockerRemovableDrivePolicy interface {
	PBitLockerRemovableDrivePolicy() *BitLockerRemovableDrivePolicy
}

// PBitLockerRemovableDrivePolicy pointer method for bitLockerRemovableDrivePolicy
func (p *BitLockerRemovableDrivePolicy) PBitLockerRemovableDrivePolicy() *BitLockerRemovableDrivePolicy {
	return p
}

// BooleanColumn undocumented
type BooleanColumn struct {
}

// IBooleanColumn interface type for booleanColumn
type IBooleanColumn interface {
	PBooleanColumn() *BooleanColumn
}

// PBooleanColumn pointer method for booleanColumn
func (p *BooleanColumn) PBooleanColumn() *BooleanColumn { return p }

// CalculatedColumn undocumented
type CalculatedColumn struct {
	// Format undocumented
	Format *string `json:"format,omitempty"`
	// Formula undocumented
	Formula *string `json:"formula,omitempty"`
	// OutputType undocumented
	OutputType *string `json:"outputType,omitempty"`
}

// ICalculatedColumn interface type for calculatedColumn
type ICalculatedColumn interface {
	PCalculatedColumn() *CalculatedColumn
}

// PCalculatedColumn pointer method for calculatedColumn
func (p *CalculatedColumn) PCalculatedColumn() *CalculatedColumn { return p }

// Calendar undocumented
type Calendar struct {
	Entity
	// Name undocumented
	Name *string `json:"name,omitempty"`
	// Color undocumented
	Color *CalendarColor `json:"color,omitempty"`
	// ChangeKey undocumented
	ChangeKey *string `json:"changeKey,omitempty"`
	// CanShare undocumented
	CanShare *bool `json:"canShare,omitempty"`
	// CanViewPrivateItems undocumented
	CanViewPrivateItems *bool `json:"canViewPrivateItems,omitempty"`
	// CanEdit undocumented
	CanEdit *bool `json:"canEdit,omitempty"`
	// Owner undocumented
	Owner *EmailAddress `json:"owner,omitempty"`
}

// ICalendar interface type for calendar
type ICalendar interface {
	PCalendar() *Calendar
}

// PCalendar pointer method for calendar
func (p *Calendar) PCalendar() *Calendar { return p }

// CalendarGroup undocumented
type CalendarGroup struct {
	Entity
	// Name undocumented
	Name *string `json:"name,omitempty"`
	// ClassId undocumented
	ClassId *UUID `json:"classId,omitempty"`
	// ChangeKey undocumented
	ChangeKey *string `json:"changeKey,omitempty"`
}

// ICalendarGroup interface type for calendarGroup
type ICalendarGroup interface {
	PCalendarGroup() *CalendarGroup
}

// PCalendarGroup pointer method for calendarGroup
func (p *CalendarGroup) PCalendarGroup() *CalendarGroup { return p }

// CertificationControl undocumented
type CertificationControl struct {
	// Name undocumented
	Name *string `json:"name,omitempty"`
	// Url undocumented
	Url *string `json:"url,omitempty"`
}

// ICertificationControl interface type for certificationControl
type ICertificationControl interface {
	PCertificationControl() *CertificationControl
}

// PCertificationControl pointer method for certificationControl
func (p *CertificationControl) PCertificationControl() *CertificationControl { return p }

// Channel undocumented
type Channel struct {
	Entity
	// DisplayName undocumented
	DisplayName *string `json:"displayName,omitempty"`
	// Description undocumented
	Description *string `json:"description,omitempty"`
	// Email undocumented
	Email *string `json:"email,omitempty"`
	// WebUrl undocumented
	WebUrl *string `json:"webUrl,omitempty"`
}

// IChannel interface type for channel
type IChannel interface {
	PChannel() *Channel
}

// PChannel pointer method for channel
func (p *Channel) PChannel() *Channel { return p }

// ChoiceColumn undocumented
type ChoiceColumn struct {
	// AllowTextEntry undocumented
	AllowTextEntry *bool `json:"allowTextEntry,omitempty"`
	// Choices undocumented
	Choices []string `json:"choices,omitempty"`
	// DisplayAs undocumented
	DisplayAs *string `json:"displayAs,omitempty"`
}

// IChoiceColumn interface type for choiceColumn
type IChoiceColumn interface {
	PChoiceColumn() *ChoiceColumn
}

// PChoiceColumn pointer method for choiceColumn
func (p *ChoiceColumn) PChoiceColumn() *ChoiceColumn { return p }

// CloudAppSecurityState undocumented
type CloudAppSecurityState struct {
	// DestinationServiceIp undocumented
	DestinationServiceIp *string `json:"destinationServiceIp,omitempty"`
	// DestinationServiceName undocumented
	DestinationServiceName *string `json:"destinationServiceName,omitempty"`
	// RiskScore undocumented
	RiskScore *string `json:"riskScore,omitempty"`
}

// ICloudAppSecurityState interface type for cloudAppSecurityState
type ICloudAppSecurityState interface {
	PCloudAppSecurityState() *CloudAppSecurityState
}

// PCloudAppSecurityState pointer method for cloudAppSecurityState
func (p *CloudAppSecurityState) PCloudAppSecurityState() *CloudAppSecurityState { return p }

// ColumnDefinition undocumented
type ColumnDefinition struct {
	Entity
	// Boolean undocumented
	Boolean *BooleanColumn `json:"boolean,omitempty"`
	// Calculated undocumented
	Calculated *CalculatedColumn `json:"calculated,omitempty"`
	// Choice undocumented
	Choice *ChoiceColumn `json:"choice,omitempty"`
	// ColumnGroup undocumented
	ColumnGroup *string `json:"columnGroup,omitempty"`
	// Currency undocumented
	Currency *CurrencyColumn `json:"currency,omitempty"`
	// DateTime undocumented
	DateTime *DateTimeColumn `json:"dateTime,omitempty"`
	// DefaultValue undocumented
	DefaultValue *DefaultColumnValue `json:"defaultValue,omitempty"`
	// Description undocumented
	Description *string `json:"description,omitempty"`
	// DisplayName undocumented
	DisplayName *string `json:"displayName,omitempty"`
	// EnforceUniqueValues undocumented
	EnforceUniqueValues *bool `json:"enforceUniqueValues,omitempty"`
	// Hidden undocumented
	Hidden *bool `json:"hidden,omitempty"`
	// Indexed undocumented
	Indexed *bool `json:"indexed,omitempty"`
	// Lookup undocumented
	Lookup *LookupColumn `json:"lookup,omitempty"`
	// Name undocumented
	Name *string `json:"name,omitempty"`
	// Number undocumented
	Number *NumberColumn `json:"number,omitempty"`
	// PersonOrGroup undocumented
	PersonOrGroup *PersonOrGroupColumn `json:"personOrGroup,omitempty"`
	// ReadOnly undocumented
	ReadOnly *bool `json:"readOnly,omitempty"`
	// Required undocumented
	Required *bool `json:"required,omitempty"`
	// Text undocumented
	Text *TextColumn `json:"text,omitempty"`
}

// IColumnDefinition interface type for columnDefinition
type IColumnDefinition interface {
	PColumnDefinition() *ColumnDefinition
}

// PColumnDefinition pointer method for columnDefinition
func (p *ColumnDefinition) PColumnDefinition() *ColumnDefinition { return p }

// ColumnLink undocumented
type ColumnLink struct {
	Entity
	// Name undocumented
	Name *string `json:"name,omitempty"`
}

// IColumnLink interface type for columnLink
type IColumnLink interface {
	PColumnLink() *ColumnLink
}

// PColumnLink pointer method for columnLink
func (p *ColumnLink) PColumnLink() *ColumnLink { return p }

// ComplianceInformation undocumented
type ComplianceInformation struct {
	// CertificationControls undocumented
	CertificationControls []CertificationControl `json:"certificationControls,omitempty"`
	// CertificationName undocumented
	CertificationName *string `json:"certificationName,omitempty"`
}

// IComplianceInformation interface type for complianceInformation
type IComplianceInformation interface {
	PComplianceInformation() *ComplianceInformation
}

// PComplianceInformation pointer method for complianceInformation
func (p *ComplianceInformation) PComplianceInformation() *ComplianceInformation { return p }

// ConfigurationManagerClientEnabledFeatures undocumented
type ConfigurationManagerClientEnabledFeatures struct {
	// Inventory Whether inventory is managed by Intune
	Inventory *bool `json:"inventory,omitempty"`
	// ModernApps Whether modern application is managed by Intune
	ModernApps *bool `json:"modernApps,omitempty"`
	// ResourceAccess Whether resource access is managed by Intune
	ResourceAccess *bool `json:"resourceAccess,omitempty"`
	// DeviceConfiguration Whether device configuration is managed by Intune
	DeviceConfiguration *bool `json:"deviceConfiguration,omitempty"`
	// CompliancePolicy Whether compliance policy is managed by Intune
	CompliancePolicy *bool `json:"compliancePolicy,omitempty"`
	// WindowsUpdateForBusiness Whether Windows Update for Business is managed by Intune
	WindowsUpdateForBusiness *bool `json:"windowsUpdateForBusiness,omitempty"`
}

// IConfigurationManagerClientEnabledFeatures interface type for configurationManagerClientEnabledFeatures
type IConfigurationManagerClientEnabledFeatures interface {
	PConfigurationManagerClientEnabledFeatures() *ConfigurationManagerClientEnabledFeatures
}

// PConfigurationManagerClientEnabledFeatures pointer method for configurationManagerClientEnabledFeatures
func (p *ConfigurationManagerClientEnabledFeatures) PConfigurationManagerClientEnabledFeatures() *ConfigurationManagerClientEnabledFeatures {
	return p
}

// Contact undocumented
type Contact struct {
	OutlookItem
	// ParentFolderId undocumented
	ParentFolderId *string `json:"parentFolderId,omitempty"`
	// Birthday undocumented
	Birthday *time.Time `json:"birthday,omitempty"`
	// FileAs undocumented
	FileAs *string `json:"fileAs,omitempty"`
	// DisplayName undocumented
	DisplayName *string `json:"displayName,omitempty"`
	// GivenName undocumented
	GivenName *string `json:"givenName,omitempty"`
	// Initials undocumented
	Initials *string `json:"initials,omitempty"`
	// MiddleName undocumented
	MiddleName *string `json:"middleName,omitempty"`
	// NickName undocumented
	NickName *string `json:"nickName,omitempty"`
	// Surname undocumented
	Surname *string `json:"surname,omitempty"`
	// Title undocumented
	Title *string `json:"title,omitempty"`
	// YomiGivenName undocumented
	YomiGivenName *string `json:"yomiGivenName,omitempty"`
	// YomiSurname undocumented
	YomiSurname *string `json:"yomiSurname,omitempty"`
	// YomiCompanyName undocumented
	YomiCompanyName *string `json:"yomiCompanyName,omitempty"`
	// Generation undocumented
	Generation *string `json:"generation,omitempty"`
	// EmailAddresses undocumented
	EmailAddresses []EmailAddress `json:"emailAddresses,omitempty"`
	// ImAddresses undocumented
	ImAddresses []string `json:"imAddresses,omitempty"`
	// JobTitle undocumented
	JobTitle *string `json:"jobTitle,omitempty"`
	// CompanyName undocumented
	CompanyName *string `json:"companyName,omitempty"`
	// Department undocumented
	Department *string `json:"department,omitempty"`
	// OfficeLocation undocumented
	OfficeLocation *string `json:"officeLocation,omitempty"`
	// Profession undocumented
	Profession *string `json:"profession,omitempty"`
	// BusinessHomePage undocumented
	BusinessHomePage *string `json:"businessHomePage,omitempty"`
	// AssistantName undocumented
	AssistantName *string `json:"assistantName,omitempty"`
	// Manager undocumented
	Manager *string `json:"manager,omitempty"`
	// HomePhones undocumented
	HomePhones []string `json:"homePhones,omitempty"`
	// MobilePhone undocumented
	MobilePhone *string `json:"mobilePhone,omitempty"`
	// BusinessPhones undocumented
	BusinessPhones []string `json:"businessPhones,omitempty"`
	// HomeAddress undocumented
	HomeAddress *PhysicalAddress `json:"homeAddress,omitempty"`
	// BusinessAddress undocumented
	BusinessAddress *PhysicalAddress `json:"businessAddress,omitempty"`
	// OtherAddress undocumented
	OtherAddress *PhysicalAddress `json:"otherAddress,omitempty"`
	// SpouseName undocumented
	SpouseName *string `json:"spouseName,omitempty"`
	// PersonalNotes undocumented
	PersonalNotes *string `json:"personalNotes,omitempty"`
	// Children undocumented
	Children []string `json:"children,omitempty"`
}

// IContact interface type for contact
type IContact interface {
	PContact() *Contact
}

// PContact pointer method for contact
func (p *Contact) PContact() *Contact { return p }

// ContactFolder undocumented
type ContactFolder struct {
	Entity
	// ParentFolderId undocumented
	ParentFolderId *string `json:"parentFolderId,omitempty"`
	// DisplayName undocumented
	DisplayName *string `json:"displayName,omitempty"`
}

// IContactFolder interface type for contactFolder
type IContactFolder interface {
	PContactFolder() *ContactFolder
}

// PContactFolder pointer method for contactFolder
func (p *ContactFolder) PContactFolder() *ContactFolder { return p }

// ContentType undocumented
type ContentType struct {
	Entity
	// Description undocumented
	Description *string `json:"description,omitempty"`
	// Group undocumented
	Group *string `json:"group,omitempty"`
	// Hidden undocumented
	Hidden *bool `json:"hidden,omitempty"`
	// InheritedFrom undocumented
	InheritedFrom *ItemReference `json:"inheritedFrom,omitempty"`
	// Name undocumented
	Name *string `json:"name,omitempty"`
	// Order undocumented
	Order *ContentTypeOrder `json:"order,omitempty"`
	// ParentId undocumented
	ParentId *string `json:"parentId,omitempty"`
	// ReadOnly undocumented
	ReadOnly *bool `json:"readOnly,omitempty"`
	// Sealed undocumented
	Sealed *bool `json:"sealed,omitempty"`
}

// IContentType interface type for contentType
type IContentType interface {
	PContentType() *ContentType
}

// PContentType pointer method for contentType
func (p *ContentType) PContentType() *ContentType { return p }

// ContentTypeInfo undocumented
type ContentTypeInfo struct {
	// Id undocumented
	Id *string `json:"id,omitempty"`
}

// IContentTypeInfo interface type for contentTypeInfo
type IContentTypeInfo interface {
	PContentTypeInfo() *ContentTypeInfo
}

// PContentTypeInfo pointer method for contentTypeInfo
func (p *ContentTypeInfo) PContentTypeInfo() *ContentTypeInfo { return p }

// ContentTypeOrder undocumented
type ContentTypeOrder struct {
	// Default undocumented
	Default *bool `json:"default,omitempty"`
	// Position undocumented
	Position *int `json:"position,omitempty"`
}

// IContentTypeOrder interface type for contentTypeOrder
type IContentTypeOrder interface {
	PContentTypeOrder() *ContentTypeOrder
}

// PContentTypeOrder pointer method for contentTypeOrder
func (p *ContentTypeOrder) PContentTypeOrder() *ContentTypeOrder { return p }

// Contract undocumented
type Contract struct {
	DirectoryObject
	// ContractType undocumented
	ContractType *string `json:"contractType,omitempty"`
	// CustomerId undocumented
	CustomerId *UUID `json:"customerId,omitempty"`
	// DefaultDomainName undocumented
	DefaultDomainName *string `json:"defaultDomainName,omitempty"`
	// DisplayName undocumented
	DisplayName *string `json:"displayName,omitempty"`
}

// IContract interface type for contract
type IContract interface {
	PContract() *Contract
}

// PContract pointer method for contract
func (p *Contract) PContract() *Contract { return p }

// ControlScore undocumented
type ControlScore struct {
	// ControlCategory undocumented
	ControlCategory *string `json:"controlCategory,omitempty"`
	// ControlName undocumented
	ControlName *string `json:"controlName,omitempty"`
	// Description undocumented
	Description *string `json:"description,omitempty"`
	// Score undocumented
	Score *float64 `json:"score,omitempty"`
}

// IControlScore interface type for controlScore
type IControlScore interface {
	PControlScore() *ControlScore
}

// PControlScore pointer method for controlScore
func (p *ControlScore) PControlScore() *ControlScore { return p }

// Conversation undocumented
type Conversation struct {
	Entity
	// Topic undocumented
	Topic *string `json:"topic,omitempty"`
	// HasAttachments undocumented
	HasAttachments *bool `json:"hasAttachments,omitempty"`
	// LastDeliveredDateTime undocumented
	LastDeliveredDateTime *time.Time `json:"lastDeliveredDateTime,omitempty"`
	// UniqueSenders undocumented
	UniqueSenders []string `json:"uniqueSenders,omitempty"`
	// Preview undocumented
	Preview *string `json:"preview,omitempty"`
}

// IConversation interface type for conversation
type IConversation interface {
	PConversation() *Conversation
}

// PConversation pointer method for conversation
func (p *Conversation) PConversation() *Conversation { return p }

// ConversationThread undocumented
type ConversationThread struct {
	Entity
	// ToRecipients undocumented
	ToRecipients []Recipient `json:"toRecipients,omitempty"`
	// Topic undocumented
	Topic *string `json:"topic,omitempty"`
	// HasAttachments undocumented
	HasAttachments *bool `json:"hasAttachments,omitempty"`
	// LastDeliveredDateTime undocumented
	LastDeliveredDateTime *time.Time `json:"lastDeliveredDateTime,omitempty"`
	// UniqueSenders undocumented
	UniqueSenders []string `json:"uniqueSenders,omitempty"`
	// CcRecipients undocumented
	CcRecipients []Recipient `json:"ccRecipients,omitempty"`
	// Preview undocumented
	Preview *string `json:"preview,omitempty"`
	// IsLocked undocumented
	IsLocked *bool `json:"isLocked,omitempty"`
}

// IConversationThread interface type for conversationThread
type IConversationThread interface {
	PConversationThread() *ConversationThread
}

// PConversationThread pointer method for conversationThread
func (p *ConversationThread) PConversationThread() *ConversationThread { return p }

// ConvertIdResult undocumented
type ConvertIdResult struct {
	// SourceId undocumented
	SourceId *string `json:"sourceId,omitempty"`
	// TargetId undocumented
	TargetId *string `json:"targetId,omitempty"`
	// ErrorDetails undocumented
	ErrorDetails *GenericError `json:"errorDetails,omitempty"`
}

// IConvertIdResult interface type for convertIdResult
type IConvertIdResult interface {
	PConvertIdResult() *ConvertIdResult
}

// PConvertIdResult pointer method for convertIdResult
func (p *ConvertIdResult) PConvertIdResult() *ConvertIdResult { return p }

// CurrencyColumn undocumented
type CurrencyColumn struct {
	// Locale undocumented
	Locale *string `json:"locale,omitempty"`
}

// ICurrencyColumn interface type for currencyColumn
type ICurrencyColumn interface {
	PCurrencyColumn() *CurrencyColumn
}

// PCurrencyColumn pointer method for currencyColumn
func (p *CurrencyColumn) PCurrencyColumn() *CurrencyColumn { return p }

// CustomTimeZone undocumented
type CustomTimeZone struct {
	TimeZoneBase
	// Bias undocumented
	Bias *int `json:"bias,omitempty"`
	// StandardOffset undocumented
	StandardOffset *StandardTimeZoneOffset `json:"standardOffset,omitempty"`
	// DaylightOffset undocumented
	DaylightOffset *DaylightTimeZoneOffset `json:"daylightOffset,omitempty"`
}

// ICustomTimeZone interface type for customTimeZone
type ICustomTimeZone interface {
	PCustomTimeZone() *CustomTimeZone
}

// PCustomTimeZone pointer method for customTimeZone
func (p *CustomTimeZone) PCustomTimeZone() *CustomTimeZone { return p }

// DataPolicyOperation undocumented
type DataPolicyOperation struct {
	Entity
	// CompletedDateTime undocumented
	CompletedDateTime *time.Time `json:"completedDateTime,omitempty"`
	// Status undocumented
	Status *DataPolicyOperationStatus `json:"status,omitempty"`
	// StorageLocation undocumented
	StorageLocation *string `json:"storageLocation,omitempty"`
	// UserId undocumented
	UserId *string `json:"userId,omitempty"`
	// SubmittedDateTime undocumented
	SubmittedDateTime *time.Time `json:"submittedDateTime,omitempty"`
	// Progress undocumented
	Progress *float64 `json:"progress,omitempty"`
}

// IDataPolicyOperation interface type for dataPolicyOperation
type IDataPolicyOperation interface {
	PDataPolicyOperation() *DataPolicyOperation
}

// PDataPolicyOperation pointer method for dataPolicyOperation
func (p *DataPolicyOperation) PDataPolicyOperation() *DataPolicyOperation { return p }

// DateTimeColumn undocumented
type DateTimeColumn struct {
	// DisplayAs undocumented
	DisplayAs *string `json:"displayAs,omitempty"`
	// Format undocumented
	Format *string `json:"format,omitempty"`
}

// IDateTimeColumn interface type for dateTimeColumn
type IDateTimeColumn interface {
	PDateTimeColumn() *DateTimeColumn
}

// PDateTimeColumn pointer method for dateTimeColumn
func (p *DateTimeColumn) PDateTimeColumn() *DateTimeColumn { return p }

// DateTimeTimeZone undocumented
type DateTimeTimeZone struct {
	// DateTime undocumented
	DateTime *string `json:"dateTime,omitempty"`
	// TimeZone undocumented
	TimeZone *string `json:"timeZone,omitempty"`
}

// IDateTimeTimeZone interface type for dateTimeTimeZone
type IDateTimeTimeZone interface {
	PDateTimeTimeZone() *DateTimeTimeZone
}

// PDateTimeTimeZone pointer method for dateTimeTimeZone
func (p *DateTimeTimeZone) PDateTimeTimeZone() *DateTimeTimeZone { return p }

// DaylightTimeZoneOffset undocumented
type DaylightTimeZoneOffset struct {
	StandardTimeZoneOffset
	// DaylightBias undocumented
	DaylightBias *int `json:"daylightBias,omitempty"`
}

// IDaylightTimeZoneOffset interface type for daylightTimeZoneOffset
type IDaylightTimeZoneOffset interface {
	PDaylightTimeZoneOffset() *DaylightTimeZoneOffset
}

// PDaylightTimeZoneOffset pointer method for daylightTimeZoneOffset
func (p *DaylightTimeZoneOffset) PDaylightTimeZoneOffset() *DaylightTimeZoneOffset { return p }

// DefaultColumnValue undocumented
type DefaultColumnValue struct {
	// Formula undocumented
	Formula *string `json:"formula,omitempty"`
	// Value undocumented
	Value *string `json:"value,omitempty"`
}

// IDefaultColumnValue interface type for defaultColumnValue
type IDefaultColumnValue interface {
	PDefaultColumnValue() *DefaultColumnValue
}

// PDefaultColumnValue pointer method for defaultColumnValue
func (p *DefaultColumnValue) PDefaultColumnValue() *DefaultColumnValue { return p }

// DefaultManagedAppProtection Policy used to configure detailed management settings for a specified set of apps for all users not targeted by a TargetedManagedAppProtection Policy
type DefaultManagedAppProtection struct {
	ManagedAppProtection
	// AppDataEncryptionType Type of encryption which should be used for data in a managed app. (iOS Only)
	AppDataEncryptionType *ManagedAppDataEncryptionType `json:"appDataEncryptionType,omitempty"`
	// ScreenCaptureBlocked Indicates whether screen capture is blocked. (Android only)
	ScreenCaptureBlocked *bool `json:"screenCaptureBlocked,omitempty"`
	// EncryptAppData Indicates whether managed-app data should be encrypted. (Android only)
	EncryptAppData *bool `json:"encryptAppData,omitempty"`
	// DisableAppEncryptionIfDeviceEncryptionIsEnabled When this setting is enabled, app level encryption is disabled if device level encryption is enabled. (Android only)
	DisableAppEncryptionIfDeviceEncryptionIsEnabled *bool `json:"disableAppEncryptionIfDeviceEncryptionIsEnabled,omitempty"`
	// MinimumRequiredSdkVersion Versions less than the specified version will block the managed app from accessing company data. (iOS Only)
	MinimumRequiredSdkVersion *string `json:"minimumRequiredSdkVersion,omitempty"`
	// CustomSettings A set of string key and string value pairs to be sent to the affected users, unalterned by this service
	CustomSettings []KeyValuePair `json:"customSettings,omitempty"`
	// DeployedAppCount Count of apps to which the current policy is deployed.
	DeployedAppCount *int `json:"deployedAppCount,omitempty"`
	// MinimumRequiredPatchVersion Define the oldest required Android security patch level a user can have to gain secure access to the app. (Android only)
	MinimumRequiredPatchVersion *string `json:"minimumRequiredPatchVersion,omitempty"`
	// MinimumWarningPatchVersion Define the oldest recommended Android security patch level a user can have for secure access to the app. (Android only)
	MinimumWarningPatchVersion *string `json:"minimumWarningPatchVersion,omitempty"`
	// FaceIdBlocked Indicates whether use of the FaceID is allowed in place of a pin if PinRequired is set to True. (iOS Only)
	FaceIdBlocked *bool `json:"faceIdBlocked,omitempty"`
}

// IDefaultManagedAppProtection interface type for defaultManagedAppProtection
type IDefaultManagedAppProtection interface {
	PDefaultManagedAppProtection() *DefaultManagedAppProtection
}

// PDefaultManagedAppProtection pointer method for defaultManagedAppProtection
func (p *DefaultManagedAppProtection) PDefaultManagedAppProtection() *DefaultManagedAppProtection {
	return p
}

// DefenderDetectedMalwareActions undocumented
type DefenderDetectedMalwareActions struct {
	// LowSeverity Indicates a Defender action to take for low severity Malware threat detected.
	LowSeverity *DefenderThreatAction `json:"lowSeverity,omitempty"`
	// ModerateSeverity Indicates a Defender action to take for moderate severity Malware threat detected.
	ModerateSeverity *DefenderThreatAction `json:"moderateSeverity,omitempty"`
	// HighSeverity Indicates a Defender action to take for high severity Malware threat detected.
	HighSeverity *DefenderThreatAction `json:"highSeverity,omitempty"`
	// SevereSeverity Indicates a Defender action to take for severe severity Malware threat detected.
	SevereSeverity *DefenderThreatAction `json:"severeSeverity,omitempty"`
}

// IDefenderDetectedMalwareActions interface type for defenderDetectedMalwareActions
type IDefenderDetectedMalwareActions interface {
	PDefenderDetectedMalwareActions() *DefenderDetectedMalwareActions
}

// PDefenderDetectedMalwareActions pointer method for defenderDetectedMalwareActions
func (p *DefenderDetectedMalwareActions) PDefenderDetectedMalwareActions() *DefenderDetectedMalwareActions {
	return p
}

// DeleteUserFromSharedAppleDeviceActionResult undocumented
type DeleteUserFromSharedAppleDeviceActionResult struct {
	DeviceActionResult
	// UserPrincipalName User principal name of the user to be deleted
	UserPrincipalName *string `json:"userPrincipalName,omitempty"`
}

// IDeleteUserFromSharedAppleDeviceActionResult interface type for deleteUserFromSharedAppleDeviceActionResult
type IDeleteUserFromSharedAppleDeviceActionResult interface {
	PDeleteUserFromSharedAppleDeviceActionResult() *DeleteUserFromSharedAppleDeviceActionResult
}

// PDeleteUserFromSharedAppleDeviceActionResult pointer method for deleteUserFromSharedAppleDeviceActionResult
func (p *DeleteUserFromSharedAppleDeviceActionResult) PDeleteUserFromSharedAppleDeviceActionResult() *DeleteUserFromSharedAppleDeviceActionResult {
	return p
}

// Deleted undocumented
type Deleted struct {
	// State undocumented
	State *string `json:"state,omitempty"`
}

// IDeleted interface type for deleted
type IDeleted interface {
	PDeleted() *Deleted
}

// PDeleted pointer method for deleted
func (p *Deleted) PDeleted() *Deleted { return p }

// DetectedApp A managed or unmanaged app that is installed on a managed device. Unmanaged apps will only appear for devices marked as corporate owned.
type DetectedApp struct {
	Entity
	// DisplayName Name of the discovered application. Read-only
	DisplayName *string `json:"displayName,omitempty"`
	// Version Version of the discovered application. Read-only
	Version *string `json:"version,omitempty"`
	// SizeInByte Discovered application size in bytes. Read-only
	SizeInByte *int `json:"sizeInByte,omitempty"`
	// DeviceCount The number of devices that have installed this application
	DeviceCount *int `json:"deviceCount,omitempty"`
}

// IDetectedApp interface type for detectedApp
type IDetectedApp interface {
	PDetectedApp() *DetectedApp
}

// PDetectedApp pointer method for detectedApp
func (p *DetectedApp) PDetectedApp() *DetectedApp { return p }

// Device undocumented
type Device struct {
	DirectoryObject
	// AccountEnabled undocumented
	AccountEnabled *bool `json:"accountEnabled,omitempty"`
	// AlternativeSecurityIds undocumented
	AlternativeSecurityIds []AlternativeSecurityId `json:"alternativeSecurityIds,omitempty"`
	// ApproximateLastSignInDateTime undocumented
	ApproximateLastSignInDateTime *time.Time `json:"approximateLastSignInDateTime,omitempty"`
	// ComplianceExpirationDateTime undocumented
	ComplianceExpirationDateTime *time.Time `json:"complianceExpirationDateTime,omitempty"`
	// DeviceId undocumented
	DeviceId *string `json:"deviceId,omitempty"`
	// DeviceMetadata undocumented
	DeviceMetadata *string `json:"deviceMetadata,omitempty"`
	// DeviceVersion undocumented
	DeviceVersion *int `json:"deviceVersion,omitempty"`
	// DisplayName undocumented
	DisplayName *string `json:"displayName,omitempty"`
	// IsCompliant undocumented
	IsCompliant *bool `json:"isCompliant,omitempty"`
	// IsManaged undocumented
	IsManaged *bool `json:"isManaged,omitempty"`
	// OnPremisesLastSyncDateTime undocumented
	OnPremisesLastSyncDateTime *time.Time `json:"onPremisesLastSyncDateTime,omitempty"`
	// OnPremisesSyncEnabled undocumented
	OnPremisesSyncEnabled *bool `json:"onPremisesSyncEnabled,omitempty"`
	// OperatingSystem undocumented
	OperatingSystem *string `json:"operatingSystem,omitempty"`
	// OperatingSystemVersion undocumented
	OperatingSystemVersion *string `json:"operatingSystemVersion,omitempty"`
	// PhysicalIds undocumented
	PhysicalIds []string `json:"physicalIds,omitempty"`
	// ProfileType undocumented
	ProfileType *string `json:"profileType,omitempty"`
	// SystemLabels undocumented
	SystemLabels []string `json:"systemLabels,omitempty"`
	// TrustType undocumented
	TrustType *string `json:"trustType,omitempty"`
}

// IDevice interface type for device
type IDevice interface {
	PDevice() *Device
}

// PDevice pointer method for device
func (p *Device) PDevice() *Device { return p }

// DeviceActionResult undocumented
type DeviceActionResult struct {
	// ActionName Action name
	ActionName *string `json:"actionName,omitempty"`
	// ActionState State of the action
	ActionState *ActionState `json:"actionState,omitempty"`
	// StartDateTime Time the action was initiated
	StartDateTime *time.Time `json:"startDateTime,omitempty"`
	// LastUpdatedDateTime Time the action state was last updated
	LastUpdatedDateTime *time.Time `json:"lastUpdatedDateTime,omitempty"`
}

// IDeviceActionResult interface type for deviceActionResult
type IDeviceActionResult interface {
	PDeviceActionResult() *DeviceActionResult
}

// PDeviceActionResult pointer method for deviceActionResult
func (p *DeviceActionResult) PDeviceActionResult() *DeviceActionResult { return p }

// DeviceAndAppManagementAssignmentTarget undocumented
type DeviceAndAppManagementAssignmentTarget struct {
}

// IDeviceAndAppManagementAssignmentTarget interface type for deviceAndAppManagementAssignmentTarget
type IDeviceAndAppManagementAssignmentTarget interface {
	PDeviceAndAppManagementAssignmentTarget() *DeviceAndAppManagementAssignmentTarget
}

// PDeviceAndAppManagementAssignmentTarget pointer method for deviceAndAppManagementAssignmentTarget
func (p *DeviceAndAppManagementAssignmentTarget) PDeviceAndAppManagementAssignmentTarget() *DeviceAndAppManagementAssignmentTarget {
	return p
}

// DeviceAndAppManagementRoleAssignment The Role Assignment resource. Role assignments tie together a role definition with members and scopes. There can be one or more role assignments per role. This applies to custom and built-in roles.
type DeviceAndAppManagementRoleAssignment struct {
	RoleAssignment
	// Members The list of ids of role member security groups. These are IDs from Azure Active Directory.
	Members []string `json:"members,omitempty"`
}

// IDeviceAndAppManagementRoleAssignment interface type for deviceAndAppManagementRoleAssignment
type IDeviceAndAppManagementRoleAssignment interface {
	PDeviceAndAppManagementRoleAssignment() *DeviceAndAppManagementRoleAssignment
}

// PDeviceAndAppManagementRoleAssignment pointer method for deviceAndAppManagementRoleAssignment
func (p *DeviceAndAppManagementRoleAssignment) PDeviceAndAppManagementRoleAssignment() *DeviceAndAppManagementRoleAssignment {
	return p
}

// DeviceAndAppManagementRoleDefinition The Role Definition resource. The role definition is the foundation of role based access in Intune. The role combines an Intune resource such as a Mobile App and associated role permissions such as Create or Read for the resource. There are two types of roles, built-in and custom. Built-in roles cannot be modified. Both built-in roles and custom roles must have assignments to be enforced. Create custom roles if you want to define a role that allows any of the available resources and role permissions to be combined into a single role.
type DeviceAndAppManagementRoleDefinition struct {
	RoleDefinition
}

// IDeviceAndAppManagementRoleDefinition interface type for deviceAndAppManagementRoleDefinition
type IDeviceAndAppManagementRoleDefinition interface {
	PDeviceAndAppManagementRoleDefinition() *DeviceAndAppManagementRoleDefinition
}

// PDeviceAndAppManagementRoleDefinition pointer method for deviceAndAppManagementRoleDefinition
func (p *DeviceAndAppManagementRoleDefinition) PDeviceAndAppManagementRoleDefinition() *DeviceAndAppManagementRoleDefinition {
	return p
}

// DeviceAppManagement Device app management singleton entity.
type DeviceAppManagement struct {
	Entity
	// MicrosoftStoreForBusinessLastSuccessfulSyncDateTime The last time the apps from the Microsoft Store for Business were synced successfully for the account.
	MicrosoftStoreForBusinessLastSuccessfulSyncDateTime *time.Time `json:"microsoftStoreForBusinessLastSuccessfulSyncDateTime,omitempty"`
	// IsEnabledForMicrosoftStoreForBusiness Whether the account is enabled for syncing applications from the Microsoft Store for Business.
	IsEnabledForMicrosoftStoreForBusiness *bool `json:"isEnabledForMicrosoftStoreForBusiness,omitempty"`
	// MicrosoftStoreForBusinessLanguage The locale information used to sync applications from the Microsoft Store for Business. Cultures that are specific to a country/region. The names of these cultures follow RFC 4646 (Windows Vista and later). The format is <languagecode2>-<country/regioncode2>, where <languagecode2> is a lowercase two-letter code derived from ISO 639-1 and <country/regioncode2> is an uppercase two-letter code derived from ISO 3166. For example, en-US for English (United States) is a specific culture.
	MicrosoftStoreForBusinessLanguage *string `json:"microsoftStoreForBusinessLanguage,omitempty"`
	// MicrosoftStoreForBusinessLastCompletedApplicationSyncTime The last time an application sync from the Microsoft Store for Business was completed.
	MicrosoftStoreForBusinessLastCompletedApplicationSyncTime *time.Time `json:"microsoftStoreForBusinessLastCompletedApplicationSyncTime,omitempty"`
}

// IDeviceAppManagement interface type for deviceAppManagement
type IDeviceAppManagement interface {
	PDeviceAppManagement() *DeviceAppManagement
}

// PDeviceAppManagement pointer method for deviceAppManagement
func (p *DeviceAppManagement) PDeviceAppManagement() *DeviceAppManagement { return p }

// DeviceCategory Device categories provides a way to organize your devices. Using device categories, company administrators can define their own categories that make sense to their company.These categories can then be applied to a device in the Intune Azure console or selected by a user during device enrollment. You can filter reports and create dynamic Azure Active Directory device groups based on device categories.
type DeviceCategory struct {
	Entity
	// DisplayName Display name for the device category.
	DisplayName *string `json:"displayName,omitempty"`
	// Description Optional description for the device category.
	Description *string `json:"description,omitempty"`
}

// IDeviceCategory interface type for deviceCategory
type IDeviceCategory interface {
	PDeviceCategory() *DeviceCategory
}

// PDeviceCategory pointer method for deviceCategory
func (p *DeviceCategory) PDeviceCategory() *DeviceCategory { return p }

// DeviceComplianceActionItem Scheduled Action Configuration
type DeviceComplianceActionItem struct {
	Entity
	// GracePeriodHours Number of hours to wait till the action will be enforced. Valid values 0 to 8760
	GracePeriodHours *int `json:"gracePeriodHours,omitempty"`
	// ActionType What action to take
	ActionType *DeviceComplianceActionType `json:"actionType,omitempty"`
	// NotificationTemplateId What notification Message template to use
	NotificationTemplateId *string `json:"notificationTemplateId,omitempty"`
	// NotificationMessageCCList A list of group IDs to speicify who to CC this notification message to.
	NotificationMessageCCList []string `json:"notificationMessageCCList,omitempty"`
}

// IDeviceComplianceActionItem interface type for deviceComplianceActionItem
type IDeviceComplianceActionItem interface {
	PDeviceComplianceActionItem() *DeviceComplianceActionItem
}

// PDeviceComplianceActionItem pointer method for deviceComplianceActionItem
func (p *DeviceComplianceActionItem) PDeviceComplianceActionItem() *DeviceComplianceActionItem {
	return p
}

// DeviceComplianceDeviceOverview undocumented
type DeviceComplianceDeviceOverview struct {
	Entity
	// PendingCount Number of pending devices
	PendingCount *int `json:"pendingCount,omitempty"`
	// NotApplicableCount Number of not applicable devices
	NotApplicableCount *int `json:"notApplicableCount,omitempty"`
	// SuccessCount Number of succeeded devices
	SuccessCount *int `json:"successCount,omitempty"`
	// ErrorCount Number of error devices
	ErrorCount *int `json:"errorCount,omitempty"`
	// FailedCount Number of failed devices
	FailedCount *int `json:"failedCount,omitempty"`
	// LastUpdateDateTime Last update time
	LastUpdateDateTime *time.Time `json:"lastUpdateDateTime,omitempty"`
	// ConfigurationVersion Version of the policy for that overview
	ConfigurationVersion *int `json:"configurationVersion,omitempty"`
}

// IDeviceComplianceDeviceOverview interface type for deviceComplianceDeviceOverview
type IDeviceComplianceDeviceOverview interface {
	PDeviceComplianceDeviceOverview() *DeviceComplianceDeviceOverview
}

// PDeviceComplianceDeviceOverview pointer method for deviceComplianceDeviceOverview
func (p *DeviceComplianceDeviceOverview) PDeviceComplianceDeviceOverview() *DeviceComplianceDeviceOverview {
	return p
}

// DeviceComplianceDeviceStatus undocumented
type DeviceComplianceDeviceStatus struct {
	Entity
	// DeviceDisplayName Device name of the DevicePolicyStatus.
	DeviceDisplayName *string `json:"deviceDisplayName,omitempty"`
	// UserName The User Name that is being reported
	UserName *string `json:"userName,omitempty"`
	// DeviceModel The device model that is being reported
	DeviceModel *string `json:"deviceModel,omitempty"`
	// ComplianceGracePeriodExpirationDateTime The DateTime when device compliance grace period expires
	ComplianceGracePeriodExpirationDateTime *time.Time `json:"complianceGracePeriodExpirationDateTime,omitempty"`
	// Status Compliance status of the policy report.
	Status *ComplianceStatus `json:"status,omitempty"`
	// LastReportedDateTime Last modified date time of the policy report.
	LastReportedDateTime *time.Time `json:"lastReportedDateTime,omitempty"`
	// UserPrincipalName UserPrincipalName.
	UserPrincipalName *string `json:"userPrincipalName,omitempty"`
}

// IDeviceComplianceDeviceStatus interface type for deviceComplianceDeviceStatus
type IDeviceComplianceDeviceStatus interface {
	PDeviceComplianceDeviceStatus() *DeviceComplianceDeviceStatus
}

// PDeviceComplianceDeviceStatus pointer method for deviceComplianceDeviceStatus
func (p *DeviceComplianceDeviceStatus) PDeviceComplianceDeviceStatus() *DeviceComplianceDeviceStatus {
	return p
}

// DeviceCompliancePolicy This is the base class for Compliance policy. Compliance policies are platform specific and individual per-platform compliance policies inherit from here.
type DeviceCompliancePolicy struct {
	Entity
	// CreatedDateTime DateTime the object was created.
	CreatedDateTime *time.Time `json:"createdDateTime,omitempty"`
	// Description Admin provided description of the Device Configuration.
	Description *string `json:"description,omitempty"`
	// LastModifiedDateTime DateTime the object was last modified.
	LastModifiedDateTime *time.Time `json:"lastModifiedDateTime,omitempty"`
	// DisplayName Admin provided name of the device configuration.
	DisplayName *string `json:"displayName,omitempty"`
	// Version Version of the device configuration.
	Version *int `json:"version,omitempty"`
}

// IDeviceCompliancePolicy interface type for deviceCompliancePolicy
type IDeviceCompliancePolicy interface {
	PDeviceCompliancePolicy() *DeviceCompliancePolicy
}

// PDeviceCompliancePolicy pointer method for deviceCompliancePolicy
func (p *DeviceCompliancePolicy) PDeviceCompliancePolicy() *DeviceCompliancePolicy { return p }

// DeviceCompliancePolicyAssignment Device compliance policy assignment.
type DeviceCompliancePolicyAssignment struct {
	Entity
	// Target Target for the compliance policy assignment.
	Target *DeviceAndAppManagementAssignmentTarget `json:"target,omitempty"`
}

// IDeviceCompliancePolicyAssignment interface type for deviceCompliancePolicyAssignment
type IDeviceCompliancePolicyAssignment interface {
	PDeviceCompliancePolicyAssignment() *DeviceCompliancePolicyAssignment
}

// PDeviceCompliancePolicyAssignment pointer method for deviceCompliancePolicyAssignment
func (p *DeviceCompliancePolicyAssignment) PDeviceCompliancePolicyAssignment() *DeviceCompliancePolicyAssignment {
	return p
}

// DeviceCompliancePolicyDeviceStateSummary undocumented
type DeviceCompliancePolicyDeviceStateSummary struct {
	Entity
	// InGracePeriodCount Number of devices that are in grace period
	InGracePeriodCount *int `json:"inGracePeriodCount,omitempty"`
	// ConfigManagerCount Number of devices that have compliance managed by System Center Configuration Manager
	ConfigManagerCount *int `json:"configManagerCount,omitempty"`
	// UnknownDeviceCount Number of unknown devices
	UnknownDeviceCount *int `json:"unknownDeviceCount,omitempty"`
	// NotApplicableDeviceCount Number of not applicable devices
	NotApplicableDeviceCount *int `json:"notApplicableDeviceCount,omitempty"`
	// CompliantDeviceCount Number of compliant devices
	CompliantDeviceCount *int `json:"compliantDeviceCount,omitempty"`
	// RemediatedDeviceCount Number of remediated devices
	RemediatedDeviceCount *int `json:"remediatedDeviceCount,omitempty"`
	// NonCompliantDeviceCount Number of NonCompliant devices
	NonCompliantDeviceCount *int `json:"nonCompliantDeviceCount,omitempty"`
	// ErrorDeviceCount Number of error devices
	ErrorDeviceCount *int `json:"errorDeviceCount,omitempty"`
	// ConflictDeviceCount Number of conflict devices
	ConflictDeviceCount *int `json:"conflictDeviceCount,omitempty"`
}

// IDeviceCompliancePolicyDeviceStateSummary interface type for deviceCompliancePolicyDeviceStateSummary
type IDeviceCompliancePolicyDeviceStateSummary interface {
	PDeviceCompliancePolicyDeviceStateSummary() *DeviceCompliancePolicyDeviceStateSummary
}

// PDeviceCompliancePolicyDeviceStateSummary pointer method for deviceCompliancePolicyDeviceStateSummary
func (p *DeviceCompliancePolicyDeviceStateSummary) PDeviceCompliancePolicyDeviceStateSummary() *DeviceCompliancePolicyDeviceStateSummary {
	return p
}

// DeviceCompliancePolicySettingState undocumented
type DeviceCompliancePolicySettingState struct {
	// Setting The setting that is being reported
	Setting *string `json:"setting,omitempty"`
	// SettingName Localized/user friendly setting name that is being reported
	SettingName *string `json:"settingName,omitempty"`
	// InstanceDisplayName Name of setting instance that is being reported.
	InstanceDisplayName *string `json:"instanceDisplayName,omitempty"`
	// State The compliance state of the setting
	State *ComplianceStatus `json:"state,omitempty"`
	// ErrorCode Error code for the setting
	ErrorCode *int `json:"errorCode,omitempty"`
	// ErrorDescription Error description
	ErrorDescription *string `json:"errorDescription,omitempty"`
	// UserId UserId
	UserId *string `json:"userId,omitempty"`
	// UserName UserName
	UserName *string `json:"userName,omitempty"`
	// UserEmail UserEmail
	UserEmail *string `json:"userEmail,omitempty"`
	// UserPrincipalName UserPrincipalName.
	UserPrincipalName *string `json:"userPrincipalName,omitempty"`
	// Sources Contributing policies
	Sources []SettingSource `json:"sources,omitempty"`
	// CurrentValue Current value of setting on device
	CurrentValue *string `json:"currentValue,omitempty"`
}

// IDeviceCompliancePolicySettingState interface type for deviceCompliancePolicySettingState
type IDeviceCompliancePolicySettingState interface {
	PDeviceCompliancePolicySettingState() *DeviceCompliancePolicySettingState
}

// PDeviceCompliancePolicySettingState pointer method for deviceCompliancePolicySettingState
func (p *DeviceCompliancePolicySettingState) PDeviceCompliancePolicySettingState() *DeviceCompliancePolicySettingState {
	return p
}

// DeviceCompliancePolicySettingStateSummary Device Compilance Policy Setting State summary across the account.
type DeviceCompliancePolicySettingStateSummary struct {
	Entity
	// Setting The setting class name and property name.
	Setting *string `json:"setting,omitempty"`
	// SettingName Name of the setting.
	SettingName *string `json:"settingName,omitempty"`
	// PlatformType Setting platform
	PlatformType *PolicyPlatformType `json:"platformType,omitempty"`
	// UnknownDeviceCount Number of unknown devices
	UnknownDeviceCount *int `json:"unknownDeviceCount,omitempty"`
	// NotApplicableDeviceCount Number of not applicable devices
	NotApplicableDeviceCount *int `json:"notApplicableDeviceCount,omitempty"`
	// CompliantDeviceCount Number of compliant devices
	CompliantDeviceCount *int `json:"compliantDeviceCount,omitempty"`
	// RemediatedDeviceCount Number of remediated devices
	RemediatedDeviceCount *int `json:"remediatedDeviceCount,omitempty"`
	// NonCompliantDeviceCount Number of NonCompliant devices
	NonCompliantDeviceCount *int `json:"nonCompliantDeviceCount,omitempty"`
	// ErrorDeviceCount Number of error devices
	ErrorDeviceCount *int `json:"errorDeviceCount,omitempty"`
	// ConflictDeviceCount Number of conflict devices
	ConflictDeviceCount *int `json:"conflictDeviceCount,omitempty"`
}

// IDeviceCompliancePolicySettingStateSummary interface type for deviceCompliancePolicySettingStateSummary
type IDeviceCompliancePolicySettingStateSummary interface {
	PDeviceCompliancePolicySettingStateSummary() *DeviceCompliancePolicySettingStateSummary
}

// PDeviceCompliancePolicySettingStateSummary pointer method for deviceCompliancePolicySettingStateSummary
func (p *DeviceCompliancePolicySettingStateSummary) PDeviceCompliancePolicySettingStateSummary() *DeviceCompliancePolicySettingStateSummary {
	return p
}

// DeviceCompliancePolicyState Device Compliance Policy State for a given device.
type DeviceCompliancePolicyState struct {
	Entity
	// SettingStates undocumented
	SettingStates []DeviceCompliancePolicySettingState `json:"settingStates,omitempty"`
	// DisplayName The name of the policy for this policyBase
	DisplayName *string `json:"displayName,omitempty"`
	// Version The version of the policy
	Version *int `json:"version,omitempty"`
	// PlatformType Platform type that the policy applies to
	PlatformType *PolicyPlatformType `json:"platformType,omitempty"`
	// State The compliance state of the policy
	State *ComplianceStatus `json:"state,omitempty"`
	// SettingCount Count of how many setting a policy holds
	SettingCount *int `json:"settingCount,omitempty"`
}

// IDeviceCompliancePolicyState interface type for deviceCompliancePolicyState
type IDeviceCompliancePolicyState interface {
	PDeviceCompliancePolicyState() *DeviceCompliancePolicyState
}

// PDeviceCompliancePolicyState pointer method for deviceCompliancePolicyState
func (p *DeviceCompliancePolicyState) PDeviceCompliancePolicyState() *DeviceCompliancePolicyState {
	return p
}

// DeviceComplianceScheduledActionForRule Scheduled Action for Rule
type DeviceComplianceScheduledActionForRule struct {
	Entity
	// RuleName Name of the rule which this scheduled action applies to.
	RuleName *string `json:"ruleName,omitempty"`
}

// IDeviceComplianceScheduledActionForRule interface type for deviceComplianceScheduledActionForRule
type IDeviceComplianceScheduledActionForRule interface {
	PDeviceComplianceScheduledActionForRule() *DeviceComplianceScheduledActionForRule
}

// PDeviceComplianceScheduledActionForRule pointer method for deviceComplianceScheduledActionForRule
func (p *DeviceComplianceScheduledActionForRule) PDeviceComplianceScheduledActionForRule() *DeviceComplianceScheduledActionForRule {
	return p
}

// DeviceComplianceSettingState Device compliance setting State for a given device.
type DeviceComplianceSettingState struct {
	Entity
	// Setting The setting class name and property name.
	Setting *string `json:"setting,omitempty"`
	// SettingName The Setting Name that is being reported
	SettingName *string `json:"settingName,omitempty"`
	// DeviceId The Device Id that is being reported
	DeviceId *string `json:"deviceId,omitempty"`
	// DeviceName The Device Name that is being reported
	DeviceName *string `json:"deviceName,omitempty"`
	// UserId The user Id that is being reported
	UserId *string `json:"userId,omitempty"`
	// UserEmail The User email address that is being reported
	UserEmail *string `json:"userEmail,omitempty"`
	// UserName The User Name that is being reported
	UserName *string `json:"userName,omitempty"`
	// UserPrincipalName The User PrincipalName that is being reported
	UserPrincipalName *string `json:"userPrincipalName,omitempty"`
	// DeviceModel The device model that is being reported
	DeviceModel *string `json:"deviceModel,omitempty"`
	// State The compliance state of the setting
	State *ComplianceStatus `json:"state,omitempty"`
	// ComplianceGracePeriodExpirationDateTime The DateTime when device compliance grace period expires
	ComplianceGracePeriodExpirationDateTime *time.Time `json:"complianceGracePeriodExpirationDateTime,omitempty"`
}

// IDeviceComplianceSettingState interface type for deviceComplianceSettingState
type IDeviceComplianceSettingState interface {
	PDeviceComplianceSettingState() *DeviceComplianceSettingState
}

// PDeviceComplianceSettingState pointer method for deviceComplianceSettingState
func (p *DeviceComplianceSettingState) PDeviceComplianceSettingState() *DeviceComplianceSettingState {
	return p
}

// DeviceComplianceUserOverview undocumented
type DeviceComplianceUserOverview struct {
	Entity
	// PendingCount Number of pending Users
	PendingCount *int `json:"pendingCount,omitempty"`
	// NotApplicableCount Number of not applicable users
	NotApplicableCount *int `json:"notApplicableCount,omitempty"`
	// SuccessCount Number of succeeded Users
	SuccessCount *int `json:"successCount,omitempty"`
	// ErrorCount Number of error Users
	ErrorCount *int `json:"errorCount,omitempty"`
	// FailedCount Number of failed Users
	FailedCount *int `json:"failedCount,omitempty"`
	// LastUpdateDateTime Last update time
	LastUpdateDateTime *time.Time `json:"lastUpdateDateTime,omitempty"`
	// ConfigurationVersion Version of the policy for that overview
	ConfigurationVersion *int `json:"configurationVersion,omitempty"`
}

// IDeviceComplianceUserOverview interface type for deviceComplianceUserOverview
type IDeviceComplianceUserOverview interface {
	PDeviceComplianceUserOverview() *DeviceComplianceUserOverview
}

// PDeviceComplianceUserOverview pointer method for deviceComplianceUserOverview
func (p *DeviceComplianceUserOverview) PDeviceComplianceUserOverview() *DeviceComplianceUserOverview {
	return p
}

// DeviceComplianceUserStatus undocumented
type DeviceComplianceUserStatus struct {
	Entity
	// UserDisplayName User name of the DevicePolicyStatus.
	UserDisplayName *string `json:"userDisplayName,omitempty"`
	// DevicesCount Devices count for that user.
	DevicesCount *int `json:"devicesCount,omitempty"`
	// Status Compliance status of the policy report.
	Status *ComplianceStatus `json:"status,omitempty"`
	// LastReportedDateTime Last modified date time of the policy report.
	LastReportedDateTime *time.Time `json:"lastReportedDateTime,omitempty"`
	// UserPrincipalName UserPrincipalName.
	UserPrincipalName *string `json:"userPrincipalName,omitempty"`
}

// IDeviceComplianceUserStatus interface type for deviceComplianceUserStatus
type IDeviceComplianceUserStatus interface {
	PDeviceComplianceUserStatus() *DeviceComplianceUserStatus
}

// PDeviceComplianceUserStatus pointer method for deviceComplianceUserStatus
func (p *DeviceComplianceUserStatus) PDeviceComplianceUserStatus() *DeviceComplianceUserStatus {
	return p
}

// DeviceConfiguration Device Configuration.
type DeviceConfiguration struct {
	Entity
	// LastModifiedDateTime DateTime the object was last modified.
	LastModifiedDateTime *time.Time `json:"lastModifiedDateTime,omitempty"`
	// CreatedDateTime DateTime the object was created.
	CreatedDateTime *time.Time `json:"createdDateTime,omitempty"`
	// Description Admin provided description of the Device Configuration.
	Description *string `json:"description,omitempty"`
	// DisplayName Admin provided name of the device configuration.
	DisplayName *string `json:"displayName,omitempty"`
	// Version Version of the device configuration.
	Version *int `json:"version,omitempty"`
}

// IDeviceConfiguration interface type for deviceConfiguration
type IDeviceConfiguration interface {
	PDeviceConfiguration() *DeviceConfiguration
}

// PDeviceConfiguration pointer method for deviceConfiguration
func (p *DeviceConfiguration) PDeviceConfiguration() *DeviceConfiguration { return p }

// DeviceConfigurationAssignment The device configuration assignment entity assigns an AAD group to a specific device configuration.
type DeviceConfigurationAssignment struct {
	Entity
	// Target The assignment target for the device configuration.
	Target *DeviceAndAppManagementAssignmentTarget `json:"target,omitempty"`
}

// IDeviceConfigurationAssignment interface type for deviceConfigurationAssignment
type IDeviceConfigurationAssignment interface {
	PDeviceConfigurationAssignment() *DeviceConfigurationAssignment
}

// PDeviceConfigurationAssignment pointer method for deviceConfigurationAssignment
func (p *DeviceConfigurationAssignment) PDeviceConfigurationAssignment() *DeviceConfigurationAssignment {
	return p
}

// DeviceConfigurationDeviceOverview undocumented
type DeviceConfigurationDeviceOverview struct {
	Entity
	// PendingCount Number of pending devices
	PendingCount *int `json:"pendingCount,omitempty"`
	// NotApplicableCount Number of not applicable devices
	NotApplicableCount *int `json:"notApplicableCount,omitempty"`
	// SuccessCount Number of succeeded devices
	SuccessCount *int `json:"successCount,omitempty"`
	// ErrorCount Number of error devices
	ErrorCount *int `json:"errorCount,omitempty"`
	// FailedCount Number of failed devices
	FailedCount *int `json:"failedCount,omitempty"`
	// LastUpdateDateTime Last update time
	LastUpdateDateTime *time.Time `json:"lastUpdateDateTime,omitempty"`
	// ConfigurationVersion Version of the policy for that overview
	ConfigurationVersion *int `json:"configurationVersion,omitempty"`
}

// IDeviceConfigurationDeviceOverview interface type for deviceConfigurationDeviceOverview
type IDeviceConfigurationDeviceOverview interface {
	PDeviceConfigurationDeviceOverview() *DeviceConfigurationDeviceOverview
}

// PDeviceConfigurationDeviceOverview pointer method for deviceConfigurationDeviceOverview
func (p *DeviceConfigurationDeviceOverview) PDeviceConfigurationDeviceOverview() *DeviceConfigurationDeviceOverview {
	return p
}

// DeviceConfigurationDeviceStateSummary undocumented
type DeviceConfigurationDeviceStateSummary struct {
	Entity
	// UnknownDeviceCount Number of unknown devices
	UnknownDeviceCount *int `json:"unknownDeviceCount,omitempty"`
	// NotApplicableDeviceCount Number of not applicable devices
	NotApplicableDeviceCount *int `json:"notApplicableDeviceCount,omitempty"`
	// CompliantDeviceCount Number of compliant devices
	CompliantDeviceCount *int `json:"compliantDeviceCount,omitempty"`
	// RemediatedDeviceCount Number of remediated devices
	RemediatedDeviceCount *int `json:"remediatedDeviceCount,omitempty"`
	// NonCompliantDeviceCount Number of NonCompliant devices
	NonCompliantDeviceCount *int `json:"nonCompliantDeviceCount,omitempty"`
	// ErrorDeviceCount Number of error devices
	ErrorDeviceCount *int `json:"errorDeviceCount,omitempty"`
	// ConflictDeviceCount Number of conflict devices
	ConflictDeviceCount *int `json:"conflictDeviceCount,omitempty"`
}

// IDeviceConfigurationDeviceStateSummary interface type for deviceConfigurationDeviceStateSummary
type IDeviceConfigurationDeviceStateSummary interface {
	PDeviceConfigurationDeviceStateSummary() *DeviceConfigurationDeviceStateSummary
}

// PDeviceConfigurationDeviceStateSummary pointer method for deviceConfigurationDeviceStateSummary
func (p *DeviceConfigurationDeviceStateSummary) PDeviceConfigurationDeviceStateSummary() *DeviceConfigurationDeviceStateSummary {
	return p
}

// DeviceConfigurationDeviceStatus undocumented
type DeviceConfigurationDeviceStatus struct {
	Entity
	// DeviceDisplayName Device name of the DevicePolicyStatus.
	DeviceDisplayName *string `json:"deviceDisplayName,omitempty"`
	// UserName The User Name that is being reported
	UserName *string `json:"userName,omitempty"`
	// DeviceModel The device model that is being reported
	DeviceModel *string `json:"deviceModel,omitempty"`
	// ComplianceGracePeriodExpirationDateTime The DateTime when device compliance grace period expires
	ComplianceGracePeriodExpirationDateTime *time.Time `json:"complianceGracePeriodExpirationDateTime,omitempty"`
	// Status Compliance status of the policy report.
	Status *ComplianceStatus `json:"status,omitempty"`
	// LastReportedDateTime Last modified date time of the policy report.
	LastReportedDateTime *time.Time `json:"lastReportedDateTime,omitempty"`
	// UserPrincipalName UserPrincipalName.
	UserPrincipalName *string `json:"userPrincipalName,omitempty"`
}

// IDeviceConfigurationDeviceStatus interface type for deviceConfigurationDeviceStatus
type IDeviceConfigurationDeviceStatus interface {
	PDeviceConfigurationDeviceStatus() *DeviceConfigurationDeviceStatus
}

// PDeviceConfigurationDeviceStatus pointer method for deviceConfigurationDeviceStatus
func (p *DeviceConfigurationDeviceStatus) PDeviceConfigurationDeviceStatus() *DeviceConfigurationDeviceStatus {
	return p
}

// DeviceConfigurationSettingState undocumented
type DeviceConfigurationSettingState struct {
	// Setting The setting that is being reported
	Setting *string `json:"setting,omitempty"`
	// SettingName Localized/user friendly setting name that is being reported
	SettingName *string `json:"settingName,omitempty"`
	// InstanceDisplayName Name of setting instance that is being reported.
	InstanceDisplayName *string `json:"instanceDisplayName,omitempty"`
	// State The compliance state of the setting
	State *ComplianceStatus `json:"state,omitempty"`
	// ErrorCode Error code for the setting
	ErrorCode *int `json:"errorCode,omitempty"`
	// ErrorDescription Error description
	ErrorDescription *string `json:"errorDescription,omitempty"`
	// UserId UserId
	UserId *string `json:"userId,omitempty"`
	// UserName UserName
	UserName *string `json:"userName,omitempty"`
	// UserEmail UserEmail
	UserEmail *string `json:"userEmail,omitempty"`
	// UserPrincipalName UserPrincipalName.
	UserPrincipalName *string `json:"userPrincipalName,omitempty"`
	// Sources Contributing policies
	Sources []SettingSource `json:"sources,omitempty"`
	// CurrentValue Current value of setting on device
	CurrentValue *string `json:"currentValue,omitempty"`
}

// IDeviceConfigurationSettingState interface type for deviceConfigurationSettingState
type IDeviceConfigurationSettingState interface {
	PDeviceConfigurationSettingState() *DeviceConfigurationSettingState
}

// PDeviceConfigurationSettingState pointer method for deviceConfigurationSettingState
func (p *DeviceConfigurationSettingState) PDeviceConfigurationSettingState() *DeviceConfigurationSettingState {
	return p
}

// DeviceConfigurationState Device Configuration State for a given device.
type DeviceConfigurationState struct {
	Entity
	// SettingStates undocumented
	SettingStates []DeviceConfigurationSettingState `json:"settingStates,omitempty"`
	// DisplayName The name of the policy for this policyBase
	DisplayName *string `json:"displayName,omitempty"`
	// Version The version of the policy
	Version *int `json:"version,omitempty"`
	// PlatformType Platform type that the policy applies to
	PlatformType *PolicyPlatformType `json:"platformType,omitempty"`
	// State The compliance state of the policy
	State *ComplianceStatus `json:"state,omitempty"`
	// SettingCount Count of how many setting a policy holds
	SettingCount *int `json:"settingCount,omitempty"`
}

// IDeviceConfigurationState interface type for deviceConfigurationState
type IDeviceConfigurationState interface {
	PDeviceConfigurationState() *DeviceConfigurationState
}

// PDeviceConfigurationState pointer method for deviceConfigurationState
func (p *DeviceConfigurationState) PDeviceConfigurationState() *DeviceConfigurationState { return p }

// DeviceConfigurationUserOverview undocumented
type DeviceConfigurationUserOverview struct {
	Entity
	// PendingCount Number of pending Users
	PendingCount *int `json:"pendingCount,omitempty"`
	// NotApplicableCount Number of not applicable users
	NotApplicableCount *int `json:"notApplicableCount,omitempty"`
	// SuccessCount Number of succeeded Users
	SuccessCount *int `json:"successCount,omitempty"`
	// ErrorCount Number of error Users
	ErrorCount *int `json:"errorCount,omitempty"`
	// FailedCount Number of failed Users
	FailedCount *int `json:"failedCount,omitempty"`
	// LastUpdateDateTime Last update time
	LastUpdateDateTime *time.Time `json:"lastUpdateDateTime,omitempty"`
	// ConfigurationVersion Version of the policy for that overview
	ConfigurationVersion *int `json:"configurationVersion,omitempty"`
}

// IDeviceConfigurationUserOverview interface type for deviceConfigurationUserOverview
type IDeviceConfigurationUserOverview interface {
	PDeviceConfigurationUserOverview() *DeviceConfigurationUserOverview
}

// PDeviceConfigurationUserOverview pointer method for deviceConfigurationUserOverview
func (p *DeviceConfigurationUserOverview) PDeviceConfigurationUserOverview() *DeviceConfigurationUserOverview {
	return p
}

// DeviceConfigurationUserStatus undocumented
type DeviceConfigurationUserStatus struct {
	Entity
	// UserDisplayName User name of the DevicePolicyStatus.
	UserDisplayName *string `json:"userDisplayName,omitempty"`
	// DevicesCount Devices count for that user.
	DevicesCount *int `json:"devicesCount,omitempty"`
	// Status Compliance status of the policy report.
	Status *ComplianceStatus `json:"status,omitempty"`
	// LastReportedDateTime Last modified date time of the policy report.
	LastReportedDateTime *time.Time `json:"lastReportedDateTime,omitempty"`
	// UserPrincipalName UserPrincipalName.
	UserPrincipalName *string `json:"userPrincipalName,omitempty"`
}

// IDeviceConfigurationUserStatus interface type for deviceConfigurationUserStatus
type IDeviceConfigurationUserStatus interface {
	PDeviceConfigurationUserStatus() *DeviceConfigurationUserStatus
}

// PDeviceConfigurationUserStatus pointer method for deviceConfigurationUserStatus
func (p *DeviceConfigurationUserStatus) PDeviceConfigurationUserStatus() *DeviceConfigurationUserStatus {
	return p
}

// DeviceDetail undocumented
type DeviceDetail struct {
	// DeviceId undocumented
	DeviceId *string `json:"deviceId,omitempty"`
	// DisplayName undocumented
	DisplayName *string `json:"displayName,omitempty"`
	// OperatingSystem undocumented
	OperatingSystem *string `json:"operatingSystem,omitempty"`
	// Browser undocumented
	Browser *string `json:"browser,omitempty"`
	// IsCompliant undocumented
	IsCompliant *bool `json:"isCompliant,omitempty"`
	// IsManaged undocumented
	IsManaged *bool `json:"isManaged,omitempty"`
	// TrustType undocumented
	TrustType *string `json:"trustType,omitempty"`
}

// IDeviceDetail interface type for deviceDetail
type IDeviceDetail interface {
	PDeviceDetail() *DeviceDetail
}

// PDeviceDetail pointer method for deviceDetail
func (p *DeviceDetail) PDeviceDetail() *DeviceDetail { return p }

// DeviceEnrollmentConfiguration undocumented
type DeviceEnrollmentConfiguration struct {
	Entity
	// DisplayName undocumented
	DisplayName *string `json:"displayName,omitempty"`
	// Description undocumented
	Description *string `json:"description,omitempty"`
	// Priority undocumented
	Priority *int `json:"priority,omitempty"`
	// CreatedDateTime undocumented
	CreatedDateTime *time.Time `json:"createdDateTime,omitempty"`
	// LastModifiedDateTime undocumented
	LastModifiedDateTime *time.Time `json:"lastModifiedDateTime,omitempty"`
	// Version undocumented
	Version *int `json:"version,omitempty"`
}

// IDeviceEnrollmentConfiguration interface type for deviceEnrollmentConfiguration
type IDeviceEnrollmentConfiguration interface {
	PDeviceEnrollmentConfiguration() *DeviceEnrollmentConfiguration
}

// PDeviceEnrollmentConfiguration pointer method for deviceEnrollmentConfiguration
func (p *DeviceEnrollmentConfiguration) PDeviceEnrollmentConfiguration() *DeviceEnrollmentConfiguration {
	return p
}

// DeviceEnrollmentLimitConfiguration undocumented
type DeviceEnrollmentLimitConfiguration struct {
	DeviceEnrollmentConfiguration
	// Limit undocumented
	Limit *int `json:"limit,omitempty"`
}

// IDeviceEnrollmentLimitConfiguration interface type for deviceEnrollmentLimitConfiguration
type IDeviceEnrollmentLimitConfiguration interface {
	PDeviceEnrollmentLimitConfiguration() *DeviceEnrollmentLimitConfiguration
}

// PDeviceEnrollmentLimitConfiguration pointer method for deviceEnrollmentLimitConfiguration
func (p *DeviceEnrollmentLimitConfiguration) PDeviceEnrollmentLimitConfiguration() *DeviceEnrollmentLimitConfiguration {
	return p
}

// DeviceEnrollmentPlatformRestriction undocumented
type DeviceEnrollmentPlatformRestriction struct {
	// PlatformBlocked Block the platform from enrolling
	PlatformBlocked *bool `json:"platformBlocked,omitempty"`
	// PersonalDeviceEnrollmentBlocked Block personally owned devices from enrolling
	PersonalDeviceEnrollmentBlocked *bool `json:"personalDeviceEnrollmentBlocked,omitempty"`
	// OsMinimumVersion Min OS version supported
	OsMinimumVersion *string `json:"osMinimumVersion,omitempty"`
	// OsMaximumVersion Max OS version supported
	OsMaximumVersion *string `json:"osMaximumVersion,omitempty"`
}

// IDeviceEnrollmentPlatformRestriction interface type for deviceEnrollmentPlatformRestriction
type IDeviceEnrollmentPlatformRestriction interface {
	PDeviceEnrollmentPlatformRestriction() *DeviceEnrollmentPlatformRestriction
}

// PDeviceEnrollmentPlatformRestriction pointer method for deviceEnrollmentPlatformRestriction
func (p *DeviceEnrollmentPlatformRestriction) PDeviceEnrollmentPlatformRestriction() *DeviceEnrollmentPlatformRestriction {
	return p
}

// DeviceEnrollmentPlatformRestrictionsConfiguration undocumented
type DeviceEnrollmentPlatformRestrictionsConfiguration struct {
	DeviceEnrollmentConfiguration
	// IosRestriction undocumented
	IosRestriction *DeviceEnrollmentPlatformRestriction `json:"iosRestriction,omitempty"`
	// WindowsRestriction undocumented
	WindowsRestriction *DeviceEnrollmentPlatformRestriction `json:"windowsRestriction,omitempty"`
	// WindowsMobileRestriction undocumented
	WindowsMobileRestriction *DeviceEnrollmentPlatformRestriction `json:"windowsMobileRestriction,omitempty"`
	// AndroidRestriction undocumented
	AndroidRestriction *DeviceEnrollmentPlatformRestriction `json:"androidRestriction,omitempty"`
	// MacOSRestriction undocumented
	MacOSRestriction *DeviceEnrollmentPlatformRestriction `json:"macOSRestriction,omitempty"`
}

// IDeviceEnrollmentPlatformRestrictionsConfiguration interface type for deviceEnrollmentPlatformRestrictionsConfiguration
type IDeviceEnrollmentPlatformRestrictionsConfiguration interface {
	PDeviceEnrollmentPlatformRestrictionsConfiguration() *DeviceEnrollmentPlatformRestrictionsConfiguration
}

// PDeviceEnrollmentPlatformRestrictionsConfiguration pointer method for deviceEnrollmentPlatformRestrictionsConfiguration
func (p *DeviceEnrollmentPlatformRestrictionsConfiguration) PDeviceEnrollmentPlatformRestrictionsConfiguration() *DeviceEnrollmentPlatformRestrictionsConfiguration {
	return p
}

// DeviceEnrollmentWindowsHelloForBusinessConfiguration undocumented
type DeviceEnrollmentWindowsHelloForBusinessConfiguration struct {
	DeviceEnrollmentConfiguration
	// PinMinimumLength undocumented
	PinMinimumLength *int `json:"pinMinimumLength,omitempty"`
	// PinMaximumLength undocumented
	PinMaximumLength *int `json:"pinMaximumLength,omitempty"`
	// PinUppercaseCharactersUsage undocumented
	PinUppercaseCharactersUsage *WindowsHelloForBusinessPinUsage `json:"pinUppercaseCharactersUsage,omitempty"`
	// PinLowercaseCharactersUsage undocumented
	PinLowercaseCharactersUsage *WindowsHelloForBusinessPinUsage `json:"pinLowercaseCharactersUsage,omitempty"`
	// PinSpecialCharactersUsage undocumented
	PinSpecialCharactersUsage *WindowsHelloForBusinessPinUsage `json:"pinSpecialCharactersUsage,omitempty"`
	// State undocumented
	State *Enablement `json:"state,omitempty"`
	// SecurityDeviceRequired undocumented
	SecurityDeviceRequired *bool `json:"securityDeviceRequired,omitempty"`
	// UnlockWithBiometricsEnabled undocumented
	UnlockWithBiometricsEnabled *bool `json:"unlockWithBiometricsEnabled,omitempty"`
	// RemotePassportEnabled undocumented
	RemotePassportEnabled *bool `json:"remotePassportEnabled,omitempty"`
	// PinPreviousBlockCount undocumented
	PinPreviousBlockCount *int `json:"pinPreviousBlockCount,omitempty"`
	// PinExpirationInDays undocumented
	PinExpirationInDays *int `json:"pinExpirationInDays,omitempty"`
	// EnhancedBiometricsState undocumented
	EnhancedBiometricsState *Enablement `json:"enhancedBiometricsState,omitempty"`
}

// IDeviceEnrollmentWindowsHelloForBusinessConfiguration interface type for deviceEnrollmentWindowsHelloForBusinessConfiguration
type IDeviceEnrollmentWindowsHelloForBusinessConfiguration interface {
	PDeviceEnrollmentWindowsHelloForBusinessConfiguration() *DeviceEnrollmentWindowsHelloForBusinessConfiguration
}

// PDeviceEnrollmentWindowsHelloForBusinessConfiguration pointer method for deviceEnrollmentWindowsHelloForBusinessConfiguration
func (p *DeviceEnrollmentWindowsHelloForBusinessConfiguration) PDeviceEnrollmentWindowsHelloForBusinessConfiguration() *DeviceEnrollmentWindowsHelloForBusinessConfiguration {
	return p
}

// DeviceExchangeAccessStateSummary undocumented
type DeviceExchangeAccessStateSummary struct {
	// AllowedDeviceCount Total count of devices with Exchange Access State: Allowed.
	AllowedDeviceCount *int `json:"allowedDeviceCount,omitempty"`
	// BlockedDeviceCount Total count of devices with Exchange Access State: Blocked.
	BlockedDeviceCount *int `json:"blockedDeviceCount,omitempty"`
	// QuarantinedDeviceCount Total count of devices with Exchange Access State: Quarantined.
	QuarantinedDeviceCount *int `json:"quarantinedDeviceCount,omitempty"`
	// UnknownDeviceCount Total count of devices with Exchange Access State: Unknown.
	UnknownDeviceCount *int `json:"unknownDeviceCount,omitempty"`
	// UnavailableDeviceCount Total count of devices for which no Exchange Access State could be found.
	UnavailableDeviceCount *int `json:"unavailableDeviceCount,omitempty"`
}

// IDeviceExchangeAccessStateSummary interface type for deviceExchangeAccessStateSummary
type IDeviceExchangeAccessStateSummary interface {
	PDeviceExchangeAccessStateSummary() *DeviceExchangeAccessStateSummary
}

// PDeviceExchangeAccessStateSummary pointer method for deviceExchangeAccessStateSummary
func (p *DeviceExchangeAccessStateSummary) PDeviceExchangeAccessStateSummary() *DeviceExchangeAccessStateSummary {
	return p
}

// DeviceGeoLocation undocumented
type DeviceGeoLocation struct {
	// LastCollectedDateTime Time at which location was recorded, relative to UTC
	LastCollectedDateTime *time.Time `json:"lastCollectedDateTime,omitempty"`
	// Longitude Longitude coordinate of the device's location
	Longitude *float64 `json:"longitude,omitempty"`
	// Latitude Latitude coordinate of the device's location
	Latitude *float64 `json:"latitude,omitempty"`
	// Altitude Altitude, given in meters above sea level
	Altitude *float64 `json:"altitude,omitempty"`
	// HorizontalAccuracy Accuracy of longitude and latitude in meters
	HorizontalAccuracy *float64 `json:"horizontalAccuracy,omitempty"`
	// VerticalAccuracy Accuracy of altitude in meters
	VerticalAccuracy *float64 `json:"verticalAccuracy,omitempty"`
	// Heading Heading in degrees from true north
	Heading *float64 `json:"heading,omitempty"`
	// Speed Speed the device is traveling in meters per second
	Speed *float64 `json:"speed,omitempty"`
}

// IDeviceGeoLocation interface type for deviceGeoLocation
type IDeviceGeoLocation interface {
	PDeviceGeoLocation() *DeviceGeoLocation
}

// PDeviceGeoLocation pointer method for deviceGeoLocation
func (p *DeviceGeoLocation) PDeviceGeoLocation() *DeviceGeoLocation { return p }

// DeviceHealthAttestationState undocumented
type DeviceHealthAttestationState struct {
	// LastUpdateDateTime The Timestamp of the last update.
	LastUpdateDateTime *string `json:"lastUpdateDateTime,omitempty"`
	// ContentNamespaceUrl The DHA report version. (Namespace version)
	ContentNamespaceUrl *string `json:"contentNamespaceUrl,omitempty"`
	// DeviceHealthAttestationStatus The DHA report version. (Namespace version)
	DeviceHealthAttestationStatus *string `json:"deviceHealthAttestationStatus,omitempty"`
	// ContentVersion The HealthAttestation state schema version
	ContentVersion *string `json:"contentVersion,omitempty"`
	// IssuedDateTime The DateTime when device was evaluated or issued to MDM
	IssuedDateTime *time.Time `json:"issuedDateTime,omitempty"`
	// AttestationIdentityKey TWhen an Attestation Identity Key (AIK) is present on a device, it indicates that the device has an endorsement key (EK) certificate.
	AttestationIdentityKey *string `json:"attestationIdentityKey,omitempty"`
	// ResetCount The number of times a PC device has hibernated or resumed
	ResetCount *int `json:"resetCount,omitempty"`
	// RestartCount The number of times a PC device has rebooted
	RestartCount *int `json:"restartCount,omitempty"`
	// DataExcutionPolicy DEP Policy defines a set of hardware and software technologies that perform additional checks on memory
	DataExcutionPolicy *string `json:"dataExcutionPolicy,omitempty"`
	// BitLockerStatus On or Off of BitLocker Drive Encryption
	BitLockerStatus *string `json:"bitLockerStatus,omitempty"`
	// BootManagerVersion The version of the Boot Manager
	BootManagerVersion *string `json:"bootManagerVersion,omitempty"`
	// CodeIntegrityCheckVersion The version of the Boot Manager
	CodeIntegrityCheckVersion *string `json:"codeIntegrityCheckVersion,omitempty"`
	// SecureBoot When Secure Boot is enabled, the core components must have the correct cryptographic signatures
	SecureBoot *string `json:"secureBoot,omitempty"`
	// BootDebugging When bootDebugging is enabled, the device is used in development and testing
	BootDebugging *string `json:"bootDebugging,omitempty"`
	// OperatingSystemKernelDebugging When operatingSystemKernelDebugging is enabled, the device is used in development and testing
	OperatingSystemKernelDebugging *string `json:"operatingSystemKernelDebugging,omitempty"`
	// CodeIntegrity  When code integrity is enabled, code execution is restricted to integrity verified code
	CodeIntegrity *string `json:"codeIntegrity,omitempty"`
	// TestSigning When test signing is allowed, the device does not enforce signature validation during boot
	TestSigning *string `json:"testSigning,omitempty"`
	// SafeMode Safe mode is a troubleshooting option for Windows that starts your computer in a limited state
	SafeMode *string `json:"safeMode,omitempty"`
	// WindowsPE Operating system running with limited services that is used to prepare a computer for Windows
	WindowsPE *string `json:"windowsPE,omitempty"`
	// EarlyLaunchAntiMalwareDriverProtection ELAM provides protection for the computers in your network when they start up
	EarlyLaunchAntiMalwareDriverProtection *string `json:"earlyLaunchAntiMalwareDriverProtection,omitempty"`
	// VirtualSecureMode VSM is a container that protects high value assets from a compromised kernel
	VirtualSecureMode *string `json:"virtualSecureMode,omitempty"`
	// PcrHashAlgorithm Informational attribute that identifies the HASH algorithm that was used by TPM
	PcrHashAlgorithm *string `json:"pcrHashAlgorithm,omitempty"`
	// BootAppSecurityVersion The security version number of the Boot Application
	BootAppSecurityVersion *string `json:"bootAppSecurityVersion,omitempty"`
	// BootManagerSecurityVersion The security version number of the Boot Application
	BootManagerSecurityVersion *string `json:"bootManagerSecurityVersion,omitempty"`
	// TpmVersion The security version number of the Boot Application
	TpmVersion *string `json:"tpmVersion,omitempty"`
	// Pcr0 The measurement that is captured in PCR[0]
	Pcr0 *string `json:"pcr0,omitempty"`
	// SecureBootConfigurationPolicyFingerPrint Fingerprint of the Custom Secure Boot Configuration Policy
	SecureBootConfigurationPolicyFingerPrint *string `json:"secureBootConfigurationPolicyFingerPrint,omitempty"`
	// CodeIntegrityPolicy The Code Integrity policy that is controlling the security of the boot environment
	CodeIntegrityPolicy *string `json:"codeIntegrityPolicy,omitempty"`
	// BootRevisionListInfo The Boot Revision List that was loaded during initial boot on the attested device
	BootRevisionListInfo *string `json:"bootRevisionListInfo,omitempty"`
	// OperatingSystemRevListInfo The Operating System Revision List that was loaded during initial boot on the attested device
	OperatingSystemRevListInfo *string `json:"operatingSystemRevListInfo,omitempty"`
	// HealthStatusMismatchInfo This attribute appears if DHA-Service detects an integrity issue
	HealthStatusMismatchInfo *string `json:"healthStatusMismatchInfo,omitempty"`
	// HealthAttestationSupportedStatus This attribute indicates if DHA is supported for the device
	HealthAttestationSupportedStatus *string `json:"healthAttestationSupportedStatus,omitempty"`
}

// IDeviceHealthAttestationState interface type for deviceHealthAttestationState
type IDeviceHealthAttestationState interface {
	PDeviceHealthAttestationState() *DeviceHealthAttestationState
}

// PDeviceHealthAttestationState pointer method for deviceHealthAttestationState
func (p *DeviceHealthAttestationState) PDeviceHealthAttestationState() *DeviceHealthAttestationState {
	return p
}

// DeviceInstallState Contains properties for the installation state for a device.
type DeviceInstallState struct {
	Entity
	// DeviceName Device name.
	DeviceName *string `json:"deviceName,omitempty"`
	// DeviceId Device Id.
	DeviceId *string `json:"deviceId,omitempty"`
	// LastSyncDateTime Last sync date and time.
	LastSyncDateTime *time.Time `json:"lastSyncDateTime,omitempty"`
	// InstallState The install state of the eBook.
	InstallState *InstallState `json:"installState,omitempty"`
	// ErrorCode The error code for install failures.
	ErrorCode *string `json:"errorCode,omitempty"`
	// OsVersion OS Version.
	OsVersion *string `json:"osVersion,omitempty"`
	// OsDescription OS Description.
	OsDescription *string `json:"osDescription,omitempty"`
	// UserName Device User Name.
	UserName *string `json:"userName,omitempty"`
}

// IDeviceInstallState interface type for deviceInstallState
type IDeviceInstallState interface {
	PDeviceInstallState() *DeviceInstallState
}

// PDeviceInstallState pointer method for deviceInstallState
func (p *DeviceInstallState) PDeviceInstallState() *DeviceInstallState { return p }

// DeviceManagement Singleton entity that acts as a container for all device management functionality.
type DeviceManagement struct {
	Entity
	// Settings Account level settings.
	Settings *DeviceManagementSettings `json:"settings,omitempty"`
	// IntuneBrand intuneBrand contains data which is used in customizing the appearance of the Company Portal applications as well as the end user web portal.
	IntuneBrand *IntuneBrand `json:"intuneBrand,omitempty"`
	// SubscriptionState Tenant mobile device management subscription state.
	SubscriptionState *DeviceManagementSubscriptionState `json:"subscriptionState,omitempty"`
}

// IDeviceManagement interface type for deviceManagement
type IDeviceManagement interface {
	PDeviceManagement() *DeviceManagement
}

// PDeviceManagement pointer method for deviceManagement
func (p *DeviceManagement) PDeviceManagement() *DeviceManagement { return p }

// DeviceManagementExchangeConnector Entity which represents a connection to an Exchange environment.
type DeviceManagementExchangeConnector struct {
	Entity
	// LastSyncDateTime Last sync time for the Exchange Connector
	LastSyncDateTime *time.Time `json:"lastSyncDateTime,omitempty"`
	// Status Exchange Connector Status
	Status *DeviceManagementExchangeConnectorStatus `json:"status,omitempty"`
	// PrimarySmtpAddress Email address used to configure the Service To Service Exchange Connector.
	PrimarySmtpAddress *string `json:"primarySmtpAddress,omitempty"`
	// ServerName The name of the Exchange server.
	ServerName *string `json:"serverName,omitempty"`
	// ConnectorServerName The name of the server hosting the Exchange Connector.
	ConnectorServerName *string `json:"connectorServerName,omitempty"`
	// ExchangeConnectorType The type of Exchange Connector Configured.
	ExchangeConnectorType *DeviceManagementExchangeConnectorType `json:"exchangeConnectorType,omitempty"`
	// Version The version of the ExchangeConnectorAgent
	Version *string `json:"version,omitempty"`
	// ExchangeAlias An alias assigned to the Exchange server
	ExchangeAlias *string `json:"exchangeAlias,omitempty"`
	// ExchangeOrganization Exchange Organization to the Exchange server
	ExchangeOrganization *string `json:"exchangeOrganization,omitempty"`
}

// IDeviceManagementExchangeConnector interface type for deviceManagementExchangeConnector
type IDeviceManagementExchangeConnector interface {
	PDeviceManagementExchangeConnector() *DeviceManagementExchangeConnector
}

// PDeviceManagementExchangeConnector pointer method for deviceManagementExchangeConnector
func (p *DeviceManagementExchangeConnector) PDeviceManagementExchangeConnector() *DeviceManagementExchangeConnector {
	return p
}

// DeviceManagementPartner Entity which represents a connection to device management partner.
type DeviceManagementPartner struct {
	Entity
	// LastHeartbeatDateTime Timestamp of last heartbeat after admin enabled option Connect to Device management Partner
	LastHeartbeatDateTime *time.Time `json:"lastHeartbeatDateTime,omitempty"`
	// PartnerState Partner state of this tenant
	PartnerState *DeviceManagementPartnerTenantState `json:"partnerState,omitempty"`
	// PartnerAppType Partner App type
	PartnerAppType *DeviceManagementPartnerAppType `json:"partnerAppType,omitempty"`
	// SingleTenantAppId Partner Single tenant App id
	SingleTenantAppId *string `json:"singleTenantAppId,omitempty"`
	// DisplayName Partner display name
	DisplayName *string `json:"displayName,omitempty"`
	// IsConfigured Whether device management partner is configured or not
	IsConfigured *bool `json:"isConfigured,omitempty"`
	// WhenPartnerDevicesWillBeRemovedDateTime DateTime in UTC when PartnerDevices will be removed
	WhenPartnerDevicesWillBeRemovedDateTime *time.Time `json:"whenPartnerDevicesWillBeRemovedDateTime,omitempty"`
	// WhenPartnerDevicesWillBeMarkedAsNonCompliantDateTime DateTime in UTC when PartnerDevices will be marked as NonCompliant
	WhenPartnerDevicesWillBeMarkedAsNonCompliantDateTime *time.Time `json:"whenPartnerDevicesWillBeMarkedAsNonCompliantDateTime,omitempty"`
}

// IDeviceManagementPartner interface type for deviceManagementPartner
type IDeviceManagementPartner interface {
	PDeviceManagementPartner() *DeviceManagementPartner
}

// PDeviceManagementPartner pointer method for deviceManagementPartner
func (p *DeviceManagementPartner) PDeviceManagementPartner() *DeviceManagementPartner { return p }

// DeviceManagementSettings undocumented
type DeviceManagementSettings struct {
	// DeviceComplianceCheckinThresholdDays The number of days a device is allowed to go without checking in to remain compliant. Valid values 0 to 120
	DeviceComplianceCheckinThresholdDays *int `json:"deviceComplianceCheckinThresholdDays,omitempty"`
	// IsScheduledActionEnabled Is feature enabled or not for scheduled action for rule.
	IsScheduledActionEnabled *bool `json:"isScheduledActionEnabled,omitempty"`
	// SecureByDefault Device should be noncompliant when there is no compliance policy targeted when this is true
	SecureByDefault *bool `json:"secureByDefault,omitempty"`
}

// IDeviceManagementSettings interface type for deviceManagementSettings
type IDeviceManagementSettings interface {
	PDeviceManagementSettings() *DeviceManagementSettings
}

// PDeviceManagementSettings pointer method for deviceManagementSettings
func (p *DeviceManagementSettings) PDeviceManagementSettings() *DeviceManagementSettings { return p }

// DeviceManagementTroubleshootingEvent Event representing an general failure.
type DeviceManagementTroubleshootingEvent struct {
	Entity
	// EventDateTime Time when the event occurred .
	EventDateTime *time.Time `json:"eventDateTime,omitempty"`
	// CorrelationId Id used for tracing the failure in the service.
	CorrelationId *string `json:"correlationId,omitempty"`
}

// IDeviceManagementTroubleshootingEvent interface type for deviceManagementTroubleshootingEvent
type IDeviceManagementTroubleshootingEvent interface {
	PDeviceManagementTroubleshootingEvent() *DeviceManagementTroubleshootingEvent
}

// PDeviceManagementTroubleshootingEvent pointer method for deviceManagementTroubleshootingEvent
func (p *DeviceManagementTroubleshootingEvent) PDeviceManagementTroubleshootingEvent() *DeviceManagementTroubleshootingEvent {
	return p
}

// DeviceOperatingSystemSummary undocumented
type DeviceOperatingSystemSummary struct {
	// AndroidCount Number of android device count.
	AndroidCount *int `json:"androidCount,omitempty"`
	// IosCount Number of iOS device count.
	IosCount *int `json:"iosCount,omitempty"`
	// MacOSCount Number of Mac OS X device count.
	MacOSCount *int `json:"macOSCount,omitempty"`
	// WindowsMobileCount Number of Windows mobile device count.
	WindowsMobileCount *int `json:"windowsMobileCount,omitempty"`
	// WindowsCount Number of Windows device count.
	WindowsCount *int `json:"windowsCount,omitempty"`
	// UnknownCount Number of unknown device count.
	UnknownCount *int `json:"unknownCount,omitempty"`
}

// IDeviceOperatingSystemSummary interface type for deviceOperatingSystemSummary
type IDeviceOperatingSystemSummary interface {
	PDeviceOperatingSystemSummary() *DeviceOperatingSystemSummary
}

// PDeviceOperatingSystemSummary pointer method for deviceOperatingSystemSummary
func (p *DeviceOperatingSystemSummary) PDeviceOperatingSystemSummary() *DeviceOperatingSystemSummary {
	return p
}

// Diagnostic undocumented
type Diagnostic struct {
	// Message undocumented
	Message *string `json:"message,omitempty"`
	// Url undocumented
	Url *string `json:"url,omitempty"`
}

// IDiagnostic interface type for diagnostic
type IDiagnostic interface {
	PDiagnostic() *Diagnostic
}

// PDiagnostic pointer method for diagnostic
func (p *Diagnostic) PDiagnostic() *Diagnostic { return p }

// Directory undocumented
type Directory struct {
	Entity
}

// IDirectory interface type for directory
type IDirectory interface {
	PDirectory() *Directory
}

// PDirectory pointer method for directory
func (p *Directory) PDirectory() *Directory { return p }

// DirectoryAudit undocumented
type DirectoryAudit struct {
	Entity
	// Category undocumented
	Category *string `json:"category,omitempty"`
	// CorrelationId undocumented
	CorrelationId *string `json:"correlationId,omitempty"`
	// Result undocumented
	Result *OperationResult `json:"result,omitempty"`
	// ResultReason undocumented
	ResultReason *string `json:"resultReason,omitempty"`
	// ActivityDisplayName undocumented
	ActivityDisplayName *string `json:"activityDisplayName,omitempty"`
	// ActivityDateTime undocumented
	ActivityDateTime *time.Time `json:"activityDateTime,omitempty"`
	// LoggedByService undocumented
	LoggedByService *string `json:"loggedByService,omitempty"`
	// OperationType undocumented
	OperationType *string `json:"operationType,omitempty"`
	// InitiatedBy undocumented
	InitiatedBy *AuditActivityInitiator `json:"initiatedBy,omitempty"`
	// TargetResources undocumented
	TargetResources []TargetResource `json:"targetResources,omitempty"`
	// AdditionalDetails undocumented
	AdditionalDetails []KeyValue `json:"additionalDetails,omitempty"`
}

// IDirectoryAudit interface type for directoryAudit
type IDirectoryAudit interface {
	PDirectoryAudit() *DirectoryAudit
}

// PDirectoryAudit pointer method for directoryAudit
func (p *DirectoryAudit) PDirectoryAudit() *DirectoryAudit { return p }

// DirectoryObject Represents an Azure Active Directory object. The directoryObject type is the base type for many other directory entity types.
type DirectoryObject struct {
	Entity
	// DeletedDateTime undocumented
	DeletedDateTime *time.Time `json:"deletedDateTime,omitempty"`
}

// IDirectoryObject interface type for directoryObject
type IDirectoryObject interface {
	PDirectoryObject() *DirectoryObject
}

// PDirectoryObject pointer method for directoryObject
func (p *DirectoryObject) PDirectoryObject() *DirectoryObject { return p }

// DirectoryObjectPartnerReference undocumented
type DirectoryObjectPartnerReference struct {
	DirectoryObject
	// Description undocumented
	Description *string `json:"description,omitempty"`
	// DisplayName undocumented
	DisplayName *string `json:"displayName,omitempty"`
	// ExternalPartnerTenantId undocumented
	ExternalPartnerTenantId *UUID `json:"externalPartnerTenantId,omitempty"`
	// ObjectType undocumented
	ObjectType *string `json:"objectType,omitempty"`
}

// IDirectoryObjectPartnerReference interface type for directoryObjectPartnerReference
type IDirectoryObjectPartnerReference interface {
	PDirectoryObjectPartnerReference() *DirectoryObjectPartnerReference
}

// PDirectoryObjectPartnerReference pointer method for directoryObjectPartnerReference
func (p *DirectoryObjectPartnerReference) PDirectoryObjectPartnerReference() *DirectoryObjectPartnerReference {
	return p
}

// DirectoryRole undocumented
type DirectoryRole struct {
	DirectoryObject
	// Description undocumented
	Description *string `json:"description,omitempty"`
	// DisplayName undocumented
	DisplayName *string `json:"displayName,omitempty"`
	// RoleTemplateId undocumented
	RoleTemplateId *string `json:"roleTemplateId,omitempty"`
}

// IDirectoryRole interface type for directoryRole
type IDirectoryRole interface {
	PDirectoryRole() *DirectoryRole
}

// PDirectoryRole pointer method for directoryRole
func (p *DirectoryRole) PDirectoryRole() *DirectoryRole { return p }

// DirectoryRoleTemplate undocumented
type DirectoryRoleTemplate struct {
	DirectoryObject
	// Description undocumented
	Description *string `json:"description,omitempty"`
	// DisplayName undocumented
	DisplayName *string `json:"displayName,omitempty"`
}

// IDirectoryRoleTemplate interface type for directoryRoleTemplate
type IDirectoryRoleTemplate interface {
	PDirectoryRoleTemplate() *DirectoryRoleTemplate
}

// PDirectoryRoleTemplate pointer method for directoryRoleTemplate
func (p *DirectoryRoleTemplate) PDirectoryRoleTemplate() *DirectoryRoleTemplate { return p }

// Domain undocumented
type Domain struct {
	Entity
	// AuthenticationType undocumented
	AuthenticationType *string `json:"authenticationType,omitempty"`
	// AvailabilityStatus undocumented
	AvailabilityStatus *string `json:"availabilityStatus,omitempty"`
	// IsAdminManaged undocumented
	IsAdminManaged *bool `json:"isAdminManaged,omitempty"`
	// IsDefault undocumented
	IsDefault *bool `json:"isDefault,omitempty"`
	// IsInitial undocumented
	IsInitial *bool `json:"isInitial,omitempty"`
	// IsRoot undocumented
	IsRoot *bool `json:"isRoot,omitempty"`
	// IsVerified undocumented
	IsVerified *bool `json:"isVerified,omitempty"`
	// PasswordNotificationWindowInDays undocumented
	PasswordNotificationWindowInDays *int `json:"passwordNotificationWindowInDays,omitempty"`
	// PasswordValidityPeriodInDays undocumented
	PasswordValidityPeriodInDays *int `json:"passwordValidityPeriodInDays,omitempty"`
	// SupportedServices undocumented
	SupportedServices []string `json:"supportedServices,omitempty"`
	// State undocumented
	State *DomainState `json:"state,omitempty"`
}

// IDomain interface type for domain
type IDomain interface {
	PDomain() *Domain
}

// PDomain pointer method for domain
func (p *Domain) PDomain() *Domain { return p }

// DomainDnsCnameRecord undocumented
type DomainDnsCnameRecord struct {
	DomainDnsRecord
	// CanonicalName undocumented
	CanonicalName *string `json:"canonicalName,omitempty"`
}

// IDomainDnsCnameRecord interface type for domainDnsCnameRecord
type IDomainDnsCnameRecord interface {
	PDomainDnsCnameRecord() *DomainDnsCnameRecord
}

// PDomainDnsCnameRecord pointer method for domainDnsCnameRecord
func (p *DomainDnsCnameRecord) PDomainDnsCnameRecord() *DomainDnsCnameRecord { return p }

// DomainDnsMxRecord undocumented
type DomainDnsMxRecord struct {
	DomainDnsRecord
	// MailExchange undocumented
	MailExchange *string `json:"mailExchange,omitempty"`
	// Preference undocumented
	Preference *int `json:"preference,omitempty"`
}

// IDomainDnsMxRecord interface type for domainDnsMxRecord
type IDomainDnsMxRecord interface {
	PDomainDnsMxRecord() *DomainDnsMxRecord
}

// PDomainDnsMxRecord pointer method for domainDnsMxRecord
func (p *DomainDnsMxRecord) PDomainDnsMxRecord() *DomainDnsMxRecord { return p }

// DomainDnsRecord undocumented
type DomainDnsRecord struct {
	Entity
	// IsOptional undocumented
	IsOptional *bool `json:"isOptional,omitempty"`
	// Label undocumented
	Label *string `json:"label,omitempty"`
	// RecordType undocumented
	RecordType *string `json:"recordType,omitempty"`
	// SupportedService undocumented
	SupportedService *string `json:"supportedService,omitempty"`
	// Ttl undocumented
	Ttl *int `json:"ttl,omitempty"`
}

// IDomainDnsRecord interface type for domainDnsRecord
type IDomainDnsRecord interface {
	PDomainDnsRecord() *DomainDnsRecord
}

// PDomainDnsRecord pointer method for domainDnsRecord
func (p *DomainDnsRecord) PDomainDnsRecord() *DomainDnsRecord { return p }

// DomainDnsSrvRecord undocumented
type DomainDnsSrvRecord struct {
	DomainDnsRecord
	// NameTarget undocumented
	NameTarget *string `json:"nameTarget,omitempty"`
	// Port undocumented
	Port *int `json:"port,omitempty"`
	// Priority undocumented
	Priority *int `json:"priority,omitempty"`
	// Protocol undocumented
	Protocol *string `json:"protocol,omitempty"`
	// Service undocumented
	Service *string `json:"service,omitempty"`
	// Weight undocumented
	Weight *int `json:"weight,omitempty"`
}

// IDomainDnsSrvRecord interface type for domainDnsSrvRecord
type IDomainDnsSrvRecord interface {
	PDomainDnsSrvRecord() *DomainDnsSrvRecord
}

// PDomainDnsSrvRecord pointer method for domainDnsSrvRecord
func (p *DomainDnsSrvRecord) PDomainDnsSrvRecord() *DomainDnsSrvRecord { return p }

// DomainDnsTxtRecord undocumented
type DomainDnsTxtRecord struct {
	DomainDnsRecord
	// Text undocumented
	Text *string `json:"text,omitempty"`
}

// IDomainDnsTxtRecord interface type for domainDnsTxtRecord
type IDomainDnsTxtRecord interface {
	PDomainDnsTxtRecord() *DomainDnsTxtRecord
}

// PDomainDnsTxtRecord pointer method for domainDnsTxtRecord
func (p *DomainDnsTxtRecord) PDomainDnsTxtRecord() *DomainDnsTxtRecord { return p }

// DomainDnsUnavailableRecord undocumented
type DomainDnsUnavailableRecord struct {
	DomainDnsRecord
	// Description undocumented
	Description *string `json:"description,omitempty"`
}

// IDomainDnsUnavailableRecord interface type for domainDnsUnavailableRecord
type IDomainDnsUnavailableRecord interface {
	PDomainDnsUnavailableRecord() *DomainDnsUnavailableRecord
}

// PDomainDnsUnavailableRecord pointer method for domainDnsUnavailableRecord
func (p *DomainDnsUnavailableRecord) PDomainDnsUnavailableRecord() *DomainDnsUnavailableRecord {
	return p
}

// DomainState undocumented
type DomainState struct {
	// Status undocumented
	Status *string `json:"status,omitempty"`
	// Operation undocumented
	Operation *string `json:"operation,omitempty"`
	// LastActionDateTime undocumented
	LastActionDateTime *time.Time `json:"lastActionDateTime,omitempty"`
}

// IDomainState interface type for domainState
type IDomainState interface {
	PDomainState() *DomainState
}

// PDomainState pointer method for domainState
func (p *DomainState) PDomainState() *DomainState { return p }

// Drive undocumented
type Drive struct {
	BaseItem
	// DriveType undocumented
	DriveType *string `json:"driveType,omitempty"`
	// Owner undocumented
	Owner *IdentitySet `json:"owner,omitempty"`
	// Quota undocumented
	Quota *Quota `json:"quota,omitempty"`
	// SharePointIds undocumented
	SharePointIds *SharepointIds `json:"sharePointIds,omitempty"`
	// System undocumented
	System *SystemFacet `json:"system,omitempty"`
}

// IDrive interface type for drive
type IDrive interface {
	PDrive() *Drive
}

// PDrive pointer method for drive
func (p *Drive) PDrive() *Drive { return p }

// DriveItem undocumented
type DriveItem struct {
	BaseItem
	// Audio undocumented
	Audio *Audio `json:"audio,omitempty"`
	// Content undocumented
	Content *Stream `json:"content,omitempty"`
	// CTag undocumented
	CTag *string `json:"cTag,omitempty"`
	// Deleted undocumented
	Deleted *Deleted `json:"deleted,omitempty"`
	// File undocumented
	File *File `json:"file,omitempty"`
	// FileSystemInfo undocumented
	FileSystemInfo *FileSystemInfo `json:"fileSystemInfo,omitempty"`
	// Folder undocumented
	Folder *Folder `json:"folder,omitempty"`
	// Image undocumented
	Image *Image `json:"image,omitempty"`
	// Location undocumented
	Location *GeoCoordinates `json:"location,omitempty"`
	// Package undocumented
	Package *Package `json:"package,omitempty"`
	// Photo undocumented
	Photo *Photo `json:"photo,omitempty"`
	// Publication undocumented
	Publication *PublicationFacet `json:"publication,omitempty"`
	// RemoteItem undocumented
	RemoteItem *RemoteItem `json:"remoteItem,omitempty"`
	// Root undocumented
	Root *Root `json:"root,omitempty"`
	// SearchResult undocumented
	SearchResult *SearchResult `json:"searchResult,omitempty"`
	// Shared undocumented
	Shared *Shared `json:"shared,omitempty"`
	// SharepointIds undocumented
	SharepointIds *SharepointIds `json:"sharepointIds,omitempty"`
	// Size undocumented
	Size *int `json:"size,omitempty"`
	// SpecialFolder undocumented
	SpecialFolder *SpecialFolder `json:"specialFolder,omitempty"`
	// Video undocumented
	Video *Video `json:"video,omitempty"`
	// WebDavUrl undocumented
	WebDavUrl *string `json:"webDavUrl,omitempty"`
}

// IDriveItem interface type for driveItem
type IDriveItem interface {
	PDriveItem() *DriveItem
}

// PDriveItem pointer method for driveItem
func (p *DriveItem) PDriveItem() *DriveItem { return p }

// DriveItemUploadableProperties undocumented
type DriveItemUploadableProperties struct {
	// Description undocumented
	Description *string `json:"description,omitempty"`
	// FileSystemInfo undocumented
	FileSystemInfo *FileSystemInfo `json:"fileSystemInfo,omitempty"`
	// Name undocumented
	Name *string `json:"name,omitempty"`
}

// IDriveItemUploadableProperties interface type for driveItemUploadableProperties
type IDriveItemUploadableProperties interface {
	PDriveItemUploadableProperties() *DriveItemUploadableProperties
}

// PDriveItemUploadableProperties pointer method for driveItemUploadableProperties
func (p *DriveItemUploadableProperties) PDriveItemUploadableProperties() *DriveItemUploadableProperties {
	return p
}

// DriveItemVersion undocumented
type DriveItemVersion struct {
	BaseItemVersion
	// Content undocumented
	Content *Stream `json:"content,omitempty"`
	// Size undocumented
	Size *int `json:"size,omitempty"`
}

// IDriveItemVersion interface type for driveItemVersion
type IDriveItemVersion interface {
	PDriveItemVersion() *DriveItemVersion
}

// PDriveItemVersion pointer method for driveItemVersion
func (p *DriveItemVersion) PDriveItemVersion() *DriveItemVersion { return p }

// DriveRecipient undocumented
type DriveRecipient struct {
	// Alias undocumented
	Alias *string `json:"alias,omitempty"`
	// Email undocumented
	Email *string `json:"email,omitempty"`
	// ObjectId undocumented
	ObjectId *string `json:"objectId,omitempty"`
}

// IDriveRecipient interface type for driveRecipient
type IDriveRecipient interface {
	PDriveRecipient() *DriveRecipient
}

// PDriveRecipient pointer method for driveRecipient
func (p *DriveRecipient) PDriveRecipient() *DriveRecipient { return p }

// EBookInstallSummary Contains properties for the installation summary of a book for a device.
type EBookInstallSummary struct {
	Entity
	// InstalledDeviceCount Number of Devices that have successfully installed this book.
	InstalledDeviceCount *int `json:"installedDeviceCount,omitempty"`
	// FailedDeviceCount Number of Devices that have failed to install this book.
	FailedDeviceCount *int `json:"failedDeviceCount,omitempty"`
	// NotInstalledDeviceCount Number of Devices that does not have this book installed.
	NotInstalledDeviceCount *int `json:"notInstalledDeviceCount,omitempty"`
	// InstalledUserCount Number of Users whose devices have all succeeded to install this book.
	InstalledUserCount *int `json:"installedUserCount,omitempty"`
	// FailedUserCount Number of Users that have 1 or more device that failed to install this book.
	FailedUserCount *int `json:"failedUserCount,omitempty"`
	// NotInstalledUserCount Number of Users that did not install this book.
	NotInstalledUserCount *int `json:"notInstalledUserCount,omitempty"`
}

// IEBookInstallSummary interface type for eBookInstallSummary
type IEBookInstallSummary interface {
	PEBookInstallSummary() *EBookInstallSummary
}

// PEBookInstallSummary pointer method for eBookInstallSummary
func (p *EBookInstallSummary) PEBookInstallSummary() *EBookInstallSummary { return p }

// EdgeSearchEngine undocumented
type EdgeSearchEngine struct {
	EdgeSearchEngineBase
	// EdgeSearchEngineType Allows IT admins to set a predefined default search engine for MDM-Controlled devices.
	EdgeSearchEngineType *EdgeSearchEngineType `json:"edgeSearchEngineType,omitempty"`
}

// IEdgeSearchEngine interface type for edgeSearchEngine
type IEdgeSearchEngine interface {
	PEdgeSearchEngine() *EdgeSearchEngine
}

// PEdgeSearchEngine pointer method for edgeSearchEngine
func (p *EdgeSearchEngine) PEdgeSearchEngine() *EdgeSearchEngine { return p }

// EdgeSearchEngineBase undocumented
type EdgeSearchEngineBase struct {
}

// IEdgeSearchEngineBase interface type for edgeSearchEngineBase
type IEdgeSearchEngineBase interface {
	PEdgeSearchEngineBase() *EdgeSearchEngineBase
}

// PEdgeSearchEngineBase pointer method for edgeSearchEngineBase
func (p *EdgeSearchEngineBase) PEdgeSearchEngineBase() *EdgeSearchEngineBase { return p }

// EdgeSearchEngineCustom undocumented
type EdgeSearchEngineCustom struct {
	EdgeSearchEngineBase
	// EdgeSearchEngineOpenSearchXmlUrl Points to a https link containing the OpenSearch xml file that contains, at minimum, the short name and the URL to the search Engine.
	EdgeSearchEngineOpenSearchXmlUrl *string `json:"edgeSearchEngineOpenSearchXmlUrl,omitempty"`
}

// IEdgeSearchEngineCustom interface type for edgeSearchEngineCustom
type IEdgeSearchEngineCustom interface {
	PEdgeSearchEngineCustom() *EdgeSearchEngineCustom
}

// PEdgeSearchEngineCustom pointer method for edgeSearchEngineCustom
func (p *EdgeSearchEngineCustom) PEdgeSearchEngineCustom() *EdgeSearchEngineCustom { return p }

// EditionUpgradeConfiguration Windows 10 Edition Upgrade configuration.
type EditionUpgradeConfiguration struct {
	DeviceConfiguration
	// LicenseType Edition Upgrade License Type.
	LicenseType *EditionUpgradeLicenseType `json:"licenseType,omitempty"`
	// TargetEdition Edition Upgrade Target Edition.
	TargetEdition *Windows10EditionType `json:"targetEdition,omitempty"`
	// License Edition Upgrade License File Content.
	License *string `json:"license,omitempty"`
	// ProductKey Edition Upgrade Product Key.
	ProductKey *string `json:"productKey,omitempty"`
}

// IEditionUpgradeConfiguration interface type for editionUpgradeConfiguration
type IEditionUpgradeConfiguration interface {
	PEditionUpgradeConfiguration() *EditionUpgradeConfiguration
}

// PEditionUpgradeConfiguration pointer method for editionUpgradeConfiguration
func (p *EditionUpgradeConfiguration) PEditionUpgradeConfiguration() *EditionUpgradeConfiguration {
	return p
}

// EducationClass undocumented
type EducationClass struct {
	Entity
	// DisplayName undocumented
	DisplayName *string `json:"displayName,omitempty"`
	// MailNickname undocumented
	MailNickname *string `json:"mailNickname,omitempty"`
	// Description undocumented
	Description *string `json:"description,omitempty"`
	// CreatedBy undocumented
	CreatedBy *IdentitySet `json:"createdBy,omitempty"`
	// ClassCode undocumented
	ClassCode *string `json:"classCode,omitempty"`
	// ExternalName undocumented
	ExternalName *string `json:"externalName,omitempty"`
	// ExternalId undocumented
	ExternalId *string `json:"externalId,omitempty"`
	// ExternalSource undocumented
	ExternalSource *EducationExternalSource `json:"externalSource,omitempty"`
	// Term undocumented
	Term *EducationTerm `json:"term,omitempty"`
}

// IEducationClass interface type for educationClass
type IEducationClass interface {
	PEducationClass() *EducationClass
}

// PEducationClass pointer method for educationClass
func (p *EducationClass) PEducationClass() *EducationClass { return p }

// EducationOrganization undocumented
type EducationOrganization struct {
	Entity
	// DisplayName undocumented
	DisplayName *string `json:"displayName,omitempty"`
	// Description undocumented
	Description *string `json:"description,omitempty"`
	// ExternalSource undocumented
	ExternalSource *EducationExternalSource `json:"externalSource,omitempty"`
}

// IEducationOrganization interface type for educationOrganization
type IEducationOrganization interface {
	PEducationOrganization() *EducationOrganization
}

// PEducationOrganization pointer method for educationOrganization
func (p *EducationOrganization) PEducationOrganization() *EducationOrganization { return p }

// EducationRoot undocumented
type EducationRoot struct {
	Entity
}

// IEducationRoot interface type for educationRoot
type IEducationRoot interface {
	PEducationRoot() *EducationRoot
}

// PEducationRoot pointer method for educationRoot
func (p *EducationRoot) PEducationRoot() *EducationRoot { return p }

// EducationSchool undocumented
type EducationSchool struct {
	EducationOrganization
	// PrincipalEmail undocumented
	PrincipalEmail *string `json:"principalEmail,omitempty"`
	// PrincipalName undocumented
	PrincipalName *string `json:"principalName,omitempty"`
	// ExternalPrincipalId undocumented
	ExternalPrincipalId *string `json:"externalPrincipalId,omitempty"`
	// LowestGrade undocumented
	LowestGrade *string `json:"lowestGrade,omitempty"`
	// HighestGrade undocumented
	HighestGrade *string `json:"highestGrade,omitempty"`
	// SchoolNumber undocumented
	SchoolNumber *string `json:"schoolNumber,omitempty"`
	// ExternalId undocumented
	ExternalId *string `json:"externalId,omitempty"`
	// Phone undocumented
	Phone *string `json:"phone,omitempty"`
	// Fax undocumented
	Fax *string `json:"fax,omitempty"`
	// CreatedBy undocumented
	CreatedBy *IdentitySet `json:"createdBy,omitempty"`
	// Address undocumented
	Address *PhysicalAddress `json:"address,omitempty"`
}

// IEducationSchool interface type for educationSchool
type IEducationSchool interface {
	PEducationSchool() *EducationSchool
}

// PEducationSchool pointer method for educationSchool
func (p *EducationSchool) PEducationSchool() *EducationSchool { return p }

// EducationStudent undocumented
type EducationStudent struct {
	// GraduationYear undocumented
	GraduationYear *string `json:"graduationYear,omitempty"`
	// Grade undocumented
	Grade *string `json:"grade,omitempty"`
	// BirthDate undocumented
	BirthDate *time.Time `json:"birthDate,omitempty"`
	// Gender undocumented
	Gender *EducationGender `json:"gender,omitempty"`
	// StudentNumber undocumented
	StudentNumber *string `json:"studentNumber,omitempty"`
	// ExternalId undocumented
	ExternalId *string `json:"externalId,omitempty"`
}

// IEducationStudent interface type for educationStudent
type IEducationStudent interface {
	PEducationStudent() *EducationStudent
}

// PEducationStudent pointer method for educationStudent
func (p *EducationStudent) PEducationStudent() *EducationStudent { return p }

// EducationTeacher undocumented
type EducationTeacher struct {
	// TeacherNumber undocumented
	TeacherNumber *string `json:"teacherNumber,omitempty"`
	// ExternalId undocumented
	ExternalId *string `json:"externalId,omitempty"`
}

// IEducationTeacher interface type for educationTeacher
type IEducationTeacher interface {
	PEducationTeacher() *EducationTeacher
}

// PEducationTeacher pointer method for educationTeacher
func (p *EducationTeacher) PEducationTeacher() *EducationTeacher { return p }

// EducationTerm undocumented
type EducationTerm struct {
	// ExternalId undocumented
	ExternalId *string `json:"externalId,omitempty"`
	// StartDate undocumented
	StartDate *time.Time `json:"startDate,omitempty"`
	// EndDate undocumented
	EndDate *time.Time `json:"endDate,omitempty"`
	// DisplayName undocumented
	DisplayName *string `json:"displayName,omitempty"`
}

// IEducationTerm interface type for educationTerm
type IEducationTerm interface {
	PEducationTerm() *EducationTerm
}

// PEducationTerm pointer method for educationTerm
func (p *EducationTerm) PEducationTerm() *EducationTerm { return p }

// EducationUser undocumented
type EducationUser struct {
	Entity
	// PrimaryRole undocumented
	PrimaryRole *EducationUserRole `json:"primaryRole,omitempty"`
	// MiddleName undocumented
	MiddleName *string `json:"middleName,omitempty"`
	// ExternalSource undocumented
	ExternalSource *EducationExternalSource `json:"externalSource,omitempty"`
	// ResidenceAddress undocumented
	ResidenceAddress *PhysicalAddress `json:"residenceAddress,omitempty"`
	// MailingAddress undocumented
	MailingAddress *PhysicalAddress `json:"mailingAddress,omitempty"`
	// Student undocumented
	Student *EducationStudent `json:"student,omitempty"`
	// Teacher undocumented
	Teacher *EducationTeacher `json:"teacher,omitempty"`
	// CreatedBy undocumented
	CreatedBy *IdentitySet `json:"createdBy,omitempty"`
	// AccountEnabled undocumented
	AccountEnabled *bool `json:"accountEnabled,omitempty"`
	// AssignedLicenses undocumented
	AssignedLicenses []AssignedLicense `json:"assignedLicenses,omitempty"`
	// AssignedPlans undocumented
	AssignedPlans []AssignedPlan `json:"assignedPlans,omitempty"`
	// BusinessPhones undocumented
	BusinessPhones []string `json:"businessPhones,omitempty"`
	// Department undocumented
	Department *string `json:"department,omitempty"`
	// DisplayName undocumented
	DisplayName *string `json:"displayName,omitempty"`
	// GivenName undocumented
	GivenName *string `json:"givenName,omitempty"`
	// Mail undocumented
	Mail *string `json:"mail,omitempty"`
	// MailNickname undocumented
	MailNickname *string `json:"mailNickname,omitempty"`
	// MobilePhone undocumented
	MobilePhone *string `json:"mobilePhone,omitempty"`
	// PasswordPolicies undocumented
	PasswordPolicies *string `json:"passwordPolicies,omitempty"`
	// PasswordProfile undocumented
	PasswordProfile *PasswordProfile `json:"passwordProfile,omitempty"`
	// OfficeLocation undocumented
	OfficeLocation *string `json:"officeLocation,omitempty"`
	// PreferredLanguage undocumented
	PreferredLanguage *string `json:"preferredLanguage,omitempty"`
	// ProvisionedPlans undocumented
	ProvisionedPlans []ProvisionedPlan `json:"provisionedPlans,omitempty"`
	// RefreshTokensValidFromDateTime undocumented
	RefreshTokensValidFromDateTime *time.Time `json:"refreshTokensValidFromDateTime,omitempty"`
	// ShowInAddressList undocumented
	ShowInAddressList *bool `json:"showInAddressList,omitempty"`
	// Surname undocumented
	Surname *string `json:"surname,omitempty"`
	// UsageLocation undocumented
	UsageLocation *string `json:"usageLocation,omitempty"`
	// UserPrincipalName undocumented
	UserPrincipalName *string `json:"userPrincipalName,omitempty"`
	// UserType undocumented
	UserType *string `json:"userType,omitempty"`
}

// IEducationUser interface type for educationUser
type IEducationUser interface {
	PEducationUser() *EducationUser
}

// PEducationUser pointer method for educationUser
func (p *EducationUser) PEducationUser() *EducationUser { return p }

// EmailAddress undocumented
type EmailAddress struct {
	// Name undocumented
	Name *string `json:"name,omitempty"`
	// Address undocumented
	Address *string `json:"address,omitempty"`
}

// IEmailAddress interface type for emailAddress
type IEmailAddress interface {
	PEmailAddress() *EmailAddress
}

// PEmailAddress pointer method for emailAddress
func (p *EmailAddress) PEmailAddress() *EmailAddress { return p }

// EnrollmentConfigurationAssignment undocumented
type EnrollmentConfigurationAssignment struct {
	Entity
	// Target undocumented
	Target *DeviceAndAppManagementAssignmentTarget `json:"target,omitempty"`
}

// IEnrollmentConfigurationAssignment interface type for enrollmentConfigurationAssignment
type IEnrollmentConfigurationAssignment interface {
	PEnrollmentConfigurationAssignment() *EnrollmentConfigurationAssignment
}

// PEnrollmentConfigurationAssignment pointer method for enrollmentConfigurationAssignment
func (p *EnrollmentConfigurationAssignment) PEnrollmentConfigurationAssignment() *EnrollmentConfigurationAssignment {
	return p
}

// EnrollmentTroubleshootingEvent Event representing an enrollment failure.
type EnrollmentTroubleshootingEvent struct {
	DeviceManagementTroubleshootingEvent
	// ManagedDeviceIdentifier Device identifier created or collected by Intune.
	ManagedDeviceIdentifier *string `json:"managedDeviceIdentifier,omitempty"`
	// OperatingSystem Operating System.
	OperatingSystem *string `json:"operatingSystem,omitempty"`
	// OsVersion OS Version.
	OsVersion *string `json:"osVersion,omitempty"`
	// UserId Identifier for the user that tried to enroll the device.
	UserId *string `json:"userId,omitempty"`
	// DeviceId Azure AD device identifier.
	DeviceId *string `json:"deviceId,omitempty"`
	// EnrollmentType Type of the enrollment.
	EnrollmentType *DeviceEnrollmentType `json:"enrollmentType,omitempty"`
	// FailureCategory Highlevel failure category.
	FailureCategory *DeviceEnrollmentFailureReason `json:"failureCategory,omitempty"`
	// FailureReason Detailed failure reason.
	FailureReason *string `json:"failureReason,omitempty"`
}

// IEnrollmentTroubleshootingEvent interface type for enrollmentTroubleshootingEvent
type IEnrollmentTroubleshootingEvent interface {
	PEnrollmentTroubleshootingEvent() *EnrollmentTroubleshootingEvent
}

// PEnrollmentTroubleshootingEvent pointer method for enrollmentTroubleshootingEvent
func (p *EnrollmentTroubleshootingEvent) PEnrollmentTroubleshootingEvent() *EnrollmentTroubleshootingEvent {
	return p
}

// Entity undocumented
type Entity struct {
	// Id undocumented
	Id *string `json:"id,omitempty"`
}

// IEntity interface type for entity
type IEntity interface {
	PEntity() *Entity
}

// PEntity pointer method for entity
func (p *Entity) PEntity() *Entity { return p }

// Event undocumented
type Event struct {
	OutlookItem
	// OriginalStartTimeZone undocumented
	OriginalStartTimeZone *string `json:"originalStartTimeZone,omitempty"`
	// OriginalEndTimeZone undocumented
	OriginalEndTimeZone *string `json:"originalEndTimeZone,omitempty"`
	// ResponseStatus undocumented
	ResponseStatus *ResponseStatus `json:"responseStatus,omitempty"`
	// ICalUId undocumented
	ICalUId *string `json:"iCalUId,omitempty"`
	// ReminderMinutesBeforeStart undocumented
	ReminderMinutesBeforeStart *int `json:"reminderMinutesBeforeStart,omitempty"`
	// IsReminderOn undocumented
	IsReminderOn *bool `json:"isReminderOn,omitempty"`
	// HasAttachments undocumented
	HasAttachments *bool `json:"hasAttachments,omitempty"`
	// Subject undocumented
	Subject *string `json:"subject,omitempty"`
	// Body undocumented
	Body *ItemBody `json:"body,omitempty"`
	// BodyPreview undocumented
	BodyPreview *string `json:"bodyPreview,omitempty"`
	// Importance undocumented
	Importance *Importance `json:"importance,omitempty"`
	// Sensitivity undocumented
	Sensitivity *Sensitivity `json:"sensitivity,omitempty"`
	// Start undocumented
	Start *DateTimeTimeZone `json:"start,omitempty"`
	// OriginalStart undocumented
	OriginalStart *time.Time `json:"originalStart,omitempty"`
	// End undocumented
	End *DateTimeTimeZone `json:"end,omitempty"`
	// Location undocumented
	Location *Location `json:"location,omitempty"`
	// Locations undocumented
	Locations []Location `json:"locations,omitempty"`
	// IsAllDay undocumented
	IsAllDay *bool `json:"isAllDay,omitempty"`
	// IsCancelled undocumented
	IsCancelled *bool `json:"isCancelled,omitempty"`
	// IsOrganizer undocumented
	IsOrganizer *bool `json:"isOrganizer,omitempty"`
	// Recurrence undocumented
	Recurrence *PatternedRecurrence `json:"recurrence,omitempty"`
	// ResponseRequested undocumented
	ResponseRequested *bool `json:"responseRequested,omitempty"`
	// SeriesMasterId undocumented
	SeriesMasterId *string `json:"seriesMasterId,omitempty"`
	// ShowAs undocumented
	ShowAs *FreeBusyStatus `json:"showAs,omitempty"`
	// Type undocumented
	Type *EventType `json:"type,omitempty"`
	// Attendees undocumented
	Attendees []Attendee `json:"attendees,omitempty"`
	// Organizer undocumented
	Organizer *Recipient `json:"organizer,omitempty"`
	// WebLink undocumented
	WebLink *string `json:"webLink,omitempty"`
	// OnlineMeetingUrl undocumented
	OnlineMeetingUrl *string `json:"onlineMeetingUrl,omitempty"`
}

// IEvent interface type for event
type IEvent interface {
	PEvent() *Event
}

// PEvent pointer method for event
func (p *Event) PEvent() *Event { return p }

// EventMessage undocumented
type EventMessage struct {
	Message
	// MeetingMessageType undocumented
	MeetingMessageType *MeetingMessageType `json:"meetingMessageType,omitempty"`
}

// IEventMessage interface type for eventMessage
type IEventMessage interface {
	PEventMessage() *EventMessage
}

// PEventMessage pointer method for eventMessage
func (p *EventMessage) PEventMessage() *EventMessage { return p }

// ExclusionGroupAssignmentTarget undocumented
type ExclusionGroupAssignmentTarget struct {
	GroupAssignmentTarget
}

// IExclusionGroupAssignmentTarget interface type for exclusionGroupAssignmentTarget
type IExclusionGroupAssignmentTarget interface {
	PExclusionGroupAssignmentTarget() *ExclusionGroupAssignmentTarget
}

// PExclusionGroupAssignmentTarget pointer method for exclusionGroupAssignmentTarget
func (p *ExclusionGroupAssignmentTarget) PExclusionGroupAssignmentTarget() *ExclusionGroupAssignmentTarget {
	return p
}

// Extension undocumented
type Extension struct {
	Entity
}

// IExtension interface type for extension
type IExtension interface {
	PExtension() *Extension
}

// PExtension pointer method for extension
func (p *Extension) PExtension() *Extension { return p }

// ExtensionSchemaProperty undocumented
type ExtensionSchemaProperty struct {
	// Name undocumented
	Name *string `json:"name,omitempty"`
	// Type undocumented
	Type *string `json:"type,omitempty"`
}

// IExtensionSchemaProperty interface type for extensionSchemaProperty
type IExtensionSchemaProperty interface {
	PExtensionSchemaProperty() *ExtensionSchemaProperty
}

// PExtensionSchemaProperty pointer method for extensionSchemaProperty
func (p *ExtensionSchemaProperty) PExtensionSchemaProperty() *ExtensionSchemaProperty { return p }

// ExternalLink undocumented
type ExternalLink struct {
	// Href undocumented
	Href *string `json:"href,omitempty"`
}

// IExternalLink interface type for externalLink
type IExternalLink interface {
	PExternalLink() *ExternalLink
}

// PExternalLink pointer method for externalLink
func (p *ExternalLink) PExternalLink() *ExternalLink { return p }

// FieldValueSet undocumented
type FieldValueSet struct {
	Entity
}

// IFieldValueSet interface type for fieldValueSet
type IFieldValueSet interface {
	PFieldValueSet() *FieldValueSet
}

// PFieldValueSet pointer method for fieldValueSet
func (p *FieldValueSet) PFieldValueSet() *FieldValueSet { return p }

// File undocumented
type File struct {
	// Hashes undocumented
	Hashes *Hashes `json:"hashes,omitempty"`
	// MimeType undocumented
	MimeType *string `json:"mimeType,omitempty"`
	// ProcessingMetadata undocumented
	ProcessingMetadata *bool `json:"processingMetadata,omitempty"`
}

// IFile interface type for file
type IFile interface {
	PFile() *File
}

// PFile pointer method for file
func (p *File) PFile() *File { return p }

// FileAttachment undocumented
type FileAttachment struct {
	Attachment
	// ContentId undocumented
	ContentId *string `json:"contentId,omitempty"`
	// ContentLocation undocumented
	ContentLocation *string `json:"contentLocation,omitempty"`
	// ContentBytes undocumented
	ContentBytes *Binary `json:"contentBytes,omitempty"`
}

// IFileAttachment interface type for fileAttachment
type IFileAttachment interface {
	PFileAttachment() *FileAttachment
}

// PFileAttachment pointer method for fileAttachment
func (p *FileAttachment) PFileAttachment() *FileAttachment { return p }

// FileEncryptionInfo undocumented
type FileEncryptionInfo struct {
	// EncryptionKey The key used to encrypt the file content.
	EncryptionKey *Binary `json:"encryptionKey,omitempty"`
	// InitializationVector The initialization vector used for the encryption algorithm.
	InitializationVector *Binary `json:"initializationVector,omitempty"`
	// Mac The hash of the encrypted file content + IV (content hash).
	Mac *Binary `json:"mac,omitempty"`
	// MacKey The key used to get mac.
	MacKey *Binary `json:"macKey,omitempty"`
	// ProfileIdentifier The the profile identifier.
	ProfileIdentifier *string `json:"profileIdentifier,omitempty"`
	// FileDigest The file digest prior to encryption.
	FileDigest *Binary `json:"fileDigest,omitempty"`
	// FileDigestAlgorithm The file digest algorithm.
	FileDigestAlgorithm *string `json:"fileDigestAlgorithm,omitempty"`
}

// IFileEncryptionInfo interface type for fileEncryptionInfo
type IFileEncryptionInfo interface {
	PFileEncryptionInfo() *FileEncryptionInfo
}

// PFileEncryptionInfo pointer method for fileEncryptionInfo
func (p *FileEncryptionInfo) PFileEncryptionInfo() *FileEncryptionInfo { return p }

// FileHash undocumented
type FileHash struct {
	// HashType undocumented
	HashType *FileHashType `json:"hashType,omitempty"`
	// HashValue undocumented
	HashValue *string `json:"hashValue,omitempty"`
}

// IFileHash interface type for fileHash
type IFileHash interface {
	PFileHash() *FileHash
}

// PFileHash pointer method for fileHash
func (p *FileHash) PFileHash() *FileHash { return p }

// FileSecurityState undocumented
type FileSecurityState struct {
	// FileHash undocumented
	FileHash *FileHash `json:"fileHash,omitempty"`
	// Name undocumented
	Name *string `json:"name,omitempty"`
	// Path undocumented
	Path *string `json:"path,omitempty"`
	// RiskScore undocumented
	RiskScore *string `json:"riskScore,omitempty"`
}

// IFileSecurityState interface type for fileSecurityState
type IFileSecurityState interface {
	PFileSecurityState() *FileSecurityState
}

// PFileSecurityState pointer method for fileSecurityState
func (p *FileSecurityState) PFileSecurityState() *FileSecurityState { return p }

// FileSystemInfo undocumented
type FileSystemInfo struct {
	// CreatedDateTime undocumented
	CreatedDateTime *time.Time `json:"createdDateTime,omitempty"`
	// LastAccessedDateTime undocumented
	LastAccessedDateTime *time.Time `json:"lastAccessedDateTime,omitempty"`
	// LastModifiedDateTime undocumented
	LastModifiedDateTime *time.Time `json:"lastModifiedDateTime,omitempty"`
}

// IFileSystemInfo interface type for fileSystemInfo
type IFileSystemInfo interface {
	PFileSystemInfo() *FileSystemInfo
}

// PFileSystemInfo pointer method for fileSystemInfo
func (p *FileSystemInfo) PFileSystemInfo() *FileSystemInfo { return p }

// Folder undocumented
type Folder struct {
	// ChildCount undocumented
	ChildCount *int `json:"childCount,omitempty"`
	// View undocumented
	View *FolderView `json:"view,omitempty"`
}

// IFolder interface type for folder
type IFolder interface {
	PFolder() *Folder
}

// PFolder pointer method for folder
func (p *Folder) PFolder() *Folder { return p }

// FolderView undocumented
type FolderView struct {
	// SortBy undocumented
	SortBy *string `json:"sortBy,omitempty"`
	// SortOrder undocumented
	SortOrder *string `json:"sortOrder,omitempty"`
	// ViewType undocumented
	ViewType *string `json:"viewType,omitempty"`
}

// IFolderView interface type for folderView
type IFolderView interface {
	PFolderView() *FolderView
}

// PFolderView pointer method for folderView
func (p *FolderView) PFolderView() *FolderView { return p }

// FollowupFlag undocumented
type FollowupFlag struct {
	// CompletedDateTime undocumented
	CompletedDateTime *DateTimeTimeZone `json:"completedDateTime,omitempty"`
	// DueDateTime undocumented
	DueDateTime *DateTimeTimeZone `json:"dueDateTime,omitempty"`
	// StartDateTime undocumented
	StartDateTime *DateTimeTimeZone `json:"startDateTime,omitempty"`
	// FlagStatus undocumented
	FlagStatus *FollowupFlagStatus `json:"flagStatus,omitempty"`
}

// IFollowupFlag interface type for followupFlag
type IFollowupFlag interface {
	PFollowupFlag() *FollowupFlag
}

// PFollowupFlag pointer method for followupFlag
func (p *FollowupFlag) PFollowupFlag() *FollowupFlag { return p }

// FreeBusyError undocumented
type FreeBusyError struct {
	// Message undocumented
	Message *string `json:"message,omitempty"`
	// ResponseCode undocumented
	ResponseCode *string `json:"responseCode,omitempty"`
}

// IFreeBusyError interface type for freeBusyError
type IFreeBusyError interface {
	PFreeBusyError() *FreeBusyError
}

// PFreeBusyError pointer method for freeBusyError
func (p *FreeBusyError) PFreeBusyError() *FreeBusyError { return p }

// GenericError undocumented
type GenericError struct {
	// Message undocumented
	Message *string `json:"message,omitempty"`
	// Code undocumented
	Code *string `json:"code,omitempty"`
}

// IGenericError interface type for genericError
type IGenericError interface {
	PGenericError() *GenericError
}

// PGenericError pointer method for genericError
func (p *GenericError) PGenericError() *GenericError { return p }

// GeoCoordinates undocumented
type GeoCoordinates struct {
	// Altitude undocumented
	Altitude *float64 `json:"altitude,omitempty"`
	// Latitude undocumented
	Latitude *float64 `json:"latitude,omitempty"`
	// Longitude undocumented
	Longitude *float64 `json:"longitude,omitempty"`
}

// IGeoCoordinates interface type for geoCoordinates
type IGeoCoordinates interface {
	PGeoCoordinates() *GeoCoordinates
}

// PGeoCoordinates pointer method for geoCoordinates
func (p *GeoCoordinates) PGeoCoordinates() *GeoCoordinates { return p }

// Group undocumented
type Group struct {
	DirectoryObject
	// AssignedLicenses undocumented
	AssignedLicenses []AssignedLicense `json:"assignedLicenses,omitempty"`
	// Classification undocumented
	Classification *string `json:"classification,omitempty"`
	// CreatedDateTime undocumented
	CreatedDateTime *time.Time `json:"createdDateTime,omitempty"`
	// Description undocumented
	Description *string `json:"description,omitempty"`
	// DisplayName undocumented
	DisplayName *string `json:"displayName,omitempty"`
	// HasMembersWithLicenseErrors undocumented
	HasMembersWithLicenseErrors *bool `json:"hasMembersWithLicenseErrors,omitempty"`
	// GroupTypes undocumented
	GroupTypes []string `json:"groupTypes,omitempty"`
	// LicenseProcessingState undocumented
	LicenseProcessingState *LicenseProcessingState `json:"licenseProcessingState,omitempty"`
	// Mail undocumented
	Mail *string `json:"mail,omitempty"`
	// MailEnabled undocumented
	MailEnabled *bool `json:"mailEnabled,omitempty"`
	// MailNickname undocumented
	MailNickname *string `json:"mailNickname,omitempty"`
	// OnPremisesLastSyncDateTime undocumented
	OnPremisesLastSyncDateTime *time.Time `json:"onPremisesLastSyncDateTime,omitempty"`
	// OnPremisesProvisioningErrors undocumented
	OnPremisesProvisioningErrors []OnPremisesProvisioningError `json:"onPremisesProvisioningErrors,omitempty"`
	// OnPremisesSecurityIdentifier undocumented
	OnPremisesSecurityIdentifier *string `json:"onPremisesSecurityIdentifier,omitempty"`
	// OnPremisesSyncEnabled undocumented
	OnPremisesSyncEnabled *bool `json:"onPremisesSyncEnabled,omitempty"`
	// PreferredDataLocation undocumented
	PreferredDataLocation *string `json:"preferredDataLocation,omitempty"`
	// ProxyAddresses undocumented
	ProxyAddresses []string `json:"proxyAddresses,omitempty"`
	// RenewedDateTime undocumented
	RenewedDateTime *time.Time `json:"renewedDateTime,omitempty"`
	// SecurityEnabled undocumented
	SecurityEnabled *bool `json:"securityEnabled,omitempty"`
	// Visibility undocumented
	Visibility *string `json:"visibility,omitempty"`
	// AllowExternalSenders undocumented
	AllowExternalSenders *bool `json:"allowExternalSenders,omitempty"`
	// AutoSubscribeNewMembers undocumented
	AutoSubscribeNewMembers *bool `json:"autoSubscribeNewMembers,omitempty"`
	// IsSubscribedByMail undocumented
	IsSubscribedByMail *bool `json:"isSubscribedByMail,omitempty"`
	// UnseenCount undocumented
	UnseenCount *int `json:"unseenCount,omitempty"`
	// IsArchived undocumented
	IsArchived *bool `json:"isArchived,omitempty"`
}

// IGroup interface type for group
type IGroup interface {
	PGroup() *Group
}

// PGroup pointer method for group
func (p *Group) PGroup() *Group { return p }

// GroupAssignmentTarget undocumented
type GroupAssignmentTarget struct {
	DeviceAndAppManagementAssignmentTarget
	// GroupId The group Id that is the target of the assignment.
	GroupId *string `json:"groupId,omitempty"`
}

// IGroupAssignmentTarget interface type for groupAssignmentTarget
type IGroupAssignmentTarget interface {
	PGroupAssignmentTarget() *GroupAssignmentTarget
}

// PGroupAssignmentTarget pointer method for groupAssignmentTarget
func (p *GroupAssignmentTarget) PGroupAssignmentTarget() *GroupAssignmentTarget { return p }

// GroupLifecyclePolicy undocumented
type GroupLifecyclePolicy struct {
	Entity
	// GroupLifetimeInDays undocumented
	GroupLifetimeInDays *int `json:"groupLifetimeInDays,omitempty"`
	// ManagedGroupTypes undocumented
	ManagedGroupTypes *string `json:"managedGroupTypes,omitempty"`
	// AlternateNotificationEmails undocumented
	AlternateNotificationEmails *string `json:"alternateNotificationEmails,omitempty"`
}

// IGroupLifecyclePolicy interface type for groupLifecyclePolicy
type IGroupLifecyclePolicy interface {
	PGroupLifecyclePolicy() *GroupLifecyclePolicy
}

// PGroupLifecyclePolicy pointer method for groupLifecyclePolicy
func (p *GroupLifecyclePolicy) PGroupLifecyclePolicy() *GroupLifecyclePolicy { return p }

// GroupSetting undocumented
type GroupSetting struct {
	Entity
	// DisplayName undocumented
	DisplayName *string `json:"displayName,omitempty"`
	// TemplateId undocumented
	TemplateId *string `json:"templateId,omitempty"`
	// Values undocumented
	Values []SettingValue `json:"values,omitempty"`
}

// IGroupSetting interface type for groupSetting
type IGroupSetting interface {
	PGroupSetting() *GroupSetting
}

// PGroupSetting pointer method for groupSetting
func (p *GroupSetting) PGroupSetting() *GroupSetting { return p }

// GroupSettingTemplate undocumented
type GroupSettingTemplate struct {
	DirectoryObject
	// DisplayName undocumented
	DisplayName *string `json:"displayName,omitempty"`
	// Description undocumented
	Description *string `json:"description,omitempty"`
	// Values undocumented
	Values []SettingTemplateValue `json:"values,omitempty"`
}

// IGroupSettingTemplate interface type for groupSettingTemplate
type IGroupSettingTemplate interface {
	PGroupSettingTemplate() *GroupSettingTemplate
}

// PGroupSettingTemplate pointer method for groupSettingTemplate
func (p *GroupSettingTemplate) PGroupSettingTemplate() *GroupSettingTemplate { return p }

// Hashes undocumented
type Hashes struct {
	// Crc32Hash undocumented
	Crc32Hash *string `json:"crc32Hash,omitempty"`
	// QuickXorHash undocumented
	QuickXorHash *string `json:"quickXorHash,omitempty"`
	// Sha1Hash undocumented
	Sha1Hash *string `json:"sha1Hash,omitempty"`
}

// IHashes interface type for hashes
type IHashes interface {
	PHashes() *Hashes
}

// PHashes pointer method for hashes
func (p *Hashes) PHashes() *Hashes { return p }

// HostSecurityState undocumented
type HostSecurityState struct {
	// Fqdn undocumented
	Fqdn *string `json:"fqdn,omitempty"`
	// IsAzureAdJoined undocumented
	IsAzureAdJoined *bool `json:"isAzureAdJoined,omitempty"`
	// IsAzureAdRegistered undocumented
	IsAzureAdRegistered *bool `json:"isAzureAdRegistered,omitempty"`
	// IsHybridAzureDomainJoined undocumented
	IsHybridAzureDomainJoined *bool `json:"isHybridAzureDomainJoined,omitempty"`
	// NetBiosName undocumented
	NetBiosName *string `json:"netBiosName,omitempty"`
	// Os undocumented
	Os *string `json:"os,omitempty"`
	// PrivateIpAddress undocumented
	PrivateIpAddress *string `json:"privateIpAddress,omitempty"`
	// PublicIpAddress undocumented
	PublicIpAddress *string `json:"publicIpAddress,omitempty"`
	// RiskScore undocumented
	RiskScore *string `json:"riskScore,omitempty"`
}

// IHostSecurityState interface type for hostSecurityState
type IHostSecurityState interface {
	PHostSecurityState() *HostSecurityState
}

// PHostSecurityState pointer method for hostSecurityState
func (p *HostSecurityState) PHostSecurityState() *HostSecurityState { return p }

// IPv4Range undocumented
type IPv4Range struct {
	IpRange
	// LowerAddress Lower address.
	LowerAddress *string `json:"lowerAddress,omitempty"`
	// UpperAddress Upper address.
	UpperAddress *string `json:"upperAddress,omitempty"`
}

// IIPv4Range interface type for iPv4Range
type IIPv4Range interface {
	PIPv4Range() *IPv4Range
}

// PIPv4Range pointer method for iPv4Range
func (p *IPv4Range) PIPv4Range() *IPv4Range { return p }

// IPv6Range undocumented
type IPv6Range struct {
	IpRange
	// LowerAddress Lower address
	LowerAddress *string `json:"lowerAddress,omitempty"`
	// UpperAddress Upper address
	UpperAddress *string `json:"upperAddress,omitempty"`
}

// IIPv6Range interface type for iPv6Range
type IIPv6Range interface {
	PIPv6Range() *IPv6Range
}

// PIPv6Range pointer method for iPv6Range
func (p *IPv6Range) PIPv6Range() *IPv6Range { return p }

// Identity undocumented
type Identity struct {
	// DisplayName undocumented
	DisplayName *string `json:"displayName,omitempty"`
	// Id undocumented
	Id *string `json:"id,omitempty"`
}

// IIdentity interface type for identity
type IIdentity interface {
	PIdentity() *Identity
}

// PIdentity pointer method for identity
func (p *Identity) PIdentity() *Identity { return p }

// IdentityProvider undocumented
type IdentityProvider struct {
	Entity
	// Type undocumented
	Type *string `json:"type,omitempty"`
	// Name undocumented
	Name *string `json:"name,omitempty"`
	// ClientId undocumented
	ClientId *string `json:"clientId,omitempty"`
	// ClientSecret undocumented
	ClientSecret *string `json:"clientSecret,omitempty"`
}

// IIdentityProvider interface type for identityProvider
type IIdentityProvider interface {
	PIdentityProvider() *IdentityProvider
}

// PIdentityProvider pointer method for identityProvider
func (p *IdentityProvider) PIdentityProvider() *IdentityProvider { return p }

// IdentitySet undocumented
type IdentitySet struct {
	// Application undocumented
	Application *Identity `json:"application,omitempty"`
	// Device undocumented
	Device *Identity `json:"device,omitempty"`
	// User undocumented
	User *Identity `json:"user,omitempty"`
}

// IIdentitySet interface type for identitySet
type IIdentitySet interface {
	PIdentitySet() *IdentitySet
}

// PIdentitySet pointer method for identitySet
func (p *IdentitySet) PIdentitySet() *IdentitySet { return p }

// Image undocumented
type Image struct {
	// Height undocumented
	Height *int `json:"height,omitempty"`
	// Width undocumented
	Width *int `json:"width,omitempty"`
}

// IImage interface type for image
type IImage interface {
	PImage() *Image
}

// PImage pointer method for image
func (p *Image) PImage() *Image { return p }

// ImageInfo undocumented
type ImageInfo struct {
	// IconUrl undocumented
	IconUrl *string `json:"iconUrl,omitempty"`
	// AlternativeText undocumented
	AlternativeText *string `json:"alternativeText,omitempty"`
	// AlternateText undocumented
	AlternateText *string `json:"alternateText,omitempty"`
	// AddImageQuery undocumented
	AddImageQuery *bool `json:"addImageQuery,omitempty"`
}

// IImageInfo interface type for imageInfo
type IImageInfo interface {
	PImageInfo() *ImageInfo
}

// PImageInfo pointer method for imageInfo
func (p *ImageInfo) PImageInfo() *ImageInfo { return p }

// IncompleteData undocumented
type IncompleteData struct {
	// MissingDataBeforeDateTime undocumented
	MissingDataBeforeDateTime *time.Time `json:"missingDataBeforeDateTime,omitempty"`
	// WasThrottled undocumented
	WasThrottled *bool `json:"wasThrottled,omitempty"`
}

// IIncompleteData interface type for incompleteData
type IIncompleteData interface {
	PIncompleteData() *IncompleteData
}

// PIncompleteData pointer method for incompleteData
func (p *IncompleteData) PIncompleteData() *IncompleteData { return p }

// InferenceClassification undocumented
type InferenceClassification struct {
	Entity
}

// IInferenceClassification interface type for inferenceClassification
type IInferenceClassification interface {
	PInferenceClassification() *InferenceClassification
}

// PInferenceClassification pointer method for inferenceClassification
func (p *InferenceClassification) PInferenceClassification() *InferenceClassification { return p }

// InferenceClassificationOverride undocumented
type InferenceClassificationOverride struct {
	Entity
	// ClassifyAs undocumented
	ClassifyAs *InferenceClassificationType `json:"classifyAs,omitempty"`
	// SenderEmailAddress undocumented
	SenderEmailAddress *EmailAddress `json:"senderEmailAddress,omitempty"`
}

// IInferenceClassificationOverride interface type for inferenceClassificationOverride
type IInferenceClassificationOverride interface {
	PInferenceClassificationOverride() *InferenceClassificationOverride
}

// PInferenceClassificationOverride pointer method for inferenceClassificationOverride
func (p *InferenceClassificationOverride) PInferenceClassificationOverride() *InferenceClassificationOverride {
	return p
}

// InsightIdentity undocumented
type InsightIdentity struct {
	// DisplayName undocumented
	DisplayName *string `json:"displayName,omitempty"`
	// Id undocumented
	Id *string `json:"id,omitempty"`
	// Address undocumented
	Address *string `json:"address,omitempty"`
}

// IInsightIdentity interface type for insightIdentity
type IInsightIdentity interface {
	PInsightIdentity() *InsightIdentity
}

// PInsightIdentity pointer method for insightIdentity
func (p *InsightIdentity) PInsightIdentity() *InsightIdentity { return p }

// InternetMessageHeader undocumented
type InternetMessageHeader struct {
	// Name undocumented
	Name *string `json:"name,omitempty"`
	// Value undocumented
	Value *string `json:"value,omitempty"`
}

// IInternetMessageHeader interface type for internetMessageHeader
type IInternetMessageHeader interface {
	PInternetMessageHeader() *InternetMessageHeader
}

// PInternetMessageHeader pointer method for internetMessageHeader
func (p *InternetMessageHeader) PInternetMessageHeader() *InternetMessageHeader { return p }

// IntuneBrand undocumented
type IntuneBrand struct {
	// DisplayName Company/organization name that is displayed to end users.
	DisplayName *string `json:"displayName,omitempty"`
	// ContactITName Name of the person/organization responsible for IT support.
	ContactITName *string `json:"contactITName,omitempty"`
	// ContactITPhoneNumber Phone number of the person/organization responsible for IT support.
	ContactITPhoneNumber *string `json:"contactITPhoneNumber,omitempty"`
	// ContactITEmailAddress Email address of the person/organization responsible for IT support.
	ContactITEmailAddress *string `json:"contactITEmailAddress,omitempty"`
	// ContactITNotes Text comments regarding the person/organization responsible for IT support.
	ContactITNotes *string `json:"contactITNotes,omitempty"`
	// PrivacyUrl URL to the company/organizations privacy policy.
	PrivacyUrl *string `json:"privacyUrl,omitempty"`
	// OnlineSupportSiteUrl URL to the company/organizations IT helpdesk site.
	OnlineSupportSiteUrl *string `json:"onlineSupportSiteUrl,omitempty"`
	// OnlineSupportSiteName Display name of the company/organizations IT helpdesk site.
	OnlineSupportSiteName *string `json:"onlineSupportSiteName,omitempty"`
	// ThemeColor Primary theme color used in the Company Portal applications and web portal.
	ThemeColor *RgbColor `json:"themeColor,omitempty"`
	// ShowLogo Boolean that represents whether the administrator-supplied logo images are shown or not shown.
	ShowLogo *bool `json:"showLogo,omitempty"`
	// LightBackgroundLogo Logo image displayed in Company Portal apps which have a light background behind the logo.
	LightBackgroundLogo *MimeContent `json:"lightBackgroundLogo,omitempty"`
	// DarkBackgroundLogo Logo image displayed in Company Portal apps which have a dark background behind the logo.
	DarkBackgroundLogo *MimeContent `json:"darkBackgroundLogo,omitempty"`
	// ShowNameNextToLogo Boolean that represents whether the administrator-supplied display name will be shown next to the logo image.
	ShowNameNextToLogo *bool `json:"showNameNextToLogo,omitempty"`
	// ShowDisplayNameNextToLogo Boolean that represents whether the administrator-supplied display name will be shown next to the logo image.
	ShowDisplayNameNextToLogo *bool `json:"showDisplayNameNextToLogo,omitempty"`
}

// IIntuneBrand interface type for intuneBrand
type IIntuneBrand interface {
	PIntuneBrand() *IntuneBrand
}

// PIntuneBrand pointer method for intuneBrand
func (p *IntuneBrand) PIntuneBrand() *IntuneBrand { return p }

// Invitation undocumented
type Invitation struct {
	Entity
	// InvitedUserDisplayName undocumented
	InvitedUserDisplayName *string `json:"invitedUserDisplayName,omitempty"`
	// InvitedUserType undocumented
	InvitedUserType *string `json:"invitedUserType,omitempty"`
	// InvitedUserEmailAddress undocumented
	InvitedUserEmailAddress *string `json:"invitedUserEmailAddress,omitempty"`
	// InvitedUserMessageInfo undocumented
	InvitedUserMessageInfo *InvitedUserMessageInfo `json:"invitedUserMessageInfo,omitempty"`
	// SendInvitationMessage undocumented
	SendInvitationMessage *bool `json:"sendInvitationMessage,omitempty"`
	// InviteRedirectUrl undocumented
	InviteRedirectUrl *string `json:"inviteRedirectUrl,omitempty"`
	// InviteRedeemUrl undocumented
	InviteRedeemUrl *string `json:"inviteRedeemUrl,omitempty"`
	// Status undocumented
	Status *string `json:"status,omitempty"`
}

// IInvitation interface type for invitation
type IInvitation interface {
	PInvitation() *Invitation
}

// PInvitation pointer method for invitation
func (p *Invitation) PInvitation() *Invitation { return p }

// InvitedUserMessageInfo undocumented
type InvitedUserMessageInfo struct {
	// CcRecipients undocumented
	CcRecipients []Recipient `json:"ccRecipients,omitempty"`
	// MessageLanguage undocumented
	MessageLanguage *string `json:"messageLanguage,omitempty"`
	// CustomizedMessageBody undocumented
	CustomizedMessageBody *string `json:"customizedMessageBody,omitempty"`
}

// IInvitedUserMessageInfo interface type for invitedUserMessageInfo
type IInvitedUserMessageInfo interface {
	PInvitedUserMessageInfo() *InvitedUserMessageInfo
}

// PInvitedUserMessageInfo pointer method for invitedUserMessageInfo
func (p *InvitedUserMessageInfo) PInvitedUserMessageInfo() *InvitedUserMessageInfo { return p }

// IosCertificateProfile Device Configuration.
type IosCertificateProfile struct {
	DeviceConfiguration
}

// IIosCertificateProfile interface type for iosCertificateProfile
type IIosCertificateProfile interface {
	PIosCertificateProfile() *IosCertificateProfile
}

// PIosCertificateProfile pointer method for iosCertificateProfile
func (p *IosCertificateProfile) PIosCertificateProfile() *IosCertificateProfile { return p }

// IosCompliancePolicy This class contains compliance settings for IOS.
type IosCompliancePolicy struct {
	DeviceCompliancePolicy
	// PasscodeBlockSimple Indicates whether or not to block simple passcodes.
	PasscodeBlockSimple *bool `json:"passcodeBlockSimple,omitempty"`
	// PasscodeExpirationDays Number of days before the passcode expires. Valid values 1 to 65535
	PasscodeExpirationDays *int `json:"passcodeExpirationDays,omitempty"`
	// PasscodeMinimumLength Minimum length of passcode. Valid values 4 to 14
	PasscodeMinimumLength *int `json:"passcodeMinimumLength,omitempty"`
	// PasscodeMinutesOfInactivityBeforeLock Minutes of inactivity before a passcode is required.
	PasscodeMinutesOfInactivityBeforeLock *int `json:"passcodeMinutesOfInactivityBeforeLock,omitempty"`
	// PasscodePreviousPasscodeBlockCount Number of previous passcodes to block. Valid values 1 to 24
	PasscodePreviousPasscodeBlockCount *int `json:"passcodePreviousPasscodeBlockCount,omitempty"`
	// PasscodeMinimumCharacterSetCount The number of character sets required in the password.
	PasscodeMinimumCharacterSetCount *int `json:"passcodeMinimumCharacterSetCount,omitempty"`
	// PasscodeRequiredType The required passcode type.
	PasscodeRequiredType *RequiredPasswordType `json:"passcodeRequiredType,omitempty"`
	// PasscodeRequired Indicates whether or not to require a passcode.
	PasscodeRequired *bool `json:"passcodeRequired,omitempty"`
	// OsMinimumVersion Minimum IOS version.
	OsMinimumVersion *string `json:"osMinimumVersion,omitempty"`
	// OsMaximumVersion Maximum IOS version.
	OsMaximumVersion *string `json:"osMaximumVersion,omitempty"`
	// SecurityBlockJailbrokenDevices Devices must not be jailbroken or rooted.
	SecurityBlockJailbrokenDevices *bool `json:"securityBlockJailbrokenDevices,omitempty"`
	// DeviceThreatProtectionEnabled Require that devices have enabled device threat protection .
	DeviceThreatProtectionEnabled *bool `json:"deviceThreatProtectionEnabled,omitempty"`
	// DeviceThreatProtectionRequiredSecurityLevel Require Mobile Threat Protection minimum risk level to report noncompliance.
	DeviceThreatProtectionRequiredSecurityLevel *DeviceThreatProtectionLevel `json:"deviceThreatProtectionRequiredSecurityLevel,omitempty"`
	// ManagedEmailProfileRequired Indicates whether or not to require a managed email profile.
	ManagedEmailProfileRequired *bool `json:"managedEmailProfileRequired,omitempty"`
}

// IIosCompliancePolicy interface type for iosCompliancePolicy
type IIosCompliancePolicy interface {
	PIosCompliancePolicy() *IosCompliancePolicy
}

// PIosCompliancePolicy pointer method for iosCompliancePolicy
func (p *IosCompliancePolicy) PIosCompliancePolicy() *IosCompliancePolicy { return p }

// IosCustomConfiguration This topic provides descriptions of the declared methods, properties and relationships exposed by the iosCustomConfiguration resource.
type IosCustomConfiguration struct {
	DeviceConfiguration
	// PayloadName Name that is displayed to the user.
	PayloadName *string `json:"payloadName,omitempty"`
	// PayloadFileName Payload file name (*.mobileconfig | *.xml).
	PayloadFileName *string `json:"payloadFileName,omitempty"`
	// Payload Payload. (UTF8 encoded byte array)
	Payload *Binary `json:"payload,omitempty"`
}

// IIosCustomConfiguration interface type for iosCustomConfiguration
type IIosCustomConfiguration interface {
	PIosCustomConfiguration() *IosCustomConfiguration
}

// PIosCustomConfiguration pointer method for iosCustomConfiguration
func (p *IosCustomConfiguration) PIosCustomConfiguration() *IosCustomConfiguration { return p }

// IosDeviceFeaturesConfiguration iOS Device Features Configuration Profile.
type IosDeviceFeaturesConfiguration struct {
	AppleDeviceFeaturesConfigurationBase
	// AssetTagTemplate Asset tag information for the device, displayed on the login window and lock screen.
	AssetTagTemplate *string `json:"assetTagTemplate,omitempty"`
	// LockScreenFootnote A footnote displayed on the login window and lock screen. Available in iOS 9.3.1 and later.
	LockScreenFootnote *string `json:"lockScreenFootnote,omitempty"`
	// HomeScreenDockIcons A list of app and folders to appear on the Home Screen Dock. This collection can contain a maximum of 500 elements.
	HomeScreenDockIcons []IosHomeScreenItem `json:"homeScreenDockIcons,omitempty"`
	// HomeScreenPages A list of pages on the Home Screen. This collection can contain a maximum of 500 elements.
	HomeScreenPages []IosHomeScreenPage `json:"homeScreenPages,omitempty"`
	// NotificationSettings Notification settings for each bundle id. Applicable to devices in supervised mode only (iOS 9.3 and later). This collection can contain a maximum of 500 elements.
	NotificationSettings []IosNotificationSettings `json:"notificationSettings,omitempty"`
}

// IIosDeviceFeaturesConfiguration interface type for iosDeviceFeaturesConfiguration
type IIosDeviceFeaturesConfiguration interface {
	PIosDeviceFeaturesConfiguration() *IosDeviceFeaturesConfiguration
}

// PIosDeviceFeaturesConfiguration pointer method for iosDeviceFeaturesConfiguration
func (p *IosDeviceFeaturesConfiguration) PIosDeviceFeaturesConfiguration() *IosDeviceFeaturesConfiguration {
	return p
}

// IosDeviceType undocumented
type IosDeviceType struct {
	// IPad Whether the app should run on iPads.
	IPad *bool `json:"iPad,omitempty"`
	// IPhoneAndIPod Whether the app should run on iPhones and iPods.
	IPhoneAndIPod *bool `json:"iPhoneAndIPod,omitempty"`
}

// IIosDeviceType interface type for iosDeviceType
type IIosDeviceType interface {
	PIosDeviceType() *IosDeviceType
}

// PIosDeviceType pointer method for iosDeviceType
func (p *IosDeviceType) PIosDeviceType() *IosDeviceType { return p }

// IosGeneralDeviceConfiguration This topic provides descriptions of the declared methods, properties and relationships exposed by the iosGeneralDeviceConfiguration resource.
type IosGeneralDeviceConfiguration struct {
	DeviceConfiguration
	// AccountBlockModification Indicates whether or not to allow account modification when the device is in supervised mode.
	AccountBlockModification *bool `json:"accountBlockModification,omitempty"`
	// ActivationLockAllowWhenSupervised Indicates whether or not to allow activation lock when the device is in the supervised mode.
	ActivationLockAllowWhenSupervised *bool `json:"activationLockAllowWhenSupervised,omitempty"`
	// AirDropBlocked Indicates whether or not to allow AirDrop when the device is in supervised mode.
	AirDropBlocked *bool `json:"airDropBlocked,omitempty"`
	// AirDropForceUnmanagedDropTarget Indicates whether or not to cause AirDrop to be considered an unmanaged drop target (iOS 9.0 and later).
	AirDropForceUnmanagedDropTarget *bool `json:"airDropForceUnmanagedDropTarget,omitempty"`
	// AirPlayForcePairingPasswordForOutgoingRequests Indicates whether or not to enforce all devices receiving AirPlay requests from this device to use a pairing password.
	AirPlayForcePairingPasswordForOutgoingRequests *bool `json:"airPlayForcePairingPasswordForOutgoingRequests,omitempty"`
	// AppleWatchBlockPairing Indicates whether or not to allow Apple Watch pairing when the device is in supervised mode (iOS 9.0 and later).
	AppleWatchBlockPairing *bool `json:"appleWatchBlockPairing,omitempty"`
	// AppleWatchForceWristDetection Indicates whether or not to force a paired Apple Watch to use Wrist Detection (iOS 8.2 and later).
	AppleWatchForceWristDetection *bool `json:"appleWatchForceWristDetection,omitempty"`
	// AppleNewsBlocked Indicates whether or not to block the user from using News when the device is in supervised mode (iOS 9.0 and later).
	AppleNewsBlocked *bool `json:"appleNewsBlocked,omitempty"`
	// AppsSingleAppModeList Gets or sets the list of iOS apps allowed to autonomously enter Single App Mode. Supervised only. iOS 7.0 and later. This collection can contain a maximum of 500 elements.
	AppsSingleAppModeList []AppListItem `json:"appsSingleAppModeList,omitempty"`
	// AppsVisibilityList List of apps in the visibility list (either visible/launchable apps list or hidden/unlaunchable apps list, controlled by AppsVisibilityListType) (iOS 9.3 and later). This collection can contain a maximum of 10000 elements.
	AppsVisibilityList []AppListItem `json:"appsVisibilityList,omitempty"`
	// AppsVisibilityListType Type of list that is in the AppsVisibilityList.
	AppsVisibilityListType *AppListType `json:"appsVisibilityListType,omitempty"`
	// AppStoreBlockAutomaticDownloads Indicates whether or not to block the automatic downloading of apps purchased on other devices when the device is in supervised mode (iOS 9.0 and later).
	AppStoreBlockAutomaticDownloads *bool `json:"appStoreBlockAutomaticDownloads,omitempty"`
	// AppStoreBlocked Indicates whether or not to block the user from using the App Store.
	AppStoreBlocked *bool `json:"appStoreBlocked,omitempty"`
	// AppStoreBlockInAppPurchases Indicates whether or not to block the user from making in app purchases.
	AppStoreBlockInAppPurchases *bool `json:"appStoreBlockInAppPurchases,omitempty"`
	// AppStoreBlockUIAppInstallation Indicates whether or not to block the App Store app, not restricting installation through Host apps. Applies to supervised mode only (iOS 9.0 and later).
	AppStoreBlockUIAppInstallation *bool `json:"appStoreBlockUIAppInstallation,omitempty"`
	// AppStoreRequirePassword Indicates whether or not to require a password when using the app store.
	AppStoreRequirePassword *bool `json:"appStoreRequirePassword,omitempty"`
	// BluetoothBlockModification Indicates whether or not to allow modification of Bluetooth settings when the device is in supervised mode (iOS 10.0 and later).
	BluetoothBlockModification *bool `json:"bluetoothBlockModification,omitempty"`
	// CameraBlocked Indicates whether or not to block the user from accessing the camera of the device.
	CameraBlocked *bool `json:"cameraBlocked,omitempty"`
	// CellularBlockDataRoaming Indicates whether or not to block data roaming.
	CellularBlockDataRoaming *bool `json:"cellularBlockDataRoaming,omitempty"`
	// CellularBlockGlobalBackgroundFetchWhileRoaming Indicates whether or not to block global background fetch while roaming.
	CellularBlockGlobalBackgroundFetchWhileRoaming *bool `json:"cellularBlockGlobalBackgroundFetchWhileRoaming,omitempty"`
	// CellularBlockPerAppDataModification Indicates whether or not to allow changes to cellular app data usage settings when the device is in supervised mode.
	CellularBlockPerAppDataModification *bool `json:"cellularBlockPerAppDataModification,omitempty"`
	// CellularBlockPersonalHotspot Indicates whether or not to block Personal Hotspot.
	CellularBlockPersonalHotspot *bool `json:"cellularBlockPersonalHotspot,omitempty"`
	// CellularBlockVoiceRoaming Indicates whether or not to block voice roaming.
	CellularBlockVoiceRoaming *bool `json:"cellularBlockVoiceRoaming,omitempty"`
	// CertificatesBlockUntrustedTlsCertificates Indicates whether or not to block untrusted TLS certificates.
	CertificatesBlockUntrustedTlsCertificates *bool `json:"certificatesBlockUntrustedTlsCertificates,omitempty"`
	// ClassroomAppBlockRemoteScreenObservation Indicates whether or not to allow remote screen observation by Classroom app when the device is in supervised mode (iOS 9.3 and later).
	ClassroomAppBlockRemoteScreenObservation *bool `json:"classroomAppBlockRemoteScreenObservation,omitempty"`
	// ClassroomAppForceUnpromptedScreenObservation Indicates whether or not to automatically give permission to the teacher of a managed course on the Classroom app to view a student's screen without prompting when the device is in supervised mode.
	ClassroomAppForceUnpromptedScreenObservation *bool `json:"classroomAppForceUnpromptedScreenObservation,omitempty"`
	// CompliantAppsList List of apps in the compliance (either allow list or block list, controlled by CompliantAppListType). This collection can contain a maximum of 10000 elements.
	CompliantAppsList []AppListItem `json:"compliantAppsList,omitempty"`
	// CompliantAppListType List that is in the AppComplianceList.
	CompliantAppListType *AppListType `json:"compliantAppListType,omitempty"`
	// ConfigurationProfileBlockChanges Indicates whether or not to block the user from installing configuration profiles and certificates interactively when the device is in supervised mode.
	ConfigurationProfileBlockChanges *bool `json:"configurationProfileBlockChanges,omitempty"`
	// DefinitionLookupBlocked Indicates whether or not to block definition lookup when the device is in supervised mode (iOS 8.1.3 and later ).
	DefinitionLookupBlocked *bool `json:"definitionLookupBlocked,omitempty"`
	// DeviceBlockEnableRestrictions Indicates whether or not to allow the user to enables restrictions in the device settings when the device is in supervised mode.
	DeviceBlockEnableRestrictions *bool `json:"deviceBlockEnableRestrictions,omitempty"`
	// DeviceBlockEraseContentAndSettings Indicates whether or not to allow the use of the 'Erase all content and settings' option on the device when the device is in supervised mode.
	DeviceBlockEraseContentAndSettings *bool `json:"deviceBlockEraseContentAndSettings,omitempty"`
	// DeviceBlockNameModification Indicates whether or not to allow device name modification when the device is in supervised mode (iOS 9.0 and later).
	DeviceBlockNameModification *bool `json:"deviceBlockNameModification,omitempty"`
	// DiagnosticDataBlockSubmission Indicates whether or not to block diagnostic data submission.
	DiagnosticDataBlockSubmission *bool `json:"diagnosticDataBlockSubmission,omitempty"`
	// DiagnosticDataBlockSubmissionModification Indicates whether or not to allow diagnostics submission settings modification when the device is in supervised mode (iOS 9.3.2 and later).
	DiagnosticDataBlockSubmissionModification *bool `json:"diagnosticDataBlockSubmissionModification,omitempty"`
	// DocumentsBlockManagedDocumentsInUnmanagedApps Indicates whether or not to block the user from viewing managed documents in unmanaged apps.
	DocumentsBlockManagedDocumentsInUnmanagedApps *bool `json:"documentsBlockManagedDocumentsInUnmanagedApps,omitempty"`
	// DocumentsBlockUnmanagedDocumentsInManagedApps Indicates whether or not to block the user from viewing unmanaged documents in managed apps.
	DocumentsBlockUnmanagedDocumentsInManagedApps *bool `json:"documentsBlockUnmanagedDocumentsInManagedApps,omitempty"`
	// EmailInDomainSuffixes An email address lacking a suffix that matches any of these strings will be considered out-of-domain.
	EmailInDomainSuffixes []string `json:"emailInDomainSuffixes,omitempty"`
	// EnterpriseAppBlockTrust Indicates whether or not to block the user from trusting an enterprise app.
	EnterpriseAppBlockTrust *bool `json:"enterpriseAppBlockTrust,omitempty"`
	// EnterpriseAppBlockTrustModification Indicates whether or not to block the user from modifying the enterprise app trust settings.
	EnterpriseAppBlockTrustModification *bool `json:"enterpriseAppBlockTrustModification,omitempty"`
	// FaceTimeBlocked Indicates whether or not to block the user from using FaceTime.
	FaceTimeBlocked *bool `json:"faceTimeBlocked,omitempty"`
	// FindMyFriendsBlocked Indicates whether or not to block Find My Friends when the device is in supervised mode.
	FindMyFriendsBlocked *bool `json:"findMyFriendsBlocked,omitempty"`
	// GamingBlockGameCenterFriends Indicates whether or not to block the user from having friends in Game Center.
	GamingBlockGameCenterFriends *bool `json:"gamingBlockGameCenterFriends,omitempty"`
	// GamingBlockMultiplayer Indicates whether or not to block the user from using multiplayer gaming.
	GamingBlockMultiplayer *bool `json:"gamingBlockMultiplayer,omitempty"`
	// GameCenterBlocked Indicates whether or not to block the user from using Game Center when the device is in supervised mode.
	GameCenterBlocked *bool `json:"gameCenterBlocked,omitempty"`
	// HostPairingBlocked indicates whether or not to allow host pairing to control the devices an iOS device can pair with when the iOS device is in supervised mode.
	HostPairingBlocked *bool `json:"hostPairingBlocked,omitempty"`
	// IBooksStoreBlocked Indicates whether or not to block the user from using the iBooks Store when the device is in supervised mode.
	IBooksStoreBlocked *bool `json:"iBooksStoreBlocked,omitempty"`
	// IBooksStoreBlockErotica Indicates whether or not to block the user from downloading media from the iBookstore that has been tagged as erotica.
	IBooksStoreBlockErotica *bool `json:"iBooksStoreBlockErotica,omitempty"`
	// ICloudBlockActivityContinuation Indicates whether or not to block  the the user from continuing work they started on iOS device to another iOS or macOS device.
	ICloudBlockActivityContinuation *bool `json:"iCloudBlockActivityContinuation,omitempty"`
	// ICloudBlockBackup Indicates whether or not to block iCloud backup.
	ICloudBlockBackup *bool `json:"iCloudBlockBackup,omitempty"`
	// ICloudBlockDocumentSync Indicates whether or not to block iCloud document sync.
	ICloudBlockDocumentSync *bool `json:"iCloudBlockDocumentSync,omitempty"`
	// ICloudBlockManagedAppsSync Indicates whether or not to block Managed Apps Cloud Sync.
	ICloudBlockManagedAppsSync *bool `json:"iCloudBlockManagedAppsSync,omitempty"`
	// ICloudBlockPhotoLibrary Indicates whether or not to block iCloud Photo Library.
	ICloudBlockPhotoLibrary *bool `json:"iCloudBlockPhotoLibrary,omitempty"`
	// ICloudBlockPhotoStreamSync Indicates whether or not to block iCloud Photo Stream Sync.
	ICloudBlockPhotoStreamSync *bool `json:"iCloudBlockPhotoStreamSync,omitempty"`
	// ICloudBlockSharedPhotoStream Indicates whether or not to block Shared Photo Stream.
	ICloudBlockSharedPhotoStream *bool `json:"iCloudBlockSharedPhotoStream,omitempty"`
	// ICloudRequireEncryptedBackup Indicates whether or not to require backups to iCloud be encrypted.
	ICloudRequireEncryptedBackup *bool `json:"iCloudRequireEncryptedBackup,omitempty"`
	// ITunesBlockExplicitContent Indicates whether or not to block the user from accessing explicit content in iTunes and the App Store.
	ITunesBlockExplicitContent *bool `json:"iTunesBlockExplicitContent,omitempty"`
	// ITunesBlockMusicService Indicates whether or not to block Music service and revert Music app to classic mode when the device is in supervised mode (iOS 9.3 and later and macOS 10.12 and later).
	ITunesBlockMusicService *bool `json:"iTunesBlockMusicService,omitempty"`
	// ITunesBlockRadio Indicates whether or not to block the user from using iTunes Radio when the device is in supervised mode (iOS 9.3 and later).
	ITunesBlockRadio *bool `json:"iTunesBlockRadio,omitempty"`
	// KeyboardBlockAutoCorrect Indicates whether or not to block keyboard auto-correction when the device is in supervised mode (iOS 8.1.3 and later).
	KeyboardBlockAutoCorrect *bool `json:"keyboardBlockAutoCorrect,omitempty"`
	// KeyboardBlockDictation Indicates whether or not to block the user from using dictation input when the device is in supervised mode.
	KeyboardBlockDictation *bool `json:"keyboardBlockDictation,omitempty"`
	// KeyboardBlockPredictive Indicates whether or not to block predictive keyboards when device is in supervised mode (iOS 8.1.3 and later).
	KeyboardBlockPredictive *bool `json:"keyboardBlockPredictive,omitempty"`
	// KeyboardBlockShortcuts Indicates whether or not to block keyboard shortcuts when the device is in supervised mode (iOS 9.0 and later).
	KeyboardBlockShortcuts *bool `json:"keyboardBlockShortcuts,omitempty"`
	// KeyboardBlockSpellCheck Indicates whether or not to block keyboard spell-checking when the device is in supervised mode (iOS 8.1.3 and later).
	KeyboardBlockSpellCheck *bool `json:"keyboardBlockSpellCheck,omitempty"`
	// KioskModeAllowAssistiveSpeak Indicates whether or not to allow assistive speak while in kiosk mode.
	KioskModeAllowAssistiveSpeak *bool `json:"kioskModeAllowAssistiveSpeak,omitempty"`
	// KioskModeAllowAssistiveTouchSettings Indicates whether or not to allow access to the Assistive Touch Settings while in kiosk mode.
	KioskModeAllowAssistiveTouchSettings *bool `json:"kioskModeAllowAssistiveTouchSettings,omitempty"`
	// KioskModeAllowAutoLock Indicates whether or not to allow device auto lock while in kiosk mode.
	KioskModeAllowAutoLock *bool `json:"kioskModeAllowAutoLock,omitempty"`
	// KioskModeAllowColorInversionSettings Indicates whether or not to allow access to the Color Inversion Settings while in kiosk mode.
	KioskModeAllowColorInversionSettings *bool `json:"kioskModeAllowColorInversionSettings,omitempty"`
	// KioskModeAllowRingerSwitch Indicates whether or not to allow use of the ringer switch while in kiosk mode.
	KioskModeAllowRingerSwitch *bool `json:"kioskModeAllowRingerSwitch,omitempty"`
	// KioskModeAllowScreenRotation Indicates whether or not to allow screen rotation while in kiosk mode.
	KioskModeAllowScreenRotation *bool `json:"kioskModeAllowScreenRotation,omitempty"`
	// KioskModeAllowSleepButton Indicates whether or not to allow use of the sleep button while in kiosk mode.
	KioskModeAllowSleepButton *bool `json:"kioskModeAllowSleepButton,omitempty"`
	// KioskModeAllowTouchscreen Indicates whether or not to allow use of the touchscreen while in kiosk mode.
	KioskModeAllowTouchscreen *bool `json:"kioskModeAllowTouchscreen,omitempty"`
	// KioskModeAllowVoiceOverSettings Indicates whether or not to allow access to the voice over settings while in kiosk mode.
	KioskModeAllowVoiceOverSettings *bool `json:"kioskModeAllowVoiceOverSettings,omitempty"`
	// KioskModeAllowVolumeButtons Indicates whether or not to allow use of the volume buttons while in kiosk mode.
	KioskModeAllowVolumeButtons *bool `json:"kioskModeAllowVolumeButtons,omitempty"`
	// KioskModeAllowZoomSettings Indicates whether or not to allow access to the zoom settings while in kiosk mode.
	KioskModeAllowZoomSettings *bool `json:"kioskModeAllowZoomSettings,omitempty"`
	// KioskModeAppStoreUrl URL in the app store to the app to use for kiosk mode. Use if KioskModeManagedAppId is not known.
	KioskModeAppStoreUrl *string `json:"kioskModeAppStoreUrl,omitempty"`
	// KioskModeBuiltInAppId ID for built-in apps to use for kiosk mode. Used when KioskModeManagedAppId and KioskModeAppStoreUrl are not set.
	KioskModeBuiltInAppId *string `json:"kioskModeBuiltInAppId,omitempty"`
	// KioskModeRequireAssistiveTouch Indicates whether or not to require assistive touch while in kiosk mode.
	KioskModeRequireAssistiveTouch *bool `json:"kioskModeRequireAssistiveTouch,omitempty"`
	// KioskModeRequireColorInversion Indicates whether or not to require color inversion while in kiosk mode.
	KioskModeRequireColorInversion *bool `json:"kioskModeRequireColorInversion,omitempty"`
	// KioskModeRequireMonoAudio Indicates whether or not to require mono audio while in kiosk mode.
	KioskModeRequireMonoAudio *bool `json:"kioskModeRequireMonoAudio,omitempty"`
	// KioskModeRequireVoiceOver Indicates whether or not to require voice over while in kiosk mode.
	KioskModeRequireVoiceOver *bool `json:"kioskModeRequireVoiceOver,omitempty"`
	// KioskModeRequireZoom Indicates whether or not to require zoom while in kiosk mode.
	KioskModeRequireZoom *bool `json:"kioskModeRequireZoom,omitempty"`
	// KioskModeManagedAppId Managed app id of the app to use for kiosk mode. If KioskModeManagedAppId is specified then KioskModeAppStoreUrl will be ignored.
	KioskModeManagedAppId *string `json:"kioskModeManagedAppId,omitempty"`
	// LockScreenBlockControlCenter Indicates whether or not to block the user from using control center on the lock screen.
	LockScreenBlockControlCenter *bool `json:"lockScreenBlockControlCenter,omitempty"`
	// LockScreenBlockNotificationView Indicates whether or not to block the user from using the notification view on the lock screen.
	LockScreenBlockNotificationView *bool `json:"lockScreenBlockNotificationView,omitempty"`
	// LockScreenBlockPassbook Indicates whether or not to block the user from using passbook when the device is locked.
	LockScreenBlockPassbook *bool `json:"lockScreenBlockPassbook,omitempty"`
	// LockScreenBlockTodayView Indicates whether or not to block the user from using the Today View on the lock screen.
	LockScreenBlockTodayView *bool `json:"lockScreenBlockTodayView,omitempty"`
	// MediaContentRatingAustralia Media content rating settings for Australia
	MediaContentRatingAustralia *MediaContentRatingAustralia `json:"mediaContentRatingAustralia,omitempty"`
	// MediaContentRatingCanada Media content rating settings for Canada
	MediaContentRatingCanada *MediaContentRatingCanada `json:"mediaContentRatingCanada,omitempty"`
	// MediaContentRatingFrance Media content rating settings for France
	MediaContentRatingFrance *MediaContentRatingFrance `json:"mediaContentRatingFrance,omitempty"`
	// MediaContentRatingGermany Media content rating settings for Germany
	MediaContentRatingGermany *MediaContentRatingGermany `json:"mediaContentRatingGermany,omitempty"`
	// MediaContentRatingIreland Media content rating settings for Ireland
	MediaContentRatingIreland *MediaContentRatingIreland `json:"mediaContentRatingIreland,omitempty"`
	// MediaContentRatingJapan Media content rating settings for Japan
	MediaContentRatingJapan *MediaContentRatingJapan `json:"mediaContentRatingJapan,omitempty"`
	// MediaContentRatingNewZealand Media content rating settings for New Zealand
	MediaContentRatingNewZealand *MediaContentRatingNewZealand `json:"mediaContentRatingNewZealand,omitempty"`
	// MediaContentRatingUnitedKingdom Media content rating settings for United Kingdom
	MediaContentRatingUnitedKingdom *MediaContentRatingUnitedKingdom `json:"mediaContentRatingUnitedKingdom,omitempty"`
	// MediaContentRatingUnitedStates Media content rating settings for United States
	MediaContentRatingUnitedStates *MediaContentRatingUnitedStates `json:"mediaContentRatingUnitedStates,omitempty"`
	// NetworkUsageRules List of managed apps and the network rules that applies to them. This collection can contain a maximum of 1000 elements.
	NetworkUsageRules []IosNetworkUsageRule `json:"networkUsageRules,omitempty"`
	// MediaContentRatingApps Media content rating settings for Apps
	MediaContentRatingApps *RatingAppsType `json:"mediaContentRatingApps,omitempty"`
	// MessagesBlocked Indicates whether or not to block the user from using the Messages app on the supervised device.
	MessagesBlocked *bool `json:"messagesBlocked,omitempty"`
	// NotificationsBlockSettingsModification Indicates whether or not to allow notifications settings modification (iOS 9.3 and later).
	NotificationsBlockSettingsModification *bool `json:"notificationsBlockSettingsModification,omitempty"`
	// PasscodeBlockFingerprintUnlock Indicates whether or not to block fingerprint unlock.
	PasscodeBlockFingerprintUnlock *bool `json:"passcodeBlockFingerprintUnlock,omitempty"`
	// PasscodeBlockFingerprintModification Block modification of registered Touch ID fingerprints when in supervised mode.
	PasscodeBlockFingerprintModification *bool `json:"passcodeBlockFingerprintModification,omitempty"`
	// PasscodeBlockModification Indicates whether or not to allow passcode modification on the supervised device (iOS 9.0 and later).
	PasscodeBlockModification *bool `json:"passcodeBlockModification,omitempty"`
	// PasscodeBlockSimple Indicates whether or not to block simple passcodes.
	PasscodeBlockSimple *bool `json:"passcodeBlockSimple,omitempty"`
	// PasscodeExpirationDays Number of days before the passcode expires. Valid values 1 to 65535
	PasscodeExpirationDays *int `json:"passcodeExpirationDays,omitempty"`
	// PasscodeMinimumLength Minimum length of passcode. Valid values 4 to 14
	PasscodeMinimumLength *int `json:"passcodeMinimumLength,omitempty"`
	// PasscodeMinutesOfInactivityBeforeLock Minutes of inactivity before a passcode is required.
	PasscodeMinutesOfInactivityBeforeLock *int `json:"passcodeMinutesOfInactivityBeforeLock,omitempty"`
	// PasscodeMinutesOfInactivityBeforeScreenTimeout Minutes of inactivity before the screen times out.
	PasscodeMinutesOfInactivityBeforeScreenTimeout *int `json:"passcodeMinutesOfInactivityBeforeScreenTimeout,omitempty"`
	// PasscodeMinimumCharacterSetCount Number of character sets a passcode must contain. Valid values 0 to 4
	PasscodeMinimumCharacterSetCount *int `json:"passcodeMinimumCharacterSetCount,omitempty"`
	// PasscodePreviousPasscodeBlockCount Number of previous passcodes to block. Valid values 1 to 24
	PasscodePreviousPasscodeBlockCount *int `json:"passcodePreviousPasscodeBlockCount,omitempty"`
	// PasscodeSignInFailureCountBeforeWipe Number of sign in failures allowed before wiping the device. Valid values 4 to 11
	PasscodeSignInFailureCountBeforeWipe *int `json:"passcodeSignInFailureCountBeforeWipe,omitempty"`
	// PasscodeRequiredType Type of passcode that is required.
	PasscodeRequiredType *RequiredPasswordType `json:"passcodeRequiredType,omitempty"`
	// PasscodeRequired Indicates whether or not to require a passcode.
	PasscodeRequired *bool `json:"passcodeRequired,omitempty"`
	// PodcastsBlocked Indicates whether or not to block the user from using podcasts on the supervised device (iOS 8.0 and later).
	PodcastsBlocked *bool `json:"podcastsBlocked,omitempty"`
	// SafariBlockAutofill Indicates whether or not to block the user from using Auto fill in Safari.
	SafariBlockAutofill *bool `json:"safariBlockAutofill,omitempty"`
	// SafariBlockJavaScript Indicates whether or not to block JavaScript in Safari.
	SafariBlockJavaScript *bool `json:"safariBlockJavaScript,omitempty"`
	// SafariBlockPopups Indicates whether or not to block popups in Safari.
	SafariBlockPopups *bool `json:"safariBlockPopups,omitempty"`
	// SafariBlocked Indicates whether or not to block the user from using Safari.
	SafariBlocked *bool `json:"safariBlocked,omitempty"`
	// SafariCookieSettings Cookie settings for Safari.
	SafariCookieSettings *WebBrowserCookieSettings `json:"safariCookieSettings,omitempty"`
	// SafariManagedDomains URLs matching the patterns listed here will be considered managed.
	SafariManagedDomains []string `json:"safariManagedDomains,omitempty"`
	// SafariPasswordAutoFillDomains Users can save passwords in Safari only from URLs matching the patterns listed here. Applies to devices in supervised mode (iOS 9.3 and later).
	SafariPasswordAutoFillDomains []string `json:"safariPasswordAutoFillDomains,omitempty"`
	// SafariRequireFraudWarning Indicates whether or not to require fraud warning in Safari.
	SafariRequireFraudWarning *bool `json:"safariRequireFraudWarning,omitempty"`
	// ScreenCaptureBlocked Indicates whether or not to block the user from taking Screenshots.
	ScreenCaptureBlocked *bool `json:"screenCaptureBlocked,omitempty"`
	// SiriBlocked Indicates whether or not to block the user from using Siri.
	SiriBlocked *bool `json:"siriBlocked,omitempty"`
	// SiriBlockedWhenLocked Indicates whether or not to block the user from using Siri when locked.
	SiriBlockedWhenLocked *bool `json:"siriBlockedWhenLocked,omitempty"`
	// SiriBlockUserGeneratedContent Indicates whether or not to block Siri from querying user-generated content when used on a supervised device.
	SiriBlockUserGeneratedContent *bool `json:"siriBlockUserGeneratedContent,omitempty"`
	// SiriRequireProfanityFilter Indicates whether or not to prevent Siri from dictating, or speaking profane language on supervised device.
	SiriRequireProfanityFilter *bool `json:"siriRequireProfanityFilter,omitempty"`
	// SpotlightBlockInternetResults Indicates whether or not to block Spotlight search from returning internet results on supervised device.
	SpotlightBlockInternetResults *bool `json:"spotlightBlockInternetResults,omitempty"`
	// VoiceDialingBlocked Indicates whether or not to block voice dialing.
	VoiceDialingBlocked *bool `json:"voiceDialingBlocked,omitempty"`
	// WallpaperBlockModification Indicates whether or not to allow wallpaper modification on supervised device (iOS 9.0 and later) .
	WallpaperBlockModification *bool `json:"wallpaperBlockModification,omitempty"`
	// WiFiConnectOnlyToConfiguredNetworks Indicates whether or not to force the device to use only Wi-Fi networks from configuration profiles when the device is in supervised mode.
	WiFiConnectOnlyToConfiguredNetworks *bool `json:"wiFiConnectOnlyToConfiguredNetworks,omitempty"`
}

// IIosGeneralDeviceConfiguration interface type for iosGeneralDeviceConfiguration
type IIosGeneralDeviceConfiguration interface {
	PIosGeneralDeviceConfiguration() *IosGeneralDeviceConfiguration
}

// PIosGeneralDeviceConfiguration pointer method for iosGeneralDeviceConfiguration
func (p *IosGeneralDeviceConfiguration) PIosGeneralDeviceConfiguration() *IosGeneralDeviceConfiguration {
	return p
}

// IosHomeScreenApp undocumented
type IosHomeScreenApp struct {
	IosHomeScreenItem
	// BundleID BundleID of app
	BundleID *string `json:"bundleID,omitempty"`
}

// IIosHomeScreenApp interface type for iosHomeScreenApp
type IIosHomeScreenApp interface {
	PIosHomeScreenApp() *IosHomeScreenApp
}

// PIosHomeScreenApp pointer method for iosHomeScreenApp
func (p *IosHomeScreenApp) PIosHomeScreenApp() *IosHomeScreenApp { return p }

// IosHomeScreenFolder undocumented
type IosHomeScreenFolder struct {
	IosHomeScreenItem
	// Pages Pages of Home Screen Layout Icons which must be Application Type. This collection can contain a maximum of 500 elements.
	Pages []IosHomeScreenFolderPage `json:"pages,omitempty"`
}

// IIosHomeScreenFolder interface type for iosHomeScreenFolder
type IIosHomeScreenFolder interface {
	PIosHomeScreenFolder() *IosHomeScreenFolder
}

// PIosHomeScreenFolder pointer method for iosHomeScreenFolder
func (p *IosHomeScreenFolder) PIosHomeScreenFolder() *IosHomeScreenFolder { return p }

// IosHomeScreenFolderPage undocumented
type IosHomeScreenFolderPage struct {
	// DisplayName Name of the folder page
	DisplayName *string `json:"displayName,omitempty"`
	// Apps A list of apps to appear on a page within a folder. This collection can contain a maximum of 500 elements.
	Apps []IosHomeScreenApp `json:"apps,omitempty"`
}

// IIosHomeScreenFolderPage interface type for iosHomeScreenFolderPage
type IIosHomeScreenFolderPage interface {
	PIosHomeScreenFolderPage() *IosHomeScreenFolderPage
}

// PIosHomeScreenFolderPage pointer method for iosHomeScreenFolderPage
func (p *IosHomeScreenFolderPage) PIosHomeScreenFolderPage() *IosHomeScreenFolderPage { return p }

// IosHomeScreenItem undocumented
type IosHomeScreenItem struct {
	// DisplayName Name of the app
	DisplayName *string `json:"displayName,omitempty"`
}

// IIosHomeScreenItem interface type for iosHomeScreenItem
type IIosHomeScreenItem interface {
	PIosHomeScreenItem() *IosHomeScreenItem
}

// PIosHomeScreenItem pointer method for iosHomeScreenItem
func (p *IosHomeScreenItem) PIosHomeScreenItem() *IosHomeScreenItem { return p }

// IosHomeScreenPage undocumented
type IosHomeScreenPage struct {
	// DisplayName Name of the page
	DisplayName *string `json:"displayName,omitempty"`
	// Icons A list of apps and folders to appear on a page. This collection can contain a maximum of 500 elements.
	Icons []IosHomeScreenItem `json:"icons,omitempty"`
}

// IIosHomeScreenPage interface type for iosHomeScreenPage
type IIosHomeScreenPage interface {
	PIosHomeScreenPage() *IosHomeScreenPage
}

// PIosHomeScreenPage pointer method for iosHomeScreenPage
func (p *IosHomeScreenPage) PIosHomeScreenPage() *IosHomeScreenPage { return p }

// IosLobApp Contains properties and inherited properties for iOS Line Of Business apps.
type IosLobApp struct {
	MobileLobApp
	// BundleId The Identity Name.
	BundleId *string `json:"bundleId,omitempty"`
	// ApplicableDeviceType The iOS architecture for which this app can run on.
	ApplicableDeviceType *IosDeviceType `json:"applicableDeviceType,omitempty"`
	// MinimumSupportedOperatingSystem The value for the minimum applicable operating system.
	MinimumSupportedOperatingSystem *IosMinimumOperatingSystem `json:"minimumSupportedOperatingSystem,omitempty"`
	// ExpirationDateTime The expiration time.
	ExpirationDateTime *time.Time `json:"expirationDateTime,omitempty"`
	// VersionNumber The version number of iOS Line of Business (LoB) app.
	VersionNumber *string `json:"versionNumber,omitempty"`
	// BuildNumber The build number of iOS Line of Business (LoB) app.
	BuildNumber *string `json:"buildNumber,omitempty"`
}

// IIosLobApp interface type for iosLobApp
type IIosLobApp interface {
	PIosLobApp() *IosLobApp
}

// PIosLobApp pointer method for iosLobApp
func (p *IosLobApp) PIosLobApp() *IosLobApp { return p }

// IosLobAppAssignmentSettings undocumented
type IosLobAppAssignmentSettings struct {
	MobileAppAssignmentSettings
	// VpnConfigurationId The VPN Configuration Id to apply for this app.
	VpnConfigurationId *string `json:"vpnConfigurationId,omitempty"`
}

// IIosLobAppAssignmentSettings interface type for iosLobAppAssignmentSettings
type IIosLobAppAssignmentSettings interface {
	PIosLobAppAssignmentSettings() *IosLobAppAssignmentSettings
}

// PIosLobAppAssignmentSettings pointer method for iosLobAppAssignmentSettings
func (p *IosLobAppAssignmentSettings) PIosLobAppAssignmentSettings() *IosLobAppAssignmentSettings {
	return p
}

// IosManagedAppProtection Policy used to configure detailed management settings targeted to specific security groups and for a specified set of apps on an iOS device
type IosManagedAppProtection struct {
	TargetedManagedAppProtection
	// AppDataEncryptionType Type of encryption which should be used for data in a managed app.
	AppDataEncryptionType *ManagedAppDataEncryptionType `json:"appDataEncryptionType,omitempty"`
	// MinimumRequiredSdkVersion Versions less than the specified version will block the managed app from accessing company data.
	MinimumRequiredSdkVersion *string `json:"minimumRequiredSdkVersion,omitempty"`
	// DeployedAppCount Count of apps to which the current policy is deployed.
	DeployedAppCount *int `json:"deployedAppCount,omitempty"`
	// FaceIdBlocked Indicates whether use of the FaceID is allowed in place of a pin if PinRequired is set to True.
	FaceIdBlocked *bool `json:"faceIdBlocked,omitempty"`
}

// IIosManagedAppProtection interface type for iosManagedAppProtection
type IIosManagedAppProtection interface {
	PIosManagedAppProtection() *IosManagedAppProtection
}

// PIosManagedAppProtection pointer method for iosManagedAppProtection
func (p *IosManagedAppProtection) PIosManagedAppProtection() *IosManagedAppProtection { return p }

// IosManagedAppRegistration Represents the synchronization details of an ios app, with management capabilities, for a specific user.
type IosManagedAppRegistration struct {
	ManagedAppRegistration
}

// IIosManagedAppRegistration interface type for iosManagedAppRegistration
type IIosManagedAppRegistration interface {
	PIosManagedAppRegistration() *IosManagedAppRegistration
}

// PIosManagedAppRegistration pointer method for iosManagedAppRegistration
func (p *IosManagedAppRegistration) PIosManagedAppRegistration() *IosManagedAppRegistration { return p }

// IosMinimumOperatingSystem undocumented
type IosMinimumOperatingSystem struct {
	// V8_0 Version 8.0 or later.
	V8_0 *bool `json:"v8_0,omitempty"`
	// V9_0 Version 9.0 or later.
	V9_0 *bool `json:"v9_0,omitempty"`
	// V10_0 Version 10.0 or later.
	V10_0 *bool `json:"v10_0,omitempty"`
	// V11_0 Version 11.0 or later.
	V11_0 *bool `json:"v11_0,omitempty"`
	// V12_0 Version 12.0 or later.
	V12_0 *bool `json:"v12_0,omitempty"`
}

// IIosMinimumOperatingSystem interface type for iosMinimumOperatingSystem
type IIosMinimumOperatingSystem interface {
	PIosMinimumOperatingSystem() *IosMinimumOperatingSystem
}

// PIosMinimumOperatingSystem pointer method for iosMinimumOperatingSystem
func (p *IosMinimumOperatingSystem) PIosMinimumOperatingSystem() *IosMinimumOperatingSystem { return p }

// IosMobileAppConfiguration Contains properties, inherited properties and actions for iOS mobile app configurations.
type IosMobileAppConfiguration struct {
	ManagedDeviceMobileAppConfiguration
	// EncodedSettingXml mdm app configuration Base64 binary.
	EncodedSettingXml *Binary `json:"encodedSettingXml,omitempty"`
	// Settings app configuration setting items.
	Settings []AppConfigurationSettingItem `json:"settings,omitempty"`
}

// IIosMobileAppConfiguration interface type for iosMobileAppConfiguration
type IIosMobileAppConfiguration interface {
	PIosMobileAppConfiguration() *IosMobileAppConfiguration
}

// PIosMobileAppConfiguration pointer method for iosMobileAppConfiguration
func (p *IosMobileAppConfiguration) PIosMobileAppConfiguration() *IosMobileAppConfiguration { return p }

// IosMobileAppIdentifier undocumented
type IosMobileAppIdentifier struct {
	MobileAppIdentifier
	// BundleId The identifier for an app, as specified in the app store.
	BundleId *string `json:"bundleId,omitempty"`
}

// IIosMobileAppIdentifier interface type for iosMobileAppIdentifier
type IIosMobileAppIdentifier interface {
	PIosMobileAppIdentifier() *IosMobileAppIdentifier
}

// PIosMobileAppIdentifier pointer method for iosMobileAppIdentifier
func (p *IosMobileAppIdentifier) PIosMobileAppIdentifier() *IosMobileAppIdentifier { return p }

// IosNetworkUsageRule undocumented
type IosNetworkUsageRule struct {
	// ManagedApps Information about the managed apps that this rule is going to apply to. This collection can contain a maximum of 500 elements.
	ManagedApps []AppListItem `json:"managedApps,omitempty"`
	// CellularDataBlockWhenRoaming If set to true, corresponding managed apps will not be allowed to use cellular data when roaming.
	CellularDataBlockWhenRoaming *bool `json:"cellularDataBlockWhenRoaming,omitempty"`
	// CellularDataBlocked If set to true, corresponding managed apps will not be allowed to use cellular data at any time.
	CellularDataBlocked *bool `json:"cellularDataBlocked,omitempty"`
}

// IIosNetworkUsageRule interface type for iosNetworkUsageRule
type IIosNetworkUsageRule interface {
	PIosNetworkUsageRule() *IosNetworkUsageRule
}

// PIosNetworkUsageRule pointer method for iosNetworkUsageRule
func (p *IosNetworkUsageRule) PIosNetworkUsageRule() *IosNetworkUsageRule { return p }

// IosNotificationSettings undocumented
type IosNotificationSettings struct {
	// BundleID Bundle id of app to which to apply these notification settings.
	BundleID *string `json:"bundleID,omitempty"`
	// AppName Application name to be associated with the bundleID.
	AppName *string `json:"appName,omitempty"`
	// Publisher Publisher to be associated with the bundleID.
	Publisher *string `json:"publisher,omitempty"`
	// Enabled Indicates whether notifications are allowed for this app.
	Enabled *bool `json:"enabled,omitempty"`
	// ShowInNotificationCenter Indicates whether notifications can be shown in notification center.
	ShowInNotificationCenter *bool `json:"showInNotificationCenter,omitempty"`
	// ShowOnLockScreen Indicates whether notifications can be shown on the lock screen.
	ShowOnLockScreen *bool `json:"showOnLockScreen,omitempty"`
	// AlertType Indicates the type of alert for notifications for this app.
	AlertType *IosNotificationAlertType `json:"alertType,omitempty"`
	// BadgesEnabled Indicates whether badges are allowed for this app.
	BadgesEnabled *bool `json:"badgesEnabled,omitempty"`
	// SoundsEnabled Indicates whether sounds are allowed for this app.
	SoundsEnabled *bool `json:"soundsEnabled,omitempty"`
}

// IIosNotificationSettings interface type for iosNotificationSettings
type IIosNotificationSettings interface {
	PIosNotificationSettings() *IosNotificationSettings
}

// PIosNotificationSettings pointer method for iosNotificationSettings
func (p *IosNotificationSettings) PIosNotificationSettings() *IosNotificationSettings { return p }

// IosStoreApp Contains properties and inherited properties for iOS store apps.
type IosStoreApp struct {
	MobileApp
	// BundleId The Identity Name.
	BundleId *string `json:"bundleId,omitempty"`
	// AppStoreUrl The Apple App Store URL
	AppStoreUrl *string `json:"appStoreUrl,omitempty"`
	// ApplicableDeviceType The iOS architecture for which this app can run on.
	ApplicableDeviceType *IosDeviceType `json:"applicableDeviceType,omitempty"`
	// MinimumSupportedOperatingSystem The value for the minimum applicable operating system.
	MinimumSupportedOperatingSystem *IosMinimumOperatingSystem `json:"minimumSupportedOperatingSystem,omitempty"`
}

// IIosStoreApp interface type for iosStoreApp
type IIosStoreApp interface {
	PIosStoreApp() *IosStoreApp
}

// PIosStoreApp pointer method for iosStoreApp
func (p *IosStoreApp) PIosStoreApp() *IosStoreApp { return p }

// IosStoreAppAssignmentSettings undocumented
type IosStoreAppAssignmentSettings struct {
	MobileAppAssignmentSettings
	// VpnConfigurationId The VPN Configuration Id to apply for this app.
	VpnConfigurationId *string `json:"vpnConfigurationId,omitempty"`
}

// IIosStoreAppAssignmentSettings interface type for iosStoreAppAssignmentSettings
type IIosStoreAppAssignmentSettings interface {
	PIosStoreAppAssignmentSettings() *IosStoreAppAssignmentSettings
}

// PIosStoreAppAssignmentSettings pointer method for iosStoreAppAssignmentSettings
func (p *IosStoreAppAssignmentSettings) PIosStoreAppAssignmentSettings() *IosStoreAppAssignmentSettings {
	return p
}

// IosUpdateConfiguration IOS Update Configuration, allows you to configure time window within week to install iOS updates
type IosUpdateConfiguration struct {
	DeviceConfiguration
	// ActiveHoursStart Active Hours Start (active hours mean the time window when updates install should not happen)
	ActiveHoursStart *time.Time `json:"activeHoursStart,omitempty"`
	// ActiveHoursEnd Active Hours End (active hours mean the time window when updates install should not happen)
	ActiveHoursEnd *time.Time `json:"activeHoursEnd,omitempty"`
	// ScheduledInstallDays Days in week for which active hours are configured. This collection can contain a maximum of 7 elements.
	ScheduledInstallDays []DayOfWeek `json:"scheduledInstallDays,omitempty"`
	// UtcTimeOffsetInMinutes UTC Time Offset indicated in minutes
	UtcTimeOffsetInMinutes *int `json:"utcTimeOffsetInMinutes,omitempty"`
}

// IIosUpdateConfiguration interface type for iosUpdateConfiguration
type IIosUpdateConfiguration interface {
	PIosUpdateConfiguration() *IosUpdateConfiguration
}

// PIosUpdateConfiguration pointer method for iosUpdateConfiguration
func (p *IosUpdateConfiguration) PIosUpdateConfiguration() *IosUpdateConfiguration { return p }

// IosUpdateDeviceStatus undocumented
type IosUpdateDeviceStatus struct {
	Entity
	// InstallStatus The installation status of the policy report.
	InstallStatus *IosUpdatesInstallStatus `json:"installStatus,omitempty"`
	// OsVersion The device version that is being reported.
	OsVersion *string `json:"osVersion,omitempty"`
	// DeviceId The device id that is being reported.
	DeviceId *string `json:"deviceId,omitempty"`
	// UserId The User id that is being reported.
	UserId *string `json:"userId,omitempty"`
	// DeviceDisplayName Device name of the DevicePolicyStatus.
	DeviceDisplayName *string `json:"deviceDisplayName,omitempty"`
	// UserName The User Name that is being reported
	UserName *string `json:"userName,omitempty"`
	// DeviceModel The device model that is being reported
	DeviceModel *string `json:"deviceModel,omitempty"`
	// ComplianceGracePeriodExpirationDateTime The DateTime when device compliance grace period expires
	ComplianceGracePeriodExpirationDateTime *time.Time `json:"complianceGracePeriodExpirationDateTime,omitempty"`
	// Status Compliance status of the policy report.
	Status *ComplianceStatus `json:"status,omitempty"`
	// LastReportedDateTime Last modified date time of the policy report.
	LastReportedDateTime *time.Time `json:"lastReportedDateTime,omitempty"`
	// UserPrincipalName UserPrincipalName.
	UserPrincipalName *string `json:"userPrincipalName,omitempty"`
}

// IIosUpdateDeviceStatus interface type for iosUpdateDeviceStatus
type IIosUpdateDeviceStatus interface {
	PIosUpdateDeviceStatus() *IosUpdateDeviceStatus
}

// PIosUpdateDeviceStatus pointer method for iosUpdateDeviceStatus
func (p *IosUpdateDeviceStatus) PIosUpdateDeviceStatus() *IosUpdateDeviceStatus { return p }

// IosVppApp Contains properties and inherited properties for iOS Volume-Purchased Program (VPP) Apps.
type IosVppApp struct {
	MobileApp
	// UsedLicenseCount The number of VPP licenses in use.
	UsedLicenseCount *int `json:"usedLicenseCount,omitempty"`
	// TotalLicenseCount The total number of VPP licenses.
	TotalLicenseCount *int `json:"totalLicenseCount,omitempty"`
	// ReleaseDateTime The VPP application release date and time.
	ReleaseDateTime *time.Time `json:"releaseDateTime,omitempty"`
	// AppStoreUrl The store URL.
	AppStoreUrl *string `json:"appStoreUrl,omitempty"`
	// LicensingType The supported License Type.
	LicensingType *VppLicensingType `json:"licensingType,omitempty"`
	// ApplicableDeviceType The applicable iOS Device Type.
	ApplicableDeviceType *IosDeviceType `json:"applicableDeviceType,omitempty"`
	// VppTokenOrganizationName The organization associated with the Apple Volume Purchase Program Token
	VppTokenOrganizationName *string `json:"vppTokenOrganizationName,omitempty"`
	// VppTokenAccountType The type of volume purchase program which the given Apple Volume Purchase Program Token is associated with. Possible values are: `business`, `education`.
	VppTokenAccountType *VppTokenAccountType `json:"vppTokenAccountType,omitempty"`
	// VppTokenAppleId The Apple Id associated with the given Apple Volume Purchase Program Token.
	VppTokenAppleId *string `json:"vppTokenAppleId,omitempty"`
	// BundleId The Identity Name.
	BundleId *string `json:"bundleId,omitempty"`
}

// IIosVppApp interface type for iosVppApp
type IIosVppApp interface {
	PIosVppApp() *IosVppApp
}

// PIosVppApp pointer method for iosVppApp
func (p *IosVppApp) PIosVppApp() *IosVppApp { return p }

// IosVppAppAssignmentSettings undocumented
type IosVppAppAssignmentSettings struct {
	MobileAppAssignmentSettings
	// UseDeviceLicensing Whether or not to use device licensing.
	UseDeviceLicensing *bool `json:"useDeviceLicensing,omitempty"`
	// VpnConfigurationId The VPN Configuration Id to apply for this app.
	VpnConfigurationId *string `json:"vpnConfigurationId,omitempty"`
}

// IIosVppAppAssignmentSettings interface type for iosVppAppAssignmentSettings
type IIosVppAppAssignmentSettings interface {
	PIosVppAppAssignmentSettings() *IosVppAppAssignmentSettings
}

// PIosVppAppAssignmentSettings pointer method for iosVppAppAssignmentSettings
func (p *IosVppAppAssignmentSettings) PIosVppAppAssignmentSettings() *IosVppAppAssignmentSettings {
	return p
}

// IosVppEBook A class containing the properties for iOS Vpp eBook.
type IosVppEBook struct {
	ManagedEBook
	// VppTokenId The Vpp token ID.
	VppTokenId *UUID `json:"vppTokenId,omitempty"`
	// AppleId The Apple ID associated with Vpp token.
	AppleId *string `json:"appleId,omitempty"`
	// VppOrganizationName The Vpp token's organization name.
	VppOrganizationName *string `json:"vppOrganizationName,omitempty"`
	// Genres Genres.
	Genres []string `json:"genres,omitempty"`
	// Language Language.
	Language *string `json:"language,omitempty"`
	// Seller Seller.
	Seller *string `json:"seller,omitempty"`
	// TotalLicenseCount Total license count.
	TotalLicenseCount *int `json:"totalLicenseCount,omitempty"`
	// UsedLicenseCount Used license count.
	UsedLicenseCount *int `json:"usedLicenseCount,omitempty"`
}

// IIosVppEBook interface type for iosVppEBook
type IIosVppEBook interface {
	PIosVppEBook() *IosVppEBook
}

// PIosVppEBook pointer method for iosVppEBook
func (p *IosVppEBook) PIosVppEBook() *IosVppEBook { return p }

// IosVppEBookAssignment Contains properties used to assign an iOS VPP EBook to a group.
type IosVppEBookAssignment struct {
	ManagedEBookAssignment
}

// IIosVppEBookAssignment interface type for iosVppEBookAssignment
type IIosVppEBookAssignment interface {
	PIosVppEBookAssignment() *IosVppEBookAssignment
}

// PIosVppEBookAssignment pointer method for iosVppEBookAssignment
func (p *IosVppEBookAssignment) PIosVppEBookAssignment() *IosVppEBookAssignment { return p }

// IpRange undocumented
type IpRange struct {
}

// IIpRange interface type for ipRange
type IIpRange interface {
	PIpRange() *IpRange
}

// PIpRange pointer method for ipRange
func (p *IpRange) PIpRange() *IpRange { return p }

// ItemActionStat undocumented
type ItemActionStat struct {
	// ActionCount undocumented
	ActionCount *int `json:"actionCount,omitempty"`
	// ActorCount undocumented
	ActorCount *int `json:"actorCount,omitempty"`
}

// IItemActionStat interface type for itemActionStat
type IItemActionStat interface {
	PItemActionStat() *ItemActionStat
}

// PItemActionStat pointer method for itemActionStat
func (p *ItemActionStat) PItemActionStat() *ItemActionStat { return p }

// ItemActivity undocumented
type ItemActivity struct {
	Entity
	// Access undocumented
	Access *AccessAction `json:"access,omitempty"`
	// ActivityDateTime undocumented
	ActivityDateTime *time.Time `json:"activityDateTime,omitempty"`
	// Actor undocumented
	Actor *IdentitySet `json:"actor,omitempty"`
}

// IItemActivity interface type for itemActivity
type IItemActivity interface {
	PItemActivity() *ItemActivity
}

// PItemActivity pointer method for itemActivity
func (p *ItemActivity) PItemActivity() *ItemActivity { return p }

// ItemActivityStat undocumented
type ItemActivityStat struct {
	Entity
	// StartDateTime undocumented
	StartDateTime *time.Time `json:"startDateTime,omitempty"`
	// EndDateTime undocumented
	EndDateTime *time.Time `json:"endDateTime,omitempty"`
	// Access undocumented
	Access *ItemActionStat `json:"access,omitempty"`
	// Create undocumented
	Create *ItemActionStat `json:"create,omitempty"`
	// Delete undocumented
	Delete *ItemActionStat `json:"delete,omitempty"`
	// Edit undocumented
	Edit *ItemActionStat `json:"edit,omitempty"`
	// Move undocumented
	Move *ItemActionStat `json:"move,omitempty"`
	// IsTrending undocumented
	IsTrending *bool `json:"isTrending,omitempty"`
	// IncompleteData undocumented
	IncompleteData *IncompleteData `json:"incompleteData,omitempty"`
}

// IItemActivityStat interface type for itemActivityStat
type IItemActivityStat interface {
	PItemActivityStat() *ItemActivityStat
}

// PItemActivityStat pointer method for itemActivityStat
func (p *ItemActivityStat) PItemActivityStat() *ItemActivityStat { return p }

// ItemAnalytics undocumented
type ItemAnalytics struct {
	Entity
}

// IItemAnalytics interface type for itemAnalytics
type IItemAnalytics interface {
	PItemAnalytics() *ItemAnalytics
}

// PItemAnalytics pointer method for itemAnalytics
func (p *ItemAnalytics) PItemAnalytics() *ItemAnalytics { return p }

// ItemAttachment undocumented
type ItemAttachment struct {
	Attachment
}

// IItemAttachment interface type for itemAttachment
type IItemAttachment interface {
	PItemAttachment() *ItemAttachment
}

// PItemAttachment pointer method for itemAttachment
func (p *ItemAttachment) PItemAttachment() *ItemAttachment { return p }

// ItemBody undocumented
type ItemBody struct {
	// ContentType undocumented
	ContentType *BodyType `json:"contentType,omitempty"`
	// Content undocumented
	Content *string `json:"content,omitempty"`
}

// IItemBody interface type for itemBody
type IItemBody interface {
	PItemBody() *ItemBody
}

// PItemBody pointer method for itemBody
func (p *ItemBody) PItemBody() *ItemBody { return p }

// ItemPreviewInfo undocumented
type ItemPreviewInfo struct {
	// GetUrl undocumented
	GetUrl *string `json:"getUrl,omitempty"`
	// PostParameters undocumented
	PostParameters *string `json:"postParameters,omitempty"`
	// PostUrl undocumented
	PostUrl *string `json:"postUrl,omitempty"`
}

// IItemPreviewInfo interface type for itemPreviewInfo
type IItemPreviewInfo interface {
	PItemPreviewInfo() *ItemPreviewInfo
}

// PItemPreviewInfo pointer method for itemPreviewInfo
func (p *ItemPreviewInfo) PItemPreviewInfo() *ItemPreviewInfo { return p }

// ItemReference undocumented
type ItemReference struct {
	// DriveId undocumented
	DriveId *string `json:"driveId,omitempty"`
	// DriveType undocumented
	DriveType *string `json:"driveType,omitempty"`
	// Id undocumented
	Id *string `json:"id,omitempty"`
	// Name undocumented
	Name *string `json:"name,omitempty"`
	// Path undocumented
	Path *string `json:"path,omitempty"`
	// ShareId undocumented
	ShareId *string `json:"shareId,omitempty"`
	// SharepointIds undocumented
	SharepointIds *SharepointIds `json:"sharepointIds,omitempty"`
	// SiteId undocumented
	SiteId *string `json:"siteId,omitempty"`
}

// IItemReference interface type for itemReference
type IItemReference interface {
	PItemReference() *ItemReference
}

// PItemReference pointer method for itemReference
func (p *ItemReference) PItemReference() *ItemReference { return p }

// KeyValue undocumented
type KeyValue struct {
	// Key undocumented
	Key *string `json:"key,omitempty"`
	// Value undocumented
	Value *string `json:"value,omitempty"`
}

// IKeyValue interface type for keyValue
type IKeyValue interface {
	PKeyValue() *KeyValue
}

// PKeyValue pointer method for keyValue
func (p *KeyValue) PKeyValue() *KeyValue { return p }

// KeyValuePair undocumented
type KeyValuePair struct {
	// Name Name for this key-value pair
	Name *string `json:"name,omitempty"`
	// Value Value for this key-value pair
	Value *string `json:"value,omitempty"`
}

// IKeyValuePair interface type for keyValuePair
type IKeyValuePair interface {
	PKeyValuePair() *KeyValuePair
}

// PKeyValuePair pointer method for keyValuePair
func (p *KeyValuePair) PKeyValuePair() *KeyValuePair { return p }

// LicenseAssignmentState undocumented
type LicenseAssignmentState struct {
	// SkuId undocumented
	SkuId *UUID `json:"skuId,omitempty"`
	// DisabledPlans undocumented
	DisabledPlans []UUID `json:"disabledPlans,omitempty"`
	// AssignedByGroup undocumented
	AssignedByGroup *string `json:"assignedByGroup,omitempty"`
	// State undocumented
	State *string `json:"state,omitempty"`
	// Error undocumented
	Error *string `json:"error,omitempty"`
}

// ILicenseAssignmentState interface type for licenseAssignmentState
type ILicenseAssignmentState interface {
	PLicenseAssignmentState() *LicenseAssignmentState
}

// PLicenseAssignmentState pointer method for licenseAssignmentState
func (p *LicenseAssignmentState) PLicenseAssignmentState() *LicenseAssignmentState { return p }

// LicenseDetails undocumented
type LicenseDetails struct {
	Entity
	// ServicePlans undocumented
	ServicePlans []ServicePlanInfo `json:"servicePlans,omitempty"`
	// SkuId undocumented
	SkuId *UUID `json:"skuId,omitempty"`
	// SkuPartNumber undocumented
	SkuPartNumber *string `json:"skuPartNumber,omitempty"`
}

// ILicenseDetails interface type for licenseDetails
type ILicenseDetails interface {
	PLicenseDetails() *LicenseDetails
}

// PLicenseDetails pointer method for licenseDetails
func (p *LicenseDetails) PLicenseDetails() *LicenseDetails { return p }

// LicenseProcessingState undocumented
type LicenseProcessingState struct {
	// State undocumented
	State *string `json:"state,omitempty"`
}

// ILicenseProcessingState interface type for licenseProcessingState
type ILicenseProcessingState interface {
	PLicenseProcessingState() *LicenseProcessingState
}

// PLicenseProcessingState pointer method for licenseProcessingState
func (p *LicenseProcessingState) PLicenseProcessingState() *LicenseProcessingState { return p }

// LicenseUnitsDetail undocumented
type LicenseUnitsDetail struct {
	// Enabled undocumented
	Enabled *int `json:"enabled,omitempty"`
	// Suspended undocumented
	Suspended *int `json:"suspended,omitempty"`
	// Warning undocumented
	Warning *int `json:"warning,omitempty"`
}

// ILicenseUnitsDetail interface type for licenseUnitsDetail
type ILicenseUnitsDetail interface {
	PLicenseUnitsDetail() *LicenseUnitsDetail
}

// PLicenseUnitsDetail pointer method for licenseUnitsDetail
func (p *LicenseUnitsDetail) PLicenseUnitsDetail() *LicenseUnitsDetail { return p }

// List undocumented
type List struct {
	BaseItem
	// DisplayName undocumented
	DisplayName *string `json:"displayName,omitempty"`
	// List undocumented
	List *ListInfo `json:"list,omitempty"`
	// SharepointIds undocumented
	SharepointIds *SharepointIds `json:"sharepointIds,omitempty"`
	// System undocumented
	System *SystemFacet `json:"system,omitempty"`
}

// IList interface type for list
type IList interface {
	PList() *List
}

// PList pointer method for list
func (p *List) PList() *List { return p }

// ListInfo undocumented
type ListInfo struct {
	// ContentTypesEnabled undocumented
	ContentTypesEnabled *bool `json:"contentTypesEnabled,omitempty"`
	// Hidden undocumented
	Hidden *bool `json:"hidden,omitempty"`
	// Template undocumented
	Template *string `json:"template,omitempty"`
}

// IListInfo interface type for listInfo
type IListInfo interface {
	PListInfo() *ListInfo
}

// PListInfo pointer method for listInfo
func (p *ListInfo) PListInfo() *ListInfo { return p }

// ListItem undocumented
type ListItem struct {
	BaseItem
	// ContentType undocumented
	ContentType *ContentTypeInfo `json:"contentType,omitempty"`
	// SharepointIds undocumented
	SharepointIds *SharepointIds `json:"sharepointIds,omitempty"`
}

// IListItem interface type for listItem
type IListItem interface {
	PListItem() *ListItem
}

// PListItem pointer method for listItem
func (p *ListItem) PListItem() *ListItem { return p }

// ListItemVersion undocumented
type ListItemVersion struct {
	BaseItemVersion
}

// IListItemVersion interface type for listItemVersion
type IListItemVersion interface {
	PListItemVersion() *ListItemVersion
}

// PListItemVersion pointer method for listItemVersion
func (p *ListItemVersion) PListItemVersion() *ListItemVersion { return p }

// LocaleInfo undocumented
type LocaleInfo struct {
	// Locale undocumented
	Locale *string `json:"locale,omitempty"`
	// DisplayName undocumented
	DisplayName *string `json:"displayName,omitempty"`
}

// ILocaleInfo interface type for localeInfo
type ILocaleInfo interface {
	PLocaleInfo() *LocaleInfo
}

// PLocaleInfo pointer method for localeInfo
func (p *LocaleInfo) PLocaleInfo() *LocaleInfo { return p }

// LocalizedNotificationMessage The text content of a Notification Message Template for the specified locale.
type LocalizedNotificationMessage struct {
	Entity
	// LastModifiedDateTime DateTime the object was last modified.
	LastModifiedDateTime *time.Time `json:"lastModifiedDateTime,omitempty"`
	// Locale The Locale for which this message is destined.
	Locale *string `json:"locale,omitempty"`
	// Subject The Message Template Subject.
	Subject *string `json:"subject,omitempty"`
	// MessageTemplate The Message Template content.
	MessageTemplate *string `json:"messageTemplate,omitempty"`
	// IsDefault Flag to indicate whether or not this is the default locale for language fallback. This flag can only be set. To unset, set this property to true on another Localized Notification Message.
	IsDefault *bool `json:"isDefault,omitempty"`
}

// ILocalizedNotificationMessage interface type for localizedNotificationMessage
type ILocalizedNotificationMessage interface {
	PLocalizedNotificationMessage() *LocalizedNotificationMessage
}

// PLocalizedNotificationMessage pointer method for localizedNotificationMessage
func (p *LocalizedNotificationMessage) PLocalizedNotificationMessage() *LocalizedNotificationMessage {
	return p
}

// LocateDeviceActionResult undocumented
type LocateDeviceActionResult struct {
	DeviceActionResult
	// DeviceLocation device location
	DeviceLocation *DeviceGeoLocation `json:"deviceLocation,omitempty"`
}

// ILocateDeviceActionResult interface type for locateDeviceActionResult
type ILocateDeviceActionResult interface {
	PLocateDeviceActionResult() *LocateDeviceActionResult
}

// PLocateDeviceActionResult pointer method for locateDeviceActionResult
func (p *LocateDeviceActionResult) PLocateDeviceActionResult() *LocateDeviceActionResult { return p }

// Location undocumented
type Location struct {
	// DisplayName undocumented
	DisplayName *string `json:"displayName,omitempty"`
	// LocationEmailAddress undocumented
	LocationEmailAddress *string `json:"locationEmailAddress,omitempty"`
	// Address undocumented
	Address *PhysicalAddress `json:"address,omitempty"`
	// LocationUri undocumented
	LocationUri *string `json:"locationUri,omitempty"`
	// Coordinates undocumented
	Coordinates *OutlookGeoCoordinates `json:"coordinates,omitempty"`
	// LocationType undocumented
	LocationType *LocationType `json:"locationType,omitempty"`
	// UniqueId undocumented
	UniqueId *string `json:"uniqueId,omitempty"`
	// UniqueIdType undocumented
	UniqueIdType *LocationUniqueIdType `json:"uniqueIdType,omitempty"`
}

// ILocation interface type for location
type ILocation interface {
	PLocation() *Location
}

// PLocation pointer method for location
func (p *Location) PLocation() *Location { return p }

// LocationConstraint undocumented
type LocationConstraint struct {
	// Locations undocumented
	Locations []LocationConstraintItem `json:"locations,omitempty"`
	// IsRequired undocumented
	IsRequired *bool `json:"isRequired,omitempty"`
	// SuggestLocation undocumented
	SuggestLocation *bool `json:"suggestLocation,omitempty"`
}

// ILocationConstraint interface type for locationConstraint
type ILocationConstraint interface {
	PLocationConstraint() *LocationConstraint
}

// PLocationConstraint pointer method for locationConstraint
func (p *LocationConstraint) PLocationConstraint() *LocationConstraint { return p }

// LocationConstraintItem undocumented
type LocationConstraintItem struct {
	Location
	// ResolveAvailability undocumented
	ResolveAvailability *bool `json:"resolveAvailability,omitempty"`
}

// ILocationConstraintItem interface type for locationConstraintItem
type ILocationConstraintItem interface {
	PLocationConstraintItem() *LocationConstraintItem
}

// PLocationConstraintItem pointer method for locationConstraintItem
func (p *LocationConstraintItem) PLocationConstraintItem() *LocationConstraintItem { return p }

// LookupColumn undocumented
type LookupColumn struct {
	// AllowMultipleValues undocumented
	AllowMultipleValues *bool `json:"allowMultipleValues,omitempty"`
	// AllowUnlimitedLength undocumented
	AllowUnlimitedLength *bool `json:"allowUnlimitedLength,omitempty"`
	// ColumnName undocumented
	ColumnName *string `json:"columnName,omitempty"`
	// ListId undocumented
	ListId *string `json:"listId,omitempty"`
	// PrimaryLookupColumnId undocumented
	PrimaryLookupColumnId *string `json:"primaryLookupColumnId,omitempty"`
}

// ILookupColumn interface type for lookupColumn
type ILookupColumn interface {
	PLookupColumn() *LookupColumn
}

// PLookupColumn pointer method for lookupColumn
func (p *LookupColumn) PLookupColumn() *LookupColumn { return p }

// MacOSCompliancePolicy This class contains compliance settings for Mac OS.
type MacOSCompliancePolicy struct {
	DeviceCompliancePolicy
	// PasswordRequired Whether or not to require a password.
	PasswordRequired *bool `json:"passwordRequired,omitempty"`
	// PasswordBlockSimple Indicates whether or not to block simple passwords.
	PasswordBlockSimple *bool `json:"passwordBlockSimple,omitempty"`
	// PasswordExpirationDays Number of days before the password expires. Valid values 1 to 65535
	PasswordExpirationDays *int `json:"passwordExpirationDays,omitempty"`
	// PasswordMinimumLength Minimum length of password. Valid values 4 to 14
	PasswordMinimumLength *int `json:"passwordMinimumLength,omitempty"`
	// PasswordMinutesOfInactivityBeforeLock Minutes of inactivity before a password is required.
	PasswordMinutesOfInactivityBeforeLock *int `json:"passwordMinutesOfInactivityBeforeLock,omitempty"`
	// PasswordPreviousPasswordBlockCount Number of previous passwords to block. Valid values 1 to 24
	PasswordPreviousPasswordBlockCount *int `json:"passwordPreviousPasswordBlockCount,omitempty"`
	// PasswordMinimumCharacterSetCount The number of character sets required in the password.
	PasswordMinimumCharacterSetCount *int `json:"passwordMinimumCharacterSetCount,omitempty"`
	// PasswordRequiredType The required password type.
	PasswordRequiredType *RequiredPasswordType `json:"passwordRequiredType,omitempty"`
	// OsMinimumVersion Minimum MacOS version.
	OsMinimumVersion *string `json:"osMinimumVersion,omitempty"`
	// OsMaximumVersion Maximum MacOS version.
	OsMaximumVersion *string `json:"osMaximumVersion,omitempty"`
	// SystemIntegrityProtectionEnabled Require that devices have enabled system integrity protection.
	SystemIntegrityProtectionEnabled *bool `json:"systemIntegrityProtectionEnabled,omitempty"`
	// DeviceThreatProtectionEnabled Require that devices have enabled device threat protection.
	DeviceThreatProtectionEnabled *bool `json:"deviceThreatProtectionEnabled,omitempty"`
	// DeviceThreatProtectionRequiredSecurityLevel Require Mobile Threat Protection minimum risk level to report noncompliance.
	DeviceThreatProtectionRequiredSecurityLevel *DeviceThreatProtectionLevel `json:"deviceThreatProtectionRequiredSecurityLevel,omitempty"`
	// StorageRequireEncryption Require encryption on Mac OS devices.
	StorageRequireEncryption *bool `json:"storageRequireEncryption,omitempty"`
	// FirewallEnabled Whether the firewall should be enabled or not.
	FirewallEnabled *bool `json:"firewallEnabled,omitempty"`
	// FirewallBlockAllIncoming Corresponds to the Block all incoming connections option.
	FirewallBlockAllIncoming *bool `json:"firewallBlockAllIncoming,omitempty"`
	// FirewallEnableStealthMode Corresponds to Enable stealth mode.
	FirewallEnableStealthMode *bool `json:"firewallEnableStealthMode,omitempty"`
}

// IMacOSCompliancePolicy interface type for macOSCompliancePolicy
type IMacOSCompliancePolicy interface {
	PMacOSCompliancePolicy() *MacOSCompliancePolicy
}

// PMacOSCompliancePolicy pointer method for macOSCompliancePolicy
func (p *MacOSCompliancePolicy) PMacOSCompliancePolicy() *MacOSCompliancePolicy { return p }

// MacOSCustomConfiguration This topic provides descriptions of the declared methods, properties and relationships exposed by the macOSCustomConfiguration resource.
type MacOSCustomConfiguration struct {
	DeviceConfiguration
	// PayloadName Name that is displayed to the user.
	PayloadName *string `json:"payloadName,omitempty"`
	// PayloadFileName Payload file name (*.mobileconfig | *.xml).
	PayloadFileName *string `json:"payloadFileName,omitempty"`
	// Payload Payload. (UTF8 encoded byte array)
	Payload *Binary `json:"payload,omitempty"`
}

// IMacOSCustomConfiguration interface type for macOSCustomConfiguration
type IMacOSCustomConfiguration interface {
	PMacOSCustomConfiguration() *MacOSCustomConfiguration
}

// PMacOSCustomConfiguration pointer method for macOSCustomConfiguration
func (p *MacOSCustomConfiguration) PMacOSCustomConfiguration() *MacOSCustomConfiguration { return p }

// MacOSDeviceFeaturesConfiguration MacOS device features configuration profile.
type MacOSDeviceFeaturesConfiguration struct {
	AppleDeviceFeaturesConfigurationBase
}

// IMacOSDeviceFeaturesConfiguration interface type for macOSDeviceFeaturesConfiguration
type IMacOSDeviceFeaturesConfiguration interface {
	PMacOSDeviceFeaturesConfiguration() *MacOSDeviceFeaturesConfiguration
}

// PMacOSDeviceFeaturesConfiguration pointer method for macOSDeviceFeaturesConfiguration
func (p *MacOSDeviceFeaturesConfiguration) PMacOSDeviceFeaturesConfiguration() *MacOSDeviceFeaturesConfiguration {
	return p
}

// MacOSGeneralDeviceConfiguration This topic provides descriptions of the declared methods, properties and relationships exposed by the macOSGeneralDeviceConfiguration resource.
type MacOSGeneralDeviceConfiguration struct {
	DeviceConfiguration
	// CompliantAppsList List of apps in the compliance (either allow list or block list, controlled by CompliantAppListType). This collection can contain a maximum of 10000 elements.
	CompliantAppsList []AppListItem `json:"compliantAppsList,omitempty"`
	// CompliantAppListType List that is in the CompliantAppsList.
	CompliantAppListType *AppListType `json:"compliantAppListType,omitempty"`
	// EmailInDomainSuffixes An email address lacking a suffix that matches any of these strings will be considered out-of-domain.
	EmailInDomainSuffixes []string `json:"emailInDomainSuffixes,omitempty"`
	// PasswordBlockSimple Block simple passwords.
	PasswordBlockSimple *bool `json:"passwordBlockSimple,omitempty"`
	// PasswordExpirationDays Number of days before the password expires.
	PasswordExpirationDays *int `json:"passwordExpirationDays,omitempty"`
	// PasswordMinimumCharacterSetCount Number of character sets a password must contain. Valid values 0 to 4
	PasswordMinimumCharacterSetCount *int `json:"passwordMinimumCharacterSetCount,omitempty"`
	// PasswordMinimumLength Minimum length of passwords.
	PasswordMinimumLength *int `json:"passwordMinimumLength,omitempty"`
	// PasswordMinutesOfInactivityBeforeLock Minutes of inactivity required before a password is required.
	PasswordMinutesOfInactivityBeforeLock *int `json:"passwordMinutesOfInactivityBeforeLock,omitempty"`
	// PasswordMinutesOfInactivityBeforeScreenTimeout Minutes of inactivity required before the screen times out.
	PasswordMinutesOfInactivityBeforeScreenTimeout *int `json:"passwordMinutesOfInactivityBeforeScreenTimeout,omitempty"`
	// PasswordPreviousPasswordBlockCount Number of previous passwords to block.
	PasswordPreviousPasswordBlockCount *int `json:"passwordPreviousPasswordBlockCount,omitempty"`
	// PasswordRequiredType Type of password that is required.
	PasswordRequiredType *RequiredPasswordType `json:"passwordRequiredType,omitempty"`
	// PasswordRequired Whether or not to require a password.
	PasswordRequired *bool `json:"passwordRequired,omitempty"`
}

// IMacOSGeneralDeviceConfiguration interface type for macOSGeneralDeviceConfiguration
type IMacOSGeneralDeviceConfiguration interface {
	PMacOSGeneralDeviceConfiguration() *MacOSGeneralDeviceConfiguration
}

// PMacOSGeneralDeviceConfiguration pointer method for macOSGeneralDeviceConfiguration
func (p *MacOSGeneralDeviceConfiguration) PMacOSGeneralDeviceConfiguration() *MacOSGeneralDeviceConfiguration {
	return p
}

// MacOSOfficeSuiteApp Contains properties and inherited properties for the MacOS Office Suite App.
type MacOSOfficeSuiteApp struct {
	MobileApp
}

// IMacOSOfficeSuiteApp interface type for macOSOfficeSuiteApp
type IMacOSOfficeSuiteApp interface {
	PMacOSOfficeSuiteApp() *MacOSOfficeSuiteApp
}

// PMacOSOfficeSuiteApp pointer method for macOSOfficeSuiteApp
func (p *MacOSOfficeSuiteApp) PMacOSOfficeSuiteApp() *MacOSOfficeSuiteApp { return p }

// MailFolder undocumented
type MailFolder struct {
	Entity
	// DisplayName undocumented
	DisplayName *string `json:"displayName,omitempty"`
	// ParentFolderId undocumented
	ParentFolderId *string `json:"parentFolderId,omitempty"`
	// ChildFolderCount undocumented
	ChildFolderCount *int `json:"childFolderCount,omitempty"`
	// UnreadItemCount undocumented
	UnreadItemCount *int `json:"unreadItemCount,omitempty"`
	// TotalItemCount undocumented
	TotalItemCount *int `json:"totalItemCount,omitempty"`
}

// IMailFolder interface type for mailFolder
type IMailFolder interface {
	PMailFolder() *MailFolder
}

// PMailFolder pointer method for mailFolder
func (p *MailFolder) PMailFolder() *MailFolder { return p }

// MailSearchFolder undocumented
type MailSearchFolder struct {
	MailFolder
	// IsSupported undocumented
	IsSupported *bool `json:"isSupported,omitempty"`
	// IncludeNestedFolders undocumented
	IncludeNestedFolders *bool `json:"includeNestedFolders,omitempty"`
	// SourceFolderIds undocumented
	SourceFolderIds []string `json:"sourceFolderIds,omitempty"`
	// FilterQuery undocumented
	FilterQuery *string `json:"filterQuery,omitempty"`
}

// IMailSearchFolder interface type for mailSearchFolder
type IMailSearchFolder interface {
	PMailSearchFolder() *MailSearchFolder
}

// PMailSearchFolder pointer method for mailSearchFolder
func (p *MailSearchFolder) PMailSearchFolder() *MailSearchFolder { return p }

// MailTips undocumented
type MailTips struct {
	// EmailAddress undocumented
	EmailAddress *EmailAddress `json:"emailAddress,omitempty"`
	// AutomaticReplies undocumented
	AutomaticReplies *AutomaticRepliesMailTips `json:"automaticReplies,omitempty"`
	// MailboxFull undocumented
	MailboxFull *bool `json:"mailboxFull,omitempty"`
	// CustomMailTip undocumented
	CustomMailTip *string `json:"customMailTip,omitempty"`
	// ExternalMemberCount undocumented
	ExternalMemberCount *int `json:"externalMemberCount,omitempty"`
	// TotalMemberCount undocumented
	TotalMemberCount *int `json:"totalMemberCount,omitempty"`
	// DeliveryRestricted undocumented
	DeliveryRestricted *bool `json:"deliveryRestricted,omitempty"`
	// IsModerated undocumented
	IsModerated *bool `json:"isModerated,omitempty"`
	// RecipientScope undocumented
	RecipientScope *RecipientScopeType `json:"recipientScope,omitempty"`
	// RecipientSuggestions undocumented
	RecipientSuggestions []Recipient `json:"recipientSuggestions,omitempty"`
	// MaxMessageSize undocumented
	MaxMessageSize *int `json:"maxMessageSize,omitempty"`
	// Error undocumented
	Error *MailTipsError `json:"error,omitempty"`
}

// IMailTips interface type for mailTips
type IMailTips interface {
	PMailTips() *MailTips
}

// PMailTips pointer method for mailTips
func (p *MailTips) PMailTips() *MailTips { return p }

// MailTipsError undocumented
type MailTipsError struct {
	// Message undocumented
	Message *string `json:"message,omitempty"`
	// Code undocumented
	Code *string `json:"code,omitempty"`
}

// IMailTipsError interface type for mailTipsError
type IMailTipsError interface {
	PMailTipsError() *MailTipsError
}

// PMailTipsError pointer method for mailTipsError
func (p *MailTipsError) PMailTipsError() *MailTipsError { return p }

// MailboxSettings undocumented
type MailboxSettings struct {
	// AutomaticRepliesSetting undocumented
	AutomaticRepliesSetting *AutomaticRepliesSetting `json:"automaticRepliesSetting,omitempty"`
	// ArchiveFolder undocumented
	ArchiveFolder *string `json:"archiveFolder,omitempty"`
	// TimeZone undocumented
	TimeZone *string `json:"timeZone,omitempty"`
	// Language undocumented
	Language *LocaleInfo `json:"language,omitempty"`
	// WorkingHours undocumented
	WorkingHours *WorkingHours `json:"workingHours,omitempty"`
	// DateFormat undocumented
	DateFormat *string `json:"dateFormat,omitempty"`
	// TimeFormat undocumented
	TimeFormat *string `json:"timeFormat,omitempty"`
}

// IMailboxSettings interface type for mailboxSettings
type IMailboxSettings interface {
	PMailboxSettings() *MailboxSettings
}

// PMailboxSettings pointer method for mailboxSettings
func (p *MailboxSettings) PMailboxSettings() *MailboxSettings { return p }

// MalwareState undocumented
type MalwareState struct {
	// Category undocumented
	Category *string `json:"category,omitempty"`
	// Family undocumented
	Family *string `json:"family,omitempty"`
	// Name undocumented
	Name *string `json:"name,omitempty"`
	// Severity undocumented
	Severity *string `json:"severity,omitempty"`
	// WasRunning undocumented
	WasRunning *bool `json:"wasRunning,omitempty"`
}

// IMalwareState interface type for malwareState
type IMalwareState interface {
	PMalwareState() *MalwareState
}

// PMalwareState pointer method for malwareState
func (p *MalwareState) PMalwareState() *MalwareState { return p }

// ManagedAndroidLobApp Contains properties and inherited properties for Managed Android Line Of Business apps.
type ManagedAndroidLobApp struct {
	ManagedMobileLobApp
	// PackageId The package identifier.
	PackageId *string `json:"packageId,omitempty"`
	// MinimumSupportedOperatingSystem The value for the minimum applicable operating system.
	MinimumSupportedOperatingSystem *AndroidMinimumOperatingSystem `json:"minimumSupportedOperatingSystem,omitempty"`
	// VersionName The version name of managed Android Line of Business (LoB) app.
	VersionName *string `json:"versionName,omitempty"`
	// VersionCode The version code of managed Android Line of Business (LoB) app.
	VersionCode *string `json:"versionCode,omitempty"`
}

// IManagedAndroidLobApp interface type for managedAndroidLobApp
type IManagedAndroidLobApp interface {
	PManagedAndroidLobApp() *ManagedAndroidLobApp
}

// PManagedAndroidLobApp pointer method for managedAndroidLobApp
func (p *ManagedAndroidLobApp) PManagedAndroidLobApp() *ManagedAndroidLobApp { return p }

// ManagedAndroidStoreApp Contains properties and inherited properties for Android store apps that you can manage with an Intune app protection policy.
type ManagedAndroidStoreApp struct {
	ManagedApp
	// PackageId The app's package ID.
	PackageId *string `json:"packageId,omitempty"`
	// AppStoreUrl The Android AppStoreUrl.
	AppStoreUrl *string `json:"appStoreUrl,omitempty"`
	// MinimumSupportedOperatingSystem The value for the minimum supported operating system.
	MinimumSupportedOperatingSystem *AndroidMinimumOperatingSystem `json:"minimumSupportedOperatingSystem,omitempty"`
}

// IManagedAndroidStoreApp interface type for managedAndroidStoreApp
type IManagedAndroidStoreApp interface {
	PManagedAndroidStoreApp() *ManagedAndroidStoreApp
}

// PManagedAndroidStoreApp pointer method for managedAndroidStoreApp
func (p *ManagedAndroidStoreApp) PManagedAndroidStoreApp() *ManagedAndroidStoreApp { return p }

// ManagedApp Abstract class that contains properties and inherited properties for apps that you can manage with an Intune app protection policy.
type ManagedApp struct {
	MobileApp
	// AppAvailability The Application's availability.
	AppAvailability *ManagedAppAvailability `json:"appAvailability,omitempty"`
	// Version The Application's version.
	Version *string `json:"version,omitempty"`
}

// IManagedApp interface type for managedApp
type IManagedApp interface {
	PManagedApp() *ManagedApp
}

// PManagedApp pointer method for managedApp
func (p *ManagedApp) PManagedApp() *ManagedApp { return p }

// ManagedAppConfiguration Configuration used to deliver a set of custom settings as-is to apps for users to whom the configuration is scoped
type ManagedAppConfiguration struct {
	ManagedAppPolicy
	// CustomSettings A set of string key and string value pairs to be sent to apps for users to whom the configuration is scoped, unalterned by this service
	CustomSettings []KeyValuePair `json:"customSettings,omitempty"`
}

// IManagedAppConfiguration interface type for managedAppConfiguration
type IManagedAppConfiguration interface {
	PManagedAppConfiguration() *ManagedAppConfiguration
}

// PManagedAppConfiguration pointer method for managedAppConfiguration
func (p *ManagedAppConfiguration) PManagedAppConfiguration() *ManagedAppConfiguration { return p }

// ManagedAppDiagnosticStatus undocumented
type ManagedAppDiagnosticStatus struct {
	// ValidationName The validation friendly name
	ValidationName *string `json:"validationName,omitempty"`
	// State The state of the operation
	State *string `json:"state,omitempty"`
	// MitigationInstruction Instruction on how to mitigate a failed validation
	MitigationInstruction *string `json:"mitigationInstruction,omitempty"`
}

// IManagedAppDiagnosticStatus interface type for managedAppDiagnosticStatus
type IManagedAppDiagnosticStatus interface {
	PManagedAppDiagnosticStatus() *ManagedAppDiagnosticStatus
}

// PManagedAppDiagnosticStatus pointer method for managedAppDiagnosticStatus
func (p *ManagedAppDiagnosticStatus) PManagedAppDiagnosticStatus() *ManagedAppDiagnosticStatus {
	return p
}

// ManagedAppOperation Represents an operation applied against an app registration.
type ManagedAppOperation struct {
	Entity
	// DisplayName The operation name.
	DisplayName *string `json:"displayName,omitempty"`
	// LastModifiedDateTime The last time the app operation was modified.
	LastModifiedDateTime *time.Time `json:"lastModifiedDateTime,omitempty"`
	// State The current state of the operation
	State *string `json:"state,omitempty"`
	// Version Version of the entity.
	Version *string `json:"version,omitempty"`
}

// IManagedAppOperation interface type for managedAppOperation
type IManagedAppOperation interface {
	PManagedAppOperation() *ManagedAppOperation
}

// PManagedAppOperation pointer method for managedAppOperation
func (p *ManagedAppOperation) PManagedAppOperation() *ManagedAppOperation { return p }

// ManagedAppPolicy The ManagedAppPolicy resource represents a base type for platform specific policies.
type ManagedAppPolicy struct {
	Entity
	// DisplayName Policy display name.
	DisplayName *string `json:"displayName,omitempty"`
	// Description The policy's description.
	Description *string `json:"description,omitempty"`
	// CreatedDateTime The date and time the policy was created.
	CreatedDateTime *time.Time `json:"createdDateTime,omitempty"`
	// LastModifiedDateTime Last time the policy was modified.
	LastModifiedDateTime *time.Time `json:"lastModifiedDateTime,omitempty"`
	// Version Version of the entity.
	Version *string `json:"version,omitempty"`
}

// IManagedAppPolicy interface type for managedAppPolicy
type IManagedAppPolicy interface {
	PManagedAppPolicy() *ManagedAppPolicy
}

// PManagedAppPolicy pointer method for managedAppPolicy
func (p *ManagedAppPolicy) PManagedAppPolicy() *ManagedAppPolicy { return p }

// ManagedAppPolicyDeploymentSummary The ManagedAppEntity is the base entity type for all other entity types under app management workflow.
type ManagedAppPolicyDeploymentSummary struct {
	Entity
	// DisplayName undocumented
	DisplayName *string `json:"displayName,omitempty"`
	// ConfigurationDeployedUserCount undocumented
	ConfigurationDeployedUserCount *int `json:"configurationDeployedUserCount,omitempty"`
	// LastRefreshTime undocumented
	LastRefreshTime *time.Time `json:"lastRefreshTime,omitempty"`
	// ConfigurationDeploymentSummaryPerApp undocumented
	ConfigurationDeploymentSummaryPerApp []ManagedAppPolicyDeploymentSummaryPerApp `json:"configurationDeploymentSummaryPerApp,omitempty"`
	// Version Version of the entity.
	Version *string `json:"version,omitempty"`
}

// IManagedAppPolicyDeploymentSummary interface type for managedAppPolicyDeploymentSummary
type IManagedAppPolicyDeploymentSummary interface {
	PManagedAppPolicyDeploymentSummary() *ManagedAppPolicyDeploymentSummary
}

// PManagedAppPolicyDeploymentSummary pointer method for managedAppPolicyDeploymentSummary
func (p *ManagedAppPolicyDeploymentSummary) PManagedAppPolicyDeploymentSummary() *ManagedAppPolicyDeploymentSummary {
	return p
}

// ManagedAppPolicyDeploymentSummaryPerApp undocumented
type ManagedAppPolicyDeploymentSummaryPerApp struct {
	// MobileAppIdentifier Deployment of an app.
	MobileAppIdentifier *MobileAppIdentifier `json:"mobileAppIdentifier,omitempty"`
	// ConfigurationAppliedUserCount Number of users the policy is applied.
	ConfigurationAppliedUserCount *int `json:"configurationAppliedUserCount,omitempty"`
}

// IManagedAppPolicyDeploymentSummaryPerApp interface type for managedAppPolicyDeploymentSummaryPerApp
type IManagedAppPolicyDeploymentSummaryPerApp interface {
	PManagedAppPolicyDeploymentSummaryPerApp() *ManagedAppPolicyDeploymentSummaryPerApp
}

// PManagedAppPolicyDeploymentSummaryPerApp pointer method for managedAppPolicyDeploymentSummaryPerApp
func (p *ManagedAppPolicyDeploymentSummaryPerApp) PManagedAppPolicyDeploymentSummaryPerApp() *ManagedAppPolicyDeploymentSummaryPerApp {
	return p
}

// ManagedAppProtection Policy used to configure detailed management settings for a specified set of apps
type ManagedAppProtection struct {
	ManagedAppPolicy
	// PeriodOfflineBeforeAccessCheck The period after which access is checked when the device is not connected to the internet.
	PeriodOfflineBeforeAccessCheck *time.Duration `json:"periodOfflineBeforeAccessCheck,omitempty"`
	// PeriodOnlineBeforeAccessCheck The period after which access is checked when the device is connected to the internet.
	PeriodOnlineBeforeAccessCheck *time.Duration `json:"periodOnlineBeforeAccessCheck,omitempty"`
	// AllowedInboundDataTransferSources Sources from which data is allowed to be transferred.
	AllowedInboundDataTransferSources *ManagedAppDataTransferLevel `json:"allowedInboundDataTransferSources,omitempty"`
	// AllowedOutboundDataTransferDestinations Destinations to which data is allowed to be transferred.
	AllowedOutboundDataTransferDestinations *ManagedAppDataTransferLevel `json:"allowedOutboundDataTransferDestinations,omitempty"`
	// OrganizationalCredentialsRequired Indicates whether organizational credentials are required for app use.
	OrganizationalCredentialsRequired *bool `json:"organizationalCredentialsRequired,omitempty"`
	// AllowedOutboundClipboardSharingLevel The level to which the clipboard may be shared between apps on the managed device.
	AllowedOutboundClipboardSharingLevel *ManagedAppClipboardSharingLevel `json:"allowedOutboundClipboardSharingLevel,omitempty"`
	// DataBackupBlocked Indicates whether the backup of a managed app's data is blocked.
	DataBackupBlocked *bool `json:"dataBackupBlocked,omitempty"`
	// DeviceComplianceRequired Indicates whether device compliance is required.
	DeviceComplianceRequired *bool `json:"deviceComplianceRequired,omitempty"`
	// ManagedBrowserToOpenLinksRequired Indicates whether internet links should be opened in the managed browser app.
	ManagedBrowserToOpenLinksRequired *bool `json:"managedBrowserToOpenLinksRequired,omitempty"`
	// SaveAsBlocked Indicates whether users may use the "Save As" menu item to save a copy of protected files.
	SaveAsBlocked *bool `json:"saveAsBlocked,omitempty"`
	// PeriodOfflineBeforeWipeIsEnforced The amount of time an app is allowed to remain disconnected from the internet before all managed data it is wiped.
	PeriodOfflineBeforeWipeIsEnforced *time.Duration `json:"periodOfflineBeforeWipeIsEnforced,omitempty"`
	// PinRequired Indicates whether an app-level pin is required.
	PinRequired *bool `json:"pinRequired,omitempty"`
	// MaximumPinRetries Maximum number of incorrect pin retry attempts before the managed app is either blocked or wiped.
	MaximumPinRetries *int `json:"maximumPinRetries,omitempty"`
	// SimplePinBlocked Indicates whether simplePin is blocked.
	SimplePinBlocked *bool `json:"simplePinBlocked,omitempty"`
	// MinimumPinLength Minimum pin length required for an app-level pin if PinRequired is set to True
	MinimumPinLength *int `json:"minimumPinLength,omitempty"`
	// PinCharacterSet Character set which may be used for an app-level pin if PinRequired is set to True.
	PinCharacterSet *ManagedAppPinCharacterSet `json:"pinCharacterSet,omitempty"`
	// PeriodBeforePinReset TimePeriod before the all-level pin must be reset if PinRequired is set to True.
	PeriodBeforePinReset *time.Duration `json:"periodBeforePinReset,omitempty"`
	// AllowedDataStorageLocations Data storage locations where a user may store managed data.
	AllowedDataStorageLocations []ManagedAppDataStorageLocation `json:"allowedDataStorageLocations,omitempty"`
	// ContactSyncBlocked Indicates whether contacts can be synced to the user's device.
	ContactSyncBlocked *bool `json:"contactSyncBlocked,omitempty"`
	// PrintBlocked Indicates whether printing is allowed from managed apps.
	PrintBlocked *bool `json:"printBlocked,omitempty"`
	// FingerprintBlocked Indicates whether use of the fingerprint reader is allowed in place of a pin if PinRequired is set to True.
	FingerprintBlocked *bool `json:"fingerprintBlocked,omitempty"`
	// DisableAppPinIfDevicePinIsSet Indicates whether use of the app pin is required if the device pin is set.
	DisableAppPinIfDevicePinIsSet *bool `json:"disableAppPinIfDevicePinIsSet,omitempty"`
	// MinimumRequiredOsVersion Versions less than the specified version will block the managed app from accessing company data.
	MinimumRequiredOsVersion *string `json:"minimumRequiredOsVersion,omitempty"`
	// MinimumWarningOsVersion Versions less than the specified version will result in warning message on the managed app from accessing company data.
	MinimumWarningOsVersion *string `json:"minimumWarningOsVersion,omitempty"`
	// MinimumRequiredAppVersion Versions less than the specified version will block the managed app from accessing company data.
	MinimumRequiredAppVersion *string `json:"minimumRequiredAppVersion,omitempty"`
	// MinimumWarningAppVersion Versions less than the specified version will result in warning message on the managed app.
	MinimumWarningAppVersion *string `json:"minimumWarningAppVersion,omitempty"`
}

// IManagedAppProtection interface type for managedAppProtection
type IManagedAppProtection interface {
	PManagedAppProtection() *ManagedAppProtection
}

// PManagedAppProtection pointer method for managedAppProtection
func (p *ManagedAppProtection) PManagedAppProtection() *ManagedAppProtection { return p }

// ManagedAppRegistration The ManagedAppEntity is the base entity type for all other entity types under app management workflow.
type ManagedAppRegistration struct {
	Entity
	// CreatedDateTime Date and time of creation
	CreatedDateTime *time.Time `json:"createdDateTime,omitempty"`
	// LastSyncDateTime Date and time of last the app synced with management service.
	LastSyncDateTime *time.Time `json:"lastSyncDateTime,omitempty"`
	// ApplicationVersion App version
	ApplicationVersion *string `json:"applicationVersion,omitempty"`
	// ManagementSdkVersion App management SDK version
	ManagementSdkVersion *string `json:"managementSdkVersion,omitempty"`
	// PlatformVersion Operating System version
	PlatformVersion *string `json:"platformVersion,omitempty"`
	// DeviceType Host device type
	DeviceType *string `json:"deviceType,omitempty"`
	// DeviceTag App management SDK generated tag, which helps relate apps hosted on the same device. Not guaranteed to relate apps in all conditions.
	DeviceTag *string `json:"deviceTag,omitempty"`
	// DeviceName Host device name
	DeviceName *string `json:"deviceName,omitempty"`
	// FlaggedReasons Zero or more reasons an app registration is flagged. E.g. app running on rooted device
	FlaggedReasons []ManagedAppFlaggedReason `json:"flaggedReasons,omitempty"`
	// UserId The user Id to who this app registration belongs.
	UserId *string `json:"userId,omitempty"`
	// AppIdentifier The app package Identifier
	AppIdentifier *MobileAppIdentifier `json:"appIdentifier,omitempty"`
	// Version Version of the entity.
	Version *string `json:"version,omitempty"`
}

// IManagedAppRegistration interface type for managedAppRegistration
type IManagedAppRegistration interface {
	PManagedAppRegistration() *ManagedAppRegistration
}

// PManagedAppRegistration pointer method for managedAppRegistration
func (p *ManagedAppRegistration) PManagedAppRegistration() *ManagedAppRegistration { return p }

// ManagedAppStatus Represents app protection and configuration status for the organization.
type ManagedAppStatus struct {
	Entity
	// DisplayName Friendly name of the status report.
	DisplayName *string `json:"displayName,omitempty"`
	// Version Version of the entity.
	Version *string `json:"version,omitempty"`
}

// IManagedAppStatus interface type for managedAppStatus
type IManagedAppStatus interface {
	PManagedAppStatus() *ManagedAppStatus
}

// PManagedAppStatus pointer method for managedAppStatus
func (p *ManagedAppStatus) PManagedAppStatus() *ManagedAppStatus { return p }

// ManagedAppStatusRaw Represents an un-typed status report about organizations app protection and configuration.
type ManagedAppStatusRaw struct {
	ManagedAppStatus
	// Content Status report content.
	Content json.RawMessage `json:"content,omitempty"`
}

// IManagedAppStatusRaw interface type for managedAppStatusRaw
type IManagedAppStatusRaw interface {
	PManagedAppStatusRaw() *ManagedAppStatusRaw
}

// PManagedAppStatusRaw pointer method for managedAppStatusRaw
func (p *ManagedAppStatusRaw) PManagedAppStatusRaw() *ManagedAppStatusRaw { return p }

// ManagedDevice Devices that are managed or pre-enrolled through Intune
type ManagedDevice struct {
	Entity
	// UserId Unique Identifier for the user associated with the device
	UserId *string `json:"userId,omitempty"`
	// DeviceName Name of the device
	DeviceName *string `json:"deviceName,omitempty"`
	// ManagedDeviceOwnerType Ownership of the device. Can be 'company' or 'personal'
	ManagedDeviceOwnerType *ManagedDeviceOwnerType `json:"managedDeviceOwnerType,omitempty"`
	// DeviceActionResults List of ComplexType deviceActionResult objects.
	DeviceActionResults []DeviceActionResult `json:"deviceActionResults,omitempty"`
	// EnrolledDateTime Enrollment time of the device.
	EnrolledDateTime *time.Time `json:"enrolledDateTime,omitempty"`
	// LastSyncDateTime The date and time that the device last completed a successful sync with Intune.
	LastSyncDateTime *time.Time `json:"lastSyncDateTime,omitempty"`
	// OperatingSystem Operating system of the device. Windows, iOS, etc.
	OperatingSystem *string `json:"operatingSystem,omitempty"`
	// ComplianceState Compliance state of the device.
	ComplianceState *ComplianceState `json:"complianceState,omitempty"`
	// JailBroken whether the device is jail broken or rooted.
	JailBroken *string `json:"jailBroken,omitempty"`
	// ManagementAgent Management channel of the device. Intune, EAS, etc.
	ManagementAgent *ManagementAgentType `json:"managementAgent,omitempty"`
	// OsVersion Operating system version of the device.
	OsVersion *string `json:"osVersion,omitempty"`
	// EasActivated Whether the device is Exchange ActiveSync activated.
	EasActivated *bool `json:"easActivated,omitempty"`
	// EasDeviceId Exchange ActiveSync Id of the device.
	EasDeviceId *string `json:"easDeviceId,omitempty"`
	// EasActivationDateTime Exchange ActivationSync activation time of the device.
	EasActivationDateTime *time.Time `json:"easActivationDateTime,omitempty"`
	// AzureADRegistered Whether the device is Azure Active Directory registered.
	AzureADRegistered *bool `json:"azureADRegistered,omitempty"`
	// DeviceEnrollmentType Enrollment type of the device.
	DeviceEnrollmentType *DeviceEnrollmentType `json:"deviceEnrollmentType,omitempty"`
	// ActivationLockBypassCode Code that allows the Activation Lock on a device to be bypassed.
	ActivationLockBypassCode *string `json:"activationLockBypassCode,omitempty"`
	// EmailAddress Email(s) for the user associated with the device
	EmailAddress *string `json:"emailAddress,omitempty"`
	// AzureADDeviceId The unique identifier for the Azure Active Directory device. Read only.
	AzureADDeviceId *string `json:"azureADDeviceId,omitempty"`
	// DeviceRegistrationState Device registration state.
	DeviceRegistrationState *DeviceRegistrationState `json:"deviceRegistrationState,omitempty"`
	// DeviceCategoryDisplayName Device category display name
	DeviceCategoryDisplayName *string `json:"deviceCategoryDisplayName,omitempty"`
	// IsSupervised Device supervised status
	IsSupervised *bool `json:"isSupervised,omitempty"`
	// ExchangeLastSuccessfulSyncDateTime Last time the device contacted Exchange.
	ExchangeLastSuccessfulSyncDateTime *time.Time `json:"exchangeLastSuccessfulSyncDateTime,omitempty"`
	// ExchangeAccessState The Access State of the device in Exchange.
	ExchangeAccessState *DeviceManagementExchangeAccessState `json:"exchangeAccessState,omitempty"`
	// ExchangeAccessStateReason The reason for the device's access state in Exchange.
	ExchangeAccessStateReason *DeviceManagementExchangeAccessStateReason `json:"exchangeAccessStateReason,omitempty"`
	// RemoteAssistanceSessionUrl Url that allows a Remote Assistance session to be established with the device.
	RemoteAssistanceSessionUrl *string `json:"remoteAssistanceSessionUrl,omitempty"`
	// RemoteAssistanceSessionErrorDetails An error string that identifies issues when creating Remote Assistance session objects.
	RemoteAssistanceSessionErrorDetails *string `json:"remoteAssistanceSessionErrorDetails,omitempty"`
	// IsEncrypted Device encryption status
	IsEncrypted *bool `json:"isEncrypted,omitempty"`
	// UserPrincipalName Device user principal name
	UserPrincipalName *string `json:"userPrincipalName,omitempty"`
	// Model Model of the device
	Model *string `json:"model,omitempty"`
	// Manufacturer Manufacturer of the device
	Manufacturer *string `json:"manufacturer,omitempty"`
	// Imei IMEI
	Imei *string `json:"imei,omitempty"`
	// ComplianceGracePeriodExpirationDateTime The DateTime when device compliance grace period expires
	ComplianceGracePeriodExpirationDateTime *time.Time `json:"complianceGracePeriodExpirationDateTime,omitempty"`
	// SerialNumber SerialNumber
	SerialNumber *string `json:"serialNumber,omitempty"`
	// PhoneNumber Phone number of the device
	PhoneNumber *string `json:"phoneNumber,omitempty"`
	// AndroidSecurityPatchLevel Android security patch level
	AndroidSecurityPatchLevel *string `json:"androidSecurityPatchLevel,omitempty"`
	// UserDisplayName User display name
	UserDisplayName *string `json:"userDisplayName,omitempty"`
	// ConfigurationManagerClientEnabledFeatures ConfigrMgr client enabled features
	ConfigurationManagerClientEnabledFeatures *ConfigurationManagerClientEnabledFeatures `json:"configurationManagerClientEnabledFeatures,omitempty"`
	// WiFiMacAddress Wi-Fi MAC
	WiFiMacAddress *string `json:"wiFiMacAddress,omitempty"`
	// DeviceHealthAttestationState The device health attestation state.
	DeviceHealthAttestationState *DeviceHealthAttestationState `json:"deviceHealthAttestationState,omitempty"`
	// SubscriberCarrier Subscriber Carrier
	SubscriberCarrier *string `json:"subscriberCarrier,omitempty"`
	// Meid MEID
	Meid *string `json:"meid,omitempty"`
	// TotalStorageSpaceInBytes Total Storage in Bytes
	TotalStorageSpaceInBytes *int `json:"totalStorageSpaceInBytes,omitempty"`
	// FreeStorageSpaceInBytes Free Storage in Bytes
	FreeStorageSpaceInBytes *int `json:"freeStorageSpaceInBytes,omitempty"`
	// ManagedDeviceName Automatically generated name to identify a device. Can be overwritten to a user friendly name.
	ManagedDeviceName *string `json:"managedDeviceName,omitempty"`
	// PartnerReportedThreatState Indicates the threat state of a device when a Mobile Threat Defense partner is in use by the account and device. Read Only.
	PartnerReportedThreatState *ManagedDevicePartnerReportedHealthState `json:"partnerReportedThreatState,omitempty"`
}

// IManagedDevice interface type for managedDevice
type IManagedDevice interface {
	PManagedDevice() *ManagedDevice
}

// PManagedDevice pointer method for managedDevice
func (p *ManagedDevice) PManagedDevice() *ManagedDevice { return p }

// ManagedDeviceMobileAppConfiguration An abstract class for Mobile app configuration for enrolled devices.
type ManagedDeviceMobileAppConfiguration struct {
	Entity
	// TargetedMobileApps the associated app.
	TargetedMobileApps []string `json:"targetedMobileApps,omitempty"`
	// CreatedDateTime DateTime the object was created.
	CreatedDateTime *time.Time `json:"createdDateTime,omitempty"`
	// Description Admin provided description of the Device Configuration.
	Description *string `json:"description,omitempty"`
	// LastModifiedDateTime DateTime the object was last modified.
	LastModifiedDateTime *time.Time `json:"lastModifiedDateTime,omitempty"`
	// DisplayName Admin provided name of the device configuration.
	DisplayName *string `json:"displayName,omitempty"`
	// Version Version of the device configuration.
	Version *int `json:"version,omitempty"`
}

// IManagedDeviceMobileAppConfiguration interface type for managedDeviceMobileAppConfiguration
type IManagedDeviceMobileAppConfiguration interface {
	PManagedDeviceMobileAppConfiguration() *ManagedDeviceMobileAppConfiguration
}

// PManagedDeviceMobileAppConfiguration pointer method for managedDeviceMobileAppConfiguration
func (p *ManagedDeviceMobileAppConfiguration) PManagedDeviceMobileAppConfiguration() *ManagedDeviceMobileAppConfiguration {
	return p
}

// ManagedDeviceMobileAppConfigurationAssignment Contains the properties used to assign an MDM app configuration to a group.
type ManagedDeviceMobileAppConfigurationAssignment struct {
	Entity
	// Target Assignment target that the T&C policy is assigned to.
	Target *DeviceAndAppManagementAssignmentTarget `json:"target,omitempty"`
}

// IManagedDeviceMobileAppConfigurationAssignment interface type for managedDeviceMobileAppConfigurationAssignment
type IManagedDeviceMobileAppConfigurationAssignment interface {
	PManagedDeviceMobileAppConfigurationAssignment() *ManagedDeviceMobileAppConfigurationAssignment
}

// PManagedDeviceMobileAppConfigurationAssignment pointer method for managedDeviceMobileAppConfigurationAssignment
func (p *ManagedDeviceMobileAppConfigurationAssignment) PManagedDeviceMobileAppConfigurationAssignment() *ManagedDeviceMobileAppConfigurationAssignment {
	return p
}

// ManagedDeviceMobileAppConfigurationDeviceStatus Contains properties, inherited properties and actions for an MDM mobile app configuration status for a device.
type ManagedDeviceMobileAppConfigurationDeviceStatus struct {
	Entity
	// DeviceDisplayName Device name of the DevicePolicyStatus.
	DeviceDisplayName *string `json:"deviceDisplayName,omitempty"`
	// UserName The User Name that is being reported
	UserName *string `json:"userName,omitempty"`
	// DeviceModel The device model that is being reported
	DeviceModel *string `json:"deviceModel,omitempty"`
	// ComplianceGracePeriodExpirationDateTime The DateTime when device compliance grace period expires
	ComplianceGracePeriodExpirationDateTime *time.Time `json:"complianceGracePeriodExpirationDateTime,omitempty"`
	// Status Compliance status of the policy report.
	Status *ComplianceStatus `json:"status,omitempty"`
	// LastReportedDateTime Last modified date time of the policy report.
	LastReportedDateTime *time.Time `json:"lastReportedDateTime,omitempty"`
	// UserPrincipalName UserPrincipalName.
	UserPrincipalName *string `json:"userPrincipalName,omitempty"`
}

// IManagedDeviceMobileAppConfigurationDeviceStatus interface type for managedDeviceMobileAppConfigurationDeviceStatus
type IManagedDeviceMobileAppConfigurationDeviceStatus interface {
	PManagedDeviceMobileAppConfigurationDeviceStatus() *ManagedDeviceMobileAppConfigurationDeviceStatus
}

// PManagedDeviceMobileAppConfigurationDeviceStatus pointer method for managedDeviceMobileAppConfigurationDeviceStatus
func (p *ManagedDeviceMobileAppConfigurationDeviceStatus) PManagedDeviceMobileAppConfigurationDeviceStatus() *ManagedDeviceMobileAppConfigurationDeviceStatus {
	return p
}

// ManagedDeviceMobileAppConfigurationDeviceSummary Contains properties, inherited properties and actions for an MDM mobile app configuration device status summary.
type ManagedDeviceMobileAppConfigurationDeviceSummary struct {
	Entity
	// PendingCount Number of pending devices
	PendingCount *int `json:"pendingCount,omitempty"`
	// NotApplicableCount Number of not applicable devices
	NotApplicableCount *int `json:"notApplicableCount,omitempty"`
	// SuccessCount Number of succeeded devices
	SuccessCount *int `json:"successCount,omitempty"`
	// ErrorCount Number of error devices
	ErrorCount *int `json:"errorCount,omitempty"`
	// FailedCount Number of failed devices
	FailedCount *int `json:"failedCount,omitempty"`
	// LastUpdateDateTime Last update time
	LastUpdateDateTime *time.Time `json:"lastUpdateDateTime,omitempty"`
	// ConfigurationVersion Version of the policy for that overview
	ConfigurationVersion *int `json:"configurationVersion,omitempty"`
}

// IManagedDeviceMobileAppConfigurationDeviceSummary interface type for managedDeviceMobileAppConfigurationDeviceSummary
type IManagedDeviceMobileAppConfigurationDeviceSummary interface {
	PManagedDeviceMobileAppConfigurationDeviceSummary() *ManagedDeviceMobileAppConfigurationDeviceSummary
}

// PManagedDeviceMobileAppConfigurationDeviceSummary pointer method for managedDeviceMobileAppConfigurationDeviceSummary
func (p *ManagedDeviceMobileAppConfigurationDeviceSummary) PManagedDeviceMobileAppConfigurationDeviceSummary() *ManagedDeviceMobileAppConfigurationDeviceSummary {
	return p
}

// ManagedDeviceMobileAppConfigurationUserStatus Contains properties, inherited properties and actions for an MDM mobile app configuration status for a user.
type ManagedDeviceMobileAppConfigurationUserStatus struct {
	Entity
	// UserDisplayName User name of the DevicePolicyStatus.
	UserDisplayName *string `json:"userDisplayName,omitempty"`
	// DevicesCount Devices count for that user.
	DevicesCount *int `json:"devicesCount,omitempty"`
	// Status Compliance status of the policy report.
	Status *ComplianceStatus `json:"status,omitempty"`
	// LastReportedDateTime Last modified date time of the policy report.
	LastReportedDateTime *time.Time `json:"lastReportedDateTime,omitempty"`
	// UserPrincipalName UserPrincipalName.
	UserPrincipalName *string `json:"userPrincipalName,omitempty"`
}

// IManagedDeviceMobileAppConfigurationUserStatus interface type for managedDeviceMobileAppConfigurationUserStatus
type IManagedDeviceMobileAppConfigurationUserStatus interface {
	PManagedDeviceMobileAppConfigurationUserStatus() *ManagedDeviceMobileAppConfigurationUserStatus
}

// PManagedDeviceMobileAppConfigurationUserStatus pointer method for managedDeviceMobileAppConfigurationUserStatus
func (p *ManagedDeviceMobileAppConfigurationUserStatus) PManagedDeviceMobileAppConfigurationUserStatus() *ManagedDeviceMobileAppConfigurationUserStatus {
	return p
}

// ManagedDeviceMobileAppConfigurationUserSummary Contains properties, inherited properties and actions for an MDM mobile app configuration user status summary.
type ManagedDeviceMobileAppConfigurationUserSummary struct {
	Entity
	// PendingCount Number of pending Users
	PendingCount *int `json:"pendingCount,omitempty"`
	// NotApplicableCount Number of not applicable users
	NotApplicableCount *int `json:"notApplicableCount,omitempty"`
	// SuccessCount Number of succeeded Users
	SuccessCount *int `json:"successCount,omitempty"`
	// ErrorCount Number of error Users
	ErrorCount *int `json:"errorCount,omitempty"`
	// FailedCount Number of failed Users
	FailedCount *int `json:"failedCount,omitempty"`
	// LastUpdateDateTime Last update time
	LastUpdateDateTime *time.Time `json:"lastUpdateDateTime,omitempty"`
	// ConfigurationVersion Version of the policy for that overview
	ConfigurationVersion *int `json:"configurationVersion,omitempty"`
}

// IManagedDeviceMobileAppConfigurationUserSummary interface type for managedDeviceMobileAppConfigurationUserSummary
type IManagedDeviceMobileAppConfigurationUserSummary interface {
	PManagedDeviceMobileAppConfigurationUserSummary() *ManagedDeviceMobileAppConfigurationUserSummary
}

// PManagedDeviceMobileAppConfigurationUserSummary pointer method for managedDeviceMobileAppConfigurationUserSummary
func (p *ManagedDeviceMobileAppConfigurationUserSummary) PManagedDeviceMobileAppConfigurationUserSummary() *ManagedDeviceMobileAppConfigurationUserSummary {
	return p
}

// ManagedDeviceOverview Summary data for managed devices
type ManagedDeviceOverview struct {
	Entity
	// EnrolledDeviceCount Total enrolled device count. Does not include PC devices managed via Intune PC Agent
	EnrolledDeviceCount *int `json:"enrolledDeviceCount,omitempty"`
	// MdmEnrolledCount The number of devices enrolled in MDM
	MdmEnrolledCount *int `json:"mdmEnrolledCount,omitempty"`
	// DualEnrolledDeviceCount The number of devices enrolled in both MDM and EAS
	DualEnrolledDeviceCount *int `json:"dualEnrolledDeviceCount,omitempty"`
	// DeviceOperatingSystemSummary Device operating system summary.
	DeviceOperatingSystemSummary *DeviceOperatingSystemSummary `json:"deviceOperatingSystemSummary,omitempty"`
	// DeviceExchangeAccessStateSummary Distribution of Exchange Access State in Intune
	DeviceExchangeAccessStateSummary *DeviceExchangeAccessStateSummary `json:"deviceExchangeAccessStateSummary,omitempty"`
}

// IManagedDeviceOverview interface type for managedDeviceOverview
type IManagedDeviceOverview interface {
	PManagedDeviceOverview() *ManagedDeviceOverview
}

// PManagedDeviceOverview pointer method for managedDeviceOverview
func (p *ManagedDeviceOverview) PManagedDeviceOverview() *ManagedDeviceOverview { return p }

// ManagedEBook An abstract class containing the base properties for Managed eBook.
type ManagedEBook struct {
	Entity
	// DisplayName Name of the eBook.
	DisplayName *string `json:"displayName,omitempty"`
	// Description Description.
	Description *string `json:"description,omitempty"`
	// Publisher Publisher.
	Publisher *string `json:"publisher,omitempty"`
	// PublishedDateTime The date and time when the eBook was published.
	PublishedDateTime *time.Time `json:"publishedDateTime,omitempty"`
	// LargeCover Book cover.
	LargeCover *MimeContent `json:"largeCover,omitempty"`
	// CreatedDateTime The date and time when the eBook file was created.
	CreatedDateTime *time.Time `json:"createdDateTime,omitempty"`
	// LastModifiedDateTime The date and time when the eBook was last modified.
	LastModifiedDateTime *time.Time `json:"lastModifiedDateTime,omitempty"`
	// InformationUrl The more information Url.
	InformationUrl *string `json:"informationUrl,omitempty"`
	// PrivacyInformationUrl The privacy statement Url.
	PrivacyInformationUrl *string `json:"privacyInformationUrl,omitempty"`
}

// IManagedEBook interface type for managedEBook
type IManagedEBook interface {
	PManagedEBook() *ManagedEBook
}

// PManagedEBook pointer method for managedEBook
func (p *ManagedEBook) PManagedEBook() *ManagedEBook { return p }

// ManagedEBookAssignment Contains properties used to assign a eBook to a group.
type ManagedEBookAssignment struct {
	Entity
	// Target The assignment target for eBook.
	Target *DeviceAndAppManagementAssignmentTarget `json:"target,omitempty"`
	// InstallIntent The install intent for eBook.
	InstallIntent *InstallIntent `json:"installIntent,omitempty"`
}

// IManagedEBookAssignment interface type for managedEBookAssignment
type IManagedEBookAssignment interface {
	PManagedEBookAssignment() *ManagedEBookAssignment
}

// PManagedEBookAssignment pointer method for managedEBookAssignment
func (p *ManagedEBookAssignment) PManagedEBookAssignment() *ManagedEBookAssignment { return p }

// ManagedIOSLobApp Contains properties and inherited properties for Managed iOS Line Of Business apps.
type ManagedIOSLobApp struct {
	ManagedMobileLobApp
	// BundleId The Identity Name.
	BundleId *string `json:"bundleId,omitempty"`
	// ApplicableDeviceType The iOS architecture for which this app can run on.
	ApplicableDeviceType *IosDeviceType `json:"applicableDeviceType,omitempty"`
	// MinimumSupportedOperatingSystem The value for the minimum applicable operating system.
	MinimumSupportedOperatingSystem *IosMinimumOperatingSystem `json:"minimumSupportedOperatingSystem,omitempty"`
	// ExpirationDateTime The expiration time.
	ExpirationDateTime *time.Time `json:"expirationDateTime,omitempty"`
	// VersionNumber The version number of managed iOS Line of Business (LoB) app.
	VersionNumber *string `json:"versionNumber,omitempty"`
	// BuildNumber The build number of managed iOS Line of Business (LoB) app.
	BuildNumber *string `json:"buildNumber,omitempty"`
}

// IManagedIOSLobApp interface type for managedIOSLobApp
type IManagedIOSLobApp interface {
	PManagedIOSLobApp() *ManagedIOSLobApp
}

// PManagedIOSLobApp pointer method for managedIOSLobApp
func (p *ManagedIOSLobApp) PManagedIOSLobApp() *ManagedIOSLobApp { return p }

// ManagedIOSStoreApp Contains properties and inherited properties for an iOS store app that you can manage with an Intune app protection policy.
type ManagedIOSStoreApp struct {
	ManagedApp
	// BundleId The app's Bundle ID.
	BundleId *string `json:"bundleId,omitempty"`
	// AppStoreUrl The Apple AppStoreUrl.
	AppStoreUrl *string `json:"appStoreUrl,omitempty"`
	// ApplicableDeviceType The iOS architecture for which this app can run on.
	ApplicableDeviceType *IosDeviceType `json:"applicableDeviceType,omitempty"`
	// MinimumSupportedOperatingSystem The value for the minimum supported operating system.
	MinimumSupportedOperatingSystem *IosMinimumOperatingSystem `json:"minimumSupportedOperatingSystem,omitempty"`
}

// IManagedIOSStoreApp interface type for managedIOSStoreApp
type IManagedIOSStoreApp interface {
	PManagedIOSStoreApp() *ManagedIOSStoreApp
}

// PManagedIOSStoreApp pointer method for managedIOSStoreApp
func (p *ManagedIOSStoreApp) PManagedIOSStoreApp() *ManagedIOSStoreApp { return p }

// ManagedMobileApp The identifier for the deployment an app.
type ManagedMobileApp struct {
	Entity
	// MobileAppIdentifier The identifier for an app with it's operating system type.
	MobileAppIdentifier *MobileAppIdentifier `json:"mobileAppIdentifier,omitempty"`
	// Version Version of the entity.
	Version *string `json:"version,omitempty"`
}

// IManagedMobileApp interface type for managedMobileApp
type IManagedMobileApp interface {
	PManagedMobileApp() *ManagedMobileApp
}

// PManagedMobileApp pointer method for managedMobileApp
func (p *ManagedMobileApp) PManagedMobileApp() *ManagedMobileApp { return p }

// ManagedMobileLobApp An abstract base class containing properties for all managed mobile line of business apps.
type ManagedMobileLobApp struct {
	ManagedApp
	// CommittedContentVersion The internal committed content version.
	CommittedContentVersion *string `json:"committedContentVersion,omitempty"`
	// FileName The name of the main Lob application file.
	FileName *string `json:"fileName,omitempty"`
	// Size The total size, including all uploaded files.
	Size *int `json:"size,omitempty"`
}

// IManagedMobileLobApp interface type for managedMobileLobApp
type IManagedMobileLobApp interface {
	PManagedMobileLobApp() *ManagedMobileLobApp
}

// PManagedMobileLobApp pointer method for managedMobileLobApp
func (p *ManagedMobileLobApp) PManagedMobileLobApp() *ManagedMobileLobApp { return p }

// MdmWindowsInformationProtectionPolicy Policy for Windows information protection with MDM
type MdmWindowsInformationProtectionPolicy struct {
	WindowsInformationProtection
}

// IMdmWindowsInformationProtectionPolicy interface type for mdmWindowsInformationProtectionPolicy
type IMdmWindowsInformationProtectionPolicy interface {
	PMdmWindowsInformationProtectionPolicy() *MdmWindowsInformationProtectionPolicy
}

// PMdmWindowsInformationProtectionPolicy pointer method for mdmWindowsInformationProtectionPolicy
func (p *MdmWindowsInformationProtectionPolicy) PMdmWindowsInformationProtectionPolicy() *MdmWindowsInformationProtectionPolicy {
	return p
}

// MediaContentRatingAustralia undocumented
type MediaContentRatingAustralia struct {
	// MovieRating Movies rating selected for Australia
	MovieRating *RatingAustraliaMoviesType `json:"movieRating,omitempty"`
	// TvRating TV rating selected for Australia
	TvRating *RatingAustraliaTelevisionType `json:"tvRating,omitempty"`
}

// IMediaContentRatingAustralia interface type for mediaContentRatingAustralia
type IMediaContentRatingAustralia interface {
	PMediaContentRatingAustralia() *MediaContentRatingAustralia
}

// PMediaContentRatingAustralia pointer method for mediaContentRatingAustralia
func (p *MediaContentRatingAustralia) PMediaContentRatingAustralia() *MediaContentRatingAustralia {
	return p
}

// MediaContentRatingCanada undocumented
type MediaContentRatingCanada struct {
	// MovieRating Movies rating selected for Canada
	MovieRating *RatingCanadaMoviesType `json:"movieRating,omitempty"`
	// TvRating TV rating selected for Canada
	TvRating *RatingCanadaTelevisionType `json:"tvRating,omitempty"`
}

// IMediaContentRatingCanada interface type for mediaContentRatingCanada
type IMediaContentRatingCanada interface {
	PMediaContentRatingCanada() *MediaContentRatingCanada
}

// PMediaContentRatingCanada pointer method for mediaContentRatingCanada
func (p *MediaContentRatingCanada) PMediaContentRatingCanada() *MediaContentRatingCanada { return p }

// MediaContentRatingFrance undocumented
type MediaContentRatingFrance struct {
	// MovieRating Movies rating selected for France
	MovieRating *RatingFranceMoviesType `json:"movieRating,omitempty"`
	// TvRating TV rating selected for France
	TvRating *RatingFranceTelevisionType `json:"tvRating,omitempty"`
}

// IMediaContentRatingFrance interface type for mediaContentRatingFrance
type IMediaContentRatingFrance interface {
	PMediaContentRatingFrance() *MediaContentRatingFrance
}

// PMediaContentRatingFrance pointer method for mediaContentRatingFrance
func (p *MediaContentRatingFrance) PMediaContentRatingFrance() *MediaContentRatingFrance { return p }

// MediaContentRatingGermany undocumented
type MediaContentRatingGermany struct {
	// MovieRating Movies rating selected for Germany
	MovieRating *RatingGermanyMoviesType `json:"movieRating,omitempty"`
	// TvRating TV rating selected for Germany
	TvRating *RatingGermanyTelevisionType `json:"tvRating,omitempty"`
}

// IMediaContentRatingGermany interface type for mediaContentRatingGermany
type IMediaContentRatingGermany interface {
	PMediaContentRatingGermany() *MediaContentRatingGermany
}

// PMediaContentRatingGermany pointer method for mediaContentRatingGermany
func (p *MediaContentRatingGermany) PMediaContentRatingGermany() *MediaContentRatingGermany { return p }

// MediaContentRatingIreland undocumented
type MediaContentRatingIreland struct {
	// MovieRating Movies rating selected for Ireland
	MovieRating *RatingIrelandMoviesType `json:"movieRating,omitempty"`
	// TvRating TV rating selected for Ireland
	TvRating *RatingIrelandTelevisionType `json:"tvRating,omitempty"`
}

// IMediaContentRatingIreland interface type for mediaContentRatingIreland
type IMediaContentRatingIreland interface {
	PMediaContentRatingIreland() *MediaContentRatingIreland
}

// PMediaContentRatingIreland pointer method for mediaContentRatingIreland
func (p *MediaContentRatingIreland) PMediaContentRatingIreland() *MediaContentRatingIreland { return p }

// MediaContentRatingJapan undocumented
type MediaContentRatingJapan struct {
	// MovieRating Movies rating selected for Japan
	MovieRating *RatingJapanMoviesType `json:"movieRating,omitempty"`
	// TvRating TV rating selected for Japan
	TvRating *RatingJapanTelevisionType `json:"tvRating,omitempty"`
}

// IMediaContentRatingJapan interface type for mediaContentRatingJapan
type IMediaContentRatingJapan interface {
	PMediaContentRatingJapan() *MediaContentRatingJapan
}

// PMediaContentRatingJapan pointer method for mediaContentRatingJapan
func (p *MediaContentRatingJapan) PMediaContentRatingJapan() *MediaContentRatingJapan { return p }

// MediaContentRatingNewZealand undocumented
type MediaContentRatingNewZealand struct {
	// MovieRating Movies rating selected for New Zealand
	MovieRating *RatingNewZealandMoviesType `json:"movieRating,omitempty"`
	// TvRating TV rating selected for New Zealand
	TvRating *RatingNewZealandTelevisionType `json:"tvRating,omitempty"`
}

// IMediaContentRatingNewZealand interface type for mediaContentRatingNewZealand
type IMediaContentRatingNewZealand interface {
	PMediaContentRatingNewZealand() *MediaContentRatingNewZealand
}

// PMediaContentRatingNewZealand pointer method for mediaContentRatingNewZealand
func (p *MediaContentRatingNewZealand) PMediaContentRatingNewZealand() *MediaContentRatingNewZealand {
	return p
}

// MediaContentRatingUnitedKingdom undocumented
type MediaContentRatingUnitedKingdom struct {
	// MovieRating Movies rating selected for United Kingdom
	MovieRating *RatingUnitedKingdomMoviesType `json:"movieRating,omitempty"`
	// TvRating TV rating selected for United Kingdom
	TvRating *RatingUnitedKingdomTelevisionType `json:"tvRating,omitempty"`
}

// IMediaContentRatingUnitedKingdom interface type for mediaContentRatingUnitedKingdom
type IMediaContentRatingUnitedKingdom interface {
	PMediaContentRatingUnitedKingdom() *MediaContentRatingUnitedKingdom
}

// PMediaContentRatingUnitedKingdom pointer method for mediaContentRatingUnitedKingdom
func (p *MediaContentRatingUnitedKingdom) PMediaContentRatingUnitedKingdom() *MediaContentRatingUnitedKingdom {
	return p
}

// MediaContentRatingUnitedStates undocumented
type MediaContentRatingUnitedStates struct {
	// MovieRating Movies rating selected for United States
	MovieRating *RatingUnitedStatesMoviesType `json:"movieRating,omitempty"`
	// TvRating TV rating selected for United States
	TvRating *RatingUnitedStatesTelevisionType `json:"tvRating,omitempty"`
}

// IMediaContentRatingUnitedStates interface type for mediaContentRatingUnitedStates
type IMediaContentRatingUnitedStates interface {
	PMediaContentRatingUnitedStates() *MediaContentRatingUnitedStates
}

// PMediaContentRatingUnitedStates pointer method for mediaContentRatingUnitedStates
func (p *MediaContentRatingUnitedStates) PMediaContentRatingUnitedStates() *MediaContentRatingUnitedStates {
	return p
}

// MeetingTimeSuggestion undocumented
type MeetingTimeSuggestion struct {
	// Confidence undocumented
	Confidence *float64 `json:"confidence,omitempty"`
	// Order undocumented
	Order *int `json:"order,omitempty"`
	// OrganizerAvailability undocumented
	OrganizerAvailability *FreeBusyStatus `json:"organizerAvailability,omitempty"`
	// AttendeeAvailability undocumented
	AttendeeAvailability []AttendeeAvailability `json:"attendeeAvailability,omitempty"`
	// Locations undocumented
	Locations []Location `json:"locations,omitempty"`
	// SuggestionReason undocumented
	SuggestionReason *string `json:"suggestionReason,omitempty"`
	// MeetingTimeSlot undocumented
	MeetingTimeSlot *TimeSlot `json:"meetingTimeSlot,omitempty"`
}

// IMeetingTimeSuggestion interface type for meetingTimeSuggestion
type IMeetingTimeSuggestion interface {
	PMeetingTimeSuggestion() *MeetingTimeSuggestion
}

// PMeetingTimeSuggestion pointer method for meetingTimeSuggestion
func (p *MeetingTimeSuggestion) PMeetingTimeSuggestion() *MeetingTimeSuggestion { return p }

// MeetingTimeSuggestionsResult undocumented
type MeetingTimeSuggestionsResult struct {
	// MeetingTimeSuggestions undocumented
	MeetingTimeSuggestions []MeetingTimeSuggestion `json:"meetingTimeSuggestions,omitempty"`
	// EmptySuggestionsReason undocumented
	EmptySuggestionsReason *string `json:"emptySuggestionsReason,omitempty"`
}

// IMeetingTimeSuggestionsResult interface type for meetingTimeSuggestionsResult
type IMeetingTimeSuggestionsResult interface {
	PMeetingTimeSuggestionsResult() *MeetingTimeSuggestionsResult
}

// PMeetingTimeSuggestionsResult pointer method for meetingTimeSuggestionsResult
func (p *MeetingTimeSuggestionsResult) PMeetingTimeSuggestionsResult() *MeetingTimeSuggestionsResult {
	return p
}

// Message undocumented
type Message struct {
	OutlookItem
	// ReceivedDateTime undocumented
	ReceivedDateTime *time.Time `json:"receivedDateTime,omitempty"`
	// SentDateTime undocumented
	SentDateTime *time.Time `json:"sentDateTime,omitempty"`
	// HasAttachments undocumented
	HasAttachments *bool `json:"hasAttachments,omitempty"`
	// InternetMessageId undocumented
	InternetMessageId *string `json:"internetMessageId,omitempty"`
	// InternetMessageHeaders undocumented
	InternetMessageHeaders []InternetMessageHeader `json:"internetMessageHeaders,omitempty"`
	// Subject undocumented
	Subject *string `json:"subject,omitempty"`
	// Body undocumented
	Body *ItemBody `json:"body,omitempty"`
	// BodyPreview undocumented
	BodyPreview *string `json:"bodyPreview,omitempty"`
	// Importance undocumented
	Importance *Importance `json:"importance,omitempty"`
	// ParentFolderId undocumented
	ParentFolderId *string `json:"parentFolderId,omitempty"`
	// Sender undocumented
	Sender *Recipient `json:"sender,omitempty"`
	// From undocumented
	From *Recipient `json:"from,omitempty"`
	// ToRecipients undocumented
	ToRecipients []Recipient `json:"toRecipients,omitempty"`
	// CcRecipients undocumented
	CcRecipients []Recipient `json:"ccRecipients,omitempty"`
	// BccRecipients undocumented
	BccRecipients []Recipient `json:"bccRecipients,omitempty"`
	// ReplyTo undocumented
	ReplyTo []Recipient `json:"replyTo,omitempty"`
	// ConversationId undocumented
	ConversationId *string `json:"conversationId,omitempty"`
	// UniqueBody undocumented
	UniqueBody *ItemBody `json:"uniqueBody,omitempty"`
	// IsDeliveryReceiptRequested undocumented
	IsDeliveryReceiptRequested *bool `json:"isDeliveryReceiptRequested,omitempty"`
	// IsReadReceiptRequested undocumented
	IsReadReceiptRequested *bool `json:"isReadReceiptRequested,omitempty"`
	// IsRead undocumented
	IsRead *bool `json:"isRead,omitempty"`
	// IsDraft undocumented
	IsDraft *bool `json:"isDraft,omitempty"`
	// WebLink undocumented
	WebLink *string `json:"webLink,omitempty"`
	// InferenceClassification undocumented
	InferenceClassification *InferenceClassificationType `json:"inferenceClassification,omitempty"`
	// Flag undocumented
	Flag *FollowupFlag `json:"flag,omitempty"`
}

// IMessage interface type for message
type IMessage interface {
	PMessage() *Message
}

// PMessage pointer method for message
func (p *Message) PMessage() *Message { return p }

// MessageRule undocumented
type MessageRule struct {
	Entity
	// DisplayName undocumented
	DisplayName *string `json:"displayName,omitempty"`
	// Sequence undocumented
	Sequence *int `json:"sequence,omitempty"`
	// Conditions undocumented
	Conditions *MessageRulePredicates `json:"conditions,omitempty"`
	// Actions undocumented
	Actions *MessageRuleActions `json:"actions,omitempty"`
	// Exceptions undocumented
	Exceptions *MessageRulePredicates `json:"exceptions,omitempty"`
	// IsEnabled undocumented
	IsEnabled *bool `json:"isEnabled,omitempty"`
	// HasError undocumented
	HasError *bool `json:"hasError,omitempty"`
	// IsReadOnly undocumented
	IsReadOnly *bool `json:"isReadOnly,omitempty"`
}

// IMessageRule interface type for messageRule
type IMessageRule interface {
	PMessageRule() *MessageRule
}

// PMessageRule pointer method for messageRule
func (p *MessageRule) PMessageRule() *MessageRule { return p }

// MessageRuleActions undocumented
type MessageRuleActions struct {
	// MoveToFolder undocumented
	MoveToFolder *string `json:"moveToFolder,omitempty"`
	// CopyToFolder undocumented
	CopyToFolder *string `json:"copyToFolder,omitempty"`
	// Delete undocumented
	Delete *bool `json:"delete,omitempty"`
	// PermanentDelete undocumented
	PermanentDelete *bool `json:"permanentDelete,omitempty"`
	// MarkAsRead undocumented
	MarkAsRead *bool `json:"markAsRead,omitempty"`
	// MarkImportance undocumented
	MarkImportance *Importance `json:"markImportance,omitempty"`
	// ForwardTo undocumented
	ForwardTo []Recipient `json:"forwardTo,omitempty"`
	// ForwardAsAttachmentTo undocumented
	ForwardAsAttachmentTo []Recipient `json:"forwardAsAttachmentTo,omitempty"`
	// RedirectTo undocumented
	RedirectTo []Recipient `json:"redirectTo,omitempty"`
	// AssignCategories undocumented
	AssignCategories []string `json:"assignCategories,omitempty"`
	// StopProcessingRules undocumented
	StopProcessingRules *bool `json:"stopProcessingRules,omitempty"`
}

// IMessageRuleActions interface type for messageRuleActions
type IMessageRuleActions interface {
	PMessageRuleActions() *MessageRuleActions
}

// PMessageRuleActions pointer method for messageRuleActions
func (p *MessageRuleActions) PMessageRuleActions() *MessageRuleActions { return p }

// MessageRulePredicates undocumented
type MessageRulePredicates struct {
	// Categories undocumented
	Categories []string `json:"categories,omitempty"`
	// SubjectContains undocumented
	SubjectContains []string `json:"subjectContains,omitempty"`
	// BodyContains undocumented
	BodyContains []string `json:"bodyContains,omitempty"`
	// BodyOrSubjectContains undocumented
	BodyOrSubjectContains []string `json:"bodyOrSubjectContains,omitempty"`
	// SenderContains undocumented
	SenderContains []string `json:"senderContains,omitempty"`
	// RecipientContains undocumented
	RecipientContains []string `json:"recipientContains,omitempty"`
	// HeaderContains undocumented
	HeaderContains []string `json:"headerContains,omitempty"`
	// MessageActionFlag undocumented
	MessageActionFlag *MessageActionFlag `json:"messageActionFlag,omitempty"`
	// Importance undocumented
	Importance *Importance `json:"importance,omitempty"`
	// Sensitivity undocumented
	Sensitivity *Sensitivity `json:"sensitivity,omitempty"`
	// FromAddresses undocumented
	FromAddresses []Recipient `json:"fromAddresses,omitempty"`
	// SentToAddresses undocumented
	SentToAddresses []Recipient `json:"sentToAddresses,omitempty"`
	// SentToMe undocumented
	SentToMe *bool `json:"sentToMe,omitempty"`
	// SentOnlyToMe undocumented
	SentOnlyToMe *bool `json:"sentOnlyToMe,omitempty"`
	// SentCcMe undocumented
	SentCcMe *bool `json:"sentCcMe,omitempty"`
	// SentToOrCcMe undocumented
	SentToOrCcMe *bool `json:"sentToOrCcMe,omitempty"`
	// NotSentToMe undocumented
	NotSentToMe *bool `json:"notSentToMe,omitempty"`
	// HasAttachments undocumented
	HasAttachments *bool `json:"hasAttachments,omitempty"`
	// IsApprovalRequest undocumented
	IsApprovalRequest *bool `json:"isApprovalRequest,omitempty"`
	// IsAutomaticForward undocumented
	IsAutomaticForward *bool `json:"isAutomaticForward,omitempty"`
	// IsAutomaticReply undocumented
	IsAutomaticReply *bool `json:"isAutomaticReply,omitempty"`
	// IsEncrypted undocumented
	IsEncrypted *bool `json:"isEncrypted,omitempty"`
	// IsMeetingRequest undocumented
	IsMeetingRequest *bool `json:"isMeetingRequest,omitempty"`
	// IsMeetingResponse undocumented
	IsMeetingResponse *bool `json:"isMeetingResponse,omitempty"`
	// IsNonDeliveryReport undocumented
	IsNonDeliveryReport *bool `json:"isNonDeliveryReport,omitempty"`
	// IsPermissionControlled undocumented
	IsPermissionControlled *bool `json:"isPermissionControlled,omitempty"`
	// IsReadReceipt undocumented
	IsReadReceipt *bool `json:"isReadReceipt,omitempty"`
	// IsSigned undocumented
	IsSigned *bool `json:"isSigned,omitempty"`
	// IsVoicemail undocumented
	IsVoicemail *bool `json:"isVoicemail,omitempty"`
	// WithinSizeRange undocumented
	WithinSizeRange *SizeRange `json:"withinSizeRange,omitempty"`
}

// IMessageRulePredicates interface type for messageRulePredicates
type IMessageRulePredicates interface {
	PMessageRulePredicates() *MessageRulePredicates
}

// PMessageRulePredicates pointer method for messageRulePredicates
func (p *MessageRulePredicates) PMessageRulePredicates() *MessageRulePredicates { return p }

// MicrosoftStoreForBusinessApp Microsoft Store for Business Apps. This class does not support Create, Delete, or Update.
type MicrosoftStoreForBusinessApp struct {
	MobileApp
	// UsedLicenseCount The number of Microsoft Store for Business licenses in use.
	UsedLicenseCount *int `json:"usedLicenseCount,omitempty"`
	// TotalLicenseCount The total number of Microsoft Store for Business licenses.
	TotalLicenseCount *int `json:"totalLicenseCount,omitempty"`
	// ProductKey The app product key
	ProductKey *string `json:"productKey,omitempty"`
	// LicenseType The app license type
	LicenseType *MicrosoftStoreForBusinessLicenseType `json:"licenseType,omitempty"`
	// PackageIdentityName The app package identifier
	PackageIdentityName *string `json:"packageIdentityName,omitempty"`
}

// IMicrosoftStoreForBusinessApp interface type for microsoftStoreForBusinessApp
type IMicrosoftStoreForBusinessApp interface {
	PMicrosoftStoreForBusinessApp() *MicrosoftStoreForBusinessApp
}

// PMicrosoftStoreForBusinessApp pointer method for microsoftStoreForBusinessApp
func (p *MicrosoftStoreForBusinessApp) PMicrosoftStoreForBusinessApp() *MicrosoftStoreForBusinessApp {
	return p
}

// MicrosoftStoreForBusinessAppAssignmentSettings undocumented
type MicrosoftStoreForBusinessAppAssignmentSettings struct {
	MobileAppAssignmentSettings
	// UseDeviceContext Whether or not to use device execution context for Microsoft Store for Business mobile app.
	UseDeviceContext *bool `json:"useDeviceContext,omitempty"`
}

// IMicrosoftStoreForBusinessAppAssignmentSettings interface type for microsoftStoreForBusinessAppAssignmentSettings
type IMicrosoftStoreForBusinessAppAssignmentSettings interface {
	PMicrosoftStoreForBusinessAppAssignmentSettings() *MicrosoftStoreForBusinessAppAssignmentSettings
}

// PMicrosoftStoreForBusinessAppAssignmentSettings pointer method for microsoftStoreForBusinessAppAssignmentSettings
func (p *MicrosoftStoreForBusinessAppAssignmentSettings) PMicrosoftStoreForBusinessAppAssignmentSettings() *MicrosoftStoreForBusinessAppAssignmentSettings {
	return p
}

// MimeContent undocumented
type MimeContent struct {
	// Type Indicates the content mime type.
	Type *string `json:"type,omitempty"`
	// Value The byte array that contains the actual content.
	Value *Binary `json:"value,omitempty"`
}

// IMimeContent interface type for mimeContent
type IMimeContent interface {
	PMimeContent() *MimeContent
}

// PMimeContent pointer method for mimeContent
func (p *MimeContent) PMimeContent() *MimeContent { return p }

// MobileApp An abstract class containing the base properties for Intune mobile apps.
type MobileApp struct {
	Entity
	// DisplayName The admin provided or imported title of the app.
	DisplayName *string `json:"displayName,omitempty"`
	// Description The description of the app.
	Description *string `json:"description,omitempty"`
	// Publisher The publisher of the app.
	Publisher *string `json:"publisher,omitempty"`
	// LargeIcon The large icon, to be displayed in the app details and used for upload of the icon.
	LargeIcon *MimeContent `json:"largeIcon,omitempty"`
	// CreatedDateTime The date and time the app was created.
	CreatedDateTime *time.Time `json:"createdDateTime,omitempty"`
	// LastModifiedDateTime The date and time the app was last modified.
	LastModifiedDateTime *time.Time `json:"lastModifiedDateTime,omitempty"`
	// IsFeatured The value indicating whether the app is marked as featured by the admin.
	IsFeatured *bool `json:"isFeatured,omitempty"`
	// PrivacyInformationUrl The privacy statement Url.
	PrivacyInformationUrl *string `json:"privacyInformationUrl,omitempty"`
	// InformationUrl The more information Url.
	InformationUrl *string `json:"informationUrl,omitempty"`
	// Owner The owner of the app.
	Owner *string `json:"owner,omitempty"`
	// Developer The developer of the app.
	Developer *string `json:"developer,omitempty"`
	// Notes Notes for the app.
	Notes *string `json:"notes,omitempty"`
	// PublishingState The publishing state for the app. The app cannot be assigned unless the app is published.
	PublishingState *MobileAppPublishingState `json:"publishingState,omitempty"`
}

// IMobileApp interface type for mobileApp
type IMobileApp interface {
	PMobileApp() *MobileApp
}

// PMobileApp pointer method for mobileApp
func (p *MobileApp) PMobileApp() *MobileApp { return p }

// MobileAppAssignment A class containing the properties used for Group Assignment of a Mobile App.
type MobileAppAssignment struct {
	Entity
	// Intent The install intent defined by the admin.
	Intent *InstallIntent `json:"intent,omitempty"`
	// Target The target group assignment defined by the admin.
	Target *DeviceAndAppManagementAssignmentTarget `json:"target,omitempty"`
	// Settings The settings for target assignment defined by the admin.
	Settings *MobileAppAssignmentSettings `json:"settings,omitempty"`
}

// IMobileAppAssignment interface type for mobileAppAssignment
type IMobileAppAssignment interface {
	PMobileAppAssignment() *MobileAppAssignment
}

// PMobileAppAssignment pointer method for mobileAppAssignment
func (p *MobileAppAssignment) PMobileAppAssignment() *MobileAppAssignment { return p }

// MobileAppAssignmentSettings undocumented
type MobileAppAssignmentSettings struct {
}

// IMobileAppAssignmentSettings interface type for mobileAppAssignmentSettings
type IMobileAppAssignmentSettings interface {
	PMobileAppAssignmentSettings() *MobileAppAssignmentSettings
}

// PMobileAppAssignmentSettings pointer method for mobileAppAssignmentSettings
func (p *MobileAppAssignmentSettings) PMobileAppAssignmentSettings() *MobileAppAssignmentSettings {
	return p
}

// MobileAppCategory Contains properties for a single Intune app category.
type MobileAppCategory struct {
	Entity
	// DisplayName The name of the app category.
	DisplayName *string `json:"displayName,omitempty"`
	// LastModifiedDateTime The date and time the mobileAppCategory was last modified.
	LastModifiedDateTime *time.Time `json:"lastModifiedDateTime,omitempty"`
}

// IMobileAppCategory interface type for mobileAppCategory
type IMobileAppCategory interface {
	PMobileAppCategory() *MobileAppCategory
}

// PMobileAppCategory pointer method for mobileAppCategory
func (p *MobileAppCategory) PMobileAppCategory() *MobileAppCategory { return p }

// MobileAppContent Contains content properties for a specific app version. Each mobileAppContent can have multiple mobileAppContentFile.
type MobileAppContent struct {
	Entity
}

// IMobileAppContent interface type for mobileAppContent
type IMobileAppContent interface {
	PMobileAppContent() *MobileAppContent
}

// PMobileAppContent pointer method for mobileAppContent
func (p *MobileAppContent) PMobileAppContent() *MobileAppContent { return p }

// MobileAppContentFile Contains properties for a single installer file that is associated with a given mobileAppContent version.
type MobileAppContentFile struct {
	Entity
	// AzureStorageUri The Azure Storage URI.
	AzureStorageUri *string `json:"azureStorageUri,omitempty"`
	// IsCommitted A value indicating whether the file is committed.
	IsCommitted *bool `json:"isCommitted,omitempty"`
	// CreatedDateTime The time the file was created.
	CreatedDateTime *time.Time `json:"createdDateTime,omitempty"`
	// Name the file name.
	Name *string `json:"name,omitempty"`
	// Size The size of the file prior to encryption.
	Size *int `json:"size,omitempty"`
	// SizeEncrypted The size of the file after encryption.
	SizeEncrypted *int `json:"sizeEncrypted,omitempty"`
	// AzureStorageUriExpirationDateTime The time the Azure storage Uri expires.
	AzureStorageUriExpirationDateTime *time.Time `json:"azureStorageUriExpirationDateTime,omitempty"`
	// Manifest The manifest information.
	Manifest *Binary `json:"manifest,omitempty"`
	// UploadState The state of the current upload request.
	UploadState *MobileAppContentFileUploadState `json:"uploadState,omitempty"`
}

// IMobileAppContentFile interface type for mobileAppContentFile
type IMobileAppContentFile interface {
	PMobileAppContentFile() *MobileAppContentFile
}

// PMobileAppContentFile pointer method for mobileAppContentFile
func (p *MobileAppContentFile) PMobileAppContentFile() *MobileAppContentFile { return p }

// MobileAppIdentifier undocumented
type MobileAppIdentifier struct {
}

// IMobileAppIdentifier interface type for mobileAppIdentifier
type IMobileAppIdentifier interface {
	PMobileAppIdentifier() *MobileAppIdentifier
}

// PMobileAppIdentifier pointer method for mobileAppIdentifier
func (p *MobileAppIdentifier) PMobileAppIdentifier() *MobileAppIdentifier { return p }

// MobileLobApp An abstract base class containing properties for all mobile line of business apps.
type MobileLobApp struct {
	MobileApp
	// CommittedContentVersion The internal committed content version.
	CommittedContentVersion *string `json:"committedContentVersion,omitempty"`
	// FileName The name of the main Lob application file.
	FileName *string `json:"fileName,omitempty"`
	// Size The total size, including all uploaded files.
	Size *int `json:"size,omitempty"`
}

// IMobileLobApp interface type for mobileLobApp
type IMobileLobApp interface {
	PMobileLobApp() *MobileLobApp
}

// PMobileLobApp pointer method for mobileLobApp
func (p *MobileLobApp) PMobileLobApp() *MobileLobApp { return p }

// MobileThreatDefenseConnector Entity which represents a connection to Mobile threat defense partner.
type MobileThreatDefenseConnector struct {
	Entity
	// LastHeartbeatDateTime DateTime of last Heartbeat recieved from the Data Sync Partner
	LastHeartbeatDateTime *time.Time `json:"lastHeartbeatDateTime,omitempty"`
	// PartnerState Data Sync Partner state for this account
	PartnerState *MobileThreatPartnerTenantState `json:"partnerState,omitempty"`
	// AndroidEnabled For Android, set whether data from the data sync partner should be used during compliance evaluations
	AndroidEnabled *bool `json:"androidEnabled,omitempty"`
	// IosEnabled For IOS, get or set whether data from the data sync partner should be used during compliance evaluations
	IosEnabled *bool `json:"iosEnabled,omitempty"`
	// AndroidDeviceBlockedOnMissingPartnerData For Android, set whether Intune must receive data from the data sync partner prior to marking a device compliant
	AndroidDeviceBlockedOnMissingPartnerData *bool `json:"androidDeviceBlockedOnMissingPartnerData,omitempty"`
	// IosDeviceBlockedOnMissingPartnerData For IOS, set whether Intune must receive data from the data sync partner prior to marking a device compliant
	IosDeviceBlockedOnMissingPartnerData *bool `json:"iosDeviceBlockedOnMissingPartnerData,omitempty"`
	// PartnerUnsupportedOsVersionBlocked Get or set whether to block devices on the enabled platforms that do not meet the minimum version requirements of the Data Sync Partner
	PartnerUnsupportedOsVersionBlocked *bool `json:"partnerUnsupportedOsVersionBlocked,omitempty"`
	// PartnerUnresponsivenessThresholdInDays Get or Set days the per tenant tolerance to unresponsiveness for this partner integration
	PartnerUnresponsivenessThresholdInDays *int `json:"partnerUnresponsivenessThresholdInDays,omitempty"`
}

// IMobileThreatDefenseConnector interface type for mobileThreatDefenseConnector
type IMobileThreatDefenseConnector interface {
	PMobileThreatDefenseConnector() *MobileThreatDefenseConnector
}

// PMobileThreatDefenseConnector pointer method for mobileThreatDefenseConnector
func (p *MobileThreatDefenseConnector) PMobileThreatDefenseConnector() *MobileThreatDefenseConnector {
	return p
}

// ModifiedProperty undocumented
type ModifiedProperty struct {
	// DisplayName undocumented
	DisplayName *string `json:"displayName,omitempty"`
	// OldValue undocumented
	OldValue *string `json:"oldValue,omitempty"`
	// NewValue undocumented
	NewValue *string `json:"newValue,omitempty"`
}

// IModifiedProperty interface type for modifiedProperty
type IModifiedProperty interface {
	PModifiedProperty() *ModifiedProperty
}

// PModifiedProperty pointer method for modifiedProperty
func (p *ModifiedProperty) PModifiedProperty() *ModifiedProperty { return p }

// MultiValueLegacyExtendedProperty undocumented
type MultiValueLegacyExtendedProperty struct {
	Entity
	// Value undocumented
	Value []string `json:"value,omitempty"`
}

// IMultiValueLegacyExtendedProperty interface type for multiValueLegacyExtendedProperty
type IMultiValueLegacyExtendedProperty interface {
	PMultiValueLegacyExtendedProperty() *MultiValueLegacyExtendedProperty
}

// PMultiValueLegacyExtendedProperty pointer method for multiValueLegacyExtendedProperty
func (p *MultiValueLegacyExtendedProperty) PMultiValueLegacyExtendedProperty() *MultiValueLegacyExtendedProperty {
	return p
}

// NetworkConnection undocumented
type NetworkConnection struct {
	// ApplicationName undocumented
	ApplicationName *string `json:"applicationName,omitempty"`
	// DestinationAddress undocumented
	DestinationAddress *string `json:"destinationAddress,omitempty"`
	// DestinationDomain undocumented
	DestinationDomain *string `json:"destinationDomain,omitempty"`
	// DestinationPort undocumented
	DestinationPort *string `json:"destinationPort,omitempty"`
	// DestinationUrl undocumented
	DestinationUrl *string `json:"destinationUrl,omitempty"`
	// Direction undocumented
	Direction *ConnectionDirection `json:"direction,omitempty"`
	// DomainRegisteredDateTime undocumented
	DomainRegisteredDateTime *time.Time `json:"domainRegisteredDateTime,omitempty"`
	// LocalDnsName undocumented
	LocalDnsName *string `json:"localDnsName,omitempty"`
	// NatDestinationAddress undocumented
	NatDestinationAddress *string `json:"natDestinationAddress,omitempty"`
	// NatDestinationPort undocumented
	NatDestinationPort *string `json:"natDestinationPort,omitempty"`
	// NatSourceAddress undocumented
	NatSourceAddress *string `json:"natSourceAddress,omitempty"`
	// NatSourcePort undocumented
	NatSourcePort *string `json:"natSourcePort,omitempty"`
	// Protocol undocumented
	Protocol *SecurityNetworkProtocol `json:"protocol,omitempty"`
	// RiskScore undocumented
	RiskScore *string `json:"riskScore,omitempty"`
	// SourceAddress undocumented
	SourceAddress *string `json:"sourceAddress,omitempty"`
	// SourcePort undocumented
	SourcePort *string `json:"sourcePort,omitempty"`
	// Status undocumented
	Status *ConnectionStatus `json:"status,omitempty"`
	// UrlParameters undocumented
	UrlParameters *string `json:"urlParameters,omitempty"`
}

// INetworkConnection interface type for networkConnection
type INetworkConnection interface {
	PNetworkConnection() *NetworkConnection
}

// PNetworkConnection pointer method for networkConnection
func (p *NetworkConnection) PNetworkConnection() *NetworkConnection { return p }

// Notebook undocumented
type Notebook struct {
	OnenoteEntityHierarchyModel
	// IsDefault undocumented
	IsDefault *bool `json:"isDefault,omitempty"`
	// UserRole undocumented
	UserRole *OnenoteUserRole `json:"userRole,omitempty"`
	// IsShared undocumented
	IsShared *bool `json:"isShared,omitempty"`
	// SectionsUrl undocumented
	SectionsUrl *string `json:"sectionsUrl,omitempty"`
	// SectionGroupsUrl undocumented
	SectionGroupsUrl *string `json:"sectionGroupsUrl,omitempty"`
	// Links undocumented
	Links *NotebookLinks `json:"links,omitempty"`
}

// INotebook interface type for notebook
type INotebook interface {
	PNotebook() *Notebook
}

// PNotebook pointer method for notebook
func (p *Notebook) PNotebook() *Notebook { return p }

// NotebookLinks undocumented
type NotebookLinks struct {
	// OneNoteClientUrl undocumented
	OneNoteClientUrl *ExternalLink `json:"oneNoteClientUrl,omitempty"`
	// OneNoteWebUrl undocumented
	OneNoteWebUrl *ExternalLink `json:"oneNoteWebUrl,omitempty"`
}

// INotebookLinks interface type for notebookLinks
type INotebookLinks interface {
	PNotebookLinks() *NotebookLinks
}

// PNotebookLinks pointer method for notebookLinks
func (p *NotebookLinks) PNotebookLinks() *NotebookLinks { return p }

// NotificationMessageTemplate Notification messages are messages that are sent to end users who are determined to be not-compliant with the compliance policies defined by the administrator. Administrators choose notifications and configure them in the Intune Admin Console using the compliance policy creation page under the Actions for non-compliance section. Use the notificationMessageTemplate object to create your own custom notifications for administrators to choose while configuring actions for non-compliance.
type NotificationMessageTemplate struct {
	Entity
	// LastModifiedDateTime DateTime the object was last modified.
	LastModifiedDateTime *time.Time `json:"lastModifiedDateTime,omitempty"`
	// DisplayName Display name for the Notification Message Template.
	DisplayName *string `json:"displayName,omitempty"`
	// DefaultLocale The default locale to fallback onto when the requested locale is not available.
	DefaultLocale *string `json:"defaultLocale,omitempty"`
	// BrandingOptions The Message Template Branding Options. Branding is defined in the Intune Admin Console.
	BrandingOptions *NotificationTemplateBrandingOptions `json:"brandingOptions,omitempty"`
}

// INotificationMessageTemplate interface type for notificationMessageTemplate
type INotificationMessageTemplate interface {
	PNotificationMessageTemplate() *NotificationMessageTemplate
}

// PNotificationMessageTemplate pointer method for notificationMessageTemplate
func (p *NotificationMessageTemplate) PNotificationMessageTemplate() *NotificationMessageTemplate {
	return p
}

// NumberColumn undocumented
type NumberColumn struct {
	// DecimalPlaces undocumented
	DecimalPlaces *string `json:"decimalPlaces,omitempty"`
	// DisplayAs undocumented
	DisplayAs *string `json:"displayAs,omitempty"`
	// Maximum undocumented
	Maximum *float64 `json:"maximum,omitempty"`
	// Minimum undocumented
	Minimum *float64 `json:"minimum,omitempty"`
}

// INumberColumn interface type for numberColumn
type INumberColumn interface {
	PNumberColumn() *NumberColumn
}

// PNumberColumn pointer method for numberColumn
func (p *NumberColumn) PNumberColumn() *NumberColumn { return p }

// OfficeGraphInsights undocumented
type OfficeGraphInsights struct {
	Entity
}

// IOfficeGraphInsights interface type for officeGraphInsights
type IOfficeGraphInsights interface {
	POfficeGraphInsights() *OfficeGraphInsights
}

// POfficeGraphInsights pointer method for officeGraphInsights
func (p *OfficeGraphInsights) POfficeGraphInsights() *OfficeGraphInsights { return p }

// OmaSetting undocumented
type OmaSetting struct {
	// DisplayName Display Name.
	DisplayName *string `json:"displayName,omitempty"`
	// Description Description.
	Description *string `json:"description,omitempty"`
	// OmaUri OMA.
	OmaUri *string `json:"omaUri,omitempty"`
}

// IOmaSetting interface type for omaSetting
type IOmaSetting interface {
	POmaSetting() *OmaSetting
}

// POmaSetting pointer method for omaSetting
func (p *OmaSetting) POmaSetting() *OmaSetting { return p }

// OmaSettingBase64 undocumented
type OmaSettingBase64 struct {
	OmaSetting
	// FileName File name associated with the Value property (*.cer | *.crt | *.p7b | *.bin).
	FileName *string `json:"fileName,omitempty"`
	// Value Value. (Base64 encoded string)
	Value *string `json:"value,omitempty"`
}

// IOmaSettingBase64 interface type for omaSettingBase64
type IOmaSettingBase64 interface {
	POmaSettingBase64() *OmaSettingBase64
}

// POmaSettingBase64 pointer method for omaSettingBase64
func (p *OmaSettingBase64) POmaSettingBase64() *OmaSettingBase64 { return p }

// OmaSettingBoolean undocumented
type OmaSettingBoolean struct {
	OmaSetting
	// Value Value.
	Value *bool `json:"value,omitempty"`
}

// IOmaSettingBoolean interface type for omaSettingBoolean
type IOmaSettingBoolean interface {
	POmaSettingBoolean() *OmaSettingBoolean
}

// POmaSettingBoolean pointer method for omaSettingBoolean
func (p *OmaSettingBoolean) POmaSettingBoolean() *OmaSettingBoolean { return p }

// OmaSettingDateTime undocumented
type OmaSettingDateTime struct {
	OmaSetting
	// Value Value.
	Value *time.Time `json:"value,omitempty"`
}

// IOmaSettingDateTime interface type for omaSettingDateTime
type IOmaSettingDateTime interface {
	POmaSettingDateTime() *OmaSettingDateTime
}

// POmaSettingDateTime pointer method for omaSettingDateTime
func (p *OmaSettingDateTime) POmaSettingDateTime() *OmaSettingDateTime { return p }

// OmaSettingFloatingPoint undocumented
type OmaSettingFloatingPoint struct {
	OmaSetting
	// Value Value.
	Value *float64 `json:"value,omitempty"`
}

// IOmaSettingFloatingPoint interface type for omaSettingFloatingPoint
type IOmaSettingFloatingPoint interface {
	POmaSettingFloatingPoint() *OmaSettingFloatingPoint
}

// POmaSettingFloatingPoint pointer method for omaSettingFloatingPoint
func (p *OmaSettingFloatingPoint) POmaSettingFloatingPoint() *OmaSettingFloatingPoint { return p }

// OmaSettingInteger undocumented
type OmaSettingInteger struct {
	OmaSetting
	// Value Value.
	Value *int `json:"value,omitempty"`
}

// IOmaSettingInteger interface type for omaSettingInteger
type IOmaSettingInteger interface {
	POmaSettingInteger() *OmaSettingInteger
}

// POmaSettingInteger pointer method for omaSettingInteger
func (p *OmaSettingInteger) POmaSettingInteger() *OmaSettingInteger { return p }

// OmaSettingString undocumented
type OmaSettingString struct {
	OmaSetting
	// Value Value.
	Value *string `json:"value,omitempty"`
}

// IOmaSettingString interface type for omaSettingString
type IOmaSettingString interface {
	POmaSettingString() *OmaSettingString
}

// POmaSettingString pointer method for omaSettingString
func (p *OmaSettingString) POmaSettingString() *OmaSettingString { return p }

// OmaSettingStringXml undocumented
type OmaSettingStringXml struct {
	OmaSetting
	// FileName File name associated with the Value property (*.xml).
	FileName *string `json:"fileName,omitempty"`
	// Value Value. (UTF8 encoded byte array)
	Value *Binary `json:"value,omitempty"`
}

// IOmaSettingStringXml interface type for omaSettingStringXml
type IOmaSettingStringXml interface {
	POmaSettingStringXml() *OmaSettingStringXml
}

// POmaSettingStringXml pointer method for omaSettingStringXml
func (p *OmaSettingStringXml) POmaSettingStringXml() *OmaSettingStringXml { return p }

// OnPremisesConditionalAccessSettings Singleton entity which represents the Exchange OnPremises Conditional Access Settings for a tenant.
type OnPremisesConditionalAccessSettings struct {
	Entity
	// Enabled Indicates if on premises conditional access is enabled for this organization
	Enabled *bool `json:"enabled,omitempty"`
	// IncludedGroups User groups that will be targeted by on premises conditional access. All users in these groups will be required to have mobile device managed and compliant for mail access.
	IncludedGroups []UUID `json:"includedGroups,omitempty"`
	// ExcludedGroups User groups that will be exempt by on premises conditional access. All users in these groups will be exempt from the conditional access policy.
	ExcludedGroups []UUID `json:"excludedGroups,omitempty"`
	// OverrideDefaultRule Override the default access rule when allowing a device to ensure access is granted.
	OverrideDefaultRule *bool `json:"overrideDefaultRule,omitempty"`
}

// IOnPremisesConditionalAccessSettings interface type for onPremisesConditionalAccessSettings
type IOnPremisesConditionalAccessSettings interface {
	POnPremisesConditionalAccessSettings() *OnPremisesConditionalAccessSettings
}

// POnPremisesConditionalAccessSettings pointer method for onPremisesConditionalAccessSettings
func (p *OnPremisesConditionalAccessSettings) POnPremisesConditionalAccessSettings() *OnPremisesConditionalAccessSettings {
	return p
}

// OnPremisesExtensionAttributes undocumented
type OnPremisesExtensionAttributes struct {
	// ExtensionAttribute1 undocumented
	ExtensionAttribute1 *string `json:"extensionAttribute1,omitempty"`
	// ExtensionAttribute2 undocumented
	ExtensionAttribute2 *string `json:"extensionAttribute2,omitempty"`
	// ExtensionAttribute3 undocumented
	ExtensionAttribute3 *string `json:"extensionAttribute3,omitempty"`
	// ExtensionAttribute4 undocumented
	ExtensionAttribute4 *string `json:"extensionAttribute4,omitempty"`
	// ExtensionAttribute5 undocumented
	ExtensionAttribute5 *string `json:"extensionAttribute5,omitempty"`
	// ExtensionAttribute6 undocumented
	ExtensionAttribute6 *string `json:"extensionAttribute6,omitempty"`
	// ExtensionAttribute7 undocumented
	ExtensionAttribute7 *string `json:"extensionAttribute7,omitempty"`
	// ExtensionAttribute8 undocumented
	ExtensionAttribute8 *string `json:"extensionAttribute8,omitempty"`
	// ExtensionAttribute9 undocumented
	ExtensionAttribute9 *string `json:"extensionAttribute9,omitempty"`
	// ExtensionAttribute10 undocumented
	ExtensionAttribute10 *string `json:"extensionAttribute10,omitempty"`
	// ExtensionAttribute11 undocumented
	ExtensionAttribute11 *string `json:"extensionAttribute11,omitempty"`
	// ExtensionAttribute12 undocumented
	ExtensionAttribute12 *string `json:"extensionAttribute12,omitempty"`
	// ExtensionAttribute13 undocumented
	ExtensionAttribute13 *string `json:"extensionAttribute13,omitempty"`
	// ExtensionAttribute14 undocumented
	ExtensionAttribute14 *string `json:"extensionAttribute14,omitempty"`
	// ExtensionAttribute15 undocumented
	ExtensionAttribute15 *string `json:"extensionAttribute15,omitempty"`
}

// IOnPremisesExtensionAttributes interface type for onPremisesExtensionAttributes
type IOnPremisesExtensionAttributes interface {
	POnPremisesExtensionAttributes() *OnPremisesExtensionAttributes
}

// POnPremisesExtensionAttributes pointer method for onPremisesExtensionAttributes
func (p *OnPremisesExtensionAttributes) POnPremisesExtensionAttributes() *OnPremisesExtensionAttributes {
	return p
}

// OnPremisesProvisioningError undocumented
type OnPremisesProvisioningError struct {
	// Value undocumented
	Value *string `json:"value,omitempty"`
	// Category undocumented
	Category *string `json:"category,omitempty"`
	// PropertyCausingError undocumented
	PropertyCausingError *string `json:"propertyCausingError,omitempty"`
	// OccurredDateTime undocumented
	OccurredDateTime *time.Time `json:"occurredDateTime,omitempty"`
}

// IOnPremisesProvisioningError interface type for onPremisesProvisioningError
type IOnPremisesProvisioningError interface {
	POnPremisesProvisioningError() *OnPremisesProvisioningError
}

// POnPremisesProvisioningError pointer method for onPremisesProvisioningError
func (p *OnPremisesProvisioningError) POnPremisesProvisioningError() *OnPremisesProvisioningError {
	return p
}

// Onenote undocumented
type Onenote struct {
	Entity
}

// IOnenote interface type for onenote
type IOnenote interface {
	POnenote() *Onenote
}

// POnenote pointer method for onenote
func (p *Onenote) POnenote() *Onenote { return p }

// OnenoteEntityBaseModel undocumented
type OnenoteEntityBaseModel struct {
	Entity
	// Self undocumented
	Self *string `json:"self,omitempty"`
}

// IOnenoteEntityBaseModel interface type for onenoteEntityBaseModel
type IOnenoteEntityBaseModel interface {
	POnenoteEntityBaseModel() *OnenoteEntityBaseModel
}

// POnenoteEntityBaseModel pointer method for onenoteEntityBaseModel
func (p *OnenoteEntityBaseModel) POnenoteEntityBaseModel() *OnenoteEntityBaseModel { return p }

// OnenoteEntityHierarchyModel undocumented
type OnenoteEntityHierarchyModel struct {
	OnenoteEntitySchemaObjectModel
	// DisplayName undocumented
	DisplayName *string `json:"displayName,omitempty"`
	// CreatedBy undocumented
	CreatedBy *IdentitySet `json:"createdBy,omitempty"`
	// LastModifiedBy undocumented
	LastModifiedBy *IdentitySet `json:"lastModifiedBy,omitempty"`
	// LastModifiedDateTime undocumented
	LastModifiedDateTime *time.Time `json:"lastModifiedDateTime,omitempty"`
}

// IOnenoteEntityHierarchyModel interface type for onenoteEntityHierarchyModel
type IOnenoteEntityHierarchyModel interface {
	POnenoteEntityHierarchyModel() *OnenoteEntityHierarchyModel
}

// POnenoteEntityHierarchyModel pointer method for onenoteEntityHierarchyModel
func (p *OnenoteEntityHierarchyModel) POnenoteEntityHierarchyModel() *OnenoteEntityHierarchyModel {
	return p
}

// OnenoteEntitySchemaObjectModel undocumented
type OnenoteEntitySchemaObjectModel struct {
	OnenoteEntityBaseModel
	// CreatedDateTime undocumented
	CreatedDateTime *time.Time `json:"createdDateTime,omitempty"`
}

// IOnenoteEntitySchemaObjectModel interface type for onenoteEntitySchemaObjectModel
type IOnenoteEntitySchemaObjectModel interface {
	POnenoteEntitySchemaObjectModel() *OnenoteEntitySchemaObjectModel
}

// POnenoteEntitySchemaObjectModel pointer method for onenoteEntitySchemaObjectModel
func (p *OnenoteEntitySchemaObjectModel) POnenoteEntitySchemaObjectModel() *OnenoteEntitySchemaObjectModel {
	return p
}

// OnenoteOperation undocumented
type OnenoteOperation struct {
	Operation
	// ResourceLocation undocumented
	ResourceLocation *string `json:"resourceLocation,omitempty"`
	// ResourceId undocumented
	ResourceId *string `json:"resourceId,omitempty"`
	// Error undocumented
	Error *OnenoteOperationError `json:"error,omitempty"`
	// PercentComplete undocumented
	PercentComplete *string `json:"percentComplete,omitempty"`
}

// IOnenoteOperation interface type for onenoteOperation
type IOnenoteOperation interface {
	POnenoteOperation() *OnenoteOperation
}

// POnenoteOperation pointer method for onenoteOperation
func (p *OnenoteOperation) POnenoteOperation() *OnenoteOperation { return p }

// OnenoteOperationError undocumented
type OnenoteOperationError struct {
	// Code undocumented
	Code *string `json:"code,omitempty"`
	// Message undocumented
	Message *string `json:"message,omitempty"`
}

// IOnenoteOperationError interface type for onenoteOperationError
type IOnenoteOperationError interface {
	POnenoteOperationError() *OnenoteOperationError
}

// POnenoteOperationError pointer method for onenoteOperationError
func (p *OnenoteOperationError) POnenoteOperationError() *OnenoteOperationError { return p }

// OnenotePage undocumented
type OnenotePage struct {
	OnenoteEntitySchemaObjectModel
	// Title undocumented
	Title *string `json:"title,omitempty"`
	// CreatedByAppId undocumented
	CreatedByAppId *string `json:"createdByAppId,omitempty"`
	// Links undocumented
	Links *PageLinks `json:"links,omitempty"`
	// ContentUrl undocumented
	ContentUrl *string `json:"contentUrl,omitempty"`
	// Content undocumented
	Content *Stream `json:"content,omitempty"`
	// LastModifiedDateTime undocumented
	LastModifiedDateTime *time.Time `json:"lastModifiedDateTime,omitempty"`
	// Level undocumented
	Level *int `json:"level,omitempty"`
	// Order undocumented
	Order *int `json:"order,omitempty"`
	// UserTags undocumented
	UserTags []string `json:"userTags,omitempty"`
}

// IOnenotePage interface type for onenotePage
type IOnenotePage interface {
	POnenotePage() *OnenotePage
}

// POnenotePage pointer method for onenotePage
func (p *OnenotePage) POnenotePage() *OnenotePage { return p }

// OnenotePagePreview undocumented
type OnenotePagePreview struct {
	// PreviewText undocumented
	PreviewText *string `json:"previewText,omitempty"`
	// Links undocumented
	Links *OnenotePagePreviewLinks `json:"links,omitempty"`
}

// IOnenotePagePreview interface type for onenotePagePreview
type IOnenotePagePreview interface {
	POnenotePagePreview() *OnenotePagePreview
}

// POnenotePagePreview pointer method for onenotePagePreview
func (p *OnenotePagePreview) POnenotePagePreview() *OnenotePagePreview { return p }

// OnenotePagePreviewLinks undocumented
type OnenotePagePreviewLinks struct {
	// PreviewImageUrl undocumented
	PreviewImageUrl *ExternalLink `json:"previewImageUrl,omitempty"`
}

// IOnenotePagePreviewLinks interface type for onenotePagePreviewLinks
type IOnenotePagePreviewLinks interface {
	POnenotePagePreviewLinks() *OnenotePagePreviewLinks
}

// POnenotePagePreviewLinks pointer method for onenotePagePreviewLinks
func (p *OnenotePagePreviewLinks) POnenotePagePreviewLinks() *OnenotePagePreviewLinks { return p }

// OnenotePatchContentCommand undocumented
type OnenotePatchContentCommand struct {
	// Action undocumented
	Action *OnenotePatchActionType `json:"action,omitempty"`
	// Target undocumented
	Target *string `json:"target,omitempty"`
	// Content undocumented
	Content *string `json:"content,omitempty"`
	// Position undocumented
	Position *OnenotePatchInsertPosition `json:"position,omitempty"`
}

// IOnenotePatchContentCommand interface type for onenotePatchContentCommand
type IOnenotePatchContentCommand interface {
	POnenotePatchContentCommand() *OnenotePatchContentCommand
}

// POnenotePatchContentCommand pointer method for onenotePatchContentCommand
func (p *OnenotePatchContentCommand) POnenotePatchContentCommand() *OnenotePatchContentCommand {
	return p
}

// OnenoteResource undocumented
type OnenoteResource struct {
	OnenoteEntityBaseModel
	// Content undocumented
	Content *Stream `json:"content,omitempty"`
	// ContentUrl undocumented
	ContentUrl *string `json:"contentUrl,omitempty"`
}

// IOnenoteResource interface type for onenoteResource
type IOnenoteResource interface {
	POnenoteResource() *OnenoteResource
}

// POnenoteResource pointer method for onenoteResource
func (p *OnenoteResource) POnenoteResource() *OnenoteResource { return p }

// OnenoteSection undocumented
type OnenoteSection struct {
	OnenoteEntityHierarchyModel
	// IsDefault undocumented
	IsDefault *bool `json:"isDefault,omitempty"`
	// Links undocumented
	Links *SectionLinks `json:"links,omitempty"`
	// PagesUrl undocumented
	PagesUrl *string `json:"pagesUrl,omitempty"`
}

// IOnenoteSection interface type for onenoteSection
type IOnenoteSection interface {
	POnenoteSection() *OnenoteSection
}

// POnenoteSection pointer method for onenoteSection
func (p *OnenoteSection) POnenoteSection() *OnenoteSection { return p }

// OpenTypeExtension undocumented
type OpenTypeExtension struct {
	Extension
	// ExtensionName undocumented
	ExtensionName *string `json:"extensionName,omitempty"`
}

// IOpenTypeExtension interface type for openTypeExtension
type IOpenTypeExtension interface {
	POpenTypeExtension() *OpenTypeExtension
}

// POpenTypeExtension pointer method for openTypeExtension
func (p *OpenTypeExtension) POpenTypeExtension() *OpenTypeExtension { return p }

// Operation undocumented
type Operation struct {
	Entity
	// Status undocumented
	Status *OperationStatus `json:"status,omitempty"`
	// CreatedDateTime undocumented
	CreatedDateTime *time.Time `json:"createdDateTime,omitempty"`
	// LastActionDateTime undocumented
	LastActionDateTime *time.Time `json:"lastActionDateTime,omitempty"`
}

// IOperation interface type for operation
type IOperation interface {
	POperation() *Operation
}

// POperation pointer method for operation
func (p *Operation) POperation() *Operation { return p }

// OperationError undocumented
type OperationError struct {
	// Code undocumented
	Code *string `json:"code,omitempty"`
	// Message undocumented
	Message *string `json:"message,omitempty"`
}

// IOperationError interface type for operationError
type IOperationError interface {
	POperationError() *OperationError
}

// POperationError pointer method for operationError
func (p *OperationError) POperationError() *OperationError { return p }

// Organization The organization resource represents an instance of global settings and resources which operate and are provisioned at the tenant-level.
type Organization struct {
	DirectoryObject
	// AssignedPlans undocumented
	AssignedPlans []AssignedPlan `json:"assignedPlans,omitempty"`
	// BusinessPhones undocumented
	BusinessPhones []string `json:"businessPhones,omitempty"`
	// City undocumented
	City *string `json:"city,omitempty"`
	// Country undocumented
	Country *string `json:"country,omitempty"`
	// CountryLetterCode undocumented
	CountryLetterCode *string `json:"countryLetterCode,omitempty"`
	// CreatedDateTime undocumented
	CreatedDateTime *time.Time `json:"createdDateTime,omitempty"`
	// DisplayName undocumented
	DisplayName *string `json:"displayName,omitempty"`
	// MarketingNotificationEmails undocumented
	MarketingNotificationEmails []string `json:"marketingNotificationEmails,omitempty"`
	// OnPremisesLastSyncDateTime undocumented
	OnPremisesLastSyncDateTime *time.Time `json:"onPremisesLastSyncDateTime,omitempty"`
	// OnPremisesSyncEnabled undocumented
	OnPremisesSyncEnabled *bool `json:"onPremisesSyncEnabled,omitempty"`
	// PostalCode undocumented
	PostalCode *string `json:"postalCode,omitempty"`
	// PreferredLanguage undocumented
	PreferredLanguage *string `json:"preferredLanguage,omitempty"`
	// PrivacyProfile undocumented
	PrivacyProfile *PrivacyProfile `json:"privacyProfile,omitempty"`
	// ProvisionedPlans undocumented
	ProvisionedPlans []ProvisionedPlan `json:"provisionedPlans,omitempty"`
	// SecurityComplianceNotificationMails undocumented
	SecurityComplianceNotificationMails []string `json:"securityComplianceNotificationMails,omitempty"`
	// SecurityComplianceNotificationPhones undocumented
	SecurityComplianceNotificationPhones []string `json:"securityComplianceNotificationPhones,omitempty"`
	// State undocumented
	State *string `json:"state,omitempty"`
	// Street undocumented
	Street *string `json:"street,omitempty"`
	// TechnicalNotificationMails undocumented
	TechnicalNotificationMails []string `json:"technicalNotificationMails,omitempty"`
	// VerifiedDomains undocumented
	VerifiedDomains []VerifiedDomain `json:"verifiedDomains,omitempty"`
	// MobileDeviceManagementAuthority Mobile device management authority.
	MobileDeviceManagementAuthority *MdmAuthority `json:"mobileDeviceManagementAuthority,omitempty"`
}

// IOrganization interface type for organization
type IOrganization interface {
	POrganization() *Organization
}

// POrganization pointer method for organization
func (p *Organization) POrganization() *Organization { return p }

// OutlookCategory undocumented
type OutlookCategory struct {
	Entity
	// DisplayName undocumented
	DisplayName *string `json:"displayName,omitempty"`
	// Color undocumented
	Color *CategoryColor `json:"color,omitempty"`
}

// IOutlookCategory interface type for outlookCategory
type IOutlookCategory interface {
	POutlookCategory() *OutlookCategory
}

// POutlookCategory pointer method for outlookCategory
func (p *OutlookCategory) POutlookCategory() *OutlookCategory { return p }

// OutlookGeoCoordinates undocumented
type OutlookGeoCoordinates struct {
	// Latitude undocumented
	Latitude *float64 `json:"latitude,omitempty"`
	// Longitude undocumented
	Longitude *float64 `json:"longitude,omitempty"`
	// Accuracy undocumented
	Accuracy *float64 `json:"accuracy,omitempty"`
	// Altitude undocumented
	Altitude *float64 `json:"altitude,omitempty"`
	// AltitudeAccuracy undocumented
	AltitudeAccuracy *float64 `json:"altitudeAccuracy,omitempty"`
}

// IOutlookGeoCoordinates interface type for outlookGeoCoordinates
type IOutlookGeoCoordinates interface {
	POutlookGeoCoordinates() *OutlookGeoCoordinates
}

// POutlookGeoCoordinates pointer method for outlookGeoCoordinates
func (p *OutlookGeoCoordinates) POutlookGeoCoordinates() *OutlookGeoCoordinates { return p }

// OutlookItem undocumented
type OutlookItem struct {
	Entity
	// CreatedDateTime undocumented
	CreatedDateTime *time.Time `json:"createdDateTime,omitempty"`
	// LastModifiedDateTime undocumented
	LastModifiedDateTime *time.Time `json:"lastModifiedDateTime,omitempty"`
	// ChangeKey undocumented
	ChangeKey *string `json:"changeKey,omitempty"`
	// Categories undocumented
	Categories []string `json:"categories,omitempty"`
}

// IOutlookItem interface type for outlookItem
type IOutlookItem interface {
	POutlookItem() *OutlookItem
}

// POutlookItem pointer method for outlookItem
func (p *OutlookItem) POutlookItem() *OutlookItem { return p }

// OutlookUser undocumented
type OutlookUser struct {
	Entity
}

// IOutlookUser interface type for outlookUser
type IOutlookUser interface {
	POutlookUser() *OutlookUser
}

// POutlookUser pointer method for outlookUser
func (p *OutlookUser) POutlookUser() *OutlookUser { return p }

// Package undocumented
type Package struct {
	// Type undocumented
	Type *string `json:"type,omitempty"`
}

// IPackage interface type for package
type IPackage interface {
	PPackage() *Package
}

// PPackage pointer method for package
func (p *Package) PPackage() *Package { return p }

// PageLinks undocumented
type PageLinks struct {
	// OneNoteClientUrl undocumented
	OneNoteClientUrl *ExternalLink `json:"oneNoteClientUrl,omitempty"`
	// OneNoteWebUrl undocumented
	OneNoteWebUrl *ExternalLink `json:"oneNoteWebUrl,omitempty"`
}

// IPageLinks interface type for pageLinks
type IPageLinks interface {
	PPageLinks() *PageLinks
}

// PPageLinks pointer method for pageLinks
func (p *PageLinks) PPageLinks() *PageLinks { return p }

// PasswordProfile undocumented
type PasswordProfile struct {
	// Password undocumented
	Password *string `json:"password,omitempty"`
	// ForceChangePasswordNextSignIn undocumented
	ForceChangePasswordNextSignIn *bool `json:"forceChangePasswordNextSignIn,omitempty"`
	// ForceChangePasswordNextSignInWithMfa undocumented
	ForceChangePasswordNextSignInWithMfa *bool `json:"forceChangePasswordNextSignInWithMfa,omitempty"`
}

// IPasswordProfile interface type for passwordProfile
type IPasswordProfile interface {
	PPasswordProfile() *PasswordProfile
}

// PPasswordProfile pointer method for passwordProfile
func (p *PasswordProfile) PPasswordProfile() *PasswordProfile { return p }

// PatternedRecurrence undocumented
type PatternedRecurrence struct {
	// Pattern undocumented
	Pattern *RecurrencePattern `json:"pattern,omitempty"`
	// Range undocumented
	Range *RecurrenceRange `json:"range,omitempty"`
}

// IPatternedRecurrence interface type for patternedRecurrence
type IPatternedRecurrence interface {
	PPatternedRecurrence() *PatternedRecurrence
}

// PPatternedRecurrence pointer method for patternedRecurrence
func (p *PatternedRecurrence) PPatternedRecurrence() *PatternedRecurrence { return p }

// Permission undocumented
type Permission struct {
	Entity
	// GrantedTo undocumented
	GrantedTo *IdentitySet `json:"grantedTo,omitempty"`
	// InheritedFrom undocumented
	InheritedFrom *ItemReference `json:"inheritedFrom,omitempty"`
	// Invitation undocumented
	Invitation *SharingInvitation `json:"invitation,omitempty"`
	// Link undocumented
	Link *SharingLink `json:"link,omitempty"`
	// Roles undocumented
	Roles []string `json:"roles,omitempty"`
	// ShareId undocumented
	ShareId *string `json:"shareId,omitempty"`
}

// IPermission interface type for permission
type IPermission interface {
	PPermission() *Permission
}

// PPermission pointer method for permission
func (p *Permission) PPermission() *Permission { return p }

// Person undocumented
type Person struct {
	Entity
	// DisplayName undocumented
	DisplayName *string `json:"displayName,omitempty"`
	// GivenName undocumented
	GivenName *string `json:"givenName,omitempty"`
	// Surname undocumented
	Surname *string `json:"surname,omitempty"`
	// Birthday undocumented
	Birthday *string `json:"birthday,omitempty"`
	// PersonNotes undocumented
	PersonNotes *string `json:"personNotes,omitempty"`
	// IsFavorite undocumented
	IsFavorite *bool `json:"isFavorite,omitempty"`
	// ScoredEmailAddresses undocumented
	ScoredEmailAddresses []ScoredEmailAddress `json:"scoredEmailAddresses,omitempty"`
	// Phones undocumented
	Phones []Phone `json:"phones,omitempty"`
	// PostalAddresses undocumented
	PostalAddresses []Location `json:"postalAddresses,omitempty"`
	// Websites undocumented
	Websites []Website `json:"websites,omitempty"`
	// JobTitle undocumented
	JobTitle *string `json:"jobTitle,omitempty"`
	// CompanyName undocumented
	CompanyName *string `json:"companyName,omitempty"`
	// YomiCompany undocumented
	YomiCompany *string `json:"yomiCompany,omitempty"`
	// Department undocumented
	Department *string `json:"department,omitempty"`
	// OfficeLocation undocumented
	OfficeLocation *string `json:"officeLocation,omitempty"`
	// Profession undocumented
	Profession *string `json:"profession,omitempty"`
	// PersonType undocumented
	PersonType *PersonType `json:"personType,omitempty"`
	// UserPrincipalName undocumented
	UserPrincipalName *string `json:"userPrincipalName,omitempty"`
	// ImAddress undocumented
	ImAddress *string `json:"imAddress,omitempty"`
}

// IPerson interface type for person
type IPerson interface {
	PPerson() *Person
}

// PPerson pointer method for person
func (p *Person) PPerson() *Person { return p }

// PersonOrGroupColumn undocumented
type PersonOrGroupColumn struct {
	// AllowMultipleSelection undocumented
	AllowMultipleSelection *bool `json:"allowMultipleSelection,omitempty"`
	// ChooseFromType undocumented
	ChooseFromType *string `json:"chooseFromType,omitempty"`
	// DisplayAs undocumented
	DisplayAs *string `json:"displayAs,omitempty"`
}

// IPersonOrGroupColumn interface type for personOrGroupColumn
type IPersonOrGroupColumn interface {
	PPersonOrGroupColumn() *PersonOrGroupColumn
}

// PPersonOrGroupColumn pointer method for personOrGroupColumn
func (p *PersonOrGroupColumn) PPersonOrGroupColumn() *PersonOrGroupColumn { return p }

// PersonType undocumented
type PersonType struct {
	// Class undocumented
	Class *string `json:"class,omitempty"`
	// Subclass undocumented
	Subclass *string `json:"subclass,omitempty"`
}

// IPersonType interface type for personType
type IPersonType interface {
	PPersonType() *PersonType
}

// PPersonType pointer method for personType
func (p *PersonType) PPersonType() *PersonType { return p }

// Phone undocumented
type Phone struct {
	// Type undocumented
	Type *PhoneType `json:"type,omitempty"`
	// Number undocumented
	Number *string `json:"number,omitempty"`
	// Region undocumented
	Region *string `json:"region,omitempty"`
	// Language undocumented
	Language *string `json:"language,omitempty"`
}

// IPhone interface type for phone
type IPhone interface {
	PPhone() *Phone
}

// PPhone pointer method for phone
func (p *Phone) PPhone() *Phone { return p }

// Photo undocumented
type Photo struct {
	// CameraMake undocumented
	CameraMake *string `json:"cameraMake,omitempty"`
	// CameraModel undocumented
	CameraModel *string `json:"cameraModel,omitempty"`
	// ExposureDenominator undocumented
	ExposureDenominator *float64 `json:"exposureDenominator,omitempty"`
	// ExposureNumerator undocumented
	ExposureNumerator *float64 `json:"exposureNumerator,omitempty"`
	// FNumber undocumented
	FNumber *float64 `json:"fNumber,omitempty"`
	// FocalLength undocumented
	FocalLength *float64 `json:"focalLength,omitempty"`
	// Iso undocumented
	Iso *int `json:"iso,omitempty"`
	// TakenDateTime undocumented
	TakenDateTime *time.Time `json:"takenDateTime,omitempty"`
}

// IPhoto interface type for photo
type IPhoto interface {
	PPhoto() *Photo
}

// PPhoto pointer method for photo
func (p *Photo) PPhoto() *Photo { return p }

// PhysicalAddress undocumented
type PhysicalAddress struct {
	// Street undocumented
	Street *string `json:"street,omitempty"`
	// City undocumented
	City *string `json:"city,omitempty"`
	// State undocumented
	State *string `json:"state,omitempty"`
	// CountryOrRegion undocumented
	CountryOrRegion *string `json:"countryOrRegion,omitempty"`
	// PostalCode undocumented
	PostalCode *string `json:"postalCode,omitempty"`
}

// IPhysicalAddress interface type for physicalAddress
type IPhysicalAddress interface {
	PPhysicalAddress() *PhysicalAddress
}

// PPhysicalAddress pointer method for physicalAddress
func (p *PhysicalAddress) PPhysicalAddress() *PhysicalAddress { return p }

// Planner undocumented
type Planner struct {
	Entity
}

// IPlanner interface type for planner
type IPlanner interface {
	PPlanner() *Planner
}

// PPlanner pointer method for planner
func (p *Planner) PPlanner() *Planner { return p }

// PlannerAppliedCategories undocumented
type PlannerAppliedCategories struct {
}

// IPlannerAppliedCategories interface type for plannerAppliedCategories
type IPlannerAppliedCategories interface {
	PPlannerAppliedCategories() *PlannerAppliedCategories
}

// PPlannerAppliedCategories pointer method for plannerAppliedCategories
func (p *PlannerAppliedCategories) PPlannerAppliedCategories() *PlannerAppliedCategories { return p }

// PlannerAssignedToTaskBoardTaskFormat undocumented
type PlannerAssignedToTaskBoardTaskFormat struct {
	Entity
	// UnassignedOrderHint undocumented
	UnassignedOrderHint *string `json:"unassignedOrderHint,omitempty"`
	// OrderHintsByAssignee undocumented
	OrderHintsByAssignee *PlannerOrderHintsByAssignee `json:"orderHintsByAssignee,omitempty"`
}

// IPlannerAssignedToTaskBoardTaskFormat interface type for plannerAssignedToTaskBoardTaskFormat
type IPlannerAssignedToTaskBoardTaskFormat interface {
	PPlannerAssignedToTaskBoardTaskFormat() *PlannerAssignedToTaskBoardTaskFormat
}

// PPlannerAssignedToTaskBoardTaskFormat pointer method for plannerAssignedToTaskBoardTaskFormat
func (p *PlannerAssignedToTaskBoardTaskFormat) PPlannerAssignedToTaskBoardTaskFormat() *PlannerAssignedToTaskBoardTaskFormat {
	return p
}

// PlannerAssignment undocumented
type PlannerAssignment struct {
	// AssignedBy undocumented
	AssignedBy *IdentitySet `json:"assignedBy,omitempty"`
	// AssignedDateTime undocumented
	AssignedDateTime *time.Time `json:"assignedDateTime,omitempty"`
	// OrderHint undocumented
	OrderHint *string `json:"orderHint,omitempty"`
}

// IPlannerAssignment interface type for plannerAssignment
type IPlannerAssignment interface {
	PPlannerAssignment() *PlannerAssignment
}

// PPlannerAssignment pointer method for plannerAssignment
func (p *PlannerAssignment) PPlannerAssignment() *PlannerAssignment { return p }

// PlannerAssignments undocumented
type PlannerAssignments struct {
}

// IPlannerAssignments interface type for plannerAssignments
type IPlannerAssignments interface {
	PPlannerAssignments() *PlannerAssignments
}

// PPlannerAssignments pointer method for plannerAssignments
func (p *PlannerAssignments) PPlannerAssignments() *PlannerAssignments { return p }

// PlannerBucket undocumented
type PlannerBucket struct {
	Entity
	// Name undocumented
	Name *string `json:"name,omitempty"`
	// PlanId undocumented
	PlanId *string `json:"planId,omitempty"`
	// OrderHint undocumented
	OrderHint *string `json:"orderHint,omitempty"`
}

// IPlannerBucket interface type for plannerBucket
type IPlannerBucket interface {
	PPlannerBucket() *PlannerBucket
}

// PPlannerBucket pointer method for plannerBucket
func (p *PlannerBucket) PPlannerBucket() *PlannerBucket { return p }

// PlannerBucketTaskBoardTaskFormat undocumented
type PlannerBucketTaskBoardTaskFormat struct {
	Entity
	// OrderHint undocumented
	OrderHint *string `json:"orderHint,omitempty"`
}

// IPlannerBucketTaskBoardTaskFormat interface type for plannerBucketTaskBoardTaskFormat
type IPlannerBucketTaskBoardTaskFormat interface {
	PPlannerBucketTaskBoardTaskFormat() *PlannerBucketTaskBoardTaskFormat
}

// PPlannerBucketTaskBoardTaskFormat pointer method for plannerBucketTaskBoardTaskFormat
func (p *PlannerBucketTaskBoardTaskFormat) PPlannerBucketTaskBoardTaskFormat() *PlannerBucketTaskBoardTaskFormat {
	return p
}

// PlannerCategoryDescriptions undocumented
type PlannerCategoryDescriptions struct {
	// Category1 undocumented
	Category1 *string `json:"category1,omitempty"`
	// Category2 undocumented
	Category2 *string `json:"category2,omitempty"`
	// Category3 undocumented
	Category3 *string `json:"category3,omitempty"`
	// Category4 undocumented
	Category4 *string `json:"category4,omitempty"`
	// Category5 undocumented
	Category5 *string `json:"category5,omitempty"`
	// Category6 undocumented
	Category6 *string `json:"category6,omitempty"`
}

// IPlannerCategoryDescriptions interface type for plannerCategoryDescriptions
type IPlannerCategoryDescriptions interface {
	PPlannerCategoryDescriptions() *PlannerCategoryDescriptions
}

// PPlannerCategoryDescriptions pointer method for plannerCategoryDescriptions
func (p *PlannerCategoryDescriptions) PPlannerCategoryDescriptions() *PlannerCategoryDescriptions {
	return p
}

// PlannerChecklistItem undocumented
type PlannerChecklistItem struct {
	// IsChecked undocumented
	IsChecked *bool `json:"isChecked,omitempty"`
	// Title undocumented
	Title *string `json:"title,omitempty"`
	// OrderHint undocumented
	OrderHint *string `json:"orderHint,omitempty"`
	// LastModifiedBy undocumented
	LastModifiedBy *IdentitySet `json:"lastModifiedBy,omitempty"`
	// LastModifiedDateTime undocumented
	LastModifiedDateTime *time.Time `json:"lastModifiedDateTime,omitempty"`
}

// IPlannerChecklistItem interface type for plannerChecklistItem
type IPlannerChecklistItem interface {
	PPlannerChecklistItem() *PlannerChecklistItem
}

// PPlannerChecklistItem pointer method for plannerChecklistItem
func (p *PlannerChecklistItem) PPlannerChecklistItem() *PlannerChecklistItem { return p }

// PlannerChecklistItems undocumented
type PlannerChecklistItems struct {
}

// IPlannerChecklistItems interface type for plannerChecklistItems
type IPlannerChecklistItems interface {
	PPlannerChecklistItems() *PlannerChecklistItems
}

// PPlannerChecklistItems pointer method for plannerChecklistItems
func (p *PlannerChecklistItems) PPlannerChecklistItems() *PlannerChecklistItems { return p }

// PlannerExternalReference undocumented
type PlannerExternalReference struct {
	// Alias undocumented
	Alias *string `json:"alias,omitempty"`
	// Type undocumented
	Type *string `json:"type,omitempty"`
	// PreviewPriority undocumented
	PreviewPriority *string `json:"previewPriority,omitempty"`
	// LastModifiedBy undocumented
	LastModifiedBy *IdentitySet `json:"lastModifiedBy,omitempty"`
	// LastModifiedDateTime undocumented
	LastModifiedDateTime *time.Time `json:"lastModifiedDateTime,omitempty"`
}

// IPlannerExternalReference interface type for plannerExternalReference
type IPlannerExternalReference interface {
	PPlannerExternalReference() *PlannerExternalReference
}

// PPlannerExternalReference pointer method for plannerExternalReference
func (p *PlannerExternalReference) PPlannerExternalReference() *PlannerExternalReference { return p }

// PlannerExternalReferences undocumented
type PlannerExternalReferences struct {
}

// IPlannerExternalReferences interface type for plannerExternalReferences
type IPlannerExternalReferences interface {
	PPlannerExternalReferences() *PlannerExternalReferences
}

// PPlannerExternalReferences pointer method for plannerExternalReferences
func (p *PlannerExternalReferences) PPlannerExternalReferences() *PlannerExternalReferences { return p }

// PlannerGroup undocumented
type PlannerGroup struct {
	Entity
}

// IPlannerGroup interface type for plannerGroup
type IPlannerGroup interface {
	PPlannerGroup() *PlannerGroup
}

// PPlannerGroup pointer method for plannerGroup
func (p *PlannerGroup) PPlannerGroup() *PlannerGroup { return p }

// PlannerOrderHintsByAssignee undocumented
type PlannerOrderHintsByAssignee struct {
}

// IPlannerOrderHintsByAssignee interface type for plannerOrderHintsByAssignee
type IPlannerOrderHintsByAssignee interface {
	PPlannerOrderHintsByAssignee() *PlannerOrderHintsByAssignee
}

// PPlannerOrderHintsByAssignee pointer method for plannerOrderHintsByAssignee
func (p *PlannerOrderHintsByAssignee) PPlannerOrderHintsByAssignee() *PlannerOrderHintsByAssignee {
	return p
}

// PlannerPlan undocumented
type PlannerPlan struct {
	Entity
	// CreatedBy undocumented
	CreatedBy *IdentitySet `json:"createdBy,omitempty"`
	// CreatedDateTime undocumented
	CreatedDateTime *time.Time `json:"createdDateTime,omitempty"`
	// Owner undocumented
	Owner *string `json:"owner,omitempty"`
	// Title undocumented
	Title *string `json:"title,omitempty"`
}

// IPlannerPlan interface type for plannerPlan
type IPlannerPlan interface {
	PPlannerPlan() *PlannerPlan
}

// PPlannerPlan pointer method for plannerPlan
func (p *PlannerPlan) PPlannerPlan() *PlannerPlan { return p }

// PlannerPlanDetails undocumented
type PlannerPlanDetails struct {
	Entity
	// SharedWith undocumented
	SharedWith *PlannerUserIds `json:"sharedWith,omitempty"`
	// CategoryDescriptions undocumented
	CategoryDescriptions *PlannerCategoryDescriptions `json:"categoryDescriptions,omitempty"`
}

// IPlannerPlanDetails interface type for plannerPlanDetails
type IPlannerPlanDetails interface {
	PPlannerPlanDetails() *PlannerPlanDetails
}

// PPlannerPlanDetails pointer method for plannerPlanDetails
func (p *PlannerPlanDetails) PPlannerPlanDetails() *PlannerPlanDetails { return p }

// PlannerProgressTaskBoardTaskFormat undocumented
type PlannerProgressTaskBoardTaskFormat struct {
	Entity
	// OrderHint undocumented
	OrderHint *string `json:"orderHint,omitempty"`
}

// IPlannerProgressTaskBoardTaskFormat interface type for plannerProgressTaskBoardTaskFormat
type IPlannerProgressTaskBoardTaskFormat interface {
	PPlannerProgressTaskBoardTaskFormat() *PlannerProgressTaskBoardTaskFormat
}

// PPlannerProgressTaskBoardTaskFormat pointer method for plannerProgressTaskBoardTaskFormat
func (p *PlannerProgressTaskBoardTaskFormat) PPlannerProgressTaskBoardTaskFormat() *PlannerProgressTaskBoardTaskFormat {
	return p
}

// PlannerTask undocumented
type PlannerTask struct {
	Entity
	// CreatedBy undocumented
	CreatedBy *IdentitySet `json:"createdBy,omitempty"`
	// PlanId undocumented
	PlanId *string `json:"planId,omitempty"`
	// BucketId undocumented
	BucketId *string `json:"bucketId,omitempty"`
	// Title undocumented
	Title *string `json:"title,omitempty"`
	// OrderHint undocumented
	OrderHint *string `json:"orderHint,omitempty"`
	// AssigneePriority undocumented
	AssigneePriority *string `json:"assigneePriority,omitempty"`
	// PercentComplete undocumented
	PercentComplete *int `json:"percentComplete,omitempty"`
	// StartDateTime undocumented
	StartDateTime *time.Time `json:"startDateTime,omitempty"`
	// CreatedDateTime undocumented
	CreatedDateTime *time.Time `json:"createdDateTime,omitempty"`
	// DueDateTime undocumented
	DueDateTime *time.Time `json:"dueDateTime,omitempty"`
	// HasDescription undocumented
	HasDescription *bool `json:"hasDescription,omitempty"`
	// PreviewType undocumented
	PreviewType *PlannerPreviewType `json:"previewType,omitempty"`
	// CompletedDateTime undocumented
	CompletedDateTime *time.Time `json:"completedDateTime,omitempty"`
	// CompletedBy undocumented
	CompletedBy *IdentitySet `json:"completedBy,omitempty"`
	// ReferenceCount undocumented
	ReferenceCount *int `json:"referenceCount,omitempty"`
	// ChecklistItemCount undocumented
	ChecklistItemCount *int `json:"checklistItemCount,omitempty"`
	// ActiveChecklistItemCount undocumented
	ActiveChecklistItemCount *int `json:"activeChecklistItemCount,omitempty"`
	// AppliedCategories undocumented
	AppliedCategories *PlannerAppliedCategories `json:"appliedCategories,omitempty"`
	// Assignments undocumented
	Assignments *PlannerAssignments `json:"assignments,omitempty"`
	// ConversationThreadId undocumented
	ConversationThreadId *string `json:"conversationThreadId,omitempty"`
}

// IPlannerTask interface type for plannerTask
type IPlannerTask interface {
	PPlannerTask() *PlannerTask
}

// PPlannerTask pointer method for plannerTask
func (p *PlannerTask) PPlannerTask() *PlannerTask { return p }

// PlannerTaskDetails undocumented
type PlannerTaskDetails struct {
	Entity
	// Description undocumented
	Description *string `json:"description,omitempty"`
	// PreviewType undocumented
	PreviewType *PlannerPreviewType `json:"previewType,omitempty"`
	// References undocumented
	References *PlannerExternalReferences `json:"references,omitempty"`
	// Checklist undocumented
	Checklist *PlannerChecklistItems `json:"checklist,omitempty"`
}

// IPlannerTaskDetails interface type for plannerTaskDetails
type IPlannerTaskDetails interface {
	PPlannerTaskDetails() *PlannerTaskDetails
}

// PPlannerTaskDetails pointer method for plannerTaskDetails
func (p *PlannerTaskDetails) PPlannerTaskDetails() *PlannerTaskDetails { return p }

// PlannerUser undocumented
type PlannerUser struct {
	Entity
}

// IPlannerUser interface type for plannerUser
type IPlannerUser interface {
	PPlannerUser() *PlannerUser
}

// PPlannerUser pointer method for plannerUser
func (p *PlannerUser) PPlannerUser() *PlannerUser { return p }

// PlannerUserIds undocumented
type PlannerUserIds struct {
}

// IPlannerUserIds interface type for plannerUserIds
type IPlannerUserIds interface {
	PPlannerUserIds() *PlannerUserIds
}

// PPlannerUserIds pointer method for plannerUserIds
func (p *PlannerUserIds) PPlannerUserIds() *PlannerUserIds { return p }

// Post undocumented
type Post struct {
	OutlookItem
	// Body undocumented
	Body *ItemBody `json:"body,omitempty"`
	// ReceivedDateTime undocumented
	ReceivedDateTime *time.Time `json:"receivedDateTime,omitempty"`
	// HasAttachments undocumented
	HasAttachments *bool `json:"hasAttachments,omitempty"`
	// From undocumented
	From *Recipient `json:"from,omitempty"`
	// Sender undocumented
	Sender *Recipient `json:"sender,omitempty"`
	// ConversationThreadId undocumented
	ConversationThreadId *string `json:"conversationThreadId,omitempty"`
	// NewParticipants undocumented
	NewParticipants []Recipient `json:"newParticipants,omitempty"`
	// ConversationId undocumented
	ConversationId *string `json:"conversationId,omitempty"`
}

// IPost interface type for post
type IPost interface {
	PPost() *Post
}

// PPost pointer method for post
func (p *Post) PPost() *Post { return p }

// PrivacyProfile undocumented
type PrivacyProfile struct {
	// ContactEmail undocumented
	ContactEmail *string `json:"contactEmail,omitempty"`
	// StatementUrl undocumented
	StatementUrl *string `json:"statementUrl,omitempty"`
}

// IPrivacyProfile interface type for privacyProfile
type IPrivacyProfile interface {
	PPrivacyProfile() *PrivacyProfile
}

// PPrivacyProfile pointer method for privacyProfile
func (p *PrivacyProfile) PPrivacyProfile() *PrivacyProfile { return p }

// Process undocumented
type Process struct {
	// AccountName undocumented
	AccountName *string `json:"accountName,omitempty"`
	// CommandLine undocumented
	CommandLine *string `json:"commandLine,omitempty"`
	// CreatedDateTime undocumented
	CreatedDateTime *time.Time `json:"createdDateTime,omitempty"`
	// FileHash undocumented
	FileHash *FileHash `json:"fileHash,omitempty"`
	// IntegrityLevel undocumented
	IntegrityLevel *ProcessIntegrityLevel `json:"integrityLevel,omitempty"`
	// IsElevated undocumented
	IsElevated *bool `json:"isElevated,omitempty"`
	// Name undocumented
	Name *string `json:"name,omitempty"`
	// ParentProcessCreatedDateTime undocumented
	ParentProcessCreatedDateTime *time.Time `json:"parentProcessCreatedDateTime,omitempty"`
	// ParentProcessId undocumented
	ParentProcessId *int `json:"parentProcessId,omitempty"`
	// ParentProcessName undocumented
	ParentProcessName *string `json:"parentProcessName,omitempty"`
	// Path undocumented
	Path *string `json:"path,omitempty"`
	// ProcessId undocumented
	ProcessId *int `json:"processId,omitempty"`
}

// IProcess interface type for process
type IProcess interface {
	PProcess() *Process
}

// PProcess pointer method for process
func (p *Process) PProcess() *Process { return p }

// ProfilePhoto undocumented
type ProfilePhoto struct {
	Entity
	// Height undocumented
	Height *int `json:"height,omitempty"`
	// Width undocumented
	Width *int `json:"width,omitempty"`
}

// IProfilePhoto interface type for profilePhoto
type IProfilePhoto interface {
	PProfilePhoto() *ProfilePhoto
}

// PProfilePhoto pointer method for profilePhoto
func (p *ProfilePhoto) PProfilePhoto() *ProfilePhoto { return p }

// ProvisionedPlan undocumented
type ProvisionedPlan struct {
	// CapabilityStatus undocumented
	CapabilityStatus *string `json:"capabilityStatus,omitempty"`
	// ProvisioningStatus undocumented
	ProvisioningStatus *string `json:"provisioningStatus,omitempty"`
	// Service undocumented
	Service *string `json:"service,omitempty"`
}

// IProvisionedPlan interface type for provisionedPlan
type IProvisionedPlan interface {
	PProvisionedPlan() *ProvisionedPlan
}

// PProvisionedPlan pointer method for provisionedPlan
func (p *ProvisionedPlan) PProvisionedPlan() *ProvisionedPlan { return p }

// ProxiedDomain undocumented
type ProxiedDomain struct {
	// IpAddressOrFQDN The IP address or FQDN
	IpAddressOrFQDN *string `json:"ipAddressOrFQDN,omitempty"`
	// Proxy Proxy IP or FQDN
	Proxy *string `json:"proxy,omitempty"`
}

// IProxiedDomain interface type for proxiedDomain
type IProxiedDomain interface {
	PProxiedDomain() *ProxiedDomain
}

// PProxiedDomain pointer method for proxiedDomain
func (p *ProxiedDomain) PProxiedDomain() *ProxiedDomain { return p }

// PublicationFacet undocumented
type PublicationFacet struct {
	// Level undocumented
	Level *string `json:"level,omitempty"`
	// VersionId undocumented
	VersionId *string `json:"versionId,omitempty"`
}

// IPublicationFacet interface type for publicationFacet
type IPublicationFacet interface {
	PPublicationFacet() *PublicationFacet
}

// PPublicationFacet pointer method for publicationFacet
func (p *PublicationFacet) PPublicationFacet() *PublicationFacet { return p }

// Quota undocumented
type Quota struct {
	// Deleted undocumented
	Deleted *int `json:"deleted,omitempty"`
	// Remaining undocumented
	Remaining *int `json:"remaining,omitempty"`
	// State undocumented
	State *string `json:"state,omitempty"`
	// Total undocumented
	Total *int `json:"total,omitempty"`
	// Used undocumented
	Used *int `json:"used,omitempty"`
}

// IQuota interface type for quota
type IQuota interface {
	PQuota() *Quota
}

// PQuota pointer method for quota
func (p *Quota) PQuota() *Quota { return p }

// RecentNotebook undocumented
type RecentNotebook struct {
	// DisplayName undocumented
	DisplayName *string `json:"displayName,omitempty"`
	// LastAccessedTime undocumented
	LastAccessedTime *time.Time `json:"lastAccessedTime,omitempty"`
	// Links undocumented
	Links *RecentNotebookLinks `json:"links,omitempty"`
	// SourceService undocumented
	SourceService *OnenoteSourceService `json:"sourceService,omitempty"`
}

// IRecentNotebook interface type for recentNotebook
type IRecentNotebook interface {
	PRecentNotebook() *RecentNotebook
}

// PRecentNotebook pointer method for recentNotebook
func (p *RecentNotebook) PRecentNotebook() *RecentNotebook { return p }

// RecentNotebookLinks undocumented
type RecentNotebookLinks struct {
	// OneNoteClientUrl undocumented
	OneNoteClientUrl *ExternalLink `json:"oneNoteClientUrl,omitempty"`
	// OneNoteWebUrl undocumented
	OneNoteWebUrl *ExternalLink `json:"oneNoteWebUrl,omitempty"`
}

// IRecentNotebookLinks interface type for recentNotebookLinks
type IRecentNotebookLinks interface {
	PRecentNotebookLinks() *RecentNotebookLinks
}

// PRecentNotebookLinks pointer method for recentNotebookLinks
func (p *RecentNotebookLinks) PRecentNotebookLinks() *RecentNotebookLinks { return p }

// Recipient undocumented
type Recipient struct {
	// EmailAddress undocumented
	EmailAddress *EmailAddress `json:"emailAddress,omitempty"`
}

// IRecipient interface type for recipient
type IRecipient interface {
	PRecipient() *Recipient
}

// PRecipient pointer method for recipient
func (p *Recipient) PRecipient() *Recipient { return p }

// RecurrencePattern undocumented
type RecurrencePattern struct {
	// Type undocumented
	Type *RecurrencePatternType `json:"type,omitempty"`
	// Interval undocumented
	Interval *int `json:"interval,omitempty"`
	// Month undocumented
	Month *int `json:"month,omitempty"`
	// DayOfMonth undocumented
	DayOfMonth *int `json:"dayOfMonth,omitempty"`
	// DaysOfWeek undocumented
	DaysOfWeek []DayOfWeek `json:"daysOfWeek,omitempty"`
	// FirstDayOfWeek undocumented
	FirstDayOfWeek *DayOfWeek `json:"firstDayOfWeek,omitempty"`
	// Index undocumented
	Index *WeekIndex `json:"index,omitempty"`
}

// IRecurrencePattern interface type for recurrencePattern
type IRecurrencePattern interface {
	PRecurrencePattern() *RecurrencePattern
}

// PRecurrencePattern pointer method for recurrencePattern
func (p *RecurrencePattern) PRecurrencePattern() *RecurrencePattern { return p }

// RecurrenceRange undocumented
type RecurrenceRange struct {
	// Type undocumented
	Type *RecurrenceRangeType `json:"type,omitempty"`
	// StartDate undocumented
	StartDate *time.Time `json:"startDate,omitempty"`
	// EndDate undocumented
	EndDate *time.Time `json:"endDate,omitempty"`
	// RecurrenceTimeZone undocumented
	RecurrenceTimeZone *string `json:"recurrenceTimeZone,omitempty"`
	// NumberOfOccurrences undocumented
	NumberOfOccurrences *int `json:"numberOfOccurrences,omitempty"`
}

// IRecurrenceRange interface type for recurrenceRange
type IRecurrenceRange interface {
	PRecurrenceRange() *RecurrenceRange
}

// PRecurrenceRange pointer method for recurrenceRange
func (p *RecurrenceRange) PRecurrenceRange() *RecurrenceRange { return p }

// ReferenceAttachment undocumented
type ReferenceAttachment struct {
	Attachment
}

// IReferenceAttachment interface type for referenceAttachment
type IReferenceAttachment interface {
	PReferenceAttachment() *ReferenceAttachment
}

// PReferenceAttachment pointer method for referenceAttachment
func (p *ReferenceAttachment) PReferenceAttachment() *ReferenceAttachment { return p }

// RegistryKeyState undocumented
type RegistryKeyState struct {
	// Hive undocumented
	Hive *RegistryHive `json:"hive,omitempty"`
	// Key undocumented
	Key *string `json:"key,omitempty"`
	// OldKey undocumented
	OldKey *string `json:"oldKey,omitempty"`
	// OldValueData undocumented
	OldValueData *string `json:"oldValueData,omitempty"`
	// OldValueName undocumented
	OldValueName *string `json:"oldValueName,omitempty"`
	// Operation undocumented
	Operation *RegistryOperation `json:"operation,omitempty"`
	// ProcessId undocumented
	ProcessId *int `json:"processId,omitempty"`
	// ValueData undocumented
	ValueData *string `json:"valueData,omitempty"`
	// ValueName undocumented
	ValueName *string `json:"valueName,omitempty"`
	// ValueType undocumented
	ValueType *RegistryValueType `json:"valueType,omitempty"`
}

// IRegistryKeyState interface type for registryKeyState
type IRegistryKeyState interface {
	PRegistryKeyState() *RegistryKeyState
}

// PRegistryKeyState pointer method for registryKeyState
func (p *RegistryKeyState) PRegistryKeyState() *RegistryKeyState { return p }

// Reminder undocumented
type Reminder struct {
	// EventId undocumented
	EventId *string `json:"eventId,omitempty"`
	// EventStartTime undocumented
	EventStartTime *DateTimeTimeZone `json:"eventStartTime,omitempty"`
	// EventEndTime undocumented
	EventEndTime *DateTimeTimeZone `json:"eventEndTime,omitempty"`
	// ChangeKey undocumented
	ChangeKey *string `json:"changeKey,omitempty"`
	// EventSubject undocumented
	EventSubject *string `json:"eventSubject,omitempty"`
	// EventLocation undocumented
	EventLocation *Location `json:"eventLocation,omitempty"`
	// EventWebLink undocumented
	EventWebLink *string `json:"eventWebLink,omitempty"`
	// ReminderFireTime undocumented
	ReminderFireTime *DateTimeTimeZone `json:"reminderFireTime,omitempty"`
}

// IReminder interface type for reminder
type IReminder interface {
	PReminder() *Reminder
}

// PReminder pointer method for reminder
func (p *Reminder) PReminder() *Reminder { return p }

// RemoteAssistancePartner remoteAssistPartner resources represent the metadata and status of a given Remote Assistance partner service.
type RemoteAssistancePartner struct {
	Entity
	// DisplayName Display name of the partner.
	DisplayName *string `json:"displayName,omitempty"`
	// OnboardingUrl URL of the partner's onboarding portal, where an administrator can configure their Remote Assistance service.
	OnboardingUrl *string `json:"onboardingUrl,omitempty"`
	// OnboardingStatus TBD
	OnboardingStatus *RemoteAssistanceOnboardingStatus `json:"onboardingStatus,omitempty"`
	// LastConnectionDateTime Timestamp of the last request sent to Intune by the TEM partner.
	LastConnectionDateTime *time.Time `json:"lastConnectionDateTime,omitempty"`
}

// IRemoteAssistancePartner interface type for remoteAssistancePartner
type IRemoteAssistancePartner interface {
	PRemoteAssistancePartner() *RemoteAssistancePartner
}

// PRemoteAssistancePartner pointer method for remoteAssistancePartner
func (p *RemoteAssistancePartner) PRemoteAssistancePartner() *RemoteAssistancePartner { return p }

// RemoteItem undocumented
type RemoteItem struct {
	// CreatedBy undocumented
	CreatedBy *IdentitySet `json:"createdBy,omitempty"`
	// CreatedDateTime undocumented
	CreatedDateTime *time.Time `json:"createdDateTime,omitempty"`
	// File undocumented
	File *File `json:"file,omitempty"`
	// FileSystemInfo undocumented
	FileSystemInfo *FileSystemInfo `json:"fileSystemInfo,omitempty"`
	// Folder undocumented
	Folder *Folder `json:"folder,omitempty"`
	// Id undocumented
	Id *string `json:"id,omitempty"`
	// LastModifiedBy undocumented
	LastModifiedBy *IdentitySet `json:"lastModifiedBy,omitempty"`
	// LastModifiedDateTime undocumented
	LastModifiedDateTime *time.Time `json:"lastModifiedDateTime,omitempty"`
	// Name undocumented
	Name *string `json:"name,omitempty"`
	// Package undocumented
	Package *Package `json:"package,omitempty"`
	// ParentReference undocumented
	ParentReference *ItemReference `json:"parentReference,omitempty"`
	// Shared undocumented
	Shared *Shared `json:"shared,omitempty"`
	// SharepointIds undocumented
	SharepointIds *SharepointIds `json:"sharepointIds,omitempty"`
	// Size undocumented
	Size *int `json:"size,omitempty"`
	// SpecialFolder undocumented
	SpecialFolder *SpecialFolder `json:"specialFolder,omitempty"`
	// WebDavUrl undocumented
	WebDavUrl *string `json:"webDavUrl,omitempty"`
	// WebUrl undocumented
	WebUrl *string `json:"webUrl,omitempty"`
}

// IRemoteItem interface type for remoteItem
type IRemoteItem interface {
	PRemoteItem() *RemoteItem
}

// PRemoteItem pointer method for remoteItem
func (p *RemoteItem) PRemoteItem() *RemoteItem { return p }

// RemoteLockActionResult undocumented
type RemoteLockActionResult struct {
	DeviceActionResult
	// UnlockPin Pin to unlock the client
	UnlockPin *string `json:"unlockPin,omitempty"`
}

// IRemoteLockActionResult interface type for remoteLockActionResult
type IRemoteLockActionResult interface {
	PRemoteLockActionResult() *RemoteLockActionResult
}

// PRemoteLockActionResult pointer method for remoteLockActionResult
func (p *RemoteLockActionResult) PRemoteLockActionResult() *RemoteLockActionResult { return p }

// Report undocumented
type Report struct {
	// Content undocumented
	Content *Stream `json:"content,omitempty"`
}

// IReport interface type for report
type IReport interface {
	PReport() *Report
}

// PReport pointer method for report
func (p *Report) PReport() *Report { return p }

// ReportRoot The resource that represents an instance of Enrollment Failure Reports.
type ReportRoot struct {
	Entity
}

// IReportRoot interface type for reportRoot
type IReportRoot interface {
	PReportRoot() *ReportRoot
}

// PReportRoot pointer method for reportRoot
func (p *ReportRoot) PReportRoot() *ReportRoot { return p }

// ResetPasscodeActionResult undocumented
type ResetPasscodeActionResult struct {
	DeviceActionResult
	// Passcode Newly generated passcode for the device
	Passcode *string `json:"passcode,omitempty"`
}

// IResetPasscodeActionResult interface type for resetPasscodeActionResult
type IResetPasscodeActionResult interface {
	PResetPasscodeActionResult() *ResetPasscodeActionResult
}

// PResetPasscodeActionResult pointer method for resetPasscodeActionResult
func (p *ResetPasscodeActionResult) PResetPasscodeActionResult() *ResetPasscodeActionResult { return p }

// ResourceAction undocumented
type ResourceAction struct {
	// AllowedResourceActions Allowed Actions
	AllowedResourceActions []string `json:"allowedResourceActions,omitempty"`
	// NotAllowedResourceActions Not Allowed Actions
	NotAllowedResourceActions []string `json:"notAllowedResourceActions,omitempty"`
}

// IResourceAction interface type for resourceAction
type IResourceAction interface {
	PResourceAction() *ResourceAction
}

// PResourceAction pointer method for resourceAction
func (p *ResourceAction) PResourceAction() *ResourceAction { return p }

// ResourceOperation This defines an operation or action that can be performed on an Intune resource (or entity).  Common operations are Read, Delete, Update or Create.  These operations provide basic management of the underlying Intune resource itself.  In some cases, an Intune resource can have operations that are used by the resource to take action in combination with other resources.  For example, the Assign operation is used to assign a MobileApp resource to an AAD security group.  Resource operations cannot be modified for built-in roles.This defines an operation or action that can be performed on an Intune resource (or entity).  Common operations are Get, List, Delete, Update or Create.  These operations provide basic management of the underlying Intune resource itself.  In some cases, an Intune resource can have operations that are used by the resource to take action in combination with other resources.  For example, the "Assign" operation is used to assign a MobileApp resource to an AAD security group.  Resource operations cannot be modified for built-in roles.
type ResourceOperation struct {
	Entity
	// ResourceName Name of the Resource this operation is performed on.
	ResourceName *string `json:"resourceName,omitempty"`
	// ActionName Type of action this operation is going to perform. The actionName should be concise and limited to as few words as possible.
	ActionName *string `json:"actionName,omitempty"`
	// Description Description of the resource operation. The description is used in mouse-over text for the operation when shown in the Azure Portal.
	Description *string `json:"description,omitempty"`
}

// IResourceOperation interface type for resourceOperation
type IResourceOperation interface {
	PResourceOperation() *ResourceOperation
}

// PResourceOperation pointer method for resourceOperation
func (p *ResourceOperation) PResourceOperation() *ResourceOperation { return p }

// ResourceReference undocumented
type ResourceReference struct {
	// WebUrl undocumented
	WebUrl *string `json:"webUrl,omitempty"`
	// Id undocumented
	Id *string `json:"id,omitempty"`
	// Type undocumented
	Type *string `json:"type,omitempty"`
}

// IResourceReference interface type for resourceReference
type IResourceReference interface {
	PResourceReference() *ResourceReference
}

// PResourceReference pointer method for resourceReference
func (p *ResourceReference) PResourceReference() *ResourceReference { return p }

// ResourceVisualization undocumented
type ResourceVisualization struct {
	// Title undocumented
	Title *string `json:"title,omitempty"`
	// Type undocumented
	Type *string `json:"type,omitempty"`
	// MediaType undocumented
	MediaType *string `json:"mediaType,omitempty"`
	// PreviewImageUrl undocumented
	PreviewImageUrl *string `json:"previewImageUrl,omitempty"`
	// PreviewText undocumented
	PreviewText *string `json:"previewText,omitempty"`
	// ContainerWebUrl undocumented
	ContainerWebUrl *string `json:"containerWebUrl,omitempty"`
	// ContainerDisplayName undocumented
	ContainerDisplayName *string `json:"containerDisplayName,omitempty"`
	// ContainerType undocumented
	ContainerType *string `json:"containerType,omitempty"`
}

// IResourceVisualization interface type for resourceVisualization
type IResourceVisualization interface {
	PResourceVisualization() *ResourceVisualization
}

// PResourceVisualization pointer method for resourceVisualization
func (p *ResourceVisualization) PResourceVisualization() *ResourceVisualization { return p }

// ResponseStatus undocumented
type ResponseStatus struct {
	// Response undocumented
	Response *ResponseType `json:"response,omitempty"`
	// Time undocumented
	Time *time.Time `json:"time,omitempty"`
}

// IResponseStatus interface type for responseStatus
type IResponseStatus interface {
	PResponseStatus() *ResponseStatus
}

// PResponseStatus pointer method for responseStatus
func (p *ResponseStatus) PResponseStatus() *ResponseStatus { return p }

// RestrictedSignIn undocumented
type RestrictedSignIn struct {
	SignIn
	// TargetTenantId undocumented
	TargetTenantId *UUID `json:"targetTenantId,omitempty"`
}

// IRestrictedSignIn interface type for restrictedSignIn
type IRestrictedSignIn interface {
	PRestrictedSignIn() *RestrictedSignIn
}

// PRestrictedSignIn pointer method for restrictedSignIn
func (p *RestrictedSignIn) PRestrictedSignIn() *RestrictedSignIn { return p }

// RgbColor undocumented
type RgbColor struct {
	// R Red value
	R *byte `json:"r,omitempty"`
	// G Green value
	G *byte `json:"g,omitempty"`
	// B Blue value
	B *byte `json:"b,omitempty"`
}

// IRgbColor interface type for rgbColor
type IRgbColor interface {
	PRgbColor() *RgbColor
}

// PRgbColor pointer method for rgbColor
func (p *RgbColor) PRgbColor() *RgbColor { return p }

// RoleAssignment The Role Assignment resource. Role assignments tie together a role definition with members and scopes. There can be one or more role assignments per role. This applies to custom and built-in roles.
type RoleAssignment struct {
	Entity
	// DisplayName The display or friendly name of the role Assignment.
	DisplayName *string `json:"displayName,omitempty"`
	// Description Description of the Role Assignment.
	Description *string `json:"description,omitempty"`
	// ResourceScopes List of ids of role scope member security groups.  These are IDs from Azure Active Directory.
	ResourceScopes []string `json:"resourceScopes,omitempty"`
}

// IRoleAssignment interface type for roleAssignment
type IRoleAssignment interface {
	PRoleAssignment() *RoleAssignment
}

// PRoleAssignment pointer method for roleAssignment
func (p *RoleAssignment) PRoleAssignment() *RoleAssignment { return p }

// RoleDefinition The Role Definition resource. The role definition is the foundation of role based access in Intune. The role combines an Intune resource such as a Mobile App and associated role permissions such as Create or Read for the resource. There are two types of roles, built-in and custom. Built-in roles cannot be modified. Both built-in roles and custom roles must have assignments to be enforced. Create custom roles if you want to define a role that allows any of the available resources and role permissions to be combined into a single role.
type RoleDefinition struct {
	Entity
	// DisplayName Display Name of the Role definition.
	DisplayName *string `json:"displayName,omitempty"`
	// Description Description of the Role definition.
	Description *string `json:"description,omitempty"`
	// RolePermissions List of Role Permissions this role is allowed to perform. These must match the actionName that is defined as part of the rolePermission.
	RolePermissions []RolePermission `json:"rolePermissions,omitempty"`
	// IsBuiltIn Type of Role. Set to True if it is built-in, or set to False if it is a custom role definition.
	IsBuiltIn *bool `json:"isBuiltIn,omitempty"`
}

// IRoleDefinition interface type for roleDefinition
type IRoleDefinition interface {
	PRoleDefinition() *RoleDefinition
}

// PRoleDefinition pointer method for roleDefinition
func (p *RoleDefinition) PRoleDefinition() *RoleDefinition { return p }

// RolePermission undocumented
type RolePermission struct {
	// ResourceActions Actions
	ResourceActions []ResourceAction `json:"resourceActions,omitempty"`
}

// IRolePermission interface type for rolePermission
type IRolePermission interface {
	PRolePermission() *RolePermission
}

// PRolePermission pointer method for rolePermission
func (p *RolePermission) PRolePermission() *RolePermission { return p }

// Root undocumented
type Root struct {
}

// IRoot interface type for root
type IRoot interface {
	PRoot() *Root
}

// PRoot pointer method for root
func (p *Root) PRoot() *Root { return p }

// ScheduleInformation undocumented
type ScheduleInformation struct {
	// ScheduleId undocumented
	ScheduleId *string `json:"scheduleId,omitempty"`
	// ScheduleItems undocumented
	ScheduleItems []ScheduleItem `json:"scheduleItems,omitempty"`
	// AvailabilityView undocumented
	AvailabilityView *string `json:"availabilityView,omitempty"`
	// Error undocumented
	Error *FreeBusyError `json:"error,omitempty"`
	// WorkingHours undocumented
	WorkingHours *WorkingHours `json:"workingHours,omitempty"`
}

// IScheduleInformation interface type for scheduleInformation
type IScheduleInformation interface {
	PScheduleInformation() *ScheduleInformation
}

// PScheduleInformation pointer method for scheduleInformation
func (p *ScheduleInformation) PScheduleInformation() *ScheduleInformation { return p }

// ScheduleItem undocumented
type ScheduleItem struct {
	// Start undocumented
	Start *DateTimeTimeZone `json:"start,omitempty"`
	// End undocumented
	End *DateTimeTimeZone `json:"end,omitempty"`
	// IsPrivate undocumented
	IsPrivate *bool `json:"isPrivate,omitempty"`
	// Status undocumented
	Status *FreeBusyStatus `json:"status,omitempty"`
	// Subject undocumented
	Subject *string `json:"subject,omitempty"`
	// Location undocumented
	Location *string `json:"location,omitempty"`
}

// IScheduleItem interface type for scheduleItem
type IScheduleItem interface {
	PScheduleItem() *ScheduleItem
}

// PScheduleItem pointer method for scheduleItem
func (p *ScheduleItem) PScheduleItem() *ScheduleItem { return p }

// SchemaExtension undocumented
type SchemaExtension struct {
	Entity
	// Description undocumented
	Description *string `json:"description,omitempty"`
	// TargetTypes undocumented
	TargetTypes []string `json:"targetTypes,omitempty"`
	// Properties undocumented
	Properties []ExtensionSchemaProperty `json:"properties,omitempty"`
	// Status undocumented
	Status *string `json:"status,omitempty"`
	// Owner undocumented
	Owner *string `json:"owner,omitempty"`
}

// ISchemaExtension interface type for schemaExtension
type ISchemaExtension interface {
	PSchemaExtension() *SchemaExtension
}

// PSchemaExtension pointer method for schemaExtension
func (p *SchemaExtension) PSchemaExtension() *SchemaExtension { return p }

// ScoredEmailAddress undocumented
type ScoredEmailAddress struct {
	// Address undocumented
	Address *string `json:"address,omitempty"`
	// RelevanceScore undocumented
	RelevanceScore *float64 `json:"relevanceScore,omitempty"`
	// SelectionLikelihood undocumented
	SelectionLikelihood *SelectionLikelihoodInfo `json:"selectionLikelihood,omitempty"`
	// ItemId undocumented
	ItemId *string `json:"itemId,omitempty"`
}

// IScoredEmailAddress interface type for scoredEmailAddress
type IScoredEmailAddress interface {
	PScoredEmailAddress() *ScoredEmailAddress
}

// PScoredEmailAddress pointer method for scoredEmailAddress
func (p *ScoredEmailAddress) PScoredEmailAddress() *ScoredEmailAddress { return p }

// SearchResult undocumented
type SearchResult struct {
	// OnClickTelemetryUrl undocumented
	OnClickTelemetryUrl *string `json:"onClickTelemetryUrl,omitempty"`
}

// ISearchResult interface type for searchResult
type ISearchResult interface {
	PSearchResult() *SearchResult
}

// PSearchResult pointer method for searchResult
func (p *SearchResult) PSearchResult() *SearchResult { return p }

// SectionGroup undocumented
type SectionGroup struct {
	OnenoteEntityHierarchyModel
	// SectionsUrl undocumented
	SectionsUrl *string `json:"sectionsUrl,omitempty"`
	// SectionGroupsUrl undocumented
	SectionGroupsUrl *string `json:"sectionGroupsUrl,omitempty"`
}

// ISectionGroup interface type for sectionGroup
type ISectionGroup interface {
	PSectionGroup() *SectionGroup
}

// PSectionGroup pointer method for sectionGroup
func (p *SectionGroup) PSectionGroup() *SectionGroup { return p }

// SectionLinks undocumented
type SectionLinks struct {
	// OneNoteClientUrl undocumented
	OneNoteClientUrl *ExternalLink `json:"oneNoteClientUrl,omitempty"`
	// OneNoteWebUrl undocumented
	OneNoteWebUrl *ExternalLink `json:"oneNoteWebUrl,omitempty"`
}

// ISectionLinks interface type for sectionLinks
type ISectionLinks interface {
	PSectionLinks() *SectionLinks
}

// PSectionLinks pointer method for sectionLinks
func (p *SectionLinks) PSectionLinks() *SectionLinks { return p }

// SecureScore undocumented
type SecureScore struct {
	Entity
	// ActiveUserCount undocumented
	ActiveUserCount *int `json:"activeUserCount,omitempty"`
	// AverageComparativeScores undocumented
	AverageComparativeScores []AverageComparativeScore `json:"averageComparativeScores,omitempty"`
	// AzureTenantId undocumented
	AzureTenantId *string `json:"azureTenantId,omitempty"`
	// ControlScores undocumented
	ControlScores []ControlScore `json:"controlScores,omitempty"`
	// CreatedDateTime undocumented
	CreatedDateTime *time.Time `json:"createdDateTime,omitempty"`
	// CurrentScore undocumented
	CurrentScore *float64 `json:"currentScore,omitempty"`
	// EnabledServices undocumented
	EnabledServices []string `json:"enabledServices,omitempty"`
	// LicensedUserCount undocumented
	LicensedUserCount *int `json:"licensedUserCount,omitempty"`
	// MaxScore undocumented
	MaxScore *float64 `json:"maxScore,omitempty"`
	// VendorInformation undocumented
	VendorInformation *SecurityVendorInformation `json:"vendorInformation,omitempty"`
}

// ISecureScore interface type for secureScore
type ISecureScore interface {
	PSecureScore() *SecureScore
}

// PSecureScore pointer method for secureScore
func (p *SecureScore) PSecureScore() *SecureScore { return p }

// SecureScoreControlProfile undocumented
type SecureScoreControlProfile struct {
	Entity
	// ActionType undocumented
	ActionType *string `json:"actionType,omitempty"`
	// ActionUrl undocumented
	ActionUrl *string `json:"actionUrl,omitempty"`
	// AzureTenantId undocumented
	AzureTenantId *string `json:"azureTenantId,omitempty"`
	// ComplianceInformation undocumented
	ComplianceInformation []ComplianceInformation `json:"complianceInformation,omitempty"`
	// ControlCategory undocumented
	ControlCategory *string `json:"controlCategory,omitempty"`
	// ControlStateUpdates undocumented
	ControlStateUpdates []SecureScoreControlStateUpdate `json:"controlStateUpdates,omitempty"`
	// Deprecated undocumented
	Deprecated *bool `json:"deprecated,omitempty"`
	// ImplementationCost undocumented
	ImplementationCost *string `json:"implementationCost,omitempty"`
	// LastModifiedDateTime undocumented
	LastModifiedDateTime *time.Time `json:"lastModifiedDateTime,omitempty"`
	// MaxScore undocumented
	MaxScore *float64 `json:"maxScore,omitempty"`
	// Rank undocumented
	Rank *int `json:"rank,omitempty"`
	// Remediation undocumented
	Remediation *string `json:"remediation,omitempty"`
	// RemediationImpact undocumented
	RemediationImpact *string `json:"remediationImpact,omitempty"`
	// Service undocumented
	Service *string `json:"service,omitempty"`
	// Threats undocumented
	Threats []string `json:"threats,omitempty"`
	// Tier undocumented
	Tier *string `json:"tier,omitempty"`
	// Title undocumented
	Title *string `json:"title,omitempty"`
	// UserImpact undocumented
	UserImpact *string `json:"userImpact,omitempty"`
	// VendorInformation undocumented
	VendorInformation *SecurityVendorInformation `json:"vendorInformation,omitempty"`
}

// ISecureScoreControlProfile interface type for secureScoreControlProfile
type ISecureScoreControlProfile interface {
	PSecureScoreControlProfile() *SecureScoreControlProfile
}

// PSecureScoreControlProfile pointer method for secureScoreControlProfile
func (p *SecureScoreControlProfile) PSecureScoreControlProfile() *SecureScoreControlProfile { return p }

// SecureScoreControlStateUpdate undocumented
type SecureScoreControlStateUpdate struct {
	// AssignedTo undocumented
	AssignedTo *string `json:"assignedTo,omitempty"`
	// Comment undocumented
	Comment *string `json:"comment,omitempty"`
	// State undocumented
	State *string `json:"state,omitempty"`
	// UpdatedBy undocumented
	UpdatedBy *string `json:"updatedBy,omitempty"`
	// UpdatedDateTime undocumented
	UpdatedDateTime *time.Time `json:"updatedDateTime,omitempty"`
}

// ISecureScoreControlStateUpdate interface type for secureScoreControlStateUpdate
type ISecureScoreControlStateUpdate interface {
	PSecureScoreControlStateUpdate() *SecureScoreControlStateUpdate
}

// PSecureScoreControlStateUpdate pointer method for secureScoreControlStateUpdate
func (p *SecureScoreControlStateUpdate) PSecureScoreControlStateUpdate() *SecureScoreControlStateUpdate {
	return p
}

// Security undocumented
type Security struct {
	Entity
}

// ISecurity interface type for security
type ISecurity interface {
	PSecurity() *Security
}

// PSecurity pointer method for security
func (p *Security) PSecurity() *Security { return p }

// SecurityVendorInformation undocumented
type SecurityVendorInformation struct {
	// Provider undocumented
	Provider *string `json:"provider,omitempty"`
	// ProviderVersion undocumented
	ProviderVersion *string `json:"providerVersion,omitempty"`
	// SubProvider undocumented
	SubProvider *string `json:"subProvider,omitempty"`
	// Vendor undocumented
	Vendor *string `json:"vendor,omitempty"`
}

// ISecurityVendorInformation interface type for securityVendorInformation
type ISecurityVendorInformation interface {
	PSecurityVendorInformation() *SecurityVendorInformation
}

// PSecurityVendorInformation pointer method for securityVendorInformation
func (p *SecurityVendorInformation) PSecurityVendorInformation() *SecurityVendorInformation { return p }

// ServicePlanInfo undocumented
type ServicePlanInfo struct {
	// ServicePlanId undocumented
	ServicePlanId *UUID `json:"servicePlanId,omitempty"`
	// ServicePlanName undocumented
	ServicePlanName *string `json:"servicePlanName,omitempty"`
	// ProvisioningStatus undocumented
	ProvisioningStatus *string `json:"provisioningStatus,omitempty"`
	// AppliesTo undocumented
	AppliesTo *string `json:"appliesTo,omitempty"`
}

// IServicePlanInfo interface type for servicePlanInfo
type IServicePlanInfo interface {
	PServicePlanInfo() *ServicePlanInfo
}

// PServicePlanInfo pointer method for servicePlanInfo
func (p *ServicePlanInfo) PServicePlanInfo() *ServicePlanInfo { return p }

// SettingSource undocumented
type SettingSource struct {
	// Id undocumented
	Id *string `json:"id,omitempty"`
	// DisplayName undocumented
	DisplayName *string `json:"displayName,omitempty"`
}

// ISettingSource interface type for settingSource
type ISettingSource interface {
	PSettingSource() *SettingSource
}

// PSettingSource pointer method for settingSource
func (p *SettingSource) PSettingSource() *SettingSource { return p }

// SettingStateDeviceSummary Device Compilance Policy and Configuration for a Setting State summary
type SettingStateDeviceSummary struct {
	Entity
	// SettingName Name of the setting
	SettingName *string `json:"settingName,omitempty"`
	// InstancePath Name of the InstancePath for the setting
	InstancePath *string `json:"instancePath,omitempty"`
	// UnknownDeviceCount Device Unkown count for the setting
	UnknownDeviceCount *int `json:"unknownDeviceCount,omitempty"`
	// NotApplicableDeviceCount Device Not Applicable count for the setting
	NotApplicableDeviceCount *int `json:"notApplicableDeviceCount,omitempty"`
	// CompliantDeviceCount Device Compliant count for the setting
	CompliantDeviceCount *int `json:"compliantDeviceCount,omitempty"`
	// RemediatedDeviceCount Device Compliant count for the setting
	RemediatedDeviceCount *int `json:"remediatedDeviceCount,omitempty"`
	// NonCompliantDeviceCount Device NonCompliant count for the setting
	NonCompliantDeviceCount *int `json:"nonCompliantDeviceCount,omitempty"`
	// ErrorDeviceCount Device error count for the setting
	ErrorDeviceCount *int `json:"errorDeviceCount,omitempty"`
	// ConflictDeviceCount Device conflict error count for the setting
	ConflictDeviceCount *int `json:"conflictDeviceCount,omitempty"`
}

// ISettingStateDeviceSummary interface type for settingStateDeviceSummary
type ISettingStateDeviceSummary interface {
	PSettingStateDeviceSummary() *SettingStateDeviceSummary
}

// PSettingStateDeviceSummary pointer method for settingStateDeviceSummary
func (p *SettingStateDeviceSummary) PSettingStateDeviceSummary() *SettingStateDeviceSummary { return p }

// SettingTemplateValue undocumented
type SettingTemplateValue struct {
	// Name undocumented
	Name *string `json:"name,omitempty"`
	// Type undocumented
	Type *string `json:"type,omitempty"`
	// DefaultValue undocumented
	DefaultValue *string `json:"defaultValue,omitempty"`
	// Description undocumented
	Description *string `json:"description,omitempty"`
}

// ISettingTemplateValue interface type for settingTemplateValue
type ISettingTemplateValue interface {
	PSettingTemplateValue() *SettingTemplateValue
}

// PSettingTemplateValue pointer method for settingTemplateValue
func (p *SettingTemplateValue) PSettingTemplateValue() *SettingTemplateValue { return p }

// SettingValue undocumented
type SettingValue struct {
	// Name undocumented
	Name *string `json:"name,omitempty"`
	// Value undocumented
	Value *string `json:"value,omitempty"`
}

// ISettingValue interface type for settingValue
type ISettingValue interface {
	PSettingValue() *SettingValue
}

// PSettingValue pointer method for settingValue
func (p *SettingValue) PSettingValue() *SettingValue { return p }

// Shared undocumented
type Shared struct {
	// Owner undocumented
	Owner *IdentitySet `json:"owner,omitempty"`
	// Scope undocumented
	Scope *string `json:"scope,omitempty"`
	// SharedBy undocumented
	SharedBy *IdentitySet `json:"sharedBy,omitempty"`
	// SharedDateTime undocumented
	SharedDateTime *time.Time `json:"sharedDateTime,omitempty"`
}

// IShared interface type for shared
type IShared interface {
	PShared() *Shared
}

// PShared pointer method for shared
func (p *Shared) PShared() *Shared { return p }

// SharedDriveItem undocumented
type SharedDriveItem struct {
	BaseItem
	// Owner undocumented
	Owner *IdentitySet `json:"owner,omitempty"`
}

// ISharedDriveItem interface type for sharedDriveItem
type ISharedDriveItem interface {
	PSharedDriveItem() *SharedDriveItem
}

// PSharedDriveItem pointer method for sharedDriveItem
func (p *SharedDriveItem) PSharedDriveItem() *SharedDriveItem { return p }

// SharedInsight undocumented
type SharedInsight struct {
	Entity
	// LastShared undocumented
	LastShared *SharingDetail `json:"lastShared,omitempty"`
	// SharingHistory undocumented
	SharingHistory []SharingDetail `json:"sharingHistory,omitempty"`
	// ResourceVisualization undocumented
	ResourceVisualization *ResourceVisualization `json:"resourceVisualization,omitempty"`
	// ResourceReference undocumented
	ResourceReference *ResourceReference `json:"resourceReference,omitempty"`
}

// ISharedInsight interface type for sharedInsight
type ISharedInsight interface {
	PSharedInsight() *SharedInsight
}

// PSharedInsight pointer method for sharedInsight
func (p *SharedInsight) PSharedInsight() *SharedInsight { return p }

// SharedPCAccountManagerPolicy undocumented
type SharedPCAccountManagerPolicy struct {
	// AccountDeletionPolicy Configures when accounts are deleted.
	AccountDeletionPolicy *SharedPCAccountDeletionPolicyType `json:"accountDeletionPolicy,omitempty"`
	// CacheAccountsAboveDiskFreePercentage Sets the percentage of available disk space a PC should have before it stops deleting cached shared PC accounts. Only applies when AccountDeletionPolicy is DiskSpaceThreshold or DiskSpaceThresholdOrInactiveThreshold. Valid values 0 to 100
	CacheAccountsAboveDiskFreePercentage *int `json:"cacheAccountsAboveDiskFreePercentage,omitempty"`
	// InactiveThresholdDays Specifies when the accounts will start being deleted when they have not been logged on during the specified period, given as number of days. Only applies when AccountDeletionPolicy is DiskSpaceThreshold or DiskSpaceThresholdOrInactiveThreshold.
	InactiveThresholdDays *int `json:"inactiveThresholdDays,omitempty"`
	// RemoveAccountsBelowDiskFreePercentage Sets the percentage of disk space remaining on a PC before cached accounts will be deleted to free disk space. Accounts that have been inactive the longest will be deleted first. Only applies when AccountDeletionPolicy is DiskSpaceThresholdOrInactiveThreshold. Valid values 0 to 100
	RemoveAccountsBelowDiskFreePercentage *int `json:"removeAccountsBelowDiskFreePercentage,omitempty"`
}

// ISharedPCAccountManagerPolicy interface type for sharedPCAccountManagerPolicy
type ISharedPCAccountManagerPolicy interface {
	PSharedPCAccountManagerPolicy() *SharedPCAccountManagerPolicy
}

// PSharedPCAccountManagerPolicy pointer method for sharedPCAccountManagerPolicy
func (p *SharedPCAccountManagerPolicy) PSharedPCAccountManagerPolicy() *SharedPCAccountManagerPolicy {
	return p
}

// SharedPCConfiguration This topic provides descriptions of the declared methods, properties and relationships exposed by the sharedPCConfiguration resource.
type SharedPCConfiguration struct {
	DeviceConfiguration
	// AccountManagerPolicy Specifies how accounts are managed on a shared PC. Only applies when disableAccountManager is false.
	AccountManagerPolicy *SharedPCAccountManagerPolicy `json:"accountManagerPolicy,omitempty"`
	// AllowedAccounts Indicates which type of accounts are allowed to use on a shared PC.
	AllowedAccounts *SharedPCAllowedAccountType `json:"allowedAccounts,omitempty"`
	// AllowLocalStorage Specifies whether local storage is allowed on a shared PC.
	AllowLocalStorage *bool `json:"allowLocalStorage,omitempty"`
	// DisableAccountManager Disables the account manager for shared PC mode.
	DisableAccountManager *bool `json:"disableAccountManager,omitempty"`
	// DisableEduPolicies Specifies whether the default shared PC education environment policies should be disabled. For Windows 10 RS2 and later, this policy will be applied without setting Enabled to true.
	DisableEduPolicies *bool `json:"disableEduPolicies,omitempty"`
	// DisablePowerPolicies Specifies whether the default shared PC power policies should be disabled.
	DisablePowerPolicies *bool `json:"disablePowerPolicies,omitempty"`
	// DisableSignInOnResume Disables the requirement to sign in whenever the device wakes up from sleep mode.
	DisableSignInOnResume *bool `json:"disableSignInOnResume,omitempty"`
	// Enabled Enables shared PC mode and applies the shared pc policies.
	Enabled *bool `json:"enabled,omitempty"`
	// IdleTimeBeforeSleepInSeconds Specifies the time in seconds that a device must sit idle before the PC goes to sleep. Setting this value to 0 prevents the sleep timeout from occurring.
	IdleTimeBeforeSleepInSeconds *int `json:"idleTimeBeforeSleepInSeconds,omitempty"`
	// KioskAppDisplayName Specifies the display text for the account shown on the sign-in screen which launches the app specified by SetKioskAppUserModelId. Only applies when KioskAppUserModelId is set.
	KioskAppDisplayName *string `json:"kioskAppDisplayName,omitempty"`
	// KioskAppUserModelId Specifies the application user model ID of the app to use with assigned access.
	KioskAppUserModelId *string `json:"kioskAppUserModelId,omitempty"`
	// MaintenanceStartTime Specifies the daily start time of maintenance hour.
	MaintenanceStartTime *time.Time `json:"maintenanceStartTime,omitempty"`
}

// ISharedPCConfiguration interface type for sharedPCConfiguration
type ISharedPCConfiguration interface {
	PSharedPCConfiguration() *SharedPCConfiguration
}

// PSharedPCConfiguration pointer method for sharedPCConfiguration
func (p *SharedPCConfiguration) PSharedPCConfiguration() *SharedPCConfiguration { return p }

// SharepointIds undocumented
type SharepointIds struct {
	// ListId undocumented
	ListId *string `json:"listId,omitempty"`
	// ListItemId undocumented
	ListItemId *string `json:"listItemId,omitempty"`
	// ListItemUniqueId undocumented
	ListItemUniqueId *string `json:"listItemUniqueId,omitempty"`
	// SiteId undocumented
	SiteId *string `json:"siteId,omitempty"`
	// SiteUrl undocumented
	SiteUrl *string `json:"siteUrl,omitempty"`
	// WebId undocumented
	WebId *string `json:"webId,omitempty"`
}

// ISharepointIds interface type for sharepointIds
type ISharepointIds interface {
	PSharepointIds() *SharepointIds
}

// PSharepointIds pointer method for sharepointIds
func (p *SharepointIds) PSharepointIds() *SharepointIds { return p }

// SharingDetail undocumented
type SharingDetail struct {
	// SharedBy undocumented
	SharedBy *InsightIdentity `json:"sharedBy,omitempty"`
	// SharedDateTime undocumented
	SharedDateTime *time.Time `json:"sharedDateTime,omitempty"`
	// SharingSubject undocumented
	SharingSubject *string `json:"sharingSubject,omitempty"`
	// SharingType undocumented
	SharingType *string `json:"sharingType,omitempty"`
	// SharingReference undocumented
	SharingReference *ResourceReference `json:"sharingReference,omitempty"`
}

// ISharingDetail interface type for sharingDetail
type ISharingDetail interface {
	PSharingDetail() *SharingDetail
}

// PSharingDetail pointer method for sharingDetail
func (p *SharingDetail) PSharingDetail() *SharingDetail { return p }

// SharingInvitation undocumented
type SharingInvitation struct {
	// Email undocumented
	Email *string `json:"email,omitempty"`
	// InvitedBy undocumented
	InvitedBy *IdentitySet `json:"invitedBy,omitempty"`
	// RedeemedBy undocumented
	RedeemedBy *string `json:"redeemedBy,omitempty"`
	// SignInRequired undocumented
	SignInRequired *bool `json:"signInRequired,omitempty"`
}

// ISharingInvitation interface type for sharingInvitation
type ISharingInvitation interface {
	PSharingInvitation() *SharingInvitation
}

// PSharingInvitation pointer method for sharingInvitation
func (p *SharingInvitation) PSharingInvitation() *SharingInvitation { return p }

// SharingLink undocumented
type SharingLink struct {
	// Application undocumented
	Application *Identity `json:"application,omitempty"`
	// Scope undocumented
	Scope *string `json:"scope,omitempty"`
	// Type undocumented
	Type *string `json:"type,omitempty"`
	// WebUrl undocumented
	WebUrl *string `json:"webUrl,omitempty"`
}

// ISharingLink interface type for sharingLink
type ISharingLink interface {
	PSharingLink() *SharingLink
}

// PSharingLink pointer method for sharingLink
func (p *SharingLink) PSharingLink() *SharingLink { return p }

// SignIn undocumented
type SignIn struct {
	Entity
	// CreatedDateTime undocumented
	CreatedDateTime *time.Time `json:"createdDateTime,omitempty"`
	// UserDisplayName undocumented
	UserDisplayName *string `json:"userDisplayName,omitempty"`
	// UserPrincipalName undocumented
	UserPrincipalName *string `json:"userPrincipalName,omitempty"`
	// UserId undocumented
	UserId *string `json:"userId,omitempty"`
	// AppId undocumented
	AppId *string `json:"appId,omitempty"`
	// AppDisplayName undocumented
	AppDisplayName *string `json:"appDisplayName,omitempty"`
	// IpAddress undocumented
	IpAddress *string `json:"ipAddress,omitempty"`
	// Status undocumented
	Status *SignInStatus `json:"status,omitempty"`
	// ClientAppUsed undocumented
	ClientAppUsed *string `json:"clientAppUsed,omitempty"`
	// DeviceDetail undocumented
	DeviceDetail *DeviceDetail `json:"deviceDetail,omitempty"`
	// Location undocumented
	Location *SignInLocation `json:"location,omitempty"`
	// CorrelationId undocumented
	CorrelationId *string `json:"correlationId,omitempty"`
	// ConditionalAccessStatus undocumented
	ConditionalAccessStatus *ConditionalAccessStatus `json:"conditionalAccessStatus,omitempty"`
	// AppliedConditionalAccessPolicies undocumented
	AppliedConditionalAccessPolicies []AppliedConditionalAccessPolicy `json:"appliedConditionalAccessPolicies,omitempty"`
	// IsInteractive undocumented
	IsInteractive *bool `json:"isInteractive,omitempty"`
	// RiskDetail undocumented
	RiskDetail *RiskDetail `json:"riskDetail,omitempty"`
	// RiskLevelAggregated undocumented
	RiskLevelAggregated *RiskLevel `json:"riskLevelAggregated,omitempty"`
	// RiskLevelDuringSignIn undocumented
	RiskLevelDuringSignIn *RiskLevel `json:"riskLevelDuringSignIn,omitempty"`
	// RiskState undocumented
	RiskState *RiskState `json:"riskState,omitempty"`
	// RiskEventTypes undocumented
	RiskEventTypes []RiskEventType `json:"riskEventTypes,omitempty"`
	// ResourceDisplayName undocumented
	ResourceDisplayName *string `json:"resourceDisplayName,omitempty"`
	// ResourceId undocumented
	ResourceId *string `json:"resourceId,omitempty"`
}

// ISignIn interface type for signIn
type ISignIn interface {
	PSignIn() *SignIn
}

// PSignIn pointer method for signIn
func (p *SignIn) PSignIn() *SignIn { return p }

// SignInLocation undocumented
type SignInLocation struct {
	// City undocumented
	City *string `json:"city,omitempty"`
	// State undocumented
	State *string `json:"state,omitempty"`
	// CountryOrRegion undocumented
	CountryOrRegion *string `json:"countryOrRegion,omitempty"`
	// GeoCoordinates undocumented
	GeoCoordinates *GeoCoordinates `json:"geoCoordinates,omitempty"`
}

// ISignInLocation interface type for signInLocation
type ISignInLocation interface {
	PSignInLocation() *SignInLocation
}

// PSignInLocation pointer method for signInLocation
func (p *SignInLocation) PSignInLocation() *SignInLocation { return p }

// SignInStatus undocumented
type SignInStatus struct {
	// ErrorCode undocumented
	ErrorCode *int `json:"errorCode,omitempty"`
	// FailureReason undocumented
	FailureReason *string `json:"failureReason,omitempty"`
	// AdditionalDetails undocumented
	AdditionalDetails *string `json:"additionalDetails,omitempty"`
}

// ISignInStatus interface type for signInStatus
type ISignInStatus interface {
	PSignInStatus() *SignInStatus
}

// PSignInStatus pointer method for signInStatus
func (p *SignInStatus) PSignInStatus() *SignInStatus { return p }

// SingleValueLegacyExtendedProperty undocumented
type SingleValueLegacyExtendedProperty struct {
	Entity
	// Value undocumented
	Value *string `json:"value,omitempty"`
}

// ISingleValueLegacyExtendedProperty interface type for singleValueLegacyExtendedProperty
type ISingleValueLegacyExtendedProperty interface {
	PSingleValueLegacyExtendedProperty() *SingleValueLegacyExtendedProperty
}

// PSingleValueLegacyExtendedProperty pointer method for singleValueLegacyExtendedProperty
func (p *SingleValueLegacyExtendedProperty) PSingleValueLegacyExtendedProperty() *SingleValueLegacyExtendedProperty {
	return p
}

// Site undocumented
type Site struct {
	BaseItem
	// DisplayName undocumented
	DisplayName *string `json:"displayName,omitempty"`
	// Root undocumented
	Root *Root `json:"root,omitempty"`
	// SharepointIds undocumented
	SharepointIds *SharepointIds `json:"sharepointIds,omitempty"`
	// SiteCollection undocumented
	SiteCollection *SiteCollection `json:"siteCollection,omitempty"`
}

// ISite interface type for site
type ISite interface {
	PSite() *Site
}

// PSite pointer method for site
func (p *Site) PSite() *Site { return p }

// SiteCollection undocumented
type SiteCollection struct {
	// Hostname undocumented
	Hostname *string `json:"hostname,omitempty"`
	// Root undocumented
	Root *Root `json:"root,omitempty"`
}

// ISiteCollection interface type for siteCollection
type ISiteCollection interface {
	PSiteCollection() *SiteCollection
}

// PSiteCollection pointer method for siteCollection
func (p *SiteCollection) PSiteCollection() *SiteCollection { return p }

// SizeRange undocumented
type SizeRange struct {
	// MinimumSize undocumented
	MinimumSize *int `json:"minimumSize,omitempty"`
	// MaximumSize undocumented
	MaximumSize *int `json:"maximumSize,omitempty"`
}

// ISizeRange interface type for sizeRange
type ISizeRange interface {
	PSizeRange() *SizeRange
}

// PSizeRange pointer method for sizeRange
func (p *SizeRange) PSizeRange() *SizeRange { return p }

// SoftwareUpdateStatusSummary undocumented
type SoftwareUpdateStatusSummary struct {
	Entity
	// DisplayName The name of the policy.
	DisplayName *string `json:"displayName,omitempty"`
	// CompliantDeviceCount Number of compliant devices.
	CompliantDeviceCount *int `json:"compliantDeviceCount,omitempty"`
	// NonCompliantDeviceCount Number of non compliant devices.
	NonCompliantDeviceCount *int `json:"nonCompliantDeviceCount,omitempty"`
	// RemediatedDeviceCount Number of remediated devices.
	RemediatedDeviceCount *int `json:"remediatedDeviceCount,omitempty"`
	// ErrorDeviceCount Number of devices had error.
	ErrorDeviceCount *int `json:"errorDeviceCount,omitempty"`
	// UnknownDeviceCount Number of unknown devices.
	UnknownDeviceCount *int `json:"unknownDeviceCount,omitempty"`
	// ConflictDeviceCount Number of conflict devices.
	ConflictDeviceCount *int `json:"conflictDeviceCount,omitempty"`
	// NotApplicableDeviceCount Number of not applicable devices.
	NotApplicableDeviceCount *int `json:"notApplicableDeviceCount,omitempty"`
	// CompliantUserCount Number of compliant users.
	CompliantUserCount *int `json:"compliantUserCount,omitempty"`
	// NonCompliantUserCount Number of non compliant users.
	NonCompliantUserCount *int `json:"nonCompliantUserCount,omitempty"`
	// RemediatedUserCount Number of remediated users.
	RemediatedUserCount *int `json:"remediatedUserCount,omitempty"`
	// ErrorUserCount Number of users had error.
	ErrorUserCount *int `json:"errorUserCount,omitempty"`
	// UnknownUserCount Number of unknown users.
	UnknownUserCount *int `json:"unknownUserCount,omitempty"`
	// ConflictUserCount Number of conflict users.
	ConflictUserCount *int `json:"conflictUserCount,omitempty"`
	// NotApplicableUserCount Number of not applicable users.
	NotApplicableUserCount *int `json:"notApplicableUserCount,omitempty"`
}

// ISoftwareUpdateStatusSummary interface type for softwareUpdateStatusSummary
type ISoftwareUpdateStatusSummary interface {
	PSoftwareUpdateStatusSummary() *SoftwareUpdateStatusSummary
}

// PSoftwareUpdateStatusSummary pointer method for softwareUpdateStatusSummary
func (p *SoftwareUpdateStatusSummary) PSoftwareUpdateStatusSummary() *SoftwareUpdateStatusSummary {
	return p
}

// SpecialFolder undocumented
type SpecialFolder struct {
	// Name undocumented
	Name *string `json:"name,omitempty"`
}

// ISpecialFolder interface type for specialFolder
type ISpecialFolder interface {
	PSpecialFolder() *SpecialFolder
}

// PSpecialFolder pointer method for specialFolder
func (p *SpecialFolder) PSpecialFolder() *SpecialFolder { return p }

// StandardTimeZoneOffset undocumented
type StandardTimeZoneOffset struct {
	// Time undocumented
	Time *time.Time `json:"time,omitempty"`
	// DayOccurrence undocumented
	DayOccurrence *int `json:"dayOccurrence,omitempty"`
	// DayOfWeek undocumented
	DayOfWeek *DayOfWeek `json:"dayOfWeek,omitempty"`
	// Month undocumented
	Month *int `json:"month,omitempty"`
	// Year undocumented
	Year *int `json:"year,omitempty"`
}

// IStandardTimeZoneOffset interface type for standardTimeZoneOffset
type IStandardTimeZoneOffset interface {
	PStandardTimeZoneOffset() *StandardTimeZoneOffset
}

// PStandardTimeZoneOffset pointer method for standardTimeZoneOffset
func (p *StandardTimeZoneOffset) PStandardTimeZoneOffset() *StandardTimeZoneOffset { return p }

// SubscribedSku undocumented
type SubscribedSku struct {
	Entity
	// CapabilityStatus undocumented
	CapabilityStatus *string `json:"capabilityStatus,omitempty"`
	// ConsumedUnits undocumented
	ConsumedUnits *int `json:"consumedUnits,omitempty"`
	// PrepaidUnits undocumented
	PrepaidUnits *LicenseUnitsDetail `json:"prepaidUnits,omitempty"`
	// ServicePlans undocumented
	ServicePlans []ServicePlanInfo `json:"servicePlans,omitempty"`
	// SkuId undocumented
	SkuId *UUID `json:"skuId,omitempty"`
	// SkuPartNumber undocumented
	SkuPartNumber *string `json:"skuPartNumber,omitempty"`
	// AppliesTo undocumented
	AppliesTo *string `json:"appliesTo,omitempty"`
}

// ISubscribedSku interface type for subscribedSku
type ISubscribedSku interface {
	PSubscribedSku() *SubscribedSku
}

// PSubscribedSku pointer method for subscribedSku
func (p *SubscribedSku) PSubscribedSku() *SubscribedSku { return p }

// Subscription undocumented
type Subscription struct {
	Entity
	// Resource undocumented
	Resource *string `json:"resource,omitempty"`
	// ChangeType undocumented
	ChangeType *string `json:"changeType,omitempty"`
	// ClientState undocumented
	ClientState *string `json:"clientState,omitempty"`
	// NotificationUrl undocumented
	NotificationUrl *string `json:"notificationUrl,omitempty"`
	// ExpirationDateTime undocumented
	ExpirationDateTime *time.Time `json:"expirationDateTime,omitempty"`
	// ApplicationId undocumented
	ApplicationId *string `json:"applicationId,omitempty"`
	// CreatorId undocumented
	CreatorId *string `json:"creatorId,omitempty"`
}

// ISubscription interface type for subscription
type ISubscription interface {
	PSubscription() *Subscription
}

// PSubscription pointer method for subscription
func (p *Subscription) PSubscription() *Subscription { return p }

// SystemFacet undocumented
type SystemFacet struct {
}

// ISystemFacet interface type for systemFacet
type ISystemFacet interface {
	PSystemFacet() *SystemFacet
}

// PSystemFacet pointer method for systemFacet
func (p *SystemFacet) PSystemFacet() *SystemFacet { return p }

// TargetResource undocumented
type TargetResource struct {
	// Id undocumented
	Id *string `json:"id,omitempty"`
	// DisplayName undocumented
	DisplayName *string `json:"displayName,omitempty"`
	// Type undocumented
	Type *string `json:"type,omitempty"`
	// UserPrincipalName undocumented
	UserPrincipalName *string `json:"userPrincipalName,omitempty"`
	// GroupType undocumented
	GroupType *GroupType `json:"groupType,omitempty"`
	// ModifiedProperties undocumented
	ModifiedProperties []ModifiedProperty `json:"modifiedProperties,omitempty"`
}

// ITargetResource interface type for targetResource
type ITargetResource interface {
	PTargetResource() *TargetResource
}

// PTargetResource pointer method for targetResource
func (p *TargetResource) PTargetResource() *TargetResource { return p }

// TargetedManagedAppConfiguration Configuration used to deliver a set of custom settings as-is to all users in the targeted security group
type TargetedManagedAppConfiguration struct {
	ManagedAppConfiguration
	// DeployedAppCount Count of apps to which the current policy is deployed.
	DeployedAppCount *int `json:"deployedAppCount,omitempty"`
	// IsAssigned Indicates if the policy is deployed to any inclusion groups or not.
	IsAssigned *bool `json:"isAssigned,omitempty"`
}

// ITargetedManagedAppConfiguration interface type for targetedManagedAppConfiguration
type ITargetedManagedAppConfiguration interface {
	PTargetedManagedAppConfiguration() *TargetedManagedAppConfiguration
}

// PTargetedManagedAppConfiguration pointer method for targetedManagedAppConfiguration
func (p *TargetedManagedAppConfiguration) PTargetedManagedAppConfiguration() *TargetedManagedAppConfiguration {
	return p
}

// TargetedManagedAppPolicyAssignment The type for deployment of groups or apps.
type TargetedManagedAppPolicyAssignment struct {
	Entity
	// Target Identifier for deployment of a group or app
	Target *DeviceAndAppManagementAssignmentTarget `json:"target,omitempty"`
}

// ITargetedManagedAppPolicyAssignment interface type for targetedManagedAppPolicyAssignment
type ITargetedManagedAppPolicyAssignment interface {
	PTargetedManagedAppPolicyAssignment() *TargetedManagedAppPolicyAssignment
}

// PTargetedManagedAppPolicyAssignment pointer method for targetedManagedAppPolicyAssignment
func (p *TargetedManagedAppPolicyAssignment) PTargetedManagedAppPolicyAssignment() *TargetedManagedAppPolicyAssignment {
	return p
}

// TargetedManagedAppProtection Policy used to configure detailed management settings targeted to specific security groups
type TargetedManagedAppProtection struct {
	ManagedAppProtection
	// IsAssigned Indicates if the policy is deployed to any inclusion groups or not.
	IsAssigned *bool `json:"isAssigned,omitempty"`
}

// ITargetedManagedAppProtection interface type for targetedManagedAppProtection
type ITargetedManagedAppProtection interface {
	PTargetedManagedAppProtection() *TargetedManagedAppProtection
}

// PTargetedManagedAppProtection pointer method for targetedManagedAppProtection
func (p *TargetedManagedAppProtection) PTargetedManagedAppProtection() *TargetedManagedAppProtection {
	return p
}

// Team undocumented
type Team struct {
	Entity
	// WebUrl undocumented
	WebUrl *string `json:"webUrl,omitempty"`
	// MemberSettings undocumented
	MemberSettings *TeamMemberSettings `json:"memberSettings,omitempty"`
	// GuestSettings undocumented
	GuestSettings *TeamGuestSettings `json:"guestSettings,omitempty"`
	// MessagingSettings undocumented
	MessagingSettings *TeamMessagingSettings `json:"messagingSettings,omitempty"`
	// FunSettings undocumented
	FunSettings *TeamFunSettings `json:"funSettings,omitempty"`
	// IsArchived undocumented
	IsArchived *bool `json:"isArchived,omitempty"`
}

// ITeam interface type for team
type ITeam interface {
	PTeam() *Team
}

// PTeam pointer method for team
func (p *Team) PTeam() *Team { return p }

// TeamClassSettings undocumented
type TeamClassSettings struct {
	// NotifyGuardiansAboutAssignments undocumented
	NotifyGuardiansAboutAssignments *bool `json:"notifyGuardiansAboutAssignments,omitempty"`
}

// ITeamClassSettings interface type for teamClassSettings
type ITeamClassSettings interface {
	PTeamClassSettings() *TeamClassSettings
}

// PTeamClassSettings pointer method for teamClassSettings
func (p *TeamClassSettings) PTeamClassSettings() *TeamClassSettings { return p }

// TeamFunSettings undocumented
type TeamFunSettings struct {
	// AllowGiphy undocumented
	AllowGiphy *bool `json:"allowGiphy,omitempty"`
	// GiphyContentRating undocumented
	GiphyContentRating *GiphyRatingType `json:"giphyContentRating,omitempty"`
	// AllowStickersAndMemes undocumented
	AllowStickersAndMemes *bool `json:"allowStickersAndMemes,omitempty"`
	// AllowCustomMemes undocumented
	AllowCustomMemes *bool `json:"allowCustomMemes,omitempty"`
}

// ITeamFunSettings interface type for teamFunSettings
type ITeamFunSettings interface {
	PTeamFunSettings() *TeamFunSettings
}

// PTeamFunSettings pointer method for teamFunSettings
func (p *TeamFunSettings) PTeamFunSettings() *TeamFunSettings { return p }

// TeamGuestSettings undocumented
type TeamGuestSettings struct {
	// AllowCreateUpdateChannels undocumented
	AllowCreateUpdateChannels *bool `json:"allowCreateUpdateChannels,omitempty"`
	// AllowDeleteChannels undocumented
	AllowDeleteChannels *bool `json:"allowDeleteChannels,omitempty"`
}

// ITeamGuestSettings interface type for teamGuestSettings
type ITeamGuestSettings interface {
	PTeamGuestSettings() *TeamGuestSettings
}

// PTeamGuestSettings pointer method for teamGuestSettings
func (p *TeamGuestSettings) PTeamGuestSettings() *TeamGuestSettings { return p }

// TeamMemberSettings undocumented
type TeamMemberSettings struct {
	// AllowCreateUpdateChannels undocumented
	AllowCreateUpdateChannels *bool `json:"allowCreateUpdateChannels,omitempty"`
	// AllowDeleteChannels undocumented
	AllowDeleteChannels *bool `json:"allowDeleteChannels,omitempty"`
	// AllowAddRemoveApps undocumented
	AllowAddRemoveApps *bool `json:"allowAddRemoveApps,omitempty"`
	// AllowCreateUpdateRemoveTabs undocumented
	AllowCreateUpdateRemoveTabs *bool `json:"allowCreateUpdateRemoveTabs,omitempty"`
	// AllowCreateUpdateRemoveConnectors undocumented
	AllowCreateUpdateRemoveConnectors *bool `json:"allowCreateUpdateRemoveConnectors,omitempty"`
}

// ITeamMemberSettings interface type for teamMemberSettings
type ITeamMemberSettings interface {
	PTeamMemberSettings() *TeamMemberSettings
}

// PTeamMemberSettings pointer method for teamMemberSettings
func (p *TeamMemberSettings) PTeamMemberSettings() *TeamMemberSettings { return p }

// TeamMessagingSettings undocumented
type TeamMessagingSettings struct {
	// AllowUserEditMessages undocumented
	AllowUserEditMessages *bool `json:"allowUserEditMessages,omitempty"`
	// AllowUserDeleteMessages undocumented
	AllowUserDeleteMessages *bool `json:"allowUserDeleteMessages,omitempty"`
	// AllowOwnerDeleteMessages undocumented
	AllowOwnerDeleteMessages *bool `json:"allowOwnerDeleteMessages,omitempty"`
	// AllowTeamMentions undocumented
	AllowTeamMentions *bool `json:"allowTeamMentions,omitempty"`
	// AllowChannelMentions undocumented
	AllowChannelMentions *bool `json:"allowChannelMentions,omitempty"`
}

// ITeamMessagingSettings interface type for teamMessagingSettings
type ITeamMessagingSettings interface {
	PTeamMessagingSettings() *TeamMessagingSettings
}

// PTeamMessagingSettings pointer method for teamMessagingSettings
func (p *TeamMessagingSettings) PTeamMessagingSettings() *TeamMessagingSettings { return p }

// TeamsApp undocumented
type TeamsApp struct {
	Entity
	// ExternalId undocumented
	ExternalId *string `json:"externalId,omitempty"`
	// DisplayName undocumented
	DisplayName *string `json:"displayName,omitempty"`
	// DistributionMethod undocumented
	DistributionMethod *TeamsAppDistributionMethod `json:"distributionMethod,omitempty"`
}

// ITeamsApp interface type for teamsApp
type ITeamsApp interface {
	PTeamsApp() *TeamsApp
}

// PTeamsApp pointer method for teamsApp
func (p *TeamsApp) PTeamsApp() *TeamsApp { return p }

// TeamsAppDefinition undocumented
type TeamsAppDefinition struct {
	Entity
	// TeamsAppId undocumented
	TeamsAppId *string `json:"teamsAppId,omitempty"`
	// DisplayName undocumented
	DisplayName *string `json:"displayName,omitempty"`
	// Version undocumented
	Version *string `json:"version,omitempty"`
}

// ITeamsAppDefinition interface type for teamsAppDefinition
type ITeamsAppDefinition interface {
	PTeamsAppDefinition() *TeamsAppDefinition
}

// PTeamsAppDefinition pointer method for teamsAppDefinition
func (p *TeamsAppDefinition) PTeamsAppDefinition() *TeamsAppDefinition { return p }

// TeamsAppInstallation undocumented
type TeamsAppInstallation struct {
	Entity
}

// ITeamsAppInstallation interface type for teamsAppInstallation
type ITeamsAppInstallation interface {
	PTeamsAppInstallation() *TeamsAppInstallation
}

// PTeamsAppInstallation pointer method for teamsAppInstallation
func (p *TeamsAppInstallation) PTeamsAppInstallation() *TeamsAppInstallation { return p }

// TeamsAsyncOperation undocumented
type TeamsAsyncOperation struct {
	Entity
	// OperationType undocumented
	OperationType *TeamsAsyncOperationType `json:"operationType,omitempty"`
	// CreatedDateTime undocumented
	CreatedDateTime *time.Time `json:"createdDateTime,omitempty"`
	// Status undocumented
	Status *TeamsAsyncOperationStatus `json:"status,omitempty"`
	// LastActionDateTime undocumented
	LastActionDateTime *time.Time `json:"lastActionDateTime,omitempty"`
	// AttemptsCount undocumented
	AttemptsCount *int `json:"attemptsCount,omitempty"`
	// TargetResourceId undocumented
	TargetResourceId *string `json:"targetResourceId,omitempty"`
	// TargetResourceLocation undocumented
	TargetResourceLocation *string `json:"targetResourceLocation,omitempty"`
	// Error undocumented
	Error *OperationError `json:"error,omitempty"`
}

// ITeamsAsyncOperation interface type for teamsAsyncOperation
type ITeamsAsyncOperation interface {
	PTeamsAsyncOperation() *TeamsAsyncOperation
}

// PTeamsAsyncOperation pointer method for teamsAsyncOperation
func (p *TeamsAsyncOperation) PTeamsAsyncOperation() *TeamsAsyncOperation { return p }

// TeamsTab undocumented
type TeamsTab struct {
	Entity
	// DisplayName undocumented
	DisplayName *string `json:"displayName,omitempty"`
	// WebUrl undocumented
	WebUrl *string `json:"webUrl,omitempty"`
	// Configuration undocumented
	Configuration *TeamsTabConfiguration `json:"configuration,omitempty"`
}

// ITeamsTab interface type for teamsTab
type ITeamsTab interface {
	PTeamsTab() *TeamsTab
}

// PTeamsTab pointer method for teamsTab
func (p *TeamsTab) PTeamsTab() *TeamsTab { return p }

// TeamsTabConfiguration undocumented
type TeamsTabConfiguration struct {
	// EntityId undocumented
	EntityId *string `json:"entityId,omitempty"`
	// ContentUrl undocumented
	ContentUrl *string `json:"contentUrl,omitempty"`
	// RemoveUrl undocumented
	RemoveUrl *string `json:"removeUrl,omitempty"`
	// WebsiteUrl undocumented
	WebsiteUrl *string `json:"websiteUrl,omitempty"`
}

// ITeamsTabConfiguration interface type for teamsTabConfiguration
type ITeamsTabConfiguration interface {
	PTeamsTabConfiguration() *TeamsTabConfiguration
}

// PTeamsTabConfiguration pointer method for teamsTabConfiguration
func (p *TeamsTabConfiguration) PTeamsTabConfiguration() *TeamsTabConfiguration { return p }

// TelecomExpenseManagementPartner telecomExpenseManagementPartner resources represent the metadata and status of a given TEM service. Once your organization has onboarded with a partner, the partner can be enabled or disabled to switch TEM functionality on or off.
type TelecomExpenseManagementPartner struct {
	Entity
	// DisplayName Display name of the TEM partner.
	DisplayName *string `json:"displayName,omitempty"`
	// Url URL of the TEM partner's administrative control panel, where an administrator can configure their TEM service.
	Url *string `json:"url,omitempty"`
	// AppAuthorized Whether the partner's AAD app has been authorized to access Intune.
	AppAuthorized *bool `json:"appAuthorized,omitempty"`
	// Enabled Whether Intune's connection to the TEM service is currently enabled or disabled.
	Enabled *bool `json:"enabled,omitempty"`
	// LastConnectionDateTime Timestamp of the last request sent to Intune by the TEM partner.
	LastConnectionDateTime *time.Time `json:"lastConnectionDateTime,omitempty"`
}

// ITelecomExpenseManagementPartner interface type for telecomExpenseManagementPartner
type ITelecomExpenseManagementPartner interface {
	PTelecomExpenseManagementPartner() *TelecomExpenseManagementPartner
}

// PTelecomExpenseManagementPartner pointer method for telecomExpenseManagementPartner
func (p *TelecomExpenseManagementPartner) PTelecomExpenseManagementPartner() *TelecomExpenseManagementPartner {
	return p
}

// TermsAndConditions A termsAndConditions entity represents the metadata and contents of a given Terms and Conditions (T&C) policy. T&C policies contents are presented to users upon their first attempt to enroll into Intune and subsequently upon edits where an administrator has required re-acceptance. They enable administrators to communicate the provisions to which a user must agree in order to have devices enrolled into Intune.
type TermsAndConditions struct {
	Entity
	// CreatedDateTime DateTime the object was created.
	CreatedDateTime *time.Time `json:"createdDateTime,omitempty"`
	// LastModifiedDateTime DateTime the object was last modified.
	LastModifiedDateTime *time.Time `json:"lastModifiedDateTime,omitempty"`
	// DisplayName Administrator-supplied name for the T&C policy.
	DisplayName *string `json:"displayName,omitempty"`
	// Description Administrator-supplied description of the T&C policy.
	Description *string `json:"description,omitempty"`
	// Title Administrator-supplied title of the terms and conditions. This is shown to the user on prompts to accept the T&C policy.
	Title *string `json:"title,omitempty"`
	// BodyText Administrator-supplied body text of the terms and conditions, typically the terms themselves. This is shown to the user on prompts to accept the T&C policy.
	BodyText *string `json:"bodyText,omitempty"`
	// AcceptanceStatement Administrator-supplied explanation of the terms and conditions, typically describing what it means to accept the terms and conditions set out in the T&C policy. This is shown to the user on prompts to accept the T&C policy.
	AcceptanceStatement *string `json:"acceptanceStatement,omitempty"`
	// Version Integer indicating the current version of the terms. Incremented when an administrator makes a change to the terms and wishes to require users to re-accept the modified T&C policy.
	Version *int `json:"version,omitempty"`
}

// ITermsAndConditions interface type for termsAndConditions
type ITermsAndConditions interface {
	PTermsAndConditions() *TermsAndConditions
}

// PTermsAndConditions pointer method for termsAndConditions
func (p *TermsAndConditions) PTermsAndConditions() *TermsAndConditions { return p }

// TermsAndConditionsAcceptanceStatus A termsAndConditionsAcceptanceStatus entity represents the acceptance status of a given Terms and Conditions (T&C) policy by a given user. Users must accept the most up-to-date version of the terms in order to retain access to the Company Portal.
type TermsAndConditionsAcceptanceStatus struct {
	Entity
	// UserDisplayName Display name of the user whose acceptance the entity represents.
	UserDisplayName *string `json:"userDisplayName,omitempty"`
	// AcceptedVersion Most recent version number of the T&C accepted by the user.
	AcceptedVersion *int `json:"acceptedVersion,omitempty"`
	// AcceptedDateTime DateTime when the terms were last accepted by the user.
	AcceptedDateTime *time.Time `json:"acceptedDateTime,omitempty"`
}

// ITermsAndConditionsAcceptanceStatus interface type for termsAndConditionsAcceptanceStatus
type ITermsAndConditionsAcceptanceStatus interface {
	PTermsAndConditionsAcceptanceStatus() *TermsAndConditionsAcceptanceStatus
}

// PTermsAndConditionsAcceptanceStatus pointer method for termsAndConditionsAcceptanceStatus
func (p *TermsAndConditionsAcceptanceStatus) PTermsAndConditionsAcceptanceStatus() *TermsAndConditionsAcceptanceStatus {
	return p
}

// TermsAndConditionsAssignment A termsAndConditionsAssignment entity represents the assignment of a given Terms and Conditions (T&C) policy to a given group. Users in the group will be required to accept the terms in order to have devices enrolled into Intune.
type TermsAndConditionsAssignment struct {
	Entity
	// Target Assignment target that the T&C policy is assigned to.
	Target *DeviceAndAppManagementAssignmentTarget `json:"target,omitempty"`
}

// ITermsAndConditionsAssignment interface type for termsAndConditionsAssignment
type ITermsAndConditionsAssignment interface {
	PTermsAndConditionsAssignment() *TermsAndConditionsAssignment
}

// PTermsAndConditionsAssignment pointer method for termsAndConditionsAssignment
func (p *TermsAndConditionsAssignment) PTermsAndConditionsAssignment() *TermsAndConditionsAssignment {
	return p
}

// TextColumn undocumented
type TextColumn struct {
	// AllowMultipleLines undocumented
	AllowMultipleLines *bool `json:"allowMultipleLines,omitempty"`
	// AppendChangesToExistingText undocumented
	AppendChangesToExistingText *bool `json:"appendChangesToExistingText,omitempty"`
	// LinesForEditing undocumented
	LinesForEditing *int `json:"linesForEditing,omitempty"`
	// MaxLength undocumented
	MaxLength *int `json:"maxLength,omitempty"`
	// TextType undocumented
	TextType *string `json:"textType,omitempty"`
}

// ITextColumn interface type for textColumn
type ITextColumn interface {
	PTextColumn() *TextColumn
}

// PTextColumn pointer method for textColumn
func (p *TextColumn) PTextColumn() *TextColumn { return p }

// Thumbnail undocumented
type Thumbnail struct {
	// Content undocumented
	Content *Stream `json:"content,omitempty"`
	// Height undocumented
	Height *int `json:"height,omitempty"`
	// SourceItemId undocumented
	SourceItemId *string `json:"sourceItemId,omitempty"`
	// Url undocumented
	Url *string `json:"url,omitempty"`
	// Width undocumented
	Width *int `json:"width,omitempty"`
}

// IThumbnail interface type for thumbnail
type IThumbnail interface {
	PThumbnail() *Thumbnail
}

// PThumbnail pointer method for thumbnail
func (p *Thumbnail) PThumbnail() *Thumbnail { return p }

// ThumbnailSet undocumented
type ThumbnailSet struct {
	Entity
	// Large undocumented
	Large *Thumbnail `json:"large,omitempty"`
	// Medium undocumented
	Medium *Thumbnail `json:"medium,omitempty"`
	// Small undocumented
	Small *Thumbnail `json:"small,omitempty"`
	// Source undocumented
	Source *Thumbnail `json:"source,omitempty"`
}

// IThumbnailSet interface type for thumbnailSet
type IThumbnailSet interface {
	PThumbnailSet() *ThumbnailSet
}

// PThumbnailSet pointer method for thumbnailSet
func (p *ThumbnailSet) PThumbnailSet() *ThumbnailSet { return p }

// TimeConstraint undocumented
type TimeConstraint struct {
	// ActivityDomain undocumented
	ActivityDomain *ActivityDomain `json:"activityDomain,omitempty"`
	// TimeSlots undocumented
	TimeSlots []TimeSlot `json:"timeSlots,omitempty"`
}

// ITimeConstraint interface type for timeConstraint
type ITimeConstraint interface {
	PTimeConstraint() *TimeConstraint
}

// PTimeConstraint pointer method for timeConstraint
func (p *TimeConstraint) PTimeConstraint() *TimeConstraint { return p }

// TimeSlot undocumented
type TimeSlot struct {
	// Start undocumented
	Start *DateTimeTimeZone `json:"start,omitempty"`
	// End undocumented
	End *DateTimeTimeZone `json:"end,omitempty"`
}

// ITimeSlot interface type for timeSlot
type ITimeSlot interface {
	PTimeSlot() *TimeSlot
}

// PTimeSlot pointer method for timeSlot
func (p *TimeSlot) PTimeSlot() *TimeSlot { return p }

// TimeZoneBase undocumented
type TimeZoneBase struct {
	// Name undocumented
	Name *string `json:"name,omitempty"`
}

// ITimeZoneBase interface type for timeZoneBase
type ITimeZoneBase interface {
	PTimeZoneBase() *TimeZoneBase
}

// PTimeZoneBase pointer method for timeZoneBase
func (p *TimeZoneBase) PTimeZoneBase() *TimeZoneBase { return p }

// TimeZoneInformation undocumented
type TimeZoneInformation struct {
	// Alias undocumented
	Alias *string `json:"alias,omitempty"`
	// DisplayName undocumented
	DisplayName *string `json:"displayName,omitempty"`
}

// ITimeZoneInformation interface type for timeZoneInformation
type ITimeZoneInformation interface {
	PTimeZoneInformation() *TimeZoneInformation
}

// PTimeZoneInformation pointer method for timeZoneInformation
func (p *TimeZoneInformation) PTimeZoneInformation() *TimeZoneInformation { return p }

// Trending undocumented
type Trending struct {
	Entity
	// Weight undocumented
	Weight *float64 `json:"weight,omitempty"`
	// ResourceVisualization undocumented
	ResourceVisualization *ResourceVisualization `json:"resourceVisualization,omitempty"`
	// ResourceReference undocumented
	ResourceReference *ResourceReference `json:"resourceReference,omitempty"`
	// LastModifiedDateTime undocumented
	LastModifiedDateTime *time.Time `json:"lastModifiedDateTime,omitempty"`
}

// ITrending interface type for trending
type ITrending interface {
	PTrending() *Trending
}

// PTrending pointer method for trending
func (p *Trending) PTrending() *Trending { return p }

// UpdateWindowsDeviceAccountActionParameter undocumented
type UpdateWindowsDeviceAccountActionParameter struct {
	// DeviceAccount undocumented
	DeviceAccount *WindowsDeviceAccount `json:"deviceAccount,omitempty"`
	// PasswordRotationEnabled undocumented
	PasswordRotationEnabled *bool `json:"passwordRotationEnabled,omitempty"`
	// CalendarSyncEnabled undocumented
	CalendarSyncEnabled *bool `json:"calendarSyncEnabled,omitempty"`
	// DeviceAccountEmail undocumented
	DeviceAccountEmail *string `json:"deviceAccountEmail,omitempty"`
	// ExchangeServer undocumented
	ExchangeServer *string `json:"exchangeServer,omitempty"`
	// SessionInitiationProtocalAddress undocumented
	SessionInitiationProtocalAddress *string `json:"sessionInitiationProtocalAddress,omitempty"`
}

// IUpdateWindowsDeviceAccountActionParameter interface type for updateWindowsDeviceAccountActionParameter
type IUpdateWindowsDeviceAccountActionParameter interface {
	PUpdateWindowsDeviceAccountActionParameter() *UpdateWindowsDeviceAccountActionParameter
}

// PUpdateWindowsDeviceAccountActionParameter pointer method for updateWindowsDeviceAccountActionParameter
func (p *UpdateWindowsDeviceAccountActionParameter) PUpdateWindowsDeviceAccountActionParameter() *UpdateWindowsDeviceAccountActionParameter {
	return p
}

// UploadSession undocumented
type UploadSession struct {
	// ExpirationDateTime undocumented
	ExpirationDateTime *time.Time `json:"expirationDateTime,omitempty"`
	// NextExpectedRanges undocumented
	NextExpectedRanges []string `json:"nextExpectedRanges,omitempty"`
	// UploadUrl undocumented
	UploadUrl *string `json:"uploadUrl,omitempty"`
}

// IUploadSession interface type for uploadSession
type IUploadSession interface {
	PUploadSession() *UploadSession
}

// PUploadSession pointer method for uploadSession
func (p *UploadSession) PUploadSession() *UploadSession { return p }

// UsageDetails undocumented
type UsageDetails struct {
	// LastAccessedDateTime undocumented
	LastAccessedDateTime *time.Time `json:"lastAccessedDateTime,omitempty"`
	// LastModifiedDateTime undocumented
	LastModifiedDateTime *time.Time `json:"lastModifiedDateTime,omitempty"`
}

// IUsageDetails interface type for usageDetails
type IUsageDetails interface {
	PUsageDetails() *UsageDetails
}

// PUsageDetails pointer method for usageDetails
func (p *UsageDetails) PUsageDetails() *UsageDetails { return p }

// UsedInsight undocumented
type UsedInsight struct {
	Entity
	// LastUsed undocumented
	LastUsed *UsageDetails `json:"lastUsed,omitempty"`
	// ResourceVisualization undocumented
	ResourceVisualization *ResourceVisualization `json:"resourceVisualization,omitempty"`
	// ResourceReference undocumented
	ResourceReference *ResourceReference `json:"resourceReference,omitempty"`
}

// IUsedInsight interface type for usedInsight
type IUsedInsight interface {
	PUsedInsight() *UsedInsight
}

// PUsedInsight pointer method for usedInsight
func (p *UsedInsight) PUsedInsight() *UsedInsight { return p }

// User Represents an Azure Active Directory user object.
type User struct {
	DirectoryObject
	// AccountEnabled undocumented
	AccountEnabled *bool `json:"accountEnabled,omitempty"`
	// AgeGroup undocumented
	AgeGroup *string `json:"ageGroup,omitempty"`
	// AssignedLicenses undocumented
	AssignedLicenses []AssignedLicense `json:"assignedLicenses,omitempty"`
	// AssignedPlans undocumented
	AssignedPlans []AssignedPlan `json:"assignedPlans,omitempty"`
	// BusinessPhones undocumented
	BusinessPhones []string `json:"businessPhones,omitempty"`
	// City undocumented
	City *string `json:"city,omitempty"`
	// CompanyName undocumented
	CompanyName *string `json:"companyName,omitempty"`
	// ConsentProvidedForMinor undocumented
	ConsentProvidedForMinor *string `json:"consentProvidedForMinor,omitempty"`
	// Country undocumented
	Country *string `json:"country,omitempty"`
	// Department undocumented
	Department *string `json:"department,omitempty"`
	// DisplayName undocumented
	DisplayName *string `json:"displayName,omitempty"`
	// EmployeeId undocumented
	EmployeeId *string `json:"employeeId,omitempty"`
	// FaxNumber undocumented
	FaxNumber *string `json:"faxNumber,omitempty"`
	// GivenName undocumented
	GivenName *string `json:"givenName,omitempty"`
	// ImAddresses undocumented
	ImAddresses []string `json:"imAddresses,omitempty"`
	// IsResourceAccount undocumented
	IsResourceAccount *bool `json:"isResourceAccount,omitempty"`
	// JobTitle undocumented
	JobTitle *string `json:"jobTitle,omitempty"`
	// LegalAgeGroupClassification undocumented
	LegalAgeGroupClassification *string `json:"legalAgeGroupClassification,omitempty"`
	// LicenseAssignmentStates undocumented
	LicenseAssignmentStates []LicenseAssignmentState `json:"licenseAssignmentStates,omitempty"`
	// Mail undocumented
	Mail *string `json:"mail,omitempty"`
	// MailNickname undocumented
	MailNickname *string `json:"mailNickname,omitempty"`
	// MobilePhone undocumented
	MobilePhone *string `json:"mobilePhone,omitempty"`
	// OnPremisesDistinguishedName undocumented
	OnPremisesDistinguishedName *string `json:"onPremisesDistinguishedName,omitempty"`
	// OnPremisesExtensionAttributes undocumented
	OnPremisesExtensionAttributes *OnPremisesExtensionAttributes `json:"onPremisesExtensionAttributes,omitempty"`
	// OnPremisesImmutableId undocumented
	OnPremisesImmutableId *string `json:"onPremisesImmutableId,omitempty"`
	// OnPremisesLastSyncDateTime undocumented
	OnPremisesLastSyncDateTime *time.Time `json:"onPremisesLastSyncDateTime,omitempty"`
	// OnPremisesProvisioningErrors undocumented
	OnPremisesProvisioningErrors []OnPremisesProvisioningError `json:"onPremisesProvisioningErrors,omitempty"`
	// OnPremisesSecurityIdentifier undocumented
	OnPremisesSecurityIdentifier *string `json:"onPremisesSecurityIdentifier,omitempty"`
	// OnPremisesSyncEnabled undocumented
	OnPremisesSyncEnabled *bool `json:"onPremisesSyncEnabled,omitempty"`
	// OnPremisesDomainName undocumented
	OnPremisesDomainName *string `json:"onPremisesDomainName,omitempty"`
	// OnPremisesSamAccountName undocumented
	OnPremisesSamAccountName *string `json:"onPremisesSamAccountName,omitempty"`
	// OnPremisesUserPrincipalName undocumented
	OnPremisesUserPrincipalName *string `json:"onPremisesUserPrincipalName,omitempty"`
	// OtherMails undocumented
	OtherMails []string `json:"otherMails,omitempty"`
	// PasswordPolicies undocumented
	PasswordPolicies *string `json:"passwordPolicies,omitempty"`
	// PasswordProfile undocumented
	PasswordProfile *PasswordProfile `json:"passwordProfile,omitempty"`
	// OfficeLocation undocumented
	OfficeLocation *string `json:"officeLocation,omitempty"`
	// PostalCode undocumented
	PostalCode *string `json:"postalCode,omitempty"`
	// PreferredLanguage undocumented
	PreferredLanguage *string `json:"preferredLanguage,omitempty"`
	// ProvisionedPlans undocumented
	ProvisionedPlans []ProvisionedPlan `json:"provisionedPlans,omitempty"`
	// ProxyAddresses undocumented
	ProxyAddresses []string `json:"proxyAddresses,omitempty"`
	// ShowInAddressList undocumented
	ShowInAddressList *bool `json:"showInAddressList,omitempty"`
	// SignInSessionsValidFromDateTime undocumented
	SignInSessionsValidFromDateTime *time.Time `json:"signInSessionsValidFromDateTime,omitempty"`
	// State undocumented
	State *string `json:"state,omitempty"`
	// StreetAddress undocumented
	StreetAddress *string `json:"streetAddress,omitempty"`
	// Surname undocumented
	Surname *string `json:"surname,omitempty"`
	// UsageLocation undocumented
	UsageLocation *string `json:"usageLocation,omitempty"`
	// UserPrincipalName undocumented
	UserPrincipalName *string `json:"userPrincipalName,omitempty"`
	// UserType undocumented
	UserType *string `json:"userType,omitempty"`
	// MailboxSettings undocumented
	MailboxSettings *MailboxSettings `json:"mailboxSettings,omitempty"`
	// DeviceEnrollmentLimit The limit on the maximum number of devices that the user is permitted to enroll. Allowed values are 5 or 1000.
	DeviceEnrollmentLimit *int `json:"deviceEnrollmentLimit,omitempty"`
	// AboutMe undocumented
	AboutMe *string `json:"aboutMe,omitempty"`
	// Birthday undocumented
	Birthday *time.Time `json:"birthday,omitempty"`
	// HireDate undocumented
	HireDate *time.Time `json:"hireDate,omitempty"`
	// Interests undocumented
	Interests []string `json:"interests,omitempty"`
	// MySite undocumented
	MySite *string `json:"mySite,omitempty"`
	// PastProjects undocumented
	PastProjects []string `json:"pastProjects,omitempty"`
	// PreferredName undocumented
	PreferredName *string `json:"preferredName,omitempty"`
	// Responsibilities undocumented
	Responsibilities []string `json:"responsibilities,omitempty"`
	// Schools undocumented
	Schools []string `json:"schools,omitempty"`
	// Skills undocumented
	Skills []string `json:"skills,omitempty"`
}

// IUser interface type for user
type IUser interface {
	PUser() *User
}

// PUser pointer method for user
func (p *User) PUser() *User { return p }

// UserActivity undocumented
type UserActivity struct {
	Entity
	// VisualElements undocumented
	VisualElements *VisualInfo `json:"visualElements,omitempty"`
	// ActivitySourceHost undocumented
	ActivitySourceHost *string `json:"activitySourceHost,omitempty"`
	// ActivationUrl undocumented
	ActivationUrl *string `json:"activationUrl,omitempty"`
	// AppActivityId undocumented
	AppActivityId *string `json:"appActivityId,omitempty"`
	// AppDisplayName undocumented
	AppDisplayName *string `json:"appDisplayName,omitempty"`
	// ContentUrl undocumented
	ContentUrl *string `json:"contentUrl,omitempty"`
	// CreatedDateTime undocumented
	CreatedDateTime *time.Time `json:"createdDateTime,omitempty"`
	// ExpirationDateTime undocumented
	ExpirationDateTime *time.Time `json:"expirationDateTime,omitempty"`
	// FallbackUrl undocumented
	FallbackUrl *string `json:"fallbackUrl,omitempty"`
	// LastModifiedDateTime undocumented
	LastModifiedDateTime *time.Time `json:"lastModifiedDateTime,omitempty"`
	// UserTimezone undocumented
	UserTimezone *string `json:"userTimezone,omitempty"`
	// ContentInfo undocumented
	ContentInfo json.RawMessage `json:"contentInfo,omitempty"`
	// Status undocumented
	Status *Status `json:"status,omitempty"`
}

// IUserActivity interface type for userActivity
type IUserActivity interface {
	PUserActivity() *UserActivity
}

// PUserActivity pointer method for userActivity
func (p *UserActivity) PUserActivity() *UserActivity { return p }

// UserIdentity undocumented
type UserIdentity struct {
	// Id undocumented
	Id *string `json:"id,omitempty"`
	// DisplayName undocumented
	DisplayName *string `json:"displayName,omitempty"`
	// IpAddress undocumented
	IpAddress *string `json:"ipAddress,omitempty"`
	// UserPrincipalName undocumented
	UserPrincipalName *string `json:"userPrincipalName,omitempty"`
}

// IUserIdentity interface type for userIdentity
type IUserIdentity interface {
	PUserIdentity() *UserIdentity
}

// PUserIdentity pointer method for userIdentity
func (p *UserIdentity) PUserIdentity() *UserIdentity { return p }

// UserInstallStateSummary Contains properties for the installation state summary for a user.
type UserInstallStateSummary struct {
	Entity
	// UserName User name.
	UserName *string `json:"userName,omitempty"`
	// InstalledDeviceCount Installed Device Count.
	InstalledDeviceCount *int `json:"installedDeviceCount,omitempty"`
	// FailedDeviceCount Failed Device Count.
	FailedDeviceCount *int `json:"failedDeviceCount,omitempty"`
	// NotInstalledDeviceCount Not installed device count.
	NotInstalledDeviceCount *int `json:"notInstalledDeviceCount,omitempty"`
}

// IUserInstallStateSummary interface type for userInstallStateSummary
type IUserInstallStateSummary interface {
	PUserInstallStateSummary() *UserInstallStateSummary
}

// PUserInstallStateSummary pointer method for userInstallStateSummary
func (p *UserInstallStateSummary) PUserInstallStateSummary() *UserInstallStateSummary { return p }

// UserSecurityState undocumented
type UserSecurityState struct {
	// AadUserId undocumented
	AadUserId *string `json:"aadUserId,omitempty"`
	// AccountName undocumented
	AccountName *string `json:"accountName,omitempty"`
	// DomainName undocumented
	DomainName *string `json:"domainName,omitempty"`
	// EmailRole undocumented
	EmailRole *EmailRole `json:"emailRole,omitempty"`
	// IsVpn undocumented
	IsVpn *bool `json:"isVpn,omitempty"`
	// LogonDateTime undocumented
	LogonDateTime *time.Time `json:"logonDateTime,omitempty"`
	// LogonId undocumented
	LogonId *string `json:"logonId,omitempty"`
	// LogonIp undocumented
	LogonIp *string `json:"logonIp,omitempty"`
	// LogonLocation undocumented
	LogonLocation *string `json:"logonLocation,omitempty"`
	// LogonType undocumented
	LogonType *LogonType `json:"logonType,omitempty"`
	// OnPremisesSecurityIdentifier undocumented
	OnPremisesSecurityIdentifier *string `json:"onPremisesSecurityIdentifier,omitempty"`
	// RiskScore undocumented
	RiskScore *string `json:"riskScore,omitempty"`
	// UserAccountType undocumented
	UserAccountType *UserAccountSecurityType `json:"userAccountType,omitempty"`
	// UserPrincipalName undocumented
	UserPrincipalName *string `json:"userPrincipalName,omitempty"`
}

// IUserSecurityState interface type for userSecurityState
type IUserSecurityState interface {
	PUserSecurityState() *UserSecurityState
}

// PUserSecurityState pointer method for userSecurityState
func (p *UserSecurityState) PUserSecurityState() *UserSecurityState { return p }

// UserSettings undocumented
type UserSettings struct {
	Entity
	// ContributionToContentDiscoveryDisabled undocumented
	ContributionToContentDiscoveryDisabled *bool `json:"contributionToContentDiscoveryDisabled,omitempty"`
	// ContributionToContentDiscoveryAsOrganizationDisabled undocumented
	ContributionToContentDiscoveryAsOrganizationDisabled *bool `json:"contributionToContentDiscoveryAsOrganizationDisabled,omitempty"`
}

// IUserSettings interface type for userSettings
type IUserSettings interface {
	PUserSettings() *UserSettings
}

// PUserSettings pointer method for userSettings
func (p *UserSettings) PUserSettings() *UserSettings { return p }

// VerifiedDomain undocumented
type VerifiedDomain struct {
	// Capabilities undocumented
	Capabilities *string `json:"capabilities,omitempty"`
	// IsDefault undocumented
	IsDefault *bool `json:"isDefault,omitempty"`
	// IsInitial undocumented
	IsInitial *bool `json:"isInitial,omitempty"`
	// Name undocumented
	Name *string `json:"name,omitempty"`
	// Type undocumented
	Type *string `json:"type,omitempty"`
}

// IVerifiedDomain interface type for verifiedDomain
type IVerifiedDomain interface {
	PVerifiedDomain() *VerifiedDomain
}

// PVerifiedDomain pointer method for verifiedDomain
func (p *VerifiedDomain) PVerifiedDomain() *VerifiedDomain { return p }

// Video undocumented
type Video struct {
	// AudioBitsPerSample undocumented
	AudioBitsPerSample *int `json:"audioBitsPerSample,omitempty"`
	// AudioChannels undocumented
	AudioChannels *int `json:"audioChannels,omitempty"`
	// AudioFormat undocumented
	AudioFormat *string `json:"audioFormat,omitempty"`
	// AudioSamplesPerSecond undocumented
	AudioSamplesPerSecond *int `json:"audioSamplesPerSecond,omitempty"`
	// Bitrate undocumented
	Bitrate *int `json:"bitrate,omitempty"`
	// Duration undocumented
	Duration *int `json:"duration,omitempty"`
	// FourCC undocumented
	FourCC *string `json:"fourCC,omitempty"`
	// FrameRate undocumented
	FrameRate *float64 `json:"frameRate,omitempty"`
	// Height undocumented
	Height *int `json:"height,omitempty"`
	// Width undocumented
	Width *int `json:"width,omitempty"`
}

// IVideo interface type for video
type IVideo interface {
	PVideo() *Video
}

// PVideo pointer method for video
func (p *Video) PVideo() *Video { return p }

// VisualInfo undocumented
type VisualInfo struct {
	// Attribution undocumented
	Attribution *ImageInfo `json:"attribution,omitempty"`
	// BackgroundColor undocumented
	BackgroundColor *string `json:"backgroundColor,omitempty"`
	// Description undocumented
	Description *string `json:"description,omitempty"`
	// DisplayText undocumented
	DisplayText *string `json:"displayText,omitempty"`
	// Content undocumented
	Content json.RawMessage `json:"content,omitempty"`
}

// IVisualInfo interface type for visualInfo
type IVisualInfo interface {
	PVisualInfo() *VisualInfo
}

// PVisualInfo pointer method for visualInfo
func (p *VisualInfo) PVisualInfo() *VisualInfo { return p }

// VppLicensingType undocumented
type VppLicensingType struct {
	// SupportsUserLicensing Whether the program supports the user licensing type.
	SupportsUserLicensing *bool `json:"supportsUserLicensing,omitempty"`
	// SupportsDeviceLicensing Whether the program supports the device licensing type.
	SupportsDeviceLicensing *bool `json:"supportsDeviceLicensing,omitempty"`
}

// IVppLicensingType interface type for vppLicensingType
type IVppLicensingType interface {
	PVppLicensingType() *VppLicensingType
}

// PVppLicensingType pointer method for vppLicensingType
func (p *VppLicensingType) PVppLicensingType() *VppLicensingType { return p }

// VppToken You purchase multiple licenses for iOS apps through the Apple Volume Purchase Program for Business or Education. This involves setting up an Apple VPP account from the Apple website and uploading the Apple VPP Business or Education token to Intune. You can then synchronize your volume purchase information with Intune and track your volume-purchased app use. You can upload multiple Apple VPP Business or Education tokens.
type VppToken struct {
	Entity
	// OrganizationName The organization associated with the Apple Volume Purchase Program Token
	OrganizationName *string `json:"organizationName,omitempty"`
	// VppTokenAccountType The type of volume purchase program which the given Apple Volume Purchase Program Token is associated with. Possible values are: `business`, `education`.
	VppTokenAccountType *VppTokenAccountType `json:"vppTokenAccountType,omitempty"`
	// AppleId The apple Id associated with the given Apple Volume Purchase Program Token.
	AppleId *string `json:"appleId,omitempty"`
	// ExpirationDateTime The expiration date time of the Apple Volume Purchase Program Token.
	ExpirationDateTime *time.Time `json:"expirationDateTime,omitempty"`
	// LastSyncDateTime The last time when an application sync was done with the Apple volume purchase program service using the the Apple Volume Purchase Program Token.
	LastSyncDateTime *time.Time `json:"lastSyncDateTime,omitempty"`
	// Token The Apple Volume Purchase Program Token string downloaded from the Apple Volume Purchase Program.
	Token *string `json:"token,omitempty"`
	// LastModifiedDateTime Last modification date time associated with the Apple Volume Purchase Program Token.
	LastModifiedDateTime *time.Time `json:"lastModifiedDateTime,omitempty"`
	// State Current state of the Apple Volume Purchase Program Token. Possible values are: `unknown`, `valid`, `expired`, `invalid`, `assignedToExternalMDM`.
	State *VppTokenState `json:"state,omitempty"`
	// LastSyncStatus Current sync status of the last application sync which was triggered using the Apple Volume Purchase Program Token. Possible values are: `none`, `inProgress`, `completed`, `failed`.
	LastSyncStatus *VppTokenSyncStatus `json:"lastSyncStatus,omitempty"`
	// AutomaticallyUpdateApps Whether or not apps for the VPP token will be automatically updated.
	AutomaticallyUpdateApps *bool `json:"automaticallyUpdateApps,omitempty"`
	// CountryOrRegion Whether or not apps for the VPP token will be automatically updated.
	CountryOrRegion *string `json:"countryOrRegion,omitempty"`
}

// IVppToken interface type for vppToken
type IVppToken interface {
	PVppToken() *VppToken
}

// PVppToken pointer method for vppToken
func (p *VppToken) PVppToken() *VppToken { return p }

// VulnerabilityState undocumented
type VulnerabilityState struct {
	// Cve undocumented
	Cve *string `json:"cve,omitempty"`
	// Severity undocumented
	Severity *string `json:"severity,omitempty"`
	// WasRunning undocumented
	WasRunning *bool `json:"wasRunning,omitempty"`
}

// IVulnerabilityState interface type for vulnerabilityState
type IVulnerabilityState interface {
	PVulnerabilityState() *VulnerabilityState
}

// PVulnerabilityState pointer method for vulnerabilityState
func (p *VulnerabilityState) PVulnerabilityState() *VulnerabilityState { return p }

// WebApp Contains properties and inherited properties for web apps.
type WebApp struct {
	MobileApp
	// AppUrl The web app URL.
	AppUrl *string `json:"appUrl,omitempty"`
	// UseManagedBrowser Whether or not to use managed browser. This property is only applicable for Android and IOS.
	UseManagedBrowser *bool `json:"useManagedBrowser,omitempty"`
}

// IWebApp interface type for webApp
type IWebApp interface {
	PWebApp() *WebApp
}

// PWebApp pointer method for webApp
func (p *WebApp) PWebApp() *WebApp { return p }

// Website undocumented
type Website struct {
	// Type undocumented
	Type *WebsiteType `json:"type,omitempty"`
	// Address undocumented
	Address *string `json:"address,omitempty"`
	// DisplayName undocumented
	DisplayName *string `json:"displayName,omitempty"`
}

// IWebsite interface type for website
type IWebsite interface {
	PWebsite() *Website
}

// PWebsite pointer method for website
func (p *Website) PWebsite() *Website { return p }

// Windows10CompliancePolicy This class contains compliance settings for Windows 10.
type Windows10CompliancePolicy struct {
	DeviceCompliancePolicy
	// PasswordRequired Require a password to unlock Windows device.
	PasswordRequired *bool `json:"passwordRequired,omitempty"`
	// PasswordBlockSimple Indicates whether or not to block simple password.
	PasswordBlockSimple *bool `json:"passwordBlockSimple,omitempty"`
	// PasswordRequiredToUnlockFromIdle Require a password to unlock an idle device.
	PasswordRequiredToUnlockFromIdle *bool `json:"passwordRequiredToUnlockFromIdle,omitempty"`
	// PasswordMinutesOfInactivityBeforeLock Minutes of inactivity before a password is required.
	PasswordMinutesOfInactivityBeforeLock *int `json:"passwordMinutesOfInactivityBeforeLock,omitempty"`
	// PasswordExpirationDays The password expiration in days.
	PasswordExpirationDays *int `json:"passwordExpirationDays,omitempty"`
	// PasswordMinimumLength The minimum password length.
	PasswordMinimumLength *int `json:"passwordMinimumLength,omitempty"`
	// PasswordMinimumCharacterSetCount The number of character sets required in the password.
	PasswordMinimumCharacterSetCount *int `json:"passwordMinimumCharacterSetCount,omitempty"`
	// PasswordRequiredType The required password type.
	PasswordRequiredType *RequiredPasswordType `json:"passwordRequiredType,omitempty"`
	// PasswordPreviousPasswordBlockCount The number of previous passwords to prevent re-use of.
	PasswordPreviousPasswordBlockCount *int `json:"passwordPreviousPasswordBlockCount,omitempty"`
	// RequireHealthyDeviceReport Require devices to be reported as healthy by Windows Device Health Attestation.
	RequireHealthyDeviceReport *bool `json:"requireHealthyDeviceReport,omitempty"`
	// OsMinimumVersion Minimum Windows 10 version.
	OsMinimumVersion *string `json:"osMinimumVersion,omitempty"`
	// OsMaximumVersion Maximum Windows 10 version.
	OsMaximumVersion *string `json:"osMaximumVersion,omitempty"`
	// MobileOsMinimumVersion Minimum Windows Phone version.
	MobileOsMinimumVersion *string `json:"mobileOsMinimumVersion,omitempty"`
	// MobileOsMaximumVersion Maximum Windows Phone version.
	MobileOsMaximumVersion *string `json:"mobileOsMaximumVersion,omitempty"`
	// EarlyLaunchAntiMalwareDriverEnabled Require devices to be reported as healthy by Windows Device Health Attestation - early launch antimalware driver is enabled.
	EarlyLaunchAntiMalwareDriverEnabled *bool `json:"earlyLaunchAntiMalwareDriverEnabled,omitempty"`
	// BitLockerEnabled Require devices to be reported healthy by Windows Device Health Attestation - bit locker is enabled
	BitLockerEnabled *bool `json:"bitLockerEnabled,omitempty"`
	// SecureBootEnabled Require devices to be reported as healthy by Windows Device Health Attestation - secure boot is enabled.
	SecureBootEnabled *bool `json:"secureBootEnabled,omitempty"`
	// CodeIntegrityEnabled Require devices to be reported as healthy by Windows Device Health Attestation.
	CodeIntegrityEnabled *bool `json:"codeIntegrityEnabled,omitempty"`
	// StorageRequireEncryption Require encryption on windows devices.
	StorageRequireEncryption *bool `json:"storageRequireEncryption,omitempty"`
}

// IWindows10CompliancePolicy interface type for windows10CompliancePolicy
type IWindows10CompliancePolicy interface {
	PWindows10CompliancePolicy() *Windows10CompliancePolicy
}

// PWindows10CompliancePolicy pointer method for windows10CompliancePolicy
func (p *Windows10CompliancePolicy) PWindows10CompliancePolicy() *Windows10CompliancePolicy { return p }

// Windows10CustomConfiguration This topic provides descriptions of the declared methods, properties and relationships exposed by the windows10CustomConfiguration resource.
type Windows10CustomConfiguration struct {
	DeviceConfiguration
	// OmaSettings OMA settings. This collection can contain a maximum of 1000 elements.
	OmaSettings []OmaSetting `json:"omaSettings,omitempty"`
}

// IWindows10CustomConfiguration interface type for windows10CustomConfiguration
type IWindows10CustomConfiguration interface {
	PWindows10CustomConfiguration() *Windows10CustomConfiguration
}

// PWindows10CustomConfiguration pointer method for windows10CustomConfiguration
func (p *Windows10CustomConfiguration) PWindows10CustomConfiguration() *Windows10CustomConfiguration {
	return p
}

// Windows10EndpointProtectionConfiguration This topic provides descriptions of the declared methods, properties and relationships exposed by the Windows10EndpointProtectionConfiguration resource.
type Windows10EndpointProtectionConfiguration struct {
	DeviceConfiguration
	// FirewallBlockStatefulFTP Blocks stateful FTP connections to the device
	FirewallBlockStatefulFTP *bool `json:"firewallBlockStatefulFTP,omitempty"`
	// FirewallIdleTimeoutForSecurityAssociationInSeconds Configures the idle timeout for security associations, in seconds, from 300 to 3600 inclusive. This is the period after which security associations will expire and be deleted. Valid values 300 to 3600
	FirewallIdleTimeoutForSecurityAssociationInSeconds *int `json:"firewallIdleTimeoutForSecurityAssociationInSeconds,omitempty"`
	// FirewallPreSharedKeyEncodingMethod Select the preshared key encoding to be used
	FirewallPreSharedKeyEncodingMethod *FirewallPreSharedKeyEncodingMethodType `json:"firewallPreSharedKeyEncodingMethod,omitempty"`
	// FirewallIPSecExemptionsAllowNeighborDiscovery Configures IPSec exemptions to allow neighbor discovery IPv6 ICMP type-codes
	FirewallIPSecExemptionsAllowNeighborDiscovery *bool `json:"firewallIPSecExemptionsAllowNeighborDiscovery,omitempty"`
	// FirewallIPSecExemptionsAllowICMP Configures IPSec exemptions to allow ICMP
	FirewallIPSecExemptionsAllowICMP *bool `json:"firewallIPSecExemptionsAllowICMP,omitempty"`
	// FirewallIPSecExemptionsAllowRouterDiscovery Configures IPSec exemptions to allow router discovery IPv6 ICMP type-codes
	FirewallIPSecExemptionsAllowRouterDiscovery *bool `json:"firewallIPSecExemptionsAllowRouterDiscovery,omitempty"`
	// FirewallIPSecExemptionsAllowDHCP Configures IPSec exemptions to allow both IPv4 and IPv6 DHCP traffic
	FirewallIPSecExemptionsAllowDHCP *bool `json:"firewallIPSecExemptionsAllowDHCP,omitempty"`
	// FirewallCertificateRevocationListCheckMethod Specify how the certificate revocation list is to be enforced
	FirewallCertificateRevocationListCheckMethod *FirewallCertificateRevocationListCheckMethodType `json:"firewallCertificateRevocationListCheckMethod,omitempty"`
	// FirewallMergeKeyingModuleSettings If an authentication set is not fully supported by a keying module, direct the module to ignore only unsupported authentication suites rather than the entire set
	FirewallMergeKeyingModuleSettings *bool `json:"firewallMergeKeyingModuleSettings,omitempty"`
	// FirewallPacketQueueingMethod Configures how packet queueing should be applied in the tunnel gateway scenario
	FirewallPacketQueueingMethod *FirewallPacketQueueingMethodType `json:"firewallPacketQueueingMethod,omitempty"`
	// FirewallProfileDomain Configures the firewall profile settings for domain networks
	FirewallProfileDomain *WindowsFirewallNetworkProfile `json:"firewallProfileDomain,omitempty"`
	// FirewallProfilePublic Configures the firewall profile settings for public networks
	FirewallProfilePublic *WindowsFirewallNetworkProfile `json:"firewallProfilePublic,omitempty"`
	// FirewallProfilePrivate Configures the firewall profile settings for private networks
	FirewallProfilePrivate *WindowsFirewallNetworkProfile `json:"firewallProfilePrivate,omitempty"`
	// DefenderAttackSurfaceReductionExcludedPaths List of exe files and folders to be excluded from attack surface reduction rules
	DefenderAttackSurfaceReductionExcludedPaths []string `json:"defenderAttackSurfaceReductionExcludedPaths,omitempty"`
	// DefenderGuardedFoldersAllowedAppPaths List of paths to exe that are allowed to access protected folders
	DefenderGuardedFoldersAllowedAppPaths []string `json:"defenderGuardedFoldersAllowedAppPaths,omitempty"`
	// DefenderAdditionalGuardedFolders List of folder paths to be added to the list of protected folders
	DefenderAdditionalGuardedFolders []string `json:"defenderAdditionalGuardedFolders,omitempty"`
	// DefenderExploitProtectionXml Xml content containing information regarding exploit protection details.
	DefenderExploitProtectionXml *Binary `json:"defenderExploitProtectionXml,omitempty"`
	// DefenderExploitProtectionXmlFileName Name of the file from which DefenderExploitProtectionXml was obtained.
	DefenderExploitProtectionXmlFileName *string `json:"defenderExploitProtectionXmlFileName,omitempty"`
	// DefenderSecurityCenterBlockExploitProtectionOverride Indicates whether or not to block user from overriding Exploit Protection settings.
	DefenderSecurityCenterBlockExploitProtectionOverride *bool `json:"defenderSecurityCenterBlockExploitProtectionOverride,omitempty"`
	// AppLockerApplicationControl Enables the Admin to choose what types of app to allow on devices.
	AppLockerApplicationControl *AppLockerApplicationControlType `json:"appLockerApplicationControl,omitempty"`
	// SmartScreenEnableInShell Allows IT Admins to configure SmartScreen for Windows.
	SmartScreenEnableInShell *bool `json:"smartScreenEnableInShell,omitempty"`
	// SmartScreenBlockOverrideForFiles Allows IT Admins to control whether users can can ignore SmartScreen warnings and run malicious files.
	SmartScreenBlockOverrideForFiles *bool `json:"smartScreenBlockOverrideForFiles,omitempty"`
	// ApplicationGuardEnabled Enable Windows Defender Application Guard
	ApplicationGuardEnabled *bool `json:"applicationGuardEnabled,omitempty"`
	// ApplicationGuardBlockFileTransfer Block clipboard to transfer image file, text file or neither of them
	ApplicationGuardBlockFileTransfer *ApplicationGuardBlockFileTransferType `json:"applicationGuardBlockFileTransfer,omitempty"`
	// ApplicationGuardBlockNonEnterpriseContent Block enterprise sites to load non-enterprise content, such as third party plug-ins
	ApplicationGuardBlockNonEnterpriseContent *bool `json:"applicationGuardBlockNonEnterpriseContent,omitempty"`
	// ApplicationGuardAllowPersistence Allow persisting user generated data inside the App Guard Containter (favorites, cookies, web passwords, etc.)
	ApplicationGuardAllowPersistence *bool `json:"applicationGuardAllowPersistence,omitempty"`
	// ApplicationGuardForceAuditing Force auditing will persist Windows logs and events to meet security/compliance criteria (sample events are user login-logoff, use of privilege rights, software installation, system changes, etc.)
	ApplicationGuardForceAuditing *bool `json:"applicationGuardForceAuditing,omitempty"`
	// ApplicationGuardBlockClipboardSharing Block clipboard to share data from Host to Container, or from Container to Host, or both ways, or neither ways.
	ApplicationGuardBlockClipboardSharing *ApplicationGuardBlockClipboardSharingType `json:"applicationGuardBlockClipboardSharing,omitempty"`
	// ApplicationGuardAllowPrintToPDF Allow printing to PDF from Container
	ApplicationGuardAllowPrintToPDF *bool `json:"applicationGuardAllowPrintToPDF,omitempty"`
	// ApplicationGuardAllowPrintToXPS Allow printing to XPS from Container
	ApplicationGuardAllowPrintToXPS *bool `json:"applicationGuardAllowPrintToXPS,omitempty"`
	// ApplicationGuardAllowPrintToLocalPrinters Allow printing to Local Printers from Container
	ApplicationGuardAllowPrintToLocalPrinters *bool `json:"applicationGuardAllowPrintToLocalPrinters,omitempty"`
	// ApplicationGuardAllowPrintToNetworkPrinters Allow printing to Network Printers from Container
	ApplicationGuardAllowPrintToNetworkPrinters *bool `json:"applicationGuardAllowPrintToNetworkPrinters,omitempty"`
	// BitLockerDisableWarningForOtherDiskEncryption Allows the Admin to disable the warning prompt for other disk encryption on the user machines.
	BitLockerDisableWarningForOtherDiskEncryption *bool `json:"bitLockerDisableWarningForOtherDiskEncryption,omitempty"`
	// BitLockerEnableStorageCardEncryptionOnMobile Allows the admin to require encryption to be turned on using BitLocker. This policy is valid only for a mobile SKU.
	BitLockerEnableStorageCardEncryptionOnMobile *bool `json:"bitLockerEnableStorageCardEncryptionOnMobile,omitempty"`
	// BitLockerEncryptDevice Allows the admin to require encryption to be turned on using BitLocker.
	BitLockerEncryptDevice *bool `json:"bitLockerEncryptDevice,omitempty"`
	// BitLockerRemovableDrivePolicy BitLocker Removable Drive Policy.
	BitLockerRemovableDrivePolicy *BitLockerRemovableDrivePolicy `json:"bitLockerRemovableDrivePolicy,omitempty"`
}

// IWindows10EndpointProtectionConfiguration interface type for windows10EndpointProtectionConfiguration
type IWindows10EndpointProtectionConfiguration interface {
	PWindows10EndpointProtectionConfiguration() *Windows10EndpointProtectionConfiguration
}

// PWindows10EndpointProtectionConfiguration pointer method for windows10EndpointProtectionConfiguration
func (p *Windows10EndpointProtectionConfiguration) PWindows10EndpointProtectionConfiguration() *Windows10EndpointProtectionConfiguration {
	return p
}

// Windows10EnterpriseModernAppManagementConfiguration Windows10 Enterprise Modern App Management Configuration.
type Windows10EnterpriseModernAppManagementConfiguration struct {
	DeviceConfiguration
	// UninstallBuiltInApps Indicates whether or not to uninstall a fixed list of built-in Windows apps.
	UninstallBuiltInApps *bool `json:"uninstallBuiltInApps,omitempty"`
}

// IWindows10EnterpriseModernAppManagementConfiguration interface type for windows10EnterpriseModernAppManagementConfiguration
type IWindows10EnterpriseModernAppManagementConfiguration interface {
	PWindows10EnterpriseModernAppManagementConfiguration() *Windows10EnterpriseModernAppManagementConfiguration
}

// PWindows10EnterpriseModernAppManagementConfiguration pointer method for windows10EnterpriseModernAppManagementConfiguration
func (p *Windows10EnterpriseModernAppManagementConfiguration) PWindows10EnterpriseModernAppManagementConfiguration() *Windows10EnterpriseModernAppManagementConfiguration {
	return p
}

// Windows10GeneralConfiguration This topic provides descriptions of the declared methods, properties and relationships exposed by the windows10GeneralConfiguration resource.
type Windows10GeneralConfiguration struct {
	DeviceConfiguration
	// EnterpriseCloudPrintDiscoveryEndPoint Endpoint for discovering cloud printers.
	EnterpriseCloudPrintDiscoveryEndPoint *string `json:"enterpriseCloudPrintDiscoveryEndPoint,omitempty"`
	// EnterpriseCloudPrintOAuthAuthority Authentication endpoint for acquiring OAuth tokens.
	EnterpriseCloudPrintOAuthAuthority *string `json:"enterpriseCloudPrintOAuthAuthority,omitempty"`
	// EnterpriseCloudPrintOAuthClientIdentifier GUID of a client application authorized to retrieve OAuth tokens from the OAuth Authority.
	EnterpriseCloudPrintOAuthClientIdentifier *string `json:"enterpriseCloudPrintOAuthClientIdentifier,omitempty"`
	// EnterpriseCloudPrintResourceIdentifier OAuth resource URI for print service as configured in the Azure portal.
	EnterpriseCloudPrintResourceIdentifier *string `json:"enterpriseCloudPrintResourceIdentifier,omitempty"`
	// EnterpriseCloudPrintDiscoveryMaxLimit Maximum number of printers that should be queried from a discovery endpoint. This is a mobile only setting. Valid values 1 to 65535
	EnterpriseCloudPrintDiscoveryMaxLimit *int `json:"enterpriseCloudPrintDiscoveryMaxLimit,omitempty"`
	// EnterpriseCloudPrintMopriaDiscoveryResourceIdentifier OAuth resource URI for printer discovery service as configured in Azure portal.
	EnterpriseCloudPrintMopriaDiscoveryResourceIdentifier *string `json:"enterpriseCloudPrintMopriaDiscoveryResourceIdentifier,omitempty"`
	// SearchBlockDiacritics Specifies if search can use diacritics.
	SearchBlockDiacritics *bool `json:"searchBlockDiacritics,omitempty"`
	// SearchDisableAutoLanguageDetection Specifies whether to use automatic language detection when indexing content and properties.
	SearchDisableAutoLanguageDetection *bool `json:"searchDisableAutoLanguageDetection,omitempty"`
	// SearchDisableIndexingEncryptedItems Indicates whether or not to block indexing of WIP-protected items to prevent them from appearing in search results for Cortana or Explorer.
	SearchDisableIndexingEncryptedItems *bool `json:"searchDisableIndexingEncryptedItems,omitempty"`
	// SearchEnableRemoteQueries Indicates whether or not to block remote queries of this computers index.
	SearchEnableRemoteQueries *bool `json:"searchEnableRemoteQueries,omitempty"`
	// SearchDisableIndexerBackoff Indicates whether or not to disable the search indexer backoff feature.
	SearchDisableIndexerBackoff *bool `json:"searchDisableIndexerBackoff,omitempty"`
	// SearchDisableIndexingRemovableDrive Indicates whether or not to allow users to add locations on removable drives to libraries and to be indexed.
	SearchDisableIndexingRemovableDrive *bool `json:"searchDisableIndexingRemovableDrive,omitempty"`
	// SearchEnableAutomaticIndexSizeManangement Specifies minimum amount of hard drive space on the same drive as the index location before indexing stops.
	SearchEnableAutomaticIndexSizeManangement *bool `json:"searchEnableAutomaticIndexSizeManangement,omitempty"`
	// DiagnosticsDataSubmissionMode Gets or sets a value allowing the device to send diagnostic and usage telemetry data, such as Watson.
	DiagnosticsDataSubmissionMode *DiagnosticDataSubmissionMode `json:"diagnosticsDataSubmissionMode,omitempty"`
	// OneDriveDisableFileSync Gets or sets a value allowing IT admins to prevent apps and features from working with files on OneDrive.
	OneDriveDisableFileSync *bool `json:"oneDriveDisableFileSync,omitempty"`
	// SmartScreenEnableAppInstallControl Allows IT Admins to control whether users are allowed to install apps from places other than the Store.
	SmartScreenEnableAppInstallControl *bool `json:"smartScreenEnableAppInstallControl,omitempty"`
	// PersonalizationDesktopImageUrl A http or https Url to a jpg, jpeg or png image that needs to be downloaded and used as the Desktop Image or a file Url to a local image on the file system that needs to used as the Desktop Image.
	PersonalizationDesktopImageUrl *string `json:"personalizationDesktopImageUrl,omitempty"`
	// PersonalizationLockScreenImageUrl A http or https Url to a jpg, jpeg or png image that neeeds to be downloaded and used as the Lock Screen Image or a file Url to a local image on the file system that needs to be used as the Lock Screen Image.
	PersonalizationLockScreenImageUrl *string `json:"personalizationLockScreenImageUrl,omitempty"`
	// BluetoothAllowedServices Specify a list of allowed Bluetooth services and profiles in hex formatted strings.
	BluetoothAllowedServices []string `json:"bluetoothAllowedServices,omitempty"`
	// BluetoothBlockAdvertising Whether or not to Block the user from using bluetooth advertising.
	BluetoothBlockAdvertising *bool `json:"bluetoothBlockAdvertising,omitempty"`
	// BluetoothBlockDiscoverableMode Whether or not to Block the user from using bluetooth discoverable mode.
	BluetoothBlockDiscoverableMode *bool `json:"bluetoothBlockDiscoverableMode,omitempty"`
	// BluetoothBlockPrePairing Whether or not to block specific bundled Bluetooth peripherals to automatically pair with the host device.
	BluetoothBlockPrePairing *bool `json:"bluetoothBlockPrePairing,omitempty"`
	// EdgeBlockAutofill Indicates whether or not to block auto fill.
	EdgeBlockAutofill *bool `json:"edgeBlockAutofill,omitempty"`
	// EdgeBlocked Indicates whether or not to Block the user from using the Edge browser.
	EdgeBlocked *bool `json:"edgeBlocked,omitempty"`
	// EdgeCookiePolicy Indicates which cookies to block in the Edge browser.
	EdgeCookiePolicy *EdgeCookiePolicy `json:"edgeCookiePolicy,omitempty"`
	// EdgeBlockDeveloperTools Indicates whether or not to block developer tools in the Edge browser.
	EdgeBlockDeveloperTools *bool `json:"edgeBlockDeveloperTools,omitempty"`
	// EdgeBlockSendingDoNotTrackHeader Indicates whether or not to Block the user from sending the do not track header.
	EdgeBlockSendingDoNotTrackHeader *bool `json:"edgeBlockSendingDoNotTrackHeader,omitempty"`
	// EdgeBlockExtensions Indicates whether or not to block extensions in the Edge browser.
	EdgeBlockExtensions *bool `json:"edgeBlockExtensions,omitempty"`
	// EdgeBlockInPrivateBrowsing Indicates whether or not to block InPrivate browsing on corporate networks, in the Edge browser.
	EdgeBlockInPrivateBrowsing *bool `json:"edgeBlockInPrivateBrowsing,omitempty"`
	// EdgeBlockJavaScript Indicates whether or not to Block the user from using JavaScript.
	EdgeBlockJavaScript *bool `json:"edgeBlockJavaScript,omitempty"`
	// EdgeBlockPasswordManager Indicates whether or not to Block password manager.
	EdgeBlockPasswordManager *bool `json:"edgeBlockPasswordManager,omitempty"`
	// EdgeBlockAddressBarDropdown Block the address bar dropdown functionality in Microsoft Edge. Disable this settings to minimize network connections from Microsoft Edge to Microsoft services.
	EdgeBlockAddressBarDropdown *bool `json:"edgeBlockAddressBarDropdown,omitempty"`
	// EdgeBlockCompatibilityList Block Microsoft compatibility list in Microsoft Edge. This list from Microsoft helps Edge properly display sites with known compatibility issues.
	EdgeBlockCompatibilityList *bool `json:"edgeBlockCompatibilityList,omitempty"`
	// EdgeClearBrowsingDataOnExit Clear browsing data on exiting Microsoft Edge.
	EdgeClearBrowsingDataOnExit *bool `json:"edgeClearBrowsingDataOnExit,omitempty"`
	// EdgeAllowStartPagesModification Allow users to change Start pages on Edge. Use the EdgeHomepageUrls to specify the Start pages that the user would see by default when they open Edge.
	EdgeAllowStartPagesModification *bool `json:"edgeAllowStartPagesModification,omitempty"`
	// EdgeDisableFirstRunPage Block the Microsoft web page that opens on the first use of Microsoft Edge. This policy allows enterprises, like those enrolled in zero emissions configurations, to block this page.
	EdgeDisableFirstRunPage *bool `json:"edgeDisableFirstRunPage,omitempty"`
	// EdgeBlockLiveTileDataCollection Block the collection of information by Microsoft for live tile creation when users pin a site to Start from Microsoft Edge.
	EdgeBlockLiveTileDataCollection *bool `json:"edgeBlockLiveTileDataCollection,omitempty"`
	// EdgeSyncFavoritesWithInternetExplorer Enable favorites sync between Internet Explorer and Microsoft Edge. Additions, deletions, modifications and order changes to favorites are shared between browsers.
	EdgeSyncFavoritesWithInternetExplorer *bool `json:"edgeSyncFavoritesWithInternetExplorer,omitempty"`
	// CellularBlockDataWhenRoaming Whether or not to Block the user from using data over cellular while roaming.
	CellularBlockDataWhenRoaming *bool `json:"cellularBlockDataWhenRoaming,omitempty"`
	// CellularBlockVpn Whether or not to Block the user from using VPN over cellular.
	CellularBlockVpn *bool `json:"cellularBlockVpn,omitempty"`
	// CellularBlockVpnWhenRoaming Whether or not to Block the user from using VPN when roaming over cellular.
	CellularBlockVpnWhenRoaming *bool `json:"cellularBlockVpnWhenRoaming,omitempty"`
	// DefenderBlockEndUserAccess Whether or not to block end user access to Defender.
	DefenderBlockEndUserAccess *bool `json:"defenderBlockEndUserAccess,omitempty"`
	// DefenderDaysBeforeDeletingQuarantinedMalware Number of days before deleting quarantined malware. Valid values 0 to 90
	DefenderDaysBeforeDeletingQuarantinedMalware *int `json:"defenderDaysBeforeDeletingQuarantinedMalware,omitempty"`
	// DefenderDetectedMalwareActions Gets or sets Defenders actions to take on detected Malware per threat level.
	DefenderDetectedMalwareActions *DefenderDetectedMalwareActions `json:"defenderDetectedMalwareActions,omitempty"`
	// DefenderSystemScanSchedule Defender day of the week for the system scan.
	DefenderSystemScanSchedule *WeeklySchedule `json:"defenderSystemScanSchedule,omitempty"`
	// DefenderFilesAndFoldersToExclude Files and folder to exclude from scans and real time protection.
	DefenderFilesAndFoldersToExclude []string `json:"defenderFilesAndFoldersToExclude,omitempty"`
	// DefenderFileExtensionsToExclude File extensions to exclude from scans and real time protection.
	DefenderFileExtensionsToExclude []string `json:"defenderFileExtensionsToExclude,omitempty"`
	// DefenderScanMaxCpu Max CPU usage percentage during scan. Valid values 0 to 100
	DefenderScanMaxCpu *int `json:"defenderScanMaxCpu,omitempty"`
	// DefenderMonitorFileActivity Value for monitoring file activity.
	DefenderMonitorFileActivity *DefenderMonitorFileActivity `json:"defenderMonitorFileActivity,omitempty"`
	// DefenderProcessesToExclude Processes to exclude from scans and real time protection.
	DefenderProcessesToExclude []string `json:"defenderProcessesToExclude,omitempty"`
	// DefenderPromptForSampleSubmission The configuration for how to prompt user for sample submission.
	DefenderPromptForSampleSubmission *DefenderPromptForSampleSubmission `json:"defenderPromptForSampleSubmission,omitempty"`
	// DefenderRequireBehaviorMonitoring Indicates whether or not to require behavior monitoring.
	DefenderRequireBehaviorMonitoring *bool `json:"defenderRequireBehaviorMonitoring,omitempty"`
	// DefenderRequireCloudProtection Indicates whether or not to require cloud protection.
	DefenderRequireCloudProtection *bool `json:"defenderRequireCloudProtection,omitempty"`
	// DefenderRequireNetworkInspectionSystem Indicates whether or not to require network inspection system.
	DefenderRequireNetworkInspectionSystem *bool `json:"defenderRequireNetworkInspectionSystem,omitempty"`
	// DefenderRequireRealTimeMonitoring Indicates whether or not to require real time monitoring.
	DefenderRequireRealTimeMonitoring *bool `json:"defenderRequireRealTimeMonitoring,omitempty"`
	// DefenderScanArchiveFiles Indicates whether or not to scan archive files.
	DefenderScanArchiveFiles *bool `json:"defenderScanArchiveFiles,omitempty"`
	// DefenderScanDownloads Indicates whether or not to scan downloads.
	DefenderScanDownloads *bool `json:"defenderScanDownloads,omitempty"`
	// DefenderScanNetworkFiles Indicates whether or not to scan files opened from a network folder.
	DefenderScanNetworkFiles *bool `json:"defenderScanNetworkFiles,omitempty"`
	// DefenderScanIncomingMail Indicates whether or not to scan incoming mail messages.
	DefenderScanIncomingMail *bool `json:"defenderScanIncomingMail,omitempty"`
	// DefenderScanMappedNetworkDrivesDuringFullScan Indicates whether or not to scan mapped network drives during full scan.
	DefenderScanMappedNetworkDrivesDuringFullScan *bool `json:"defenderScanMappedNetworkDrivesDuringFullScan,omitempty"`
	// DefenderScanRemovableDrivesDuringFullScan Indicates whether or not to scan removable drives during full scan.
	DefenderScanRemovableDrivesDuringFullScan *bool `json:"defenderScanRemovableDrivesDuringFullScan,omitempty"`
	// DefenderScanScriptsLoadedInInternetExplorer Indicates whether or not to scan scripts loaded in Internet Explorer browser.
	DefenderScanScriptsLoadedInInternetExplorer *bool `json:"defenderScanScriptsLoadedInInternetExplorer,omitempty"`
	// DefenderSignatureUpdateIntervalInHours The signature update interval in hours. Specify 0 not to check. Valid values 0 to 24
	DefenderSignatureUpdateIntervalInHours *int `json:"defenderSignatureUpdateIntervalInHours,omitempty"`
	// DefenderScanType The defender system scan type.
	DefenderScanType *DefenderScanType `json:"defenderScanType,omitempty"`
	// DefenderScheduledScanTime The defender time for the system scan.
	DefenderScheduledScanTime *time.Time `json:"defenderScheduledScanTime,omitempty"`
	// DefenderScheduledQuickScanTime The time to perform a daily quick scan.
	DefenderScheduledQuickScanTime *time.Time `json:"defenderScheduledQuickScanTime,omitempty"`
	// DefenderCloudBlockLevel Specifies the level of cloud-delivered protection.
	DefenderCloudBlockLevel *DefenderCloudBlockLevelType `json:"defenderCloudBlockLevel,omitempty"`
	// LockScreenAllowTimeoutConfiguration Specify whether to show a user-configurable setting to control the screen timeout while on the lock screen of Windows 10 Mobile devices. If this policy is set to Allow, the value set by lockScreenTimeoutInSeconds is ignored.
	LockScreenAllowTimeoutConfiguration *bool `json:"lockScreenAllowTimeoutConfiguration,omitempty"`
	// LockScreenBlockActionCenterNotifications Indicates whether or not to block action center notifications over lock screen.
	LockScreenBlockActionCenterNotifications *bool `json:"lockScreenBlockActionCenterNotifications,omitempty"`
	// LockScreenBlockCortana Indicates whether or not the user can interact with Cortana using speech while the system is locked.
	LockScreenBlockCortana *bool `json:"lockScreenBlockCortana,omitempty"`
	// LockScreenBlockToastNotifications Indicates whether to allow toast notifications above the device lock screen.
	LockScreenBlockToastNotifications *bool `json:"lockScreenBlockToastNotifications,omitempty"`
	// LockScreenTimeoutInSeconds Set the duration (in seconds) from the screen locking to the screen turning off for Windows 10 Mobile devices. Supported values are 11-1800. Valid values 11 to 1800
	LockScreenTimeoutInSeconds *int `json:"lockScreenTimeoutInSeconds,omitempty"`
	// PasswordBlockSimple Specify whether PINs or passwords such as "1111" or "1234" are allowed. For Windows 10 desktops, it also controls the use of picture passwords.
	PasswordBlockSimple *bool `json:"passwordBlockSimple,omitempty"`
	// PasswordExpirationDays The password expiration in days. Valid values 0 to 730
	PasswordExpirationDays *int `json:"passwordExpirationDays,omitempty"`
	// PasswordMinimumLength The minimum password length. Valid values 4 to 16
	PasswordMinimumLength *int `json:"passwordMinimumLength,omitempty"`
	// PasswordMinutesOfInactivityBeforeScreenTimeout The minutes of inactivity before the screen times out.
	PasswordMinutesOfInactivityBeforeScreenTimeout *int `json:"passwordMinutesOfInactivityBeforeScreenTimeout,omitempty"`
	// PasswordMinimumCharacterSetCount The number of character sets required in the password.
	PasswordMinimumCharacterSetCount *int `json:"passwordMinimumCharacterSetCount,omitempty"`
	// PasswordPreviousPasswordBlockCount The number of previous passwords to prevent reuse of. Valid values 0 to 50
	PasswordPreviousPasswordBlockCount *int `json:"passwordPreviousPasswordBlockCount,omitempty"`
	// PasswordRequired Indicates whether or not to require the user to have a password.
	PasswordRequired *bool `json:"passwordRequired,omitempty"`
	// PasswordRequireWhenResumeFromIdleState Indicates whether or not to require a password upon resuming from an idle state.
	PasswordRequireWhenResumeFromIdleState *bool `json:"passwordRequireWhenResumeFromIdleState,omitempty"`
	// PasswordRequiredType The required password type.
	PasswordRequiredType *RequiredPasswordType `json:"passwordRequiredType,omitempty"`
	// PasswordSignInFailureCountBeforeFactoryReset The number of sign in failures before factory reset. Valid values 0 to 999
	PasswordSignInFailureCountBeforeFactoryReset *int `json:"passwordSignInFailureCountBeforeFactoryReset,omitempty"`
	// PrivacyAdvertisingId Enables or disables the use of advertising ID. Added in Windows 10, version 1607.
	PrivacyAdvertisingId *StateManagementSetting `json:"privacyAdvertisingId,omitempty"`
	// PrivacyAutoAcceptPairingAndConsentPrompts Indicates whether or not to allow the automatic acceptance of the pairing and privacy user consent dialog when launching apps.
	PrivacyAutoAcceptPairingAndConsentPrompts *bool `json:"privacyAutoAcceptPairingAndConsentPrompts,omitempty"`
	// PrivacyBlockInputPersonalization Indicates whether or not to block the usage of cloud based speech services for Cortana, Dictation, or Store applications.
	PrivacyBlockInputPersonalization *bool `json:"privacyBlockInputPersonalization,omitempty"`
	// StartBlockUnpinningAppsFromTaskbar Indicates whether or not to block the user from unpinning apps from taskbar.
	StartBlockUnpinningAppsFromTaskbar *bool `json:"startBlockUnpinningAppsFromTaskbar,omitempty"`
	// StartMenuAppListVisibility Setting the value of this collapses the app list, removes the app list entirely, or disables the corresponding toggle in the Settings app.
	StartMenuAppListVisibility *WindowsStartMenuAppListVisibilityType `json:"startMenuAppListVisibility,omitempty"`
	// StartMenuHideChangeAccountSettings Enabling this policy hides the change account setting from appearing in the user tile in the start menu.
	StartMenuHideChangeAccountSettings *bool `json:"startMenuHideChangeAccountSettings,omitempty"`
	// StartMenuHideFrequentlyUsedApps Enabling this policy hides the most used apps from appearing on the start menu and disables the corresponding toggle in the Settings app.
	StartMenuHideFrequentlyUsedApps *bool `json:"startMenuHideFrequentlyUsedApps,omitempty"`
	// StartMenuHideHibernate Enabling this policy hides hibernate from appearing in the power button in the start menu.
	StartMenuHideHibernate *bool `json:"startMenuHideHibernate,omitempty"`
	// StartMenuHideLock Enabling this policy hides lock from appearing in the user tile in the start menu.
	StartMenuHideLock *bool `json:"startMenuHideLock,omitempty"`
	// StartMenuHidePowerButton Enabling this policy hides the power button from appearing in the start menu.
	StartMenuHidePowerButton *bool `json:"startMenuHidePowerButton,omitempty"`
	// StartMenuHideRecentJumpLists Enabling this policy hides recent jump lists from appearing on the start menu/taskbar and disables the corresponding toggle in the Settings app.
	StartMenuHideRecentJumpLists *bool `json:"startMenuHideRecentJumpLists,omitempty"`
	// StartMenuHideRecentlyAddedApps Enabling this policy hides recently added apps from appearing on the start menu and disables the corresponding toggle in the Settings app.
	StartMenuHideRecentlyAddedApps *bool `json:"startMenuHideRecentlyAddedApps,omitempty"`
	// StartMenuHideRestartOptions Enabling this policy hides Restart/Update and Restart from appearing in the power button in the start menu.
	StartMenuHideRestartOptions *bool `json:"startMenuHideRestartOptions,omitempty"`
	// StartMenuHideShutDown Enabling this policy hides shut down/update and shut down from appearing in the power button in the start menu.
	StartMenuHideShutDown *bool `json:"startMenuHideShutDown,omitempty"`
	// StartMenuHideSignOut Enabling this policy hides sign out from appearing in the user tile in the start menu.
	StartMenuHideSignOut *bool `json:"startMenuHideSignOut,omitempty"`
	// StartMenuHideSleep Enabling this policy hides sleep from appearing in the power button in the start menu.
	StartMenuHideSleep *bool `json:"startMenuHideSleep,omitempty"`
	// StartMenuHideSwitchAccount Enabling this policy hides switch account from appearing in the user tile in the start menu.
	StartMenuHideSwitchAccount *bool `json:"startMenuHideSwitchAccount,omitempty"`
	// StartMenuHideUserTile Enabling this policy hides the user tile from appearing in the start menu.
	StartMenuHideUserTile *bool `json:"startMenuHideUserTile,omitempty"`
	// StartMenuLayoutEdgeAssetsXml This policy setting allows you to import Edge assets to be used with startMenuLayoutXml policy. Start layout can contain secondary tile from Edge app which looks for Edge local asset file. Edge local asset would not exist and cause Edge secondary tile to appear empty in this case. This policy only gets applied when startMenuLayoutXml policy is modified. The value should be a UTF-8 Base64 encoded byte array.
	StartMenuLayoutEdgeAssetsXml *Binary `json:"startMenuLayoutEdgeAssetsXml,omitempty"`
	// StartMenuLayoutXml Allows admins to override the default Start menu layout and prevents the user from changing it. The layout is modified by specifying an XML file based on a layout modification schema. XML needs to be in a UTF8 encoded byte array format.
	StartMenuLayoutXml *Binary `json:"startMenuLayoutXml,omitempty"`
	// StartMenuMode Allows admins to decide how the Start menu is displayed.
	StartMenuMode *WindowsStartMenuModeType `json:"startMenuMode,omitempty"`
	// StartMenuPinnedFolderDocuments Enforces the visibility (Show/Hide) of the Documents folder shortcut on the Start menu.
	StartMenuPinnedFolderDocuments *VisibilitySetting `json:"startMenuPinnedFolderDocuments,omitempty"`
	// StartMenuPinnedFolderDownloads Enforces the visibility (Show/Hide) of the Downloads folder shortcut on the Start menu.
	StartMenuPinnedFolderDownloads *VisibilitySetting `json:"startMenuPinnedFolderDownloads,omitempty"`
	// StartMenuPinnedFolderFileExplorer Enforces the visibility (Show/Hide) of the FileExplorer shortcut on the Start menu.
	StartMenuPinnedFolderFileExplorer *VisibilitySetting `json:"startMenuPinnedFolderFileExplorer,omitempty"`
	// StartMenuPinnedFolderHomeGroup Enforces the visibility (Show/Hide) of the HomeGroup folder shortcut on the Start menu.
	StartMenuPinnedFolderHomeGroup *VisibilitySetting `json:"startMenuPinnedFolderHomeGroup,omitempty"`
	// StartMenuPinnedFolderMusic Enforces the visibility (Show/Hide) of the Music folder shortcut on the Start menu.
	StartMenuPinnedFolderMusic *VisibilitySetting `json:"startMenuPinnedFolderMusic,omitempty"`
	// StartMenuPinnedFolderNetwork Enforces the visibility (Show/Hide) of the Network folder shortcut on the Start menu.
	StartMenuPinnedFolderNetwork *VisibilitySetting `json:"startMenuPinnedFolderNetwork,omitempty"`
	// StartMenuPinnedFolderPersonalFolder Enforces the visibility (Show/Hide) of the PersonalFolder shortcut on the Start menu.
	StartMenuPinnedFolderPersonalFolder *VisibilitySetting `json:"startMenuPinnedFolderPersonalFolder,omitempty"`
	// StartMenuPinnedFolderPictures Enforces the visibility (Show/Hide) of the Pictures folder shortcut on the Start menu.
	StartMenuPinnedFolderPictures *VisibilitySetting `json:"startMenuPinnedFolderPictures,omitempty"`
	// StartMenuPinnedFolderSettings Enforces the visibility (Show/Hide) of the Settings folder shortcut on the Start menu.
	StartMenuPinnedFolderSettings *VisibilitySetting `json:"startMenuPinnedFolderSettings,omitempty"`
	// StartMenuPinnedFolderVideos Enforces the visibility (Show/Hide) of the Videos folder shortcut on the Start menu.
	StartMenuPinnedFolderVideos *VisibilitySetting `json:"startMenuPinnedFolderVideos,omitempty"`
	// SettingsBlockSettingsApp Indicates whether or not to block access to Settings app.
	SettingsBlockSettingsApp *bool `json:"settingsBlockSettingsApp,omitempty"`
	// SettingsBlockSystemPage Indicates whether or not to block access to System in Settings app.
	SettingsBlockSystemPage *bool `json:"settingsBlockSystemPage,omitempty"`
	// SettingsBlockDevicesPage Indicates whether or not to block access to Devices in Settings app.
	SettingsBlockDevicesPage *bool `json:"settingsBlockDevicesPage,omitempty"`
	// SettingsBlockNetworkInternetPage Indicates whether or not to block access to Network & Internet in Settings app.
	SettingsBlockNetworkInternetPage *bool `json:"settingsBlockNetworkInternetPage,omitempty"`
	// SettingsBlockPersonalizationPage Indicates whether or not to block access to Personalization in Settings app.
	SettingsBlockPersonalizationPage *bool `json:"settingsBlockPersonalizationPage,omitempty"`
	// SettingsBlockAccountsPage Indicates whether or not to block access to Accounts in Settings app.
	SettingsBlockAccountsPage *bool `json:"settingsBlockAccountsPage,omitempty"`
	// SettingsBlockTimeLanguagePage Indicates whether or not to block access to Time & Language in Settings app.
	SettingsBlockTimeLanguagePage *bool `json:"settingsBlockTimeLanguagePage,omitempty"`
	// SettingsBlockEaseOfAccessPage Indicates whether or not to block access to Ease of Access in Settings app.
	SettingsBlockEaseOfAccessPage *bool `json:"settingsBlockEaseOfAccessPage,omitempty"`
	// SettingsBlockPrivacyPage Indicates whether or not to block access to Privacy in Settings app.
	SettingsBlockPrivacyPage *bool `json:"settingsBlockPrivacyPage,omitempty"`
	// SettingsBlockUpdateSecurityPage Indicates whether or not to block access to Update & Security in Settings app.
	SettingsBlockUpdateSecurityPage *bool `json:"settingsBlockUpdateSecurityPage,omitempty"`
	// SettingsBlockAppsPage Indicates whether or not to block access to Apps in Settings app.
	SettingsBlockAppsPage *bool `json:"settingsBlockAppsPage,omitempty"`
	// SettingsBlockGamingPage Indicates whether or not to block access to Gaming in Settings app.
	SettingsBlockGamingPage *bool `json:"settingsBlockGamingPage,omitempty"`
	// WindowsSpotlightBlockConsumerSpecificFeatures Allows IT admins to block experiences that are typically for consumers only, such as Start suggestions, Membership notifications, Post-OOBE app install and redirect tiles.
	WindowsSpotlightBlockConsumerSpecificFeatures *bool `json:"windowsSpotlightBlockConsumerSpecificFeatures,omitempty"`
	// WindowsSpotlightBlocked Allows IT admins to turn off all Windows Spotlight features
	WindowsSpotlightBlocked *bool `json:"windowsSpotlightBlocked,omitempty"`
	// WindowsSpotlightBlockOnActionCenter Block suggestions from Microsoft that show after each OS clean install, upgrade or in an on-going basis to introduce users to what is new or changed
	WindowsSpotlightBlockOnActionCenter *bool `json:"windowsSpotlightBlockOnActionCenter,omitempty"`
	// WindowsSpotlightBlockTailoredExperiences Block personalized content in Windows spotlight based on users device usage.
	WindowsSpotlightBlockTailoredExperiences *bool `json:"windowsSpotlightBlockTailoredExperiences,omitempty"`
	// WindowsSpotlightBlockThirdPartyNotifications Block third party content delivered via Windows Spotlight
	WindowsSpotlightBlockThirdPartyNotifications *bool `json:"windowsSpotlightBlockThirdPartyNotifications,omitempty"`
	// WindowsSpotlightBlockWelcomeExperience Block Windows Spotlight Windows welcome experience
	WindowsSpotlightBlockWelcomeExperience *bool `json:"windowsSpotlightBlockWelcomeExperience,omitempty"`
	// WindowsSpotlightBlockWindowsTips Allows IT admins to turn off the popup of Windows Tips.
	WindowsSpotlightBlockWindowsTips *bool `json:"windowsSpotlightBlockWindowsTips,omitempty"`
	// WindowsSpotlightConfigureOnLockScreen Specifies the type of Spotlight
	WindowsSpotlightConfigureOnLockScreen *WindowsSpotlightEnablementSettings `json:"windowsSpotlightConfigureOnLockScreen,omitempty"`
	// NetworkProxyApplySettingsDeviceWide If set, proxy settings will be applied to all processes and accounts in the device. Otherwise, it will be applied to the user account thats enrolled into MDM.
	NetworkProxyApplySettingsDeviceWide *bool `json:"networkProxyApplySettingsDeviceWide,omitempty"`
	// NetworkProxyDisableAutoDetect Disable automatic detection of settings. If enabled, the system will try to find the path to a proxy auto-config (PAC) script.
	NetworkProxyDisableAutoDetect *bool `json:"networkProxyDisableAutoDetect,omitempty"`
	// NetworkProxyAutomaticConfigurationUrl Address to the proxy auto-config (PAC) script you want to use.
	NetworkProxyAutomaticConfigurationUrl *string `json:"networkProxyAutomaticConfigurationUrl,omitempty"`
	// NetworkProxyServer Specifies manual proxy server settings.
	NetworkProxyServer *Windows10NetworkProxyServer `json:"networkProxyServer,omitempty"`
	// AccountsBlockAddingNonMicrosoftAccountEmail Indicates whether or not to Block the user from adding email accounts to the device that are not associated with a Microsoft account.
	AccountsBlockAddingNonMicrosoftAccountEmail *bool `json:"accountsBlockAddingNonMicrosoftAccountEmail,omitempty"`
	// AntiTheftModeBlocked Indicates whether or not to block the user from selecting an AntiTheft mode preference (Windows 10 Mobile only).
	AntiTheftModeBlocked *bool `json:"antiTheftModeBlocked,omitempty"`
	// BluetoothBlocked Whether or not to Block the user from using bluetooth.
	BluetoothBlocked *bool `json:"bluetoothBlocked,omitempty"`
	// CameraBlocked Whether or not to Block the user from accessing the camera of the device.
	CameraBlocked *bool `json:"cameraBlocked,omitempty"`
	// ConnectedDevicesServiceBlocked Whether or not to block Connected Devices Service which enables discovery and connection to other devices, remote messaging, remote app sessions and other cross-device experiences.
	ConnectedDevicesServiceBlocked *bool `json:"connectedDevicesServiceBlocked,omitempty"`
	// CertificatesBlockManualRootCertificateInstallation Whether or not to Block the user from doing manual root certificate installation.
	CertificatesBlockManualRootCertificateInstallation *bool `json:"certificatesBlockManualRootCertificateInstallation,omitempty"`
	// CopyPasteBlocked Whether or not to Block the user from using copy paste.
	CopyPasteBlocked *bool `json:"copyPasteBlocked,omitempty"`
	// CortanaBlocked Whether or not to Block the user from using Cortana.
	CortanaBlocked *bool `json:"cortanaBlocked,omitempty"`
	// DeviceManagementBlockFactoryResetOnMobile Indicates whether or not to Block the user from resetting their phone.
	DeviceManagementBlockFactoryResetOnMobile *bool `json:"deviceManagementBlockFactoryResetOnMobile,omitempty"`
	// DeviceManagementBlockManualUnenroll Indicates whether or not to Block the user from doing manual un-enrollment from device management.
	DeviceManagementBlockManualUnenroll *bool `json:"deviceManagementBlockManualUnenroll,omitempty"`
	// SafeSearchFilter Specifies what filter level of safe search is required.
	SafeSearchFilter *SafeSearchFilterType `json:"safeSearchFilter,omitempty"`
	// EdgeBlockPopups Indicates whether or not to block popups.
	EdgeBlockPopups *bool `json:"edgeBlockPopups,omitempty"`
	// EdgeBlockSearchSuggestions Indicates whether or not to block the user from using the search suggestions in the address bar.
	EdgeBlockSearchSuggestions *bool `json:"edgeBlockSearchSuggestions,omitempty"`
	// EdgeBlockSendingIntranetTrafficToInternetExplorer Indicates whether or not to switch the intranet traffic from Edge to Internet Explorer. Note: the name of this property is misleading; the property is obsolete, use EdgeSendIntranetTrafficToInternetExplorer instead.
	EdgeBlockSendingIntranetTrafficToInternetExplorer *bool `json:"edgeBlockSendingIntranetTrafficToInternetExplorer,omitempty"`
	// EdgeSendIntranetTrafficToInternetExplorer Indicates whether or not to switch the intranet traffic from Edge to Internet Explorer.
	EdgeSendIntranetTrafficToInternetExplorer *bool `json:"edgeSendIntranetTrafficToInternetExplorer,omitempty"`
	// EdgeRequireSmartScreen Indicates whether or not to Require the user to use the smart screen filter.
	EdgeRequireSmartScreen *bool `json:"edgeRequireSmartScreen,omitempty"`
	// EdgeEnterpriseModeSiteListLocation Indicates the enterprise mode site list location. Could be a local file, local network or http location.
	EdgeEnterpriseModeSiteListLocation *string `json:"edgeEnterpriseModeSiteListLocation,omitempty"`
	// EdgeFirstRunUrl The first run URL for when Edge browser is opened for the first time.
	EdgeFirstRunUrl *string `json:"edgeFirstRunUrl,omitempty"`
	// EdgeSearchEngine Allows IT admins to set a default search engine for MDM-Controlled devices. Users can override this and change their default search engine provided the AllowSearchEngineCustomization policy is not set.
	EdgeSearchEngine *EdgeSearchEngineBase `json:"edgeSearchEngine,omitempty"`
	// EdgeHomepageUrls The list of URLs for homepages shodwn on MDM-enrolled devices on Edge browser.
	EdgeHomepageUrls []string `json:"edgeHomepageUrls,omitempty"`
	// EdgeBlockAccessToAboutFlags Indicates whether or not to prevent access to about flags on Edge browser.
	EdgeBlockAccessToAboutFlags *bool `json:"edgeBlockAccessToAboutFlags,omitempty"`
	// SmartScreenBlockPromptOverride Indicates whether or not users can override SmartScreen Filter warnings about potentially malicious websites.
	SmartScreenBlockPromptOverride *bool `json:"smartScreenBlockPromptOverride,omitempty"`
	// SmartScreenBlockPromptOverrideForFiles Indicates whether or not users can override the SmartScreen Filter warnings about downloading unverified files
	SmartScreenBlockPromptOverrideForFiles *bool `json:"smartScreenBlockPromptOverrideForFiles,omitempty"`
	// WebRtcBlockLocalhostIpAddress Indicates whether or not user's localhost IP address is displayed while making phone calls using the WebRTC
	WebRtcBlockLocalhostIpAddress *bool `json:"webRtcBlockLocalhostIpAddress,omitempty"`
	// InternetSharingBlocked Indicates whether or not to Block the user from using internet sharing.
	InternetSharingBlocked *bool `json:"internetSharingBlocked,omitempty"`
	// SettingsBlockAddProvisioningPackage Indicates whether or not to block the user from installing provisioning packages.
	SettingsBlockAddProvisioningPackage *bool `json:"settingsBlockAddProvisioningPackage,omitempty"`
	// SettingsBlockRemoveProvisioningPackage Indicates whether or not to block the runtime configuration agent from removing provisioning packages.
	SettingsBlockRemoveProvisioningPackage *bool `json:"settingsBlockRemoveProvisioningPackage,omitempty"`
	// SettingsBlockChangeSystemTime Indicates whether or not to block the user from changing date and time settings.
	SettingsBlockChangeSystemTime *bool `json:"settingsBlockChangeSystemTime,omitempty"`
	// SettingsBlockEditDeviceName Indicates whether or not to block the user from editing the device name.
	SettingsBlockEditDeviceName *bool `json:"settingsBlockEditDeviceName,omitempty"`
	// SettingsBlockChangeRegion Indicates whether or not to block the user from changing the region settings.
	SettingsBlockChangeRegion *bool `json:"settingsBlockChangeRegion,omitempty"`
	// SettingsBlockChangeLanguage Indicates whether or not to block the user from changing the language settings.
	SettingsBlockChangeLanguage *bool `json:"settingsBlockChangeLanguage,omitempty"`
	// SettingsBlockChangePowerSleep Indicates whether or not to block the user from changing power and sleep settings.
	SettingsBlockChangePowerSleep *bool `json:"settingsBlockChangePowerSleep,omitempty"`
	// LocationServicesBlocked Indicates whether or not to Block the user from location services.
	LocationServicesBlocked *bool `json:"locationServicesBlocked,omitempty"`
	// MicrosoftAccountBlocked Indicates whether or not to Block a Microsoft account.
	MicrosoftAccountBlocked *bool `json:"microsoftAccountBlocked,omitempty"`
	// MicrosoftAccountBlockSettingsSync Indicates whether or not to Block Microsoft account settings sync.
	MicrosoftAccountBlockSettingsSync *bool `json:"microsoftAccountBlockSettingsSync,omitempty"`
	// NfcBlocked Indicates whether or not to Block the user from using near field communication.
	NfcBlocked *bool `json:"nfcBlocked,omitempty"`
	// ResetProtectionModeBlocked Indicates whether or not to Block the user from reset protection mode.
	ResetProtectionModeBlocked *bool `json:"resetProtectionModeBlocked,omitempty"`
	// ScreenCaptureBlocked Indicates whether or not to Block the user from taking Screenshots.
	ScreenCaptureBlocked *bool `json:"screenCaptureBlocked,omitempty"`
	// StorageBlockRemovableStorage Indicates whether or not to Block the user from using removable storage.
	StorageBlockRemovableStorage *bool `json:"storageBlockRemovableStorage,omitempty"`
	// StorageRequireMobileDeviceEncryption Indicating whether or not to require encryption on a mobile device.
	StorageRequireMobileDeviceEncryption *bool `json:"storageRequireMobileDeviceEncryption,omitempty"`
	// UsbBlocked Indicates whether or not to Block the user from USB connection.
	UsbBlocked *bool `json:"usbBlocked,omitempty"`
	// VoiceRecordingBlocked Indicates whether or not to Block the user from voice recording.
	VoiceRecordingBlocked *bool `json:"voiceRecordingBlocked,omitempty"`
	// WiFiBlockAutomaticConnectHotspots Indicating whether or not to block automatically connecting to Wi-Fi hotspots. Has no impact if Wi-Fi is blocked.
	WiFiBlockAutomaticConnectHotspots *bool `json:"wiFiBlockAutomaticConnectHotspots,omitempty"`
	// WiFiBlocked Indicates whether or not to Block the user from using Wi-Fi.
	WiFiBlocked *bool `json:"wiFiBlocked,omitempty"`
	// WiFiBlockManualConfiguration Indicates whether or not to Block the user from using Wi-Fi manual configuration.
	WiFiBlockManualConfiguration *bool `json:"wiFiBlockManualConfiguration,omitempty"`
	// WiFiScanInterval Specify how often devices scan for Wi-Fi networks. Supported values are 1-500, where 100 = default, and 500 = low frequency. Valid values 1 to 500
	WiFiScanInterval *int `json:"wiFiScanInterval,omitempty"`
	// WirelessDisplayBlockProjectionToThisDevice Indicates whether or not to allow other devices from discovering this PC for projection.
	WirelessDisplayBlockProjectionToThisDevice *bool `json:"wirelessDisplayBlockProjectionToThisDevice,omitempty"`
	// WirelessDisplayBlockUserInputFromReceiver Indicates whether or not to allow user input from wireless display receiver.
	WirelessDisplayBlockUserInputFromReceiver *bool `json:"wirelessDisplayBlockUserInputFromReceiver,omitempty"`
	// WirelessDisplayRequirePinForPairing Indicates whether or not to require a PIN for new devices to initiate pairing.
	WirelessDisplayRequirePinForPairing *bool `json:"wirelessDisplayRequirePinForPairing,omitempty"`
	// WindowsStoreBlocked Indicates whether or not to Block the user from using the Windows store.
	WindowsStoreBlocked *bool `json:"windowsStoreBlocked,omitempty"`
	// AppsAllowTrustedAppsSideloading Indicates whether apps from AppX packages signed with a trusted certificate can be side loaded.
	AppsAllowTrustedAppsSideloading *StateManagementSetting `json:"appsAllowTrustedAppsSideloading,omitempty"`
	// WindowsStoreBlockAutoUpdate Indicates whether or not to block automatic update of apps from Windows Store.
	WindowsStoreBlockAutoUpdate *bool `json:"windowsStoreBlockAutoUpdate,omitempty"`
	// DeveloperUnlockSetting Indicates whether or not to allow developer unlock.
	DeveloperUnlockSetting *StateManagementSetting `json:"developerUnlockSetting,omitempty"`
	// SharedUserAppDataAllowed Indicates whether or not to block multiple users of the same app to share data.
	SharedUserAppDataAllowed *bool `json:"sharedUserAppDataAllowed,omitempty"`
	// AppsBlockWindowsStoreOriginatedApps Indicates whether or not to disable the launch of all apps from Windows Store that came pre-installed or were downloaded.
	AppsBlockWindowsStoreOriginatedApps *bool `json:"appsBlockWindowsStoreOriginatedApps,omitempty"`
	// WindowsStoreEnablePrivateStoreOnly Indicates whether or not to enable Private Store Only.
	WindowsStoreEnablePrivateStoreOnly *bool `json:"windowsStoreEnablePrivateStoreOnly,omitempty"`
	// StorageRestrictAppDataToSystemVolume Indicates whether application data is restricted to the system drive.
	StorageRestrictAppDataToSystemVolume *bool `json:"storageRestrictAppDataToSystemVolume,omitempty"`
	// StorageRestrictAppInstallToSystemVolume Indicates whether the installation of applications is restricted to the system drive.
	StorageRestrictAppInstallToSystemVolume *bool `json:"storageRestrictAppInstallToSystemVolume,omitempty"`
	// GameDvrBlocked Indicates whether or not to block DVR and broadcasting.
	GameDvrBlocked *bool `json:"gameDvrBlocked,omitempty"`
	// ExperienceBlockDeviceDiscovery Indicates whether or not to enable device discovery UX.
	ExperienceBlockDeviceDiscovery *bool `json:"experienceBlockDeviceDiscovery,omitempty"`
	// ExperienceBlockErrorDialogWhenNoSIM Indicates whether or not to allow the error dialog from displaying if no SIM card is detected.
	ExperienceBlockErrorDialogWhenNoSIM *bool `json:"experienceBlockErrorDialogWhenNoSIM,omitempty"`
	// ExperienceBlockTaskSwitcher Indicates whether or not to enable task switching on the device.
	ExperienceBlockTaskSwitcher *bool `json:"experienceBlockTaskSwitcher,omitempty"`
	// LogonBlockFastUserSwitching Disables the ability to quickly switch between users that are logged on simultaneously without logging off.
	LogonBlockFastUserSwitching *bool `json:"logonBlockFastUserSwitching,omitempty"`
	// TenantLockdownRequireNetworkDuringOutOfBoxExperience Whether the device is required to connect to the network.
	TenantLockdownRequireNetworkDuringOutOfBoxExperience *bool `json:"tenantLockdownRequireNetworkDuringOutOfBoxExperience,omitempty"`
}

// IWindows10GeneralConfiguration interface type for windows10GeneralConfiguration
type IWindows10GeneralConfiguration interface {
	PWindows10GeneralConfiguration() *Windows10GeneralConfiguration
}

// PWindows10GeneralConfiguration pointer method for windows10GeneralConfiguration
func (p *Windows10GeneralConfiguration) PWindows10GeneralConfiguration() *Windows10GeneralConfiguration {
	return p
}

// Windows10MobileCompliancePolicy This class contains compliance settings for Windows 10 Mobile.
type Windows10MobileCompliancePolicy struct {
	DeviceCompliancePolicy
	// PasswordRequired Require a password to unlock Windows Phone device.
	PasswordRequired *bool `json:"passwordRequired,omitempty"`
	// PasswordBlockSimple Whether or not to block syncing the calendar.
	PasswordBlockSimple *bool `json:"passwordBlockSimple,omitempty"`
	// PasswordMinimumLength Minimum password length. Valid values 4 to 16
	PasswordMinimumLength *int `json:"passwordMinimumLength,omitempty"`
	// PasswordMinimumCharacterSetCount The number of character sets required in the password.
	PasswordMinimumCharacterSetCount *int `json:"passwordMinimumCharacterSetCount,omitempty"`
	// PasswordRequiredType The required password type.
	PasswordRequiredType *RequiredPasswordType `json:"passwordRequiredType,omitempty"`
	// PasswordPreviousPasswordBlockCount The number of previous passwords to prevent re-use of.
	PasswordPreviousPasswordBlockCount *int `json:"passwordPreviousPasswordBlockCount,omitempty"`
	// PasswordExpirationDays Number of days before password expiration. Valid values 1 to 255
	PasswordExpirationDays *int `json:"passwordExpirationDays,omitempty"`
	// PasswordMinutesOfInactivityBeforeLock Minutes of inactivity before a password is required.
	PasswordMinutesOfInactivityBeforeLock *int `json:"passwordMinutesOfInactivityBeforeLock,omitempty"`
	// PasswordRequireToUnlockFromIdle Require a password to unlock an idle device.
	PasswordRequireToUnlockFromIdle *bool `json:"passwordRequireToUnlockFromIdle,omitempty"`
	// OsMinimumVersion Minimum Windows Phone version.
	OsMinimumVersion *string `json:"osMinimumVersion,omitempty"`
	// OsMaximumVersion Maximum Windows Phone version.
	OsMaximumVersion *string `json:"osMaximumVersion,omitempty"`
	// EarlyLaunchAntiMalwareDriverEnabled Require devices to be reported as healthy by Windows Device Health Attestation - early launch antimalware driver is enabled.
	EarlyLaunchAntiMalwareDriverEnabled *bool `json:"earlyLaunchAntiMalwareDriverEnabled,omitempty"`
	// BitLockerEnabled Require devices to be reported healthy by Windows Device Health Attestation - bit locker is enabled
	BitLockerEnabled *bool `json:"bitLockerEnabled,omitempty"`
	// SecureBootEnabled Require devices to be reported as healthy by Windows Device Health Attestation - secure boot is enabled.
	SecureBootEnabled *bool `json:"secureBootEnabled,omitempty"`
	// CodeIntegrityEnabled Require devices to be reported as healthy by Windows Device Health Attestation.
	CodeIntegrityEnabled *bool `json:"codeIntegrityEnabled,omitempty"`
	// StorageRequireEncryption Require encryption on windows devices.
	StorageRequireEncryption *bool `json:"storageRequireEncryption,omitempty"`
}

// IWindows10MobileCompliancePolicy interface type for windows10MobileCompliancePolicy
type IWindows10MobileCompliancePolicy interface {
	PWindows10MobileCompliancePolicy() *Windows10MobileCompliancePolicy
}

// PWindows10MobileCompliancePolicy pointer method for windows10MobileCompliancePolicy
func (p *Windows10MobileCompliancePolicy) PWindows10MobileCompliancePolicy() *Windows10MobileCompliancePolicy {
	return p
}

// Windows10NetworkProxyServer undocumented
type Windows10NetworkProxyServer struct {
	// Address Address to the proxy server. Specify an address in the format <server>[:<port>]
	Address *string `json:"address,omitempty"`
	// Exceptions Addresses that should not use the proxy server. The system will not use the proxy server for addresses beginning with what is specified in this node.
	Exceptions []string `json:"exceptions,omitempty"`
	// UseForLocalAddresses Specifies whether the proxy server should be used for local (intranet) addresses.
	UseForLocalAddresses *bool `json:"useForLocalAddresses,omitempty"`
}

// IWindows10NetworkProxyServer interface type for windows10NetworkProxyServer
type IWindows10NetworkProxyServer interface {
	PWindows10NetworkProxyServer() *Windows10NetworkProxyServer
}

// PWindows10NetworkProxyServer pointer method for windows10NetworkProxyServer
func (p *Windows10NetworkProxyServer) PWindows10NetworkProxyServer() *Windows10NetworkProxyServer {
	return p
}

// Windows10SecureAssessmentConfiguration This topic provides descriptions of the declared methods, properties and relationships exposed by the secureAssessment resource.
type Windows10SecureAssessmentConfiguration struct {
	DeviceConfiguration
	// LaunchUri Url link to an assessment that's automatically loaded when the secure assessment browser is launched. It has to be a valid Url (http[s]://msdn.microsoft.com/).
	LaunchUri *string `json:"launchUri,omitempty"`
	// ConfigurationAccount The account used to configure the Windows device for taking the test. The user can be a domain account (domain\user), an AAD account (username@tenant.com) or a local account (username).
	ConfigurationAccount *string `json:"configurationAccount,omitempty"`
	// AllowPrinting Indicates whether or not to allow the app from printing during the test.
	AllowPrinting *bool `json:"allowPrinting,omitempty"`
	// AllowScreenCapture Indicates whether or not to allow screen capture capability during a test.
	AllowScreenCapture *bool `json:"allowScreenCapture,omitempty"`
	// AllowTextSuggestion Indicates whether or not to allow text suggestions during the test.
	AllowTextSuggestion *bool `json:"allowTextSuggestion,omitempty"`
}

// IWindows10SecureAssessmentConfiguration interface type for windows10SecureAssessmentConfiguration
type IWindows10SecureAssessmentConfiguration interface {
	PWindows10SecureAssessmentConfiguration() *Windows10SecureAssessmentConfiguration
}

// PWindows10SecureAssessmentConfiguration pointer method for windows10SecureAssessmentConfiguration
func (p *Windows10SecureAssessmentConfiguration) PWindows10SecureAssessmentConfiguration() *Windows10SecureAssessmentConfiguration {
	return p
}

// Windows10TeamGeneralConfiguration This topic provides descriptions of the declared methods, properties and relationships exposed by the windows10TeamGeneralConfiguration resource.
type Windows10TeamGeneralConfiguration struct {
	DeviceConfiguration
	// AzureOperationalInsightsBlockTelemetry Indicates whether or not to Block Azure Operational Insights.
	AzureOperationalInsightsBlockTelemetry *bool `json:"azureOperationalInsightsBlockTelemetry,omitempty"`
	// AzureOperationalInsightsWorkspaceId The Azure Operational Insights workspace id.
	AzureOperationalInsightsWorkspaceId *string `json:"azureOperationalInsightsWorkspaceId,omitempty"`
	// AzureOperationalInsightsWorkspaceKey The Azure Operational Insights Workspace key.
	AzureOperationalInsightsWorkspaceKey *string `json:"azureOperationalInsightsWorkspaceKey,omitempty"`
	// ConnectAppBlockAutoLaunch Specifies whether to automatically launch the Connect app whenever a projection is initiated.
	ConnectAppBlockAutoLaunch *bool `json:"connectAppBlockAutoLaunch,omitempty"`
	// MaintenanceWindowBlocked Indicates whether or not to Block setting a maintenance window for device updates.
	MaintenanceWindowBlocked *bool `json:"maintenanceWindowBlocked,omitempty"`
	// MaintenanceWindowDurationInHours Maintenance window duration for device updates. Valid values 0 to 5
	MaintenanceWindowDurationInHours *int `json:"maintenanceWindowDurationInHours,omitempty"`
	// MaintenanceWindowStartTime Maintenance window start time for device updates.
	MaintenanceWindowStartTime *time.Time `json:"maintenanceWindowStartTime,omitempty"`
	// MiracastChannel The channel.
	MiracastChannel *MiracastChannel `json:"miracastChannel,omitempty"`
	// MiracastBlocked Indicates whether or not to Block wireless projection.
	MiracastBlocked *bool `json:"miracastBlocked,omitempty"`
	// MiracastRequirePin Indicates whether or not to require a pin for wireless projection.
	MiracastRequirePin *bool `json:"miracastRequirePin,omitempty"`
	// SettingsBlockMyMeetingsAndFiles Specifies whether to disable the "My meetings and files" feature in the Start menu, which shows the signed-in user's meetings and files from Office 365.
	SettingsBlockMyMeetingsAndFiles *bool `json:"settingsBlockMyMeetingsAndFiles,omitempty"`
	// SettingsBlockSessionResume Specifies whether to allow the ability to resume a session when the session times out.
	SettingsBlockSessionResume *bool `json:"settingsBlockSessionResume,omitempty"`
	// SettingsBlockSigninSuggestions Specifies whether to disable auto-populating of the sign-in dialog with invitees from scheduled meetings.
	SettingsBlockSigninSuggestions *bool `json:"settingsBlockSigninSuggestions,omitempty"`
	// SettingsDefaultVolume Specifies the default volume value for a new session. Permitted values are 0-100. The default is 45. Valid values 0 to 100
	SettingsDefaultVolume *int `json:"settingsDefaultVolume,omitempty"`
	// SettingsScreenTimeoutInMinutes Specifies the number of minutes until the Hub screen turns off.
	SettingsScreenTimeoutInMinutes *int `json:"settingsScreenTimeoutInMinutes,omitempty"`
	// SettingsSessionTimeoutInMinutes Specifies the number of minutes until the session times out.
	SettingsSessionTimeoutInMinutes *int `json:"settingsSessionTimeoutInMinutes,omitempty"`
	// SettingsSleepTimeoutInMinutes Specifies the number of minutes until the Hub enters sleep mode.
	SettingsSleepTimeoutInMinutes *int `json:"settingsSleepTimeoutInMinutes,omitempty"`
	// WelcomeScreenBlockAutomaticWakeUp Indicates whether or not to Block the welcome screen from waking up automatically when someone enters the room.
	WelcomeScreenBlockAutomaticWakeUp *bool `json:"welcomeScreenBlockAutomaticWakeUp,omitempty"`
	// WelcomeScreenBackgroundImageUrl The welcome screen background image URL. The URL must use the HTTPS protocol and return a PNG image.
	WelcomeScreenBackgroundImageUrl *string `json:"welcomeScreenBackgroundImageUrl,omitempty"`
	// WelcomeScreenMeetingInformation The welcome screen meeting information shown.
	WelcomeScreenMeetingInformation *WelcomeScreenMeetingInformation `json:"welcomeScreenMeetingInformation,omitempty"`
}

// IWindows10TeamGeneralConfiguration interface type for windows10TeamGeneralConfiguration
type IWindows10TeamGeneralConfiguration interface {
	PWindows10TeamGeneralConfiguration() *Windows10TeamGeneralConfiguration
}

// PWindows10TeamGeneralConfiguration pointer method for windows10TeamGeneralConfiguration
func (p *Windows10TeamGeneralConfiguration) PWindows10TeamGeneralConfiguration() *Windows10TeamGeneralConfiguration {
	return p
}

// Windows81CompliancePolicy This class contains compliance settings for Windows 8.1.
type Windows81CompliancePolicy struct {
	DeviceCompliancePolicy
	// PasswordRequired Require a password to unlock Windows device.
	PasswordRequired *bool `json:"passwordRequired,omitempty"`
	// PasswordBlockSimple Indicates whether or not to block simple password.
	PasswordBlockSimple *bool `json:"passwordBlockSimple,omitempty"`
	// PasswordExpirationDays Password expiration in days.
	PasswordExpirationDays *int `json:"passwordExpirationDays,omitempty"`
	// PasswordMinimumLength The minimum password length.
	PasswordMinimumLength *int `json:"passwordMinimumLength,omitempty"`
	// PasswordMinutesOfInactivityBeforeLock Minutes of inactivity before a password is required.
	PasswordMinutesOfInactivityBeforeLock *int `json:"passwordMinutesOfInactivityBeforeLock,omitempty"`
	// PasswordMinimumCharacterSetCount The number of character sets required in the password.
	PasswordMinimumCharacterSetCount *int `json:"passwordMinimumCharacterSetCount,omitempty"`
	// PasswordRequiredType The required password type.
	PasswordRequiredType *RequiredPasswordType `json:"passwordRequiredType,omitempty"`
	// PasswordPreviousPasswordBlockCount The number of previous passwords to prevent re-use of. Valid values 0 to 24
	PasswordPreviousPasswordBlockCount *int `json:"passwordPreviousPasswordBlockCount,omitempty"`
	// OsMinimumVersion Minimum Windows 8.1 version.
	OsMinimumVersion *string `json:"osMinimumVersion,omitempty"`
	// OsMaximumVersion Maximum Windows 8.1 version.
	OsMaximumVersion *string `json:"osMaximumVersion,omitempty"`
	// StorageRequireEncryption Indicates whether or not to require encryption on a windows 8.1 device.
	StorageRequireEncryption *bool `json:"storageRequireEncryption,omitempty"`
}

// IWindows81CompliancePolicy interface type for windows81CompliancePolicy
type IWindows81CompliancePolicy interface {
	PWindows81CompliancePolicy() *Windows81CompliancePolicy
}

// PWindows81CompliancePolicy pointer method for windows81CompliancePolicy
func (p *Windows81CompliancePolicy) PWindows81CompliancePolicy() *Windows81CompliancePolicy { return p }

// Windows81GeneralConfiguration This topic provides descriptions of the declared methods, properties and relationships exposed by the windows81GeneralConfiguration resource.
type Windows81GeneralConfiguration struct {
	DeviceConfiguration
	// AccountsBlockAddingNonMicrosoftAccountEmail Indicates whether or not to Block the user from adding email accounts to the device that are not associated with a Microsoft account.
	AccountsBlockAddingNonMicrosoftAccountEmail *bool `json:"accountsBlockAddingNonMicrosoftAccountEmail,omitempty"`
	// ApplyOnlyToWindows81 Value indicating whether this policy only applies to Windows 8.1. This property is read-only.
	ApplyOnlyToWindows81 *bool `json:"applyOnlyToWindows81,omitempty"`
	// BrowserBlockAutofill Indicates whether or not to block auto fill.
	BrowserBlockAutofill *bool `json:"browserBlockAutofill,omitempty"`
	// BrowserBlockAutomaticDetectionOfIntranetSites Indicates whether or not to block automatic detection of Intranet sites.
	BrowserBlockAutomaticDetectionOfIntranetSites *bool `json:"browserBlockAutomaticDetectionOfIntranetSites,omitempty"`
	// BrowserBlockEnterpriseModeAccess Indicates whether or not to block enterprise mode access.
	BrowserBlockEnterpriseModeAccess *bool `json:"browserBlockEnterpriseModeAccess,omitempty"`
	// BrowserBlockJavaScript Indicates whether or not to Block the user from using JavaScript.
	BrowserBlockJavaScript *bool `json:"browserBlockJavaScript,omitempty"`
	// BrowserBlockPlugins Indicates whether or not to block plug-ins.
	BrowserBlockPlugins *bool `json:"browserBlockPlugins,omitempty"`
	// BrowserBlockPopups Indicates whether or not to block popups.
	BrowserBlockPopups *bool `json:"browserBlockPopups,omitempty"`
	// BrowserBlockSendingDoNotTrackHeader Indicates whether or not to Block the user from sending the do not track header.
	BrowserBlockSendingDoNotTrackHeader *bool `json:"browserBlockSendingDoNotTrackHeader,omitempty"`
	// BrowserBlockSingleWordEntryOnIntranetSites Indicates whether or not to block a single word entry on Intranet sites.
	BrowserBlockSingleWordEntryOnIntranetSites *bool `json:"browserBlockSingleWordEntryOnIntranetSites,omitempty"`
	// BrowserRequireSmartScreen Indicates whether or not to require the user to use the smart screen filter.
	BrowserRequireSmartScreen *bool `json:"browserRequireSmartScreen,omitempty"`
	// BrowserEnterpriseModeSiteListLocation The enterprise mode site list location. Could be a local file, local network or http location.
	BrowserEnterpriseModeSiteListLocation *string `json:"browserEnterpriseModeSiteListLocation,omitempty"`
	// BrowserInternetSecurityLevel The internet security level.
	BrowserInternetSecurityLevel *InternetSiteSecurityLevel `json:"browserInternetSecurityLevel,omitempty"`
	// BrowserIntranetSecurityLevel The Intranet security level.
	BrowserIntranetSecurityLevel *SiteSecurityLevel `json:"browserIntranetSecurityLevel,omitempty"`
	// BrowserLoggingReportLocation The logging report location.
	BrowserLoggingReportLocation *string `json:"browserLoggingReportLocation,omitempty"`
	// BrowserRequireHighSecurityForRestrictedSites Indicates whether or not to require high security for restricted sites.
	BrowserRequireHighSecurityForRestrictedSites *bool `json:"browserRequireHighSecurityForRestrictedSites,omitempty"`
	// BrowserRequireFirewall Indicates whether or not to require a firewall.
	BrowserRequireFirewall *bool `json:"browserRequireFirewall,omitempty"`
	// BrowserRequireFraudWarning Indicates whether or not to require fraud warning.
	BrowserRequireFraudWarning *bool `json:"browserRequireFraudWarning,omitempty"`
	// BrowserTrustedSitesSecurityLevel The trusted sites security level.
	BrowserTrustedSitesSecurityLevel *SiteSecurityLevel `json:"browserTrustedSitesSecurityLevel,omitempty"`
	// CellularBlockDataRoaming Indicates whether or not to block data roaming.
	CellularBlockDataRoaming *bool `json:"cellularBlockDataRoaming,omitempty"`
	// DiagnosticsBlockDataSubmission Indicates whether or not to block diagnostic data submission.
	DiagnosticsBlockDataSubmission *bool `json:"diagnosticsBlockDataSubmission,omitempty"`
	// PasswordBlockPicturePasswordAndPin Indicates whether or not to Block the user from using a pictures password and pin.
	PasswordBlockPicturePasswordAndPin *bool `json:"passwordBlockPicturePasswordAndPin,omitempty"`
	// PasswordExpirationDays Password expiration in days.
	PasswordExpirationDays *int `json:"passwordExpirationDays,omitempty"`
	// PasswordMinimumLength The minimum password length.
	PasswordMinimumLength *int `json:"passwordMinimumLength,omitempty"`
	// PasswordMinutesOfInactivityBeforeScreenTimeout The minutes of inactivity before the screen times out.
	PasswordMinutesOfInactivityBeforeScreenTimeout *int `json:"passwordMinutesOfInactivityBeforeScreenTimeout,omitempty"`
	// PasswordMinimumCharacterSetCount The number of character sets required in the password.
	PasswordMinimumCharacterSetCount *int `json:"passwordMinimumCharacterSetCount,omitempty"`
	// PasswordPreviousPasswordBlockCount The number of previous passwords to prevent re-use of. Valid values 0 to 24
	PasswordPreviousPasswordBlockCount *int `json:"passwordPreviousPasswordBlockCount,omitempty"`
	// PasswordRequiredType The required password type.
	PasswordRequiredType *RequiredPasswordType `json:"passwordRequiredType,omitempty"`
	// PasswordSignInFailureCountBeforeFactoryReset The number of sign in failures before factory reset.
	PasswordSignInFailureCountBeforeFactoryReset *int `json:"passwordSignInFailureCountBeforeFactoryReset,omitempty"`
	// StorageRequireDeviceEncryption Indicates whether or not to require encryption on a mobile device.
	StorageRequireDeviceEncryption *bool `json:"storageRequireDeviceEncryption,omitempty"`
	// UpdatesRequireAutomaticUpdates Indicates whether or not to require automatic updates.
	UpdatesRequireAutomaticUpdates *bool `json:"updatesRequireAutomaticUpdates,omitempty"`
	// UserAccountControlSettings The user account control settings.
	UserAccountControlSettings *WindowsUserAccountControlSettings `json:"userAccountControlSettings,omitempty"`
	// WorkFoldersUrl The work folders url.
	WorkFoldersUrl *string `json:"workFoldersUrl,omitempty"`
}

// IWindows81GeneralConfiguration interface type for windows81GeneralConfiguration
type IWindows81GeneralConfiguration interface {
	PWindows81GeneralConfiguration() *Windows81GeneralConfiguration
}

// PWindows81GeneralConfiguration pointer method for windows81GeneralConfiguration
func (p *Windows81GeneralConfiguration) PWindows81GeneralConfiguration() *Windows81GeneralConfiguration {
	return p
}

// WindowsDefenderAdvancedThreatProtectionConfiguration Windows Defender AdvancedThreatProtection Configuration.
type WindowsDefenderAdvancedThreatProtectionConfiguration struct {
	DeviceConfiguration
	// AllowSampleSharing Windows Defender AdvancedThreatProtection "Allow Sample Sharing" Rule
	AllowSampleSharing *bool `json:"allowSampleSharing,omitempty"`
	// EnableExpeditedTelemetryReporting Expedite Windows Defender Advanced Threat Protection telemetry reporting frequency.
	EnableExpeditedTelemetryReporting *bool `json:"enableExpeditedTelemetryReporting,omitempty"`
}

// IWindowsDefenderAdvancedThreatProtectionConfiguration interface type for windowsDefenderAdvancedThreatProtectionConfiguration
type IWindowsDefenderAdvancedThreatProtectionConfiguration interface {
	PWindowsDefenderAdvancedThreatProtectionConfiguration() *WindowsDefenderAdvancedThreatProtectionConfiguration
}

// PWindowsDefenderAdvancedThreatProtectionConfiguration pointer method for windowsDefenderAdvancedThreatProtectionConfiguration
func (p *WindowsDefenderAdvancedThreatProtectionConfiguration) PWindowsDefenderAdvancedThreatProtectionConfiguration() *WindowsDefenderAdvancedThreatProtectionConfiguration {
	return p
}

// WindowsDefenderScanActionResult undocumented
type WindowsDefenderScanActionResult struct {
	DeviceActionResult
	// ScanType Scan type either full scan or quick scan
	ScanType *string `json:"scanType,omitempty"`
}

// IWindowsDefenderScanActionResult interface type for windowsDefenderScanActionResult
type IWindowsDefenderScanActionResult interface {
	PWindowsDefenderScanActionResult() *WindowsDefenderScanActionResult
}

// PWindowsDefenderScanActionResult pointer method for windowsDefenderScanActionResult
func (p *WindowsDefenderScanActionResult) PWindowsDefenderScanActionResult() *WindowsDefenderScanActionResult {
	return p
}

// WindowsDeviceADAccount undocumented
type WindowsDeviceADAccount struct {
	WindowsDeviceAccount
	// DomainName undocumented
	DomainName *string `json:"domainName,omitempty"`
	// UserName undocumented
	UserName *string `json:"userName,omitempty"`
}

// IWindowsDeviceADAccount interface type for windowsDeviceADAccount
type IWindowsDeviceADAccount interface {
	PWindowsDeviceADAccount() *WindowsDeviceADAccount
}

// PWindowsDeviceADAccount pointer method for windowsDeviceADAccount
func (p *WindowsDeviceADAccount) PWindowsDeviceADAccount() *WindowsDeviceADAccount { return p }

// WindowsDeviceAccount undocumented
type WindowsDeviceAccount struct {
	// Password undocumented
	Password *string `json:"password,omitempty"`
}

// IWindowsDeviceAccount interface type for windowsDeviceAccount
type IWindowsDeviceAccount interface {
	PWindowsDeviceAccount() *WindowsDeviceAccount
}

// PWindowsDeviceAccount pointer method for windowsDeviceAccount
func (p *WindowsDeviceAccount) PWindowsDeviceAccount() *WindowsDeviceAccount { return p }

// WindowsDeviceAzureADAccount undocumented
type WindowsDeviceAzureADAccount struct {
	WindowsDeviceAccount
	// UserPrincipalName undocumented
	UserPrincipalName *string `json:"userPrincipalName,omitempty"`
}

// IWindowsDeviceAzureADAccount interface type for windowsDeviceAzureADAccount
type IWindowsDeviceAzureADAccount interface {
	PWindowsDeviceAzureADAccount() *WindowsDeviceAzureADAccount
}

// PWindowsDeviceAzureADAccount pointer method for windowsDeviceAzureADAccount
func (p *WindowsDeviceAzureADAccount) PWindowsDeviceAzureADAccount() *WindowsDeviceAzureADAccount {
	return p
}

// WindowsFirewallNetworkProfile undocumented
type WindowsFirewallNetworkProfile struct {
	// FirewallEnabled Configures the host device to allow or block the firewall and advanced security enforcement for the network profile.
	FirewallEnabled *StateManagementSetting `json:"firewallEnabled,omitempty"`
	// StealthModeBlocked Prevent the server from operating in stealth mode. When StealthModeRequired and StealthModeBlocked are both true, StealthModeBlocked takes priority.
	StealthModeBlocked *bool `json:"stealthModeBlocked,omitempty"`
	// IncomingTrafficBlocked Configures the firewall to block all incoming traffic regardless of other policy settings. When IncomingTrafficRequired and IncomingTrafficBlocked are both true, IncomingTrafficBlocked takes priority.
	IncomingTrafficBlocked *bool `json:"incomingTrafficBlocked,omitempty"`
	// UnicastResponsesToMulticastBroadcastsBlocked Configures the firewall to block unicast responses to multicast broadcast traffic. When UnicastResponsesToMulticastBroadcastsRequired and UnicastResponsesToMulticastBroadcastsBlocked are both true, UnicastResponsesToMulticastBroadcastsBlocked takes priority.
	UnicastResponsesToMulticastBroadcastsBlocked *bool `json:"unicastResponsesToMulticastBroadcastsBlocked,omitempty"`
	// InboundNotificationsBlocked Prevents the firewall from displaying notifications when an application is blocked from listening on a port. When InboundNotificationsRequired and InboundNotificationsBlocked are both true, InboundNotificationsBlocked takes priority.
	InboundNotificationsBlocked *bool `json:"inboundNotificationsBlocked,omitempty"`
	// AuthorizedApplicationRulesFromGroupPolicyMerged Configures the firewall to merge authorized application rules from group policy with those from local store instead of ignoring the local store rules. When AuthorizedApplicationRulesFromGroupPolicyNotMerged and AuthorizedApplicationRulesFromGroupPolicyMerged are both true, AuthorizedApplicationRulesFromGroupPolicyMerged takes priority.
	AuthorizedApplicationRulesFromGroupPolicyMerged *bool `json:"authorizedApplicationRulesFromGroupPolicyMerged,omitempty"`
	// GlobalPortRulesFromGroupPolicyMerged Configures the firewall to merge global port rules from group policy with those from local store instead of ignoring the local store rules. When GlobalPortRulesFromGroupPolicyNotMerged and GlobalPortRulesFromGroupPolicyMerged are both true, GlobalPortRulesFromGroupPolicyMerged takes priority.
	GlobalPortRulesFromGroupPolicyMerged *bool `json:"globalPortRulesFromGroupPolicyMerged,omitempty"`
	// ConnectionSecurityRulesFromGroupPolicyMerged Configures the firewall to merge connection security rules from group policy with those from local store instead of ignoring the local store rules. When ConnectionSecurityRulesFromGroupPolicyNotMerged and ConnectionSecurityRulesFromGroupPolicyMerged are both true, ConnectionSecurityRulesFromGroupPolicyMerged takes priority.
	ConnectionSecurityRulesFromGroupPolicyMerged *bool `json:"connectionSecurityRulesFromGroupPolicyMerged,omitempty"`
	// OutboundConnectionsBlocked Configures the firewall to block all outgoing connections by default. When OutboundConnectionsRequired and OutboundConnectionsBlocked are both true, OutboundConnectionsBlocked takes priority.
	OutboundConnectionsBlocked *bool `json:"outboundConnectionsBlocked,omitempty"`
	// InboundConnectionsBlocked Configures the firewall to block all incoming connections by default. When InboundConnectionsRequired and InboundConnectionsBlocked are both true, InboundConnectionsBlocked takes priority.
	InboundConnectionsBlocked *bool `json:"inboundConnectionsBlocked,omitempty"`
	// SecuredPacketExemptionAllowed Configures the firewall to allow the host computer to respond to unsolicited network traffic of that traffic is secured by IPSec even when stealthModeBlocked is set to true. When SecuredPacketExemptionBlocked and SecuredPacketExemptionAllowed are both true, SecuredPacketExemptionAllowed takes priority.
	SecuredPacketExemptionAllowed *bool `json:"securedPacketExemptionAllowed,omitempty"`
	// PolicyRulesFromGroupPolicyMerged Configures the firewall to merge Firewall Rule policies from group policy with those from local store instead of ignoring the local store rules. When PolicyRulesFromGroupPolicyNotMerged and PolicyRulesFromGroupPolicyMerged are both true, PolicyRulesFromGroupPolicyMerged takes priority.
	PolicyRulesFromGroupPolicyMerged *bool `json:"policyRulesFromGroupPolicyMerged,omitempty"`
}

// IWindowsFirewallNetworkProfile interface type for windowsFirewallNetworkProfile
type IWindowsFirewallNetworkProfile interface {
	PWindowsFirewallNetworkProfile() *WindowsFirewallNetworkProfile
}

// PWindowsFirewallNetworkProfile pointer method for windowsFirewallNetworkProfile
func (p *WindowsFirewallNetworkProfile) PWindowsFirewallNetworkProfile() *WindowsFirewallNetworkProfile {
	return p
}

// WindowsInformationProtection Policy for Windows information protection to configure detailed management settings
type WindowsInformationProtection struct {
	ManagedAppPolicy
	// EnforcementLevel WIP enforcement level.See the Enum definition for supported values
	EnforcementLevel *WindowsInformationProtectionEnforcementLevel `json:"enforcementLevel,omitempty"`
	// EnterpriseDomain Primary enterprise domain
	EnterpriseDomain *string `json:"enterpriseDomain,omitempty"`
	// EnterpriseProtectedDomainNames List of enterprise domains to be protected
	EnterpriseProtectedDomainNames []WindowsInformationProtectionResourceCollection `json:"enterpriseProtectedDomainNames,omitempty"`
	// ProtectionUnderLockConfigRequired Specifies whether the protection under lock feature (also known as encrypt under pin) should be configured
	ProtectionUnderLockConfigRequired *bool `json:"protectionUnderLockConfigRequired,omitempty"`
	// DataRecoveryCertificate Specifies a recovery certificate that can be used for data recovery of encrypted files. This is the same as the data recovery agent(DRA) certificate for encrypting file system(EFS)
	DataRecoveryCertificate *WindowsInformationProtectionDataRecoveryCertificate `json:"dataRecoveryCertificate,omitempty"`
	// RevokeOnUnenrollDisabled This policy controls whether to revoke the WIP keys when a device unenrolls from the management service. If set to 1 (Don't revoke keys), the keys will not be revoked and the user will continue to have access to protected files after unenrollment. If the keys are not revoked, there will be no revoked file cleanup subsequently.
	RevokeOnUnenrollDisabled *bool `json:"revokeOnUnenrollDisabled,omitempty"`
	// RightsManagementServicesTemplateId TemplateID GUID to use for RMS encryption. The RMS template allows the IT admin to configure the details about who has access to RMS-protected file and how long they have access
	RightsManagementServicesTemplateId *UUID `json:"rightsManagementServicesTemplateId,omitempty"`
	// AzureRightsManagementServicesAllowed Specifies whether to allow Azure RMS encryption for WIP
	AzureRightsManagementServicesAllowed *bool `json:"azureRightsManagementServicesAllowed,omitempty"`
	// IconsVisible Determines whether overlays are added to icons for WIP protected files in Explorer and enterprise only app tiles in the Start menu. Starting in Windows 10, version 1703 this setting also configures the visibility of the WIP icon in the title bar of a WIP-protected app
	IconsVisible *bool `json:"iconsVisible,omitempty"`
	// ProtectedApps Protected applications can access enterprise data and the data handled by those applications are protected with encryption
	ProtectedApps []WindowsInformationProtectionApp `json:"protectedApps,omitempty"`
	// ExemptApps Exempt applications can also access enterprise data, but the data handled by those applications are not protected. This is because some critical enterprise applications may have compatibility problems with encrypted data.
	ExemptApps []WindowsInformationProtectionApp `json:"exemptApps,omitempty"`
	// EnterpriseNetworkDomainNames This is the list of domains that comprise the boundaries of the enterprise. Data from one of these domains that is sent to a device will be considered enterprise data and protected These locations will be considered a safe destination for enterprise data to be shared to
	EnterpriseNetworkDomainNames []WindowsInformationProtectionResourceCollection `json:"enterpriseNetworkDomainNames,omitempty"`
	// EnterpriseProxiedDomains Contains a list of Enterprise resource domains hosted in the cloud that need to be protected. Connections to these resources are considered enterprise data. If a proxy is paired with a cloud resource, traffic to the cloud resource will be routed through the enterprise network via the denoted proxy server (on Port 80). A proxy server used for this purpose must also be configured using the EnterpriseInternalProxyServers policy
	EnterpriseProxiedDomains []WindowsInformationProtectionProxiedDomainCollection `json:"enterpriseProxiedDomains,omitempty"`
	// EnterpriseIPRanges Sets the enterprise IP ranges that define the computers in the enterprise network. Data that comes from those computers will be considered part of the enterprise and protected. These locations will be considered a safe destination for enterprise data to be shared to
	EnterpriseIPRanges []WindowsInformationProtectionIPRangeCollection `json:"enterpriseIPRanges,omitempty"`
	// EnterpriseIPRangesAreAuthoritative Boolean value that tells the client to accept the configured list and not to use heuristics to attempt to find other subnets. Default is false
	EnterpriseIPRangesAreAuthoritative *bool `json:"enterpriseIPRangesAreAuthoritative,omitempty"`
	// EnterpriseProxyServers This is a list of proxy servers. Any server not on this list is considered non-enterprise
	EnterpriseProxyServers []WindowsInformationProtectionResourceCollection `json:"enterpriseProxyServers,omitempty"`
	// EnterpriseInternalProxyServers This is the comma-separated list of internal proxy servers. For example, "157.54.14.28, 157.54.11.118, 10.202.14.167, 157.53.14.163, 157.69.210.59". These proxies have been configured by the admin to connect to specific resources on the Internet. They are considered to be enterprise network locations. The proxies are only leveraged in configuring the EnterpriseProxiedDomains policy to force traffic to the matched domains through these proxies
	EnterpriseInternalProxyServers []WindowsInformationProtectionResourceCollection `json:"enterpriseInternalProxyServers,omitempty"`
	// EnterpriseProxyServersAreAuthoritative Boolean value that tells the client to accept the configured list of proxies and not try to detect other work proxies. Default is false
	EnterpriseProxyServersAreAuthoritative *bool `json:"enterpriseProxyServersAreAuthoritative,omitempty"`
	// NeutralDomainResources List of domain names that can used for work or personal resource
	NeutralDomainResources []WindowsInformationProtectionResourceCollection `json:"neutralDomainResources,omitempty"`
	// IndexingEncryptedStoresOrItemsBlocked This switch is for the Windows Search Indexer, to allow or disallow indexing of items
	IndexingEncryptedStoresOrItemsBlocked *bool `json:"indexingEncryptedStoresOrItemsBlocked,omitempty"`
	// SmbAutoEncryptedFileExtensions Specifies a list of file extensions, so that files with these extensions are encrypted when copying from an SMB share within the corporate boundary
	SmbAutoEncryptedFileExtensions []WindowsInformationProtectionResourceCollection `json:"smbAutoEncryptedFileExtensions,omitempty"`
	// IsAssigned Indicates if the policy is deployed to any inclusion groups or not.
	IsAssigned *bool `json:"isAssigned,omitempty"`
}

// IWindowsInformationProtection interface type for windowsInformationProtection
type IWindowsInformationProtection interface {
	PWindowsInformationProtection() *WindowsInformationProtection
}

// PWindowsInformationProtection pointer method for windowsInformationProtection
func (p *WindowsInformationProtection) PWindowsInformationProtection() *WindowsInformationProtection {
	return p
}

// WindowsInformationProtectionApp undocumented
type WindowsInformationProtectionApp struct {
	// DisplayName App display name.
	DisplayName *string `json:"displayName,omitempty"`
	// Description The app's description.
	Description *string `json:"description,omitempty"`
	// PublisherName The publisher name
	PublisherName *string `json:"publisherName,omitempty"`
	// ProductName The product name.
	ProductName *string `json:"productName,omitempty"`
	// Denied If true, app is denied protection or exemption.
	Denied *bool `json:"denied,omitempty"`
}

// IWindowsInformationProtectionApp interface type for windowsInformationProtectionApp
type IWindowsInformationProtectionApp interface {
	PWindowsInformationProtectionApp() *WindowsInformationProtectionApp
}

// PWindowsInformationProtectionApp pointer method for windowsInformationProtectionApp
func (p *WindowsInformationProtectionApp) PWindowsInformationProtectionApp() *WindowsInformationProtectionApp {
	return p
}

// WindowsInformationProtectionAppLearningSummary Windows Information Protection AppLearning Summary entity.
type WindowsInformationProtectionAppLearningSummary struct {
	Entity
	// ApplicationName Application Name
	ApplicationName *string `json:"applicationName,omitempty"`
	// ApplicationType Application Type
	ApplicationType *ApplicationType `json:"applicationType,omitempty"`
	// DeviceCount Device Count
	DeviceCount *int `json:"deviceCount,omitempty"`
}

// IWindowsInformationProtectionAppLearningSummary interface type for windowsInformationProtectionAppLearningSummary
type IWindowsInformationProtectionAppLearningSummary interface {
	PWindowsInformationProtectionAppLearningSummary() *WindowsInformationProtectionAppLearningSummary
}

// PWindowsInformationProtectionAppLearningSummary pointer method for windowsInformationProtectionAppLearningSummary
func (p *WindowsInformationProtectionAppLearningSummary) PWindowsInformationProtectionAppLearningSummary() *WindowsInformationProtectionAppLearningSummary {
	return p
}

// WindowsInformationProtectionAppLockerFile Windows Information Protection AppLocker File
type WindowsInformationProtectionAppLockerFile struct {
	Entity
	// DisplayName The friendly name
	DisplayName *string `json:"displayName,omitempty"`
	// FileHash SHA256 hash of the file
	FileHash *string `json:"fileHash,omitempty"`
	// File File as a byte array
	File *Binary `json:"file,omitempty"`
	// Version Version of the entity.
	Version *string `json:"version,omitempty"`
}

// IWindowsInformationProtectionAppLockerFile interface type for windowsInformationProtectionAppLockerFile
type IWindowsInformationProtectionAppLockerFile interface {
	PWindowsInformationProtectionAppLockerFile() *WindowsInformationProtectionAppLockerFile
}

// PWindowsInformationProtectionAppLockerFile pointer method for windowsInformationProtectionAppLockerFile
func (p *WindowsInformationProtectionAppLockerFile) PWindowsInformationProtectionAppLockerFile() *WindowsInformationProtectionAppLockerFile {
	return p
}

// WindowsInformationProtectionDataRecoveryCertificate undocumented
type WindowsInformationProtectionDataRecoveryCertificate struct {
	// SubjectName Data recovery Certificate subject name
	SubjectName *string `json:"subjectName,omitempty"`
	// Description Data recovery Certificate description
	Description *string `json:"description,omitempty"`
	// ExpirationDateTime Data recovery Certificate expiration datetime
	ExpirationDateTime *time.Time `json:"expirationDateTime,omitempty"`
	// Certificate Data recovery Certificate
	Certificate *Binary `json:"certificate,omitempty"`
}

// IWindowsInformationProtectionDataRecoveryCertificate interface type for windowsInformationProtectionDataRecoveryCertificate
type IWindowsInformationProtectionDataRecoveryCertificate interface {
	PWindowsInformationProtectionDataRecoveryCertificate() *WindowsInformationProtectionDataRecoveryCertificate
}

// PWindowsInformationProtectionDataRecoveryCertificate pointer method for windowsInformationProtectionDataRecoveryCertificate
func (p *WindowsInformationProtectionDataRecoveryCertificate) PWindowsInformationProtectionDataRecoveryCertificate() *WindowsInformationProtectionDataRecoveryCertificate {
	return p
}

// WindowsInformationProtectionDesktopApp undocumented
type WindowsInformationProtectionDesktopApp struct {
	WindowsInformationProtectionApp
	// BinaryName The binary name.
	BinaryName *string `json:"binaryName,omitempty"`
	// BinaryVersionLow The lower binary version.
	BinaryVersionLow *string `json:"binaryVersionLow,omitempty"`
	// BinaryVersionHigh The high binary version.
	BinaryVersionHigh *string `json:"binaryVersionHigh,omitempty"`
}

// IWindowsInformationProtectionDesktopApp interface type for windowsInformationProtectionDesktopApp
type IWindowsInformationProtectionDesktopApp interface {
	PWindowsInformationProtectionDesktopApp() *WindowsInformationProtectionDesktopApp
}

// PWindowsInformationProtectionDesktopApp pointer method for windowsInformationProtectionDesktopApp
func (p *WindowsInformationProtectionDesktopApp) PWindowsInformationProtectionDesktopApp() *WindowsInformationProtectionDesktopApp {
	return p
}

// WindowsInformationProtectionIPRangeCollection undocumented
type WindowsInformationProtectionIPRangeCollection struct {
	// DisplayName Display name
	DisplayName *string `json:"displayName,omitempty"`
	// Ranges Collection of ip ranges
	Ranges []IpRange `json:"ranges,omitempty"`
}

// IWindowsInformationProtectionIPRangeCollection interface type for windowsInformationProtectionIPRangeCollection
type IWindowsInformationProtectionIPRangeCollection interface {
	PWindowsInformationProtectionIPRangeCollection() *WindowsInformationProtectionIPRangeCollection
}

// PWindowsInformationProtectionIPRangeCollection pointer method for windowsInformationProtectionIPRangeCollection
func (p *WindowsInformationProtectionIPRangeCollection) PWindowsInformationProtectionIPRangeCollection() *WindowsInformationProtectionIPRangeCollection {
	return p
}

// WindowsInformationProtectionNetworkLearningSummary Windows Information Protection Network learning Summary entity.
type WindowsInformationProtectionNetworkLearningSummary struct {
	Entity
	// Url Website url
	Url *string `json:"url,omitempty"`
	// DeviceCount Device Count
	DeviceCount *int `json:"deviceCount,omitempty"`
}

// IWindowsInformationProtectionNetworkLearningSummary interface type for windowsInformationProtectionNetworkLearningSummary
type IWindowsInformationProtectionNetworkLearningSummary interface {
	PWindowsInformationProtectionNetworkLearningSummary() *WindowsInformationProtectionNetworkLearningSummary
}

// PWindowsInformationProtectionNetworkLearningSummary pointer method for windowsInformationProtectionNetworkLearningSummary
func (p *WindowsInformationProtectionNetworkLearningSummary) PWindowsInformationProtectionNetworkLearningSummary() *WindowsInformationProtectionNetworkLearningSummary {
	return p
}

// WindowsInformationProtectionPolicy Policy for Windows information protection without MDM
type WindowsInformationProtectionPolicy struct {
	WindowsInformationProtection
	// RevokeOnMdmHandoffDisabled New property in RS2, pending documentation
	RevokeOnMdmHandoffDisabled *bool `json:"revokeOnMdmHandoffDisabled,omitempty"`
	// MdmEnrollmentUrl Enrollment url for the MDM
	MdmEnrollmentUrl *string `json:"mdmEnrollmentUrl,omitempty"`
	// WindowsHelloForBusinessBlocked Boolean value that sets Windows Hello for Business as a method for signing into Windows.
	WindowsHelloForBusinessBlocked *bool `json:"windowsHelloForBusinessBlocked,omitempty"`
	// PinMinimumLength Integer value that sets the minimum number of characters required for the PIN. Default value is 4. The lowest number you can configure for this policy setting is 4. The largest number you can configure must be less than the number configured in the Maximum PIN length policy setting or the number 127, whichever is the lowest.
	PinMinimumLength *int `json:"pinMinimumLength,omitempty"`
	// PinUppercaseLetters Integer value that configures the use of uppercase letters in the Windows Hello for Business PIN. Default is NotAllow.
	PinUppercaseLetters *WindowsInformationProtectionPinCharacterRequirements `json:"pinUppercaseLetters,omitempty"`
	// PinLowercaseLetters Integer value that configures the use of lowercase letters in the Windows Hello for Business PIN. Default is NotAllow.
	PinLowercaseLetters *WindowsInformationProtectionPinCharacterRequirements `json:"pinLowercaseLetters,omitempty"`
	// PinSpecialCharacters Integer value that configures the use of special characters in the Windows Hello for Business PIN. Valid special characters for Windows Hello for Business PIN gestures include: ! " # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \ ] ^ _ ` { | } ~. Default is NotAllow.
	PinSpecialCharacters *WindowsInformationProtectionPinCharacterRequirements `json:"pinSpecialCharacters,omitempty"`
	// PinExpirationDays Integer value specifies the period of time (in days) that a PIN can be used before the system requires the user to change it. The largest number you can configure for this policy setting is 730. The lowest number you can configure for this policy setting is 0. If this policy is set to 0, then the user's PIN will never expire. This node was added in Windows 10, version 1511. Default is 0.
	PinExpirationDays *int `json:"pinExpirationDays,omitempty"`
	// NumberOfPastPinsRemembered Integer value that specifies the number of past PINs that can be associated to a user account that can't be reused. The largest number you can configure for this policy setting is 50. The lowest number you can configure for this policy setting is 0. If this policy is set to 0, then storage of previous PINs is not required. This node was added in Windows 10, version 1511. Default is 0.
	NumberOfPastPinsRemembered *int `json:"numberOfPastPinsRemembered,omitempty"`
	// PasswordMaximumAttemptCount The number of authentication failures allowed before the device will be wiped. A value of 0 disables device wipe functionality. Range is an integer X where 4 <= X <= 16 for desktop and 0 <= X <= 999 for mobile devices.
	PasswordMaximumAttemptCount *int `json:"passwordMaximumAttemptCount,omitempty"`
	// MinutesOfInactivityBeforeDeviceLock Specifies the maximum amount of time (in minutes) allowed after the device is idle that will cause the device to become PIN or password locked.   Range is an integer X where 0 <= X <= 999.
	MinutesOfInactivityBeforeDeviceLock *int `json:"minutesOfInactivityBeforeDeviceLock,omitempty"`
	// DaysWithoutContactBeforeUnenroll Offline interval before app data is wiped (days)
	DaysWithoutContactBeforeUnenroll *int `json:"daysWithoutContactBeforeUnenroll,omitempty"`
}

// IWindowsInformationProtectionPolicy interface type for windowsInformationProtectionPolicy
type IWindowsInformationProtectionPolicy interface {
	PWindowsInformationProtectionPolicy() *WindowsInformationProtectionPolicy
}

// PWindowsInformationProtectionPolicy pointer method for windowsInformationProtectionPolicy
func (p *WindowsInformationProtectionPolicy) PWindowsInformationProtectionPolicy() *WindowsInformationProtectionPolicy {
	return p
}

// WindowsInformationProtectionProxiedDomainCollection undocumented
type WindowsInformationProtectionProxiedDomainCollection struct {
	// DisplayName Display name
	DisplayName *string `json:"displayName,omitempty"`
	// ProxiedDomains Collection of proxied domains
	ProxiedDomains []ProxiedDomain `json:"proxiedDomains,omitempty"`
}

// IWindowsInformationProtectionProxiedDomainCollection interface type for windowsInformationProtectionProxiedDomainCollection
type IWindowsInformationProtectionProxiedDomainCollection interface {
	PWindowsInformationProtectionProxiedDomainCollection() *WindowsInformationProtectionProxiedDomainCollection
}

// PWindowsInformationProtectionProxiedDomainCollection pointer method for windowsInformationProtectionProxiedDomainCollection
func (p *WindowsInformationProtectionProxiedDomainCollection) PWindowsInformationProtectionProxiedDomainCollection() *WindowsInformationProtectionProxiedDomainCollection {
	return p
}

// WindowsInformationProtectionResourceCollection undocumented
type WindowsInformationProtectionResourceCollection struct {
	// DisplayName Display name
	DisplayName *string `json:"displayName,omitempty"`
	// Resources Collection of resources
	Resources []string `json:"resources,omitempty"`
}

// IWindowsInformationProtectionResourceCollection interface type for windowsInformationProtectionResourceCollection
type IWindowsInformationProtectionResourceCollection interface {
	PWindowsInformationProtectionResourceCollection() *WindowsInformationProtectionResourceCollection
}

// PWindowsInformationProtectionResourceCollection pointer method for windowsInformationProtectionResourceCollection
func (p *WindowsInformationProtectionResourceCollection) PWindowsInformationProtectionResourceCollection() *WindowsInformationProtectionResourceCollection {
	return p
}

// WindowsInformationProtectionStoreApp undocumented
type WindowsInformationProtectionStoreApp struct {
	WindowsInformationProtectionApp
}

// IWindowsInformationProtectionStoreApp interface type for windowsInformationProtectionStoreApp
type IWindowsInformationProtectionStoreApp interface {
	PWindowsInformationProtectionStoreApp() *WindowsInformationProtectionStoreApp
}

// PWindowsInformationProtectionStoreApp pointer method for windowsInformationProtectionStoreApp
func (p *WindowsInformationProtectionStoreApp) PWindowsInformationProtectionStoreApp() *WindowsInformationProtectionStoreApp {
	return p
}

// WindowsMinimumOperatingSystem undocumented
type WindowsMinimumOperatingSystem struct {
	// V8_0 Windows version 8.0 or later.
	V8_0 *bool `json:"v8_0,omitempty"`
	// V8_1 Windows version 8.1 or later.
	V8_1 *bool `json:"v8_1,omitempty"`
	// V10_0 Windows version 10.0 or later.
	V10_0 *bool `json:"v10_0,omitempty"`
}

// IWindowsMinimumOperatingSystem interface type for windowsMinimumOperatingSystem
type IWindowsMinimumOperatingSystem interface {
	PWindowsMinimumOperatingSystem() *WindowsMinimumOperatingSystem
}

// PWindowsMinimumOperatingSystem pointer method for windowsMinimumOperatingSystem
func (p *WindowsMinimumOperatingSystem) PWindowsMinimumOperatingSystem() *WindowsMinimumOperatingSystem {
	return p
}

// WindowsMobileMSI Contains properties and inherited properties for Windows Mobile MSI Line Of Business apps.
type WindowsMobileMSI struct {
	MobileLobApp
	// CommandLine The command line.
	CommandLine *string `json:"commandLine,omitempty"`
	// ProductCode The product code.
	ProductCode *string `json:"productCode,omitempty"`
	// ProductVersion The product version of Windows Mobile MSI Line of Business (LoB) app.
	ProductVersion *string `json:"productVersion,omitempty"`
	// IgnoreVersionDetection A boolean to control whether the app's version will be used to detect the app after it is installed on a device. Set this to true for Windows Mobile MSI Line of Business (LoB) apps that use a self update feature.
	IgnoreVersionDetection *bool `json:"ignoreVersionDetection,omitempty"`
}

// IWindowsMobileMSI interface type for windowsMobileMSI
type IWindowsMobileMSI interface {
	PWindowsMobileMSI() *WindowsMobileMSI
}

// PWindowsMobileMSI pointer method for windowsMobileMSI
func (p *WindowsMobileMSI) PWindowsMobileMSI() *WindowsMobileMSI { return p }

// WindowsPhone81CompliancePolicy This class contains compliance settings for Windows 8.1 Mobile.
type WindowsPhone81CompliancePolicy struct {
	DeviceCompliancePolicy
	// PasswordBlockSimple Whether or not to block syncing the calendar.
	PasswordBlockSimple *bool `json:"passwordBlockSimple,omitempty"`
	// PasswordExpirationDays Number of days before the password expires.
	PasswordExpirationDays *int `json:"passwordExpirationDays,omitempty"`
	// PasswordMinimumLength Minimum length of passwords.
	PasswordMinimumLength *int `json:"passwordMinimumLength,omitempty"`
	// PasswordMinutesOfInactivityBeforeLock Minutes of inactivity before a password is required.
	PasswordMinutesOfInactivityBeforeLock *int `json:"passwordMinutesOfInactivityBeforeLock,omitempty"`
	// PasswordMinimumCharacterSetCount The number of character sets required in the password.
	PasswordMinimumCharacterSetCount *int `json:"passwordMinimumCharacterSetCount,omitempty"`
	// PasswordRequiredType The required password type.
	PasswordRequiredType *RequiredPasswordType `json:"passwordRequiredType,omitempty"`
	// PasswordPreviousPasswordBlockCount Number of previous passwords to block. Valid values 0 to 24
	PasswordPreviousPasswordBlockCount *int `json:"passwordPreviousPasswordBlockCount,omitempty"`
	// PasswordRequired Whether or not to require a password.
	PasswordRequired *bool `json:"passwordRequired,omitempty"`
	// OsMinimumVersion Minimum Windows Phone version.
	OsMinimumVersion *string `json:"osMinimumVersion,omitempty"`
	// OsMaximumVersion Maximum Windows Phone version.
	OsMaximumVersion *string `json:"osMaximumVersion,omitempty"`
	// StorageRequireEncryption Require encryption on windows phone devices.
	StorageRequireEncryption *bool `json:"storageRequireEncryption,omitempty"`
}

// IWindowsPhone81CompliancePolicy interface type for windowsPhone81CompliancePolicy
type IWindowsPhone81CompliancePolicy interface {
	PWindowsPhone81CompliancePolicy() *WindowsPhone81CompliancePolicy
}

// PWindowsPhone81CompliancePolicy pointer method for windowsPhone81CompliancePolicy
func (p *WindowsPhone81CompliancePolicy) PWindowsPhone81CompliancePolicy() *WindowsPhone81CompliancePolicy {
	return p
}

// WindowsPhone81CustomConfiguration This topic provides descriptions of the declared methods, properties and relationships exposed by the windowsPhone81CustomConfiguration resource.
type WindowsPhone81CustomConfiguration struct {
	DeviceConfiguration
	// OmaSettings OMA settings. This collection can contain a maximum of 1000 elements.
	OmaSettings []OmaSetting `json:"omaSettings,omitempty"`
}

// IWindowsPhone81CustomConfiguration interface type for windowsPhone81CustomConfiguration
type IWindowsPhone81CustomConfiguration interface {
	PWindowsPhone81CustomConfiguration() *WindowsPhone81CustomConfiguration
}

// PWindowsPhone81CustomConfiguration pointer method for windowsPhone81CustomConfiguration
func (p *WindowsPhone81CustomConfiguration) PWindowsPhone81CustomConfiguration() *WindowsPhone81CustomConfiguration {
	return p
}

// WindowsPhone81GeneralConfiguration This topic provides descriptions of the declared methods, properties and relationships exposed by the windowsPhone81GeneralConfiguration resource.
type WindowsPhone81GeneralConfiguration struct {
	DeviceConfiguration
	// ApplyOnlyToWindowsPhone81 Value indicating whether this policy only applies to Windows Phone 8.1. This property is read-only.
	ApplyOnlyToWindowsPhone81 *bool `json:"applyOnlyToWindowsPhone81,omitempty"`
	// AppsBlockCopyPaste Indicates whether or not to block copy paste.
	AppsBlockCopyPaste *bool `json:"appsBlockCopyPaste,omitempty"`
	// BluetoothBlocked Indicates whether or not to block bluetooth.
	BluetoothBlocked *bool `json:"bluetoothBlocked,omitempty"`
	// CameraBlocked Indicates whether or not to block camera.
	CameraBlocked *bool `json:"cameraBlocked,omitempty"`
	// CellularBlockWifiTethering Indicates whether or not to block Wi-Fi tethering. Has no impact if Wi-Fi is blocked.
	CellularBlockWifiTethering *bool `json:"cellularBlockWifiTethering,omitempty"`
	// CompliantAppsList List of apps in the compliance (either allow list or block list, controlled by CompliantAppListType). This collection can contain a maximum of 10000 elements.
	CompliantAppsList []AppListItem `json:"compliantAppsList,omitempty"`
	// CompliantAppListType List that is in the AppComplianceList.
	CompliantAppListType *AppListType `json:"compliantAppListType,omitempty"`
	// DiagnosticDataBlockSubmission Indicates whether or not to block diagnostic data submission.
	DiagnosticDataBlockSubmission *bool `json:"diagnosticDataBlockSubmission,omitempty"`
	// EmailBlockAddingAccounts Indicates whether or not to block custom email accounts.
	EmailBlockAddingAccounts *bool `json:"emailBlockAddingAccounts,omitempty"`
	// LocationServicesBlocked Indicates whether or not to block location services.
	LocationServicesBlocked *bool `json:"locationServicesBlocked,omitempty"`
	// MicrosoftAccountBlocked Indicates whether or not to block using a Microsoft Account.
	MicrosoftAccountBlocked *bool `json:"microsoftAccountBlocked,omitempty"`
	// NfcBlocked Indicates whether or not to block Near-Field Communication.
	NfcBlocked *bool `json:"nfcBlocked,omitempty"`
	// PasswordBlockSimple Indicates whether or not to block syncing the calendar.
	PasswordBlockSimple *bool `json:"passwordBlockSimple,omitempty"`
	// PasswordExpirationDays Number of days before the password expires.
	PasswordExpirationDays *int `json:"passwordExpirationDays,omitempty"`
	// PasswordMinimumLength Minimum length of passwords.
	PasswordMinimumLength *int `json:"passwordMinimumLength,omitempty"`
	// PasswordMinutesOfInactivityBeforeScreenTimeout Minutes of inactivity before screen timeout.
	PasswordMinutesOfInactivityBeforeScreenTimeout *int `json:"passwordMinutesOfInactivityBeforeScreenTimeout,omitempty"`
	// PasswordMinimumCharacterSetCount Number of character sets a password must contain.
	PasswordMinimumCharacterSetCount *int `json:"passwordMinimumCharacterSetCount,omitempty"`
	// PasswordPreviousPasswordBlockCount Number of previous passwords to block. Valid values 0 to 24
	PasswordPreviousPasswordBlockCount *int `json:"passwordPreviousPasswordBlockCount,omitempty"`
	// PasswordSignInFailureCountBeforeFactoryReset Number of sign in failures allowed before factory reset.
	PasswordSignInFailureCountBeforeFactoryReset *int `json:"passwordSignInFailureCountBeforeFactoryReset,omitempty"`
	// PasswordRequiredType Password type that is required.
	PasswordRequiredType *RequiredPasswordType `json:"passwordRequiredType,omitempty"`
	// PasswordRequired Indicates whether or not to require a password.
	PasswordRequired *bool `json:"passwordRequired,omitempty"`
	// ScreenCaptureBlocked Indicates whether or not to block screenshots.
	ScreenCaptureBlocked *bool `json:"screenCaptureBlocked,omitempty"`
	// StorageBlockRemovableStorage Indicates whether or not to block removable storage.
	StorageBlockRemovableStorage *bool `json:"storageBlockRemovableStorage,omitempty"`
	// StorageRequireEncryption Indicates whether or not to require encryption.
	StorageRequireEncryption *bool `json:"storageRequireEncryption,omitempty"`
	// WebBrowserBlocked Indicates whether or not to block the web browser.
	WebBrowserBlocked *bool `json:"webBrowserBlocked,omitempty"`
	// WifiBlocked Indicates whether or not to block Wi-Fi.
	WifiBlocked *bool `json:"wifiBlocked,omitempty"`
	// WifiBlockAutomaticConnectHotspots Indicates whether or not to block automatically connecting to Wi-Fi hotspots. Has no impact if Wi-Fi is blocked.
	WifiBlockAutomaticConnectHotspots *bool `json:"wifiBlockAutomaticConnectHotspots,omitempty"`
	// WifiBlockHotspotReporting Indicates whether or not to block Wi-Fi hotspot reporting. Has no impact if Wi-Fi is blocked.
	WifiBlockHotspotReporting *bool `json:"wifiBlockHotspotReporting,omitempty"`
	// WindowsStoreBlocked Indicates whether or not to block the Windows Store.
	WindowsStoreBlocked *bool `json:"windowsStoreBlocked,omitempty"`
}

// IWindowsPhone81GeneralConfiguration interface type for windowsPhone81GeneralConfiguration
type IWindowsPhone81GeneralConfiguration interface {
	PWindowsPhone81GeneralConfiguration() *WindowsPhone81GeneralConfiguration
}

// PWindowsPhone81GeneralConfiguration pointer method for windowsPhone81GeneralConfiguration
func (p *WindowsPhone81GeneralConfiguration) PWindowsPhone81GeneralConfiguration() *WindowsPhone81GeneralConfiguration {
	return p
}

// WindowsUniversalAppX Contains properties and inherited properties for Windows Universal AppX Line Of Business apps.
type WindowsUniversalAppX struct {
	MobileLobApp
	// ApplicableArchitectures The Windows architecture(s) for which this app can run on.
	ApplicableArchitectures *WindowsArchitecture `json:"applicableArchitectures,omitempty"`
	// ApplicableDeviceTypes The Windows device type(s) for which this app can run on.
	ApplicableDeviceTypes *WindowsDeviceType `json:"applicableDeviceTypes,omitempty"`
	// IdentityName The Identity Name.
	IdentityName *string `json:"identityName,omitempty"`
	// IdentityPublisherHash The Identity Publisher Hash.
	IdentityPublisherHash *string `json:"identityPublisherHash,omitempty"`
	// IdentityResourceIdentifier The Identity Resource Identifier.
	IdentityResourceIdentifier *string `json:"identityResourceIdentifier,omitempty"`
	// IsBundle Whether or not the app is a bundle.
	IsBundle *bool `json:"isBundle,omitempty"`
	// MinimumSupportedOperatingSystem The value for the minimum applicable operating system.
	MinimumSupportedOperatingSystem *WindowsMinimumOperatingSystem `json:"minimumSupportedOperatingSystem,omitempty"`
	// IdentityVersion The identity version.
	IdentityVersion *string `json:"identityVersion,omitempty"`
}

// IWindowsUniversalAppX interface type for windowsUniversalAppX
type IWindowsUniversalAppX interface {
	PWindowsUniversalAppX() *WindowsUniversalAppX
}

// PWindowsUniversalAppX pointer method for windowsUniversalAppX
func (p *WindowsUniversalAppX) PWindowsUniversalAppX() *WindowsUniversalAppX { return p }

// WindowsUpdateActiveHoursInstall undocumented
type WindowsUpdateActiveHoursInstall struct {
	WindowsUpdateInstallScheduleType
	// ActiveHoursStart Active Hours Start
	ActiveHoursStart *time.Time `json:"activeHoursStart,omitempty"`
	// ActiveHoursEnd Active Hours End
	ActiveHoursEnd *time.Time `json:"activeHoursEnd,omitempty"`
}

// IWindowsUpdateActiveHoursInstall interface type for windowsUpdateActiveHoursInstall
type IWindowsUpdateActiveHoursInstall interface {
	PWindowsUpdateActiveHoursInstall() *WindowsUpdateActiveHoursInstall
}

// PWindowsUpdateActiveHoursInstall pointer method for windowsUpdateActiveHoursInstall
func (p *WindowsUpdateActiveHoursInstall) PWindowsUpdateActiveHoursInstall() *WindowsUpdateActiveHoursInstall {
	return p
}

// WindowsUpdateForBusinessConfiguration Windows Update for business configuration.
type WindowsUpdateForBusinessConfiguration struct {
	DeviceConfiguration
	// DeliveryOptimizationMode Delivery Optimization Mode
	DeliveryOptimizationMode *WindowsDeliveryOptimizationMode `json:"deliveryOptimizationMode,omitempty"`
	// PrereleaseFeatures The pre-release features.
	PrereleaseFeatures *PrereleaseFeatures `json:"prereleaseFeatures,omitempty"`
	// AutomaticUpdateMode Automatic update mode.
	AutomaticUpdateMode *AutomaticUpdateMode `json:"automaticUpdateMode,omitempty"`
	// MicrosoftUpdateServiceAllowed Allow Microsoft Update Service
	MicrosoftUpdateServiceAllowed *bool `json:"microsoftUpdateServiceAllowed,omitempty"`
	// DriversExcluded Exclude Windows update Drivers
	DriversExcluded *bool `json:"driversExcluded,omitempty"`
	// InstallationSchedule Installation schedule
	InstallationSchedule *WindowsUpdateInstallScheduleType `json:"installationSchedule,omitempty"`
	// QualityUpdatesDeferralPeriodInDays Defer Quality Updates by these many days
	QualityUpdatesDeferralPeriodInDays *int `json:"qualityUpdatesDeferralPeriodInDays,omitempty"`
	// FeatureUpdatesDeferralPeriodInDays Defer Feature Updates by these many days
	FeatureUpdatesDeferralPeriodInDays *int `json:"featureUpdatesDeferralPeriodInDays,omitempty"`
	// QualityUpdatesPaused Pause Quality Updates
	QualityUpdatesPaused *bool `json:"qualityUpdatesPaused,omitempty"`
	// FeatureUpdatesPaused Pause Feature Updates
	FeatureUpdatesPaused *bool `json:"featureUpdatesPaused,omitempty"`
	// QualityUpdatesPauseExpiryDateTime Quality Updates Pause Expiry datetime
	QualityUpdatesPauseExpiryDateTime *time.Time `json:"qualityUpdatesPauseExpiryDateTime,omitempty"`
	// FeatureUpdatesPauseExpiryDateTime Feature Updates Pause Expiry datetime
	FeatureUpdatesPauseExpiryDateTime *time.Time `json:"featureUpdatesPauseExpiryDateTime,omitempty"`
	// BusinessReadyUpdatesOnly Determines which branch devices will receive their updates from
	BusinessReadyUpdatesOnly *WindowsUpdateType `json:"businessReadyUpdatesOnly,omitempty"`
}

// IWindowsUpdateForBusinessConfiguration interface type for windowsUpdateForBusinessConfiguration
type IWindowsUpdateForBusinessConfiguration interface {
	PWindowsUpdateForBusinessConfiguration() *WindowsUpdateForBusinessConfiguration
}

// PWindowsUpdateForBusinessConfiguration pointer method for windowsUpdateForBusinessConfiguration
func (p *WindowsUpdateForBusinessConfiguration) PWindowsUpdateForBusinessConfiguration() *WindowsUpdateForBusinessConfiguration {
	return p
}

// WindowsUpdateInstallScheduleType undocumented
type WindowsUpdateInstallScheduleType struct {
}

// IWindowsUpdateInstallScheduleType interface type for windowsUpdateInstallScheduleType
type IWindowsUpdateInstallScheduleType interface {
	PWindowsUpdateInstallScheduleType() *WindowsUpdateInstallScheduleType
}

// PWindowsUpdateInstallScheduleType pointer method for windowsUpdateInstallScheduleType
func (p *WindowsUpdateInstallScheduleType) PWindowsUpdateInstallScheduleType() *WindowsUpdateInstallScheduleType {
	return p
}

// WindowsUpdateScheduledInstall undocumented
type WindowsUpdateScheduledInstall struct {
	WindowsUpdateInstallScheduleType
	// ScheduledInstallDay Scheduled Install Day in week
	ScheduledInstallDay *WeeklySchedule `json:"scheduledInstallDay,omitempty"`
	// ScheduledInstallTime Scheduled Install Time during day
	ScheduledInstallTime *time.Time `json:"scheduledInstallTime,omitempty"`
}

// IWindowsUpdateScheduledInstall interface type for windowsUpdateScheduledInstall
type IWindowsUpdateScheduledInstall interface {
	PWindowsUpdateScheduledInstall() *WindowsUpdateScheduledInstall
}

// PWindowsUpdateScheduledInstall pointer method for windowsUpdateScheduledInstall
func (p *WindowsUpdateScheduledInstall) PWindowsUpdateScheduledInstall() *WindowsUpdateScheduledInstall {
	return p
}

// Workbook undocumented
type Workbook struct {
	Entity
}

// IWorkbook interface type for workbook
type IWorkbook interface {
	PWorkbook() *Workbook
}

// PWorkbook pointer method for workbook
func (p *Workbook) PWorkbook() *Workbook { return p }

// WorkbookApplication undocumented
type WorkbookApplication struct {
	Entity
	// CalculationMode undocumented
	CalculationMode *string `json:"calculationMode,omitempty"`
}

// IWorkbookApplication interface type for workbookApplication
type IWorkbookApplication interface {
	PWorkbookApplication() *WorkbookApplication
}

// PWorkbookApplication pointer method for workbookApplication
func (p *WorkbookApplication) PWorkbookApplication() *WorkbookApplication { return p }

// WorkbookChart undocumented
type WorkbookChart struct {
	Entity
	// Height undocumented
	Height *float64 `json:"height,omitempty"`
	// Left undocumented
	Left *float64 `json:"left,omitempty"`
	// Name undocumented
	Name *string `json:"name,omitempty"`
	// Top undocumented
	Top *float64 `json:"top,omitempty"`
	// Width undocumented
	Width *float64 `json:"width,omitempty"`
}

// IWorkbookChart interface type for workbookChart
type IWorkbookChart interface {
	PWorkbookChart() *WorkbookChart
}

// PWorkbookChart pointer method for workbookChart
func (p *WorkbookChart) PWorkbookChart() *WorkbookChart { return p }

// WorkbookChartAreaFormat undocumented
type WorkbookChartAreaFormat struct {
	Entity
}

// IWorkbookChartAreaFormat interface type for workbookChartAreaFormat
type IWorkbookChartAreaFormat interface {
	PWorkbookChartAreaFormat() *WorkbookChartAreaFormat
}

// PWorkbookChartAreaFormat pointer method for workbookChartAreaFormat
func (p *WorkbookChartAreaFormat) PWorkbookChartAreaFormat() *WorkbookChartAreaFormat { return p }

// WorkbookChartAxes undocumented
type WorkbookChartAxes struct {
	Entity
}

// IWorkbookChartAxes interface type for workbookChartAxes
type IWorkbookChartAxes interface {
	PWorkbookChartAxes() *WorkbookChartAxes
}

// PWorkbookChartAxes pointer method for workbookChartAxes
func (p *WorkbookChartAxes) PWorkbookChartAxes() *WorkbookChartAxes { return p }

// WorkbookChartAxis undocumented
type WorkbookChartAxis struct {
	Entity
	// MajorUnit undocumented
	MajorUnit json.RawMessage `json:"majorUnit,omitempty"`
	// Maximum undocumented
	Maximum json.RawMessage `json:"maximum,omitempty"`
	// Minimum undocumented
	Minimum json.RawMessage `json:"minimum,omitempty"`
	// MinorUnit undocumented
	MinorUnit json.RawMessage `json:"minorUnit,omitempty"`
}

// IWorkbookChartAxis interface type for workbookChartAxis
type IWorkbookChartAxis interface {
	PWorkbookChartAxis() *WorkbookChartAxis
}

// PWorkbookChartAxis pointer method for workbookChartAxis
func (p *WorkbookChartAxis) PWorkbookChartAxis() *WorkbookChartAxis { return p }

// WorkbookChartAxisFormat undocumented
type WorkbookChartAxisFormat struct {
	Entity
}

// IWorkbookChartAxisFormat interface type for workbookChartAxisFormat
type IWorkbookChartAxisFormat interface {
	PWorkbookChartAxisFormat() *WorkbookChartAxisFormat
}

// PWorkbookChartAxisFormat pointer method for workbookChartAxisFormat
func (p *WorkbookChartAxisFormat) PWorkbookChartAxisFormat() *WorkbookChartAxisFormat { return p }

// WorkbookChartAxisTitle undocumented
type WorkbookChartAxisTitle struct {
	Entity
	// Text undocumented
	Text *string `json:"text,omitempty"`
	// Visible undocumented
	Visible *bool `json:"visible,omitempty"`
}

// IWorkbookChartAxisTitle interface type for workbookChartAxisTitle
type IWorkbookChartAxisTitle interface {
	PWorkbookChartAxisTitle() *WorkbookChartAxisTitle
}

// PWorkbookChartAxisTitle pointer method for workbookChartAxisTitle
func (p *WorkbookChartAxisTitle) PWorkbookChartAxisTitle() *WorkbookChartAxisTitle { return p }

// WorkbookChartAxisTitleFormat undocumented
type WorkbookChartAxisTitleFormat struct {
	Entity
}

// IWorkbookChartAxisTitleFormat interface type for workbookChartAxisTitleFormat
type IWorkbookChartAxisTitleFormat interface {
	PWorkbookChartAxisTitleFormat() *WorkbookChartAxisTitleFormat
}

// PWorkbookChartAxisTitleFormat pointer method for workbookChartAxisTitleFormat
func (p *WorkbookChartAxisTitleFormat) PWorkbookChartAxisTitleFormat() *WorkbookChartAxisTitleFormat {
	return p
}

// WorkbookChartDataLabelFormat undocumented
type WorkbookChartDataLabelFormat struct {
	Entity
}

// IWorkbookChartDataLabelFormat interface type for workbookChartDataLabelFormat
type IWorkbookChartDataLabelFormat interface {
	PWorkbookChartDataLabelFormat() *WorkbookChartDataLabelFormat
}

// PWorkbookChartDataLabelFormat pointer method for workbookChartDataLabelFormat
func (p *WorkbookChartDataLabelFormat) PWorkbookChartDataLabelFormat() *WorkbookChartDataLabelFormat {
	return p
}

// WorkbookChartDataLabels undocumented
type WorkbookChartDataLabels struct {
	Entity
	// Position undocumented
	Position *string `json:"position,omitempty"`
	// Separator undocumented
	Separator *string `json:"separator,omitempty"`
	// ShowBubbleSize undocumented
	ShowBubbleSize *bool `json:"showBubbleSize,omitempty"`
	// ShowCategoryName undocumented
	ShowCategoryName *bool `json:"showCategoryName,omitempty"`
	// ShowLegendKey undocumented
	ShowLegendKey *bool `json:"showLegendKey,omitempty"`
	// ShowPercentage undocumented
	ShowPercentage *bool `json:"showPercentage,omitempty"`
	// ShowSeriesName undocumented
	ShowSeriesName *bool `json:"showSeriesName,omitempty"`
	// ShowValue undocumented
	ShowValue *bool `json:"showValue,omitempty"`
}

// IWorkbookChartDataLabels interface type for workbookChartDataLabels
type IWorkbookChartDataLabels interface {
	PWorkbookChartDataLabels() *WorkbookChartDataLabels
}

// PWorkbookChartDataLabels pointer method for workbookChartDataLabels
func (p *WorkbookChartDataLabels) PWorkbookChartDataLabels() *WorkbookChartDataLabels { return p }

// WorkbookChartFill undocumented
type WorkbookChartFill struct {
	Entity
}

// IWorkbookChartFill interface type for workbookChartFill
type IWorkbookChartFill interface {
	PWorkbookChartFill() *WorkbookChartFill
}

// PWorkbookChartFill pointer method for workbookChartFill
func (p *WorkbookChartFill) PWorkbookChartFill() *WorkbookChartFill { return p }

// WorkbookChartFont undocumented
type WorkbookChartFont struct {
	Entity
	// Bold undocumented
	Bold *bool `json:"bold,omitempty"`
	// Color undocumented
	Color *string `json:"color,omitempty"`
	// Italic undocumented
	Italic *bool `json:"italic,omitempty"`
	// Name undocumented
	Name *string `json:"name,omitempty"`
	// Size undocumented
	Size *float64 `json:"size,omitempty"`
	// Underline undocumented
	Underline *string `json:"underline,omitempty"`
}

// IWorkbookChartFont interface type for workbookChartFont
type IWorkbookChartFont interface {
	PWorkbookChartFont() *WorkbookChartFont
}

// PWorkbookChartFont pointer method for workbookChartFont
func (p *WorkbookChartFont) PWorkbookChartFont() *WorkbookChartFont { return p }

// WorkbookChartGridlines undocumented
type WorkbookChartGridlines struct {
	Entity
	// Visible undocumented
	Visible *bool `json:"visible,omitempty"`
}

// IWorkbookChartGridlines interface type for workbookChartGridlines
type IWorkbookChartGridlines interface {
	PWorkbookChartGridlines() *WorkbookChartGridlines
}

// PWorkbookChartGridlines pointer method for workbookChartGridlines
func (p *WorkbookChartGridlines) PWorkbookChartGridlines() *WorkbookChartGridlines { return p }

// WorkbookChartGridlinesFormat undocumented
type WorkbookChartGridlinesFormat struct {
	Entity
}

// IWorkbookChartGridlinesFormat interface type for workbookChartGridlinesFormat
type IWorkbookChartGridlinesFormat interface {
	PWorkbookChartGridlinesFormat() *WorkbookChartGridlinesFormat
}

// PWorkbookChartGridlinesFormat pointer method for workbookChartGridlinesFormat
func (p *WorkbookChartGridlinesFormat) PWorkbookChartGridlinesFormat() *WorkbookChartGridlinesFormat {
	return p
}

// WorkbookChartLegend undocumented
type WorkbookChartLegend struct {
	Entity
	// Overlay undocumented
	Overlay *bool `json:"overlay,omitempty"`
	// Position undocumented
	Position *string `json:"position,omitempty"`
	// Visible undocumented
	Visible *bool `json:"visible,omitempty"`
}

// IWorkbookChartLegend interface type for workbookChartLegend
type IWorkbookChartLegend interface {
	PWorkbookChartLegend() *WorkbookChartLegend
}

// PWorkbookChartLegend pointer method for workbookChartLegend
func (p *WorkbookChartLegend) PWorkbookChartLegend() *WorkbookChartLegend { return p }

// WorkbookChartLegendFormat undocumented
type WorkbookChartLegendFormat struct {
	Entity
}

// IWorkbookChartLegendFormat interface type for workbookChartLegendFormat
type IWorkbookChartLegendFormat interface {
	PWorkbookChartLegendFormat() *WorkbookChartLegendFormat
}

// PWorkbookChartLegendFormat pointer method for workbookChartLegendFormat
func (p *WorkbookChartLegendFormat) PWorkbookChartLegendFormat() *WorkbookChartLegendFormat { return p }

// WorkbookChartLineFormat undocumented
type WorkbookChartLineFormat struct {
	Entity
	// Color undocumented
	Color *string `json:"color,omitempty"`
}

// IWorkbookChartLineFormat interface type for workbookChartLineFormat
type IWorkbookChartLineFormat interface {
	PWorkbookChartLineFormat() *WorkbookChartLineFormat
}

// PWorkbookChartLineFormat pointer method for workbookChartLineFormat
func (p *WorkbookChartLineFormat) PWorkbookChartLineFormat() *WorkbookChartLineFormat { return p }

// WorkbookChartPoint undocumented
type WorkbookChartPoint struct {
	Entity
	// Value undocumented
	Value json.RawMessage `json:"value,omitempty"`
}

// IWorkbookChartPoint interface type for workbookChartPoint
type IWorkbookChartPoint interface {
	PWorkbookChartPoint() *WorkbookChartPoint
}

// PWorkbookChartPoint pointer method for workbookChartPoint
func (p *WorkbookChartPoint) PWorkbookChartPoint() *WorkbookChartPoint { return p }

// WorkbookChartPointFormat undocumented
type WorkbookChartPointFormat struct {
	Entity
}

// IWorkbookChartPointFormat interface type for workbookChartPointFormat
type IWorkbookChartPointFormat interface {
	PWorkbookChartPointFormat() *WorkbookChartPointFormat
}

// PWorkbookChartPointFormat pointer method for workbookChartPointFormat
func (p *WorkbookChartPointFormat) PWorkbookChartPointFormat() *WorkbookChartPointFormat { return p }

// WorkbookChartSeries undocumented
type WorkbookChartSeries struct {
	Entity
	// Name undocumented
	Name *string `json:"name,omitempty"`
}

// IWorkbookChartSeries interface type for workbookChartSeries
type IWorkbookChartSeries interface {
	PWorkbookChartSeries() *WorkbookChartSeries
}

// PWorkbookChartSeries pointer method for workbookChartSeries
func (p *WorkbookChartSeries) PWorkbookChartSeries() *WorkbookChartSeries { return p }

// WorkbookChartSeriesFormat undocumented
type WorkbookChartSeriesFormat struct {
	Entity
}

// IWorkbookChartSeriesFormat interface type for workbookChartSeriesFormat
type IWorkbookChartSeriesFormat interface {
	PWorkbookChartSeriesFormat() *WorkbookChartSeriesFormat
}

// PWorkbookChartSeriesFormat pointer method for workbookChartSeriesFormat
func (p *WorkbookChartSeriesFormat) PWorkbookChartSeriesFormat() *WorkbookChartSeriesFormat { return p }

// WorkbookChartTitle undocumented
type WorkbookChartTitle struct {
	Entity
	// Overlay undocumented
	Overlay *bool `json:"overlay,omitempty"`
	// Text undocumented
	Text *string `json:"text,omitempty"`
	// Visible undocumented
	Visible *bool `json:"visible,omitempty"`
}

// IWorkbookChartTitle interface type for workbookChartTitle
type IWorkbookChartTitle interface {
	PWorkbookChartTitle() *WorkbookChartTitle
}

// PWorkbookChartTitle pointer method for workbookChartTitle
func (p *WorkbookChartTitle) PWorkbookChartTitle() *WorkbookChartTitle { return p }

// WorkbookChartTitleFormat undocumented
type WorkbookChartTitleFormat struct {
	Entity
}

// IWorkbookChartTitleFormat interface type for workbookChartTitleFormat
type IWorkbookChartTitleFormat interface {
	PWorkbookChartTitleFormat() *WorkbookChartTitleFormat
}

// PWorkbookChartTitleFormat pointer method for workbookChartTitleFormat
func (p *WorkbookChartTitleFormat) PWorkbookChartTitleFormat() *WorkbookChartTitleFormat { return p }

// WorkbookComment undocumented
type WorkbookComment struct {
	Entity
	// Content undocumented
	Content *string `json:"content,omitempty"`
	// ContentType undocumented
	ContentType *string `json:"contentType,omitempty"`
}

// IWorkbookComment interface type for workbookComment
type IWorkbookComment interface {
	PWorkbookComment() *WorkbookComment
}

// PWorkbookComment pointer method for workbookComment
func (p *WorkbookComment) PWorkbookComment() *WorkbookComment { return p }

// WorkbookCommentReply undocumented
type WorkbookCommentReply struct {
	Entity
	// Content undocumented
	Content *string `json:"content,omitempty"`
	// ContentType undocumented
	ContentType *string `json:"contentType,omitempty"`
}

// IWorkbookCommentReply interface type for workbookCommentReply
type IWorkbookCommentReply interface {
	PWorkbookCommentReply() *WorkbookCommentReply
}

// PWorkbookCommentReply pointer method for workbookCommentReply
func (p *WorkbookCommentReply) PWorkbookCommentReply() *WorkbookCommentReply { return p }

// WorkbookFilter undocumented
type WorkbookFilter struct {
	Entity
	// Criteria undocumented
	Criteria *WorkbookFilterCriteria `json:"criteria,omitempty"`
}

// IWorkbookFilter interface type for workbookFilter
type IWorkbookFilter interface {
	PWorkbookFilter() *WorkbookFilter
}

// PWorkbookFilter pointer method for workbookFilter
func (p *WorkbookFilter) PWorkbookFilter() *WorkbookFilter { return p }

// WorkbookFilterCriteria undocumented
type WorkbookFilterCriteria struct {
	// Color undocumented
	Color *string `json:"color,omitempty"`
	// Criterion1 undocumented
	Criterion1 *string `json:"criterion1,omitempty"`
	// Criterion2 undocumented
	Criterion2 *string `json:"criterion2,omitempty"`
	// DynamicCriteria undocumented
	DynamicCriteria *string `json:"dynamicCriteria,omitempty"`
	// FilterOn undocumented
	FilterOn *string `json:"filterOn,omitempty"`
	// Icon undocumented
	Icon *WorkbookIcon `json:"icon,omitempty"`
	// Operator undocumented
	Operator *string `json:"operator,omitempty"`
	// Values undocumented
	Values json.RawMessage `json:"values,omitempty"`
}

// IWorkbookFilterCriteria interface type for workbookFilterCriteria
type IWorkbookFilterCriteria interface {
	PWorkbookFilterCriteria() *WorkbookFilterCriteria
}

// PWorkbookFilterCriteria pointer method for workbookFilterCriteria
func (p *WorkbookFilterCriteria) PWorkbookFilterCriteria() *WorkbookFilterCriteria { return p }

// WorkbookFilterDatetime undocumented
type WorkbookFilterDatetime struct {
	// Date undocumented
	Date *string `json:"date,omitempty"`
	// Specificity undocumented
	Specificity *string `json:"specificity,omitempty"`
}

// IWorkbookFilterDatetime interface type for workbookFilterDatetime
type IWorkbookFilterDatetime interface {
	PWorkbookFilterDatetime() *WorkbookFilterDatetime
}

// PWorkbookFilterDatetime pointer method for workbookFilterDatetime
func (p *WorkbookFilterDatetime) PWorkbookFilterDatetime() *WorkbookFilterDatetime { return p }

// WorkbookFormatProtection undocumented
type WorkbookFormatProtection struct {
	Entity
	// FormulaHidden undocumented
	FormulaHidden *bool `json:"formulaHidden,omitempty"`
	// Locked undocumented
	Locked *bool `json:"locked,omitempty"`
}

// IWorkbookFormatProtection interface type for workbookFormatProtection
type IWorkbookFormatProtection interface {
	PWorkbookFormatProtection() *WorkbookFormatProtection
}

// PWorkbookFormatProtection pointer method for workbookFormatProtection
func (p *WorkbookFormatProtection) PWorkbookFormatProtection() *WorkbookFormatProtection { return p }

// WorkbookFunctionResult undocumented
type WorkbookFunctionResult struct {
	Entity
	// Error undocumented
	Error *string `json:"error,omitempty"`
	// Value undocumented
	Value json.RawMessage `json:"value,omitempty"`
}

// IWorkbookFunctionResult interface type for workbookFunctionResult
type IWorkbookFunctionResult interface {
	PWorkbookFunctionResult() *WorkbookFunctionResult
}

// PWorkbookFunctionResult pointer method for workbookFunctionResult
func (p *WorkbookFunctionResult) PWorkbookFunctionResult() *WorkbookFunctionResult { return p }

// WorkbookFunctions undocumented
type WorkbookFunctions struct {
	Entity
}

// IWorkbookFunctions interface type for workbookFunctions
type IWorkbookFunctions interface {
	PWorkbookFunctions() *WorkbookFunctions
}

// PWorkbookFunctions pointer method for workbookFunctions
func (p *WorkbookFunctions) PWorkbookFunctions() *WorkbookFunctions { return p }

// WorkbookIcon undocumented
type WorkbookIcon struct {
	// Index undocumented
	Index *int `json:"index,omitempty"`
	// Set undocumented
	Set *string `json:"set,omitempty"`
}

// IWorkbookIcon interface type for workbookIcon
type IWorkbookIcon interface {
	PWorkbookIcon() *WorkbookIcon
}

// PWorkbookIcon pointer method for workbookIcon
func (p *WorkbookIcon) PWorkbookIcon() *WorkbookIcon { return p }

// WorkbookNamedItem undocumented
type WorkbookNamedItem struct {
	Entity
	// Comment undocumented
	Comment *string `json:"comment,omitempty"`
	// Name undocumented
	Name *string `json:"name,omitempty"`
	// Scope undocumented
	Scope *string `json:"scope,omitempty"`
	// Type undocumented
	Type *string `json:"type,omitempty"`
	// Value undocumented
	Value json.RawMessage `json:"value,omitempty"`
	// Visible undocumented
	Visible *bool `json:"visible,omitempty"`
}

// IWorkbookNamedItem interface type for workbookNamedItem
type IWorkbookNamedItem interface {
	PWorkbookNamedItem() *WorkbookNamedItem
}

// PWorkbookNamedItem pointer method for workbookNamedItem
func (p *WorkbookNamedItem) PWorkbookNamedItem() *WorkbookNamedItem { return p }

// WorkbookPivotTable undocumented
type WorkbookPivotTable struct {
	Entity
	// Name undocumented
	Name *string `json:"name,omitempty"`
}

// IWorkbookPivotTable interface type for workbookPivotTable
type IWorkbookPivotTable interface {
	PWorkbookPivotTable() *WorkbookPivotTable
}

// PWorkbookPivotTable pointer method for workbookPivotTable
func (p *WorkbookPivotTable) PWorkbookPivotTable() *WorkbookPivotTable { return p }

// WorkbookRange undocumented
type WorkbookRange struct {
	Entity
	// Address undocumented
	Address *string `json:"address,omitempty"`
	// AddressLocal undocumented
	AddressLocal *string `json:"addressLocal,omitempty"`
	// CellCount undocumented
	CellCount *int `json:"cellCount,omitempty"`
	// ColumnCount undocumented
	ColumnCount *int `json:"columnCount,omitempty"`
	// ColumnHidden undocumented
	ColumnHidden *bool `json:"columnHidden,omitempty"`
	// ColumnIndex undocumented
	ColumnIndex *int `json:"columnIndex,omitempty"`
	// Formulas undocumented
	Formulas json.RawMessage `json:"formulas,omitempty"`
	// FormulasLocal undocumented
	FormulasLocal json.RawMessage `json:"formulasLocal,omitempty"`
	// FormulasR1C1 undocumented
	FormulasR1C1 json.RawMessage `json:"formulasR1C1,omitempty"`
	// Hidden undocumented
	Hidden *bool `json:"hidden,omitempty"`
	// NumberFormat undocumented
	NumberFormat json.RawMessage `json:"numberFormat,omitempty"`
	// RowCount undocumented
	RowCount *int `json:"rowCount,omitempty"`
	// RowHidden undocumented
	RowHidden *bool `json:"rowHidden,omitempty"`
	// RowIndex undocumented
	RowIndex *int `json:"rowIndex,omitempty"`
	// Text undocumented
	Text json.RawMessage `json:"text,omitempty"`
	// ValueTypes undocumented
	ValueTypes json.RawMessage `json:"valueTypes,omitempty"`
	// Values undocumented
	Values json.RawMessage `json:"values,omitempty"`
}

// IWorkbookRange interface type for workbookRange
type IWorkbookRange interface {
	PWorkbookRange() *WorkbookRange
}

// PWorkbookRange pointer method for workbookRange
func (p *WorkbookRange) PWorkbookRange() *WorkbookRange { return p }

// WorkbookRangeBorder undocumented
type WorkbookRangeBorder struct {
	Entity
	// Color undocumented
	Color *string `json:"color,omitempty"`
	// SideIndex undocumented
	SideIndex *string `json:"sideIndex,omitempty"`
	// Style undocumented
	Style *string `json:"style,omitempty"`
	// Weight undocumented
	Weight *string `json:"weight,omitempty"`
}

// IWorkbookRangeBorder interface type for workbookRangeBorder
type IWorkbookRangeBorder interface {
	PWorkbookRangeBorder() *WorkbookRangeBorder
}

// PWorkbookRangeBorder pointer method for workbookRangeBorder
func (p *WorkbookRangeBorder) PWorkbookRangeBorder() *WorkbookRangeBorder { return p }

// WorkbookRangeFill undocumented
type WorkbookRangeFill struct {
	Entity
	// Color undocumented
	Color *string `json:"color,omitempty"`
}

// IWorkbookRangeFill interface type for workbookRangeFill
type IWorkbookRangeFill interface {
	PWorkbookRangeFill() *WorkbookRangeFill
}

// PWorkbookRangeFill pointer method for workbookRangeFill
func (p *WorkbookRangeFill) PWorkbookRangeFill() *WorkbookRangeFill { return p }

// WorkbookRangeFont undocumented
type WorkbookRangeFont struct {
	Entity
	// Bold undocumented
	Bold *bool `json:"bold,omitempty"`
	// Color undocumented
	Color *string `json:"color,omitempty"`
	// Italic undocumented
	Italic *bool `json:"italic,omitempty"`
	// Name undocumented
	Name *string `json:"name,omitempty"`
	// Size undocumented
	Size *float64 `json:"size,omitempty"`
	// Underline undocumented
	Underline *string `json:"underline,omitempty"`
}

// IWorkbookRangeFont interface type for workbookRangeFont
type IWorkbookRangeFont interface {
	PWorkbookRangeFont() *WorkbookRangeFont
}

// PWorkbookRangeFont pointer method for workbookRangeFont
func (p *WorkbookRangeFont) PWorkbookRangeFont() *WorkbookRangeFont { return p }

// WorkbookRangeFormat undocumented
type WorkbookRangeFormat struct {
	Entity
	// ColumnWidth undocumented
	ColumnWidth *float64 `json:"columnWidth,omitempty"`
	// HorizontalAlignment undocumented
	HorizontalAlignment *string `json:"horizontalAlignment,omitempty"`
	// RowHeight undocumented
	RowHeight *float64 `json:"rowHeight,omitempty"`
	// VerticalAlignment undocumented
	VerticalAlignment *string `json:"verticalAlignment,omitempty"`
	// WrapText undocumented
	WrapText *bool `json:"wrapText,omitempty"`
}

// IWorkbookRangeFormat interface type for workbookRangeFormat
type IWorkbookRangeFormat interface {
	PWorkbookRangeFormat() *WorkbookRangeFormat
}

// PWorkbookRangeFormat pointer method for workbookRangeFormat
func (p *WorkbookRangeFormat) PWorkbookRangeFormat() *WorkbookRangeFormat { return p }

// WorkbookRangeReference undocumented
type WorkbookRangeReference struct {
	// Address undocumented
	Address *string `json:"address,omitempty"`
}

// IWorkbookRangeReference interface type for workbookRangeReference
type IWorkbookRangeReference interface {
	PWorkbookRangeReference() *WorkbookRangeReference
}

// PWorkbookRangeReference pointer method for workbookRangeReference
func (p *WorkbookRangeReference) PWorkbookRangeReference() *WorkbookRangeReference { return p }

// WorkbookRangeSort undocumented
type WorkbookRangeSort struct {
	Entity
}

// IWorkbookRangeSort interface type for workbookRangeSort
type IWorkbookRangeSort interface {
	PWorkbookRangeSort() *WorkbookRangeSort
}

// PWorkbookRangeSort pointer method for workbookRangeSort
func (p *WorkbookRangeSort) PWorkbookRangeSort() *WorkbookRangeSort { return p }

// WorkbookRangeView undocumented
type WorkbookRangeView struct {
	Entity
	// CellAddresses undocumented
	CellAddresses json.RawMessage `json:"cellAddresses,omitempty"`
	// ColumnCount undocumented
	ColumnCount *int `json:"columnCount,omitempty"`
	// Formulas undocumented
	Formulas json.RawMessage `json:"formulas,omitempty"`
	// FormulasLocal undocumented
	FormulasLocal json.RawMessage `json:"formulasLocal,omitempty"`
	// FormulasR1C1 undocumented
	FormulasR1C1 json.RawMessage `json:"formulasR1C1,omitempty"`
	// Index undocumented
	Index *int `json:"index,omitempty"`
	// NumberFormat undocumented
	NumberFormat json.RawMessage `json:"numberFormat,omitempty"`
	// RowCount undocumented
	RowCount *int `json:"rowCount,omitempty"`
	// Text undocumented
	Text json.RawMessage `json:"text,omitempty"`
	// ValueTypes undocumented
	ValueTypes json.RawMessage `json:"valueTypes,omitempty"`
	// Values undocumented
	Values json.RawMessage `json:"values,omitempty"`
}

// IWorkbookRangeView interface type for workbookRangeView
type IWorkbookRangeView interface {
	PWorkbookRangeView() *WorkbookRangeView
}

// PWorkbookRangeView pointer method for workbookRangeView
func (p *WorkbookRangeView) PWorkbookRangeView() *WorkbookRangeView { return p }

// WorkbookSessionInfo undocumented
type WorkbookSessionInfo struct {
	// Id undocumented
	Id *string `json:"id,omitempty"`
	// PersistChanges undocumented
	PersistChanges *bool `json:"persistChanges,omitempty"`
}

// IWorkbookSessionInfo interface type for workbookSessionInfo
type IWorkbookSessionInfo interface {
	PWorkbookSessionInfo() *WorkbookSessionInfo
}

// PWorkbookSessionInfo pointer method for workbookSessionInfo
func (p *WorkbookSessionInfo) PWorkbookSessionInfo() *WorkbookSessionInfo { return p }

// WorkbookSortField undocumented
type WorkbookSortField struct {
	// Ascending undocumented
	Ascending *bool `json:"ascending,omitempty"`
	// Color undocumented
	Color *string `json:"color,omitempty"`
	// DataOption undocumented
	DataOption *string `json:"dataOption,omitempty"`
	// Icon undocumented
	Icon *WorkbookIcon `json:"icon,omitempty"`
	// Key undocumented
	Key *int `json:"key,omitempty"`
	// SortOn undocumented
	SortOn *string `json:"sortOn,omitempty"`
}

// IWorkbookSortField interface type for workbookSortField
type IWorkbookSortField interface {
	PWorkbookSortField() *WorkbookSortField
}

// PWorkbookSortField pointer method for workbookSortField
func (p *WorkbookSortField) PWorkbookSortField() *WorkbookSortField { return p }

// WorkbookTable undocumented
type WorkbookTable struct {
	Entity
	// HighlightFirstColumn undocumented
	HighlightFirstColumn *bool `json:"highlightFirstColumn,omitempty"`
	// HighlightLastColumn undocumented
	HighlightLastColumn *bool `json:"highlightLastColumn,omitempty"`
	// LegacyId undocumented
	LegacyId *string `json:"legacyId,omitempty"`
	// Name undocumented
	Name *string `json:"name,omitempty"`
	// ShowBandedColumns undocumented
	ShowBandedColumns *bool `json:"showBandedColumns,omitempty"`
	// ShowBandedRows undocumented
	ShowBandedRows *bool `json:"showBandedRows,omitempty"`
	// ShowFilterButton undocumented
	ShowFilterButton *bool `json:"showFilterButton,omitempty"`
	// ShowHeaders undocumented
	ShowHeaders *bool `json:"showHeaders,omitempty"`
	// ShowTotals undocumented
	ShowTotals *bool `json:"showTotals,omitempty"`
	// Style undocumented
	Style *string `json:"style,omitempty"`
}

// IWorkbookTable interface type for workbookTable
type IWorkbookTable interface {
	PWorkbookTable() *WorkbookTable
}

// PWorkbookTable pointer method for workbookTable
func (p *WorkbookTable) PWorkbookTable() *WorkbookTable { return p }

// WorkbookTableColumn undocumented
type WorkbookTableColumn struct {
	Entity
	// Index undocumented
	Index *int `json:"index,omitempty"`
	// Name undocumented
	Name *string `json:"name,omitempty"`
	// Values undocumented
	Values json.RawMessage `json:"values,omitempty"`
}

// IWorkbookTableColumn interface type for workbookTableColumn
type IWorkbookTableColumn interface {
	PWorkbookTableColumn() *WorkbookTableColumn
}

// PWorkbookTableColumn pointer method for workbookTableColumn
func (p *WorkbookTableColumn) PWorkbookTableColumn() *WorkbookTableColumn { return p }

// WorkbookTableRow undocumented
type WorkbookTableRow struct {
	Entity
	// Index undocumented
	Index *int `json:"index,omitempty"`
	// Values undocumented
	Values json.RawMessage `json:"values,omitempty"`
}

// IWorkbookTableRow interface type for workbookTableRow
type IWorkbookTableRow interface {
	PWorkbookTableRow() *WorkbookTableRow
}

// PWorkbookTableRow pointer method for workbookTableRow
func (p *WorkbookTableRow) PWorkbookTableRow() *WorkbookTableRow { return p }

// WorkbookTableSort undocumented
type WorkbookTableSort struct {
	Entity
	// Fields undocumented
	Fields []WorkbookSortField `json:"fields,omitempty"`
	// MatchCase undocumented
	MatchCase *bool `json:"matchCase,omitempty"`
	// Method undocumented
	Method *string `json:"method,omitempty"`
}

// IWorkbookTableSort interface type for workbookTableSort
type IWorkbookTableSort interface {
	PWorkbookTableSort() *WorkbookTableSort
}

// PWorkbookTableSort pointer method for workbookTableSort
func (p *WorkbookTableSort) PWorkbookTableSort() *WorkbookTableSort { return p }

// WorkbookWorksheet undocumented
type WorkbookWorksheet struct {
	Entity
	// Name undocumented
	Name *string `json:"name,omitempty"`
	// Position undocumented
	Position *int `json:"position,omitempty"`
	// Visibility undocumented
	Visibility *string `json:"visibility,omitempty"`
}

// IWorkbookWorksheet interface type for workbookWorksheet
type IWorkbookWorksheet interface {
	PWorkbookWorksheet() *WorkbookWorksheet
}

// PWorkbookWorksheet pointer method for workbookWorksheet
func (p *WorkbookWorksheet) PWorkbookWorksheet() *WorkbookWorksheet { return p }

// WorkbookWorksheetProtection undocumented
type WorkbookWorksheetProtection struct {
	Entity
	// Options undocumented
	Options *WorkbookWorksheetProtectionOptions `json:"options,omitempty"`
	// Protected undocumented
	Protected *bool `json:"protected,omitempty"`
}

// IWorkbookWorksheetProtection interface type for workbookWorksheetProtection
type IWorkbookWorksheetProtection interface {
	PWorkbookWorksheetProtection() *WorkbookWorksheetProtection
}

// PWorkbookWorksheetProtection pointer method for workbookWorksheetProtection
func (p *WorkbookWorksheetProtection) PWorkbookWorksheetProtection() *WorkbookWorksheetProtection {
	return p
}

// WorkbookWorksheetProtectionOptions undocumented
type WorkbookWorksheetProtectionOptions struct {
	// AllowAutoFilter undocumented
	AllowAutoFilter *bool `json:"allowAutoFilter,omitempty"`
	// AllowDeleteColumns undocumented
	AllowDeleteColumns *bool `json:"allowDeleteColumns,omitempty"`
	// AllowDeleteRows undocumented
	AllowDeleteRows *bool `json:"allowDeleteRows,omitempty"`
	// AllowFormatCells undocumented
	AllowFormatCells *bool `json:"allowFormatCells,omitempty"`
	// AllowFormatColumns undocumented
	AllowFormatColumns *bool `json:"allowFormatColumns,omitempty"`
	// AllowFormatRows undocumented
	AllowFormatRows *bool `json:"allowFormatRows,omitempty"`
	// AllowInsertColumns undocumented
	AllowInsertColumns *bool `json:"allowInsertColumns,omitempty"`
	// AllowInsertHyperlinks undocumented
	AllowInsertHyperlinks *bool `json:"allowInsertHyperlinks,omitempty"`
	// AllowInsertRows undocumented
	AllowInsertRows *bool `json:"allowInsertRows,omitempty"`
	// AllowPivotTables undocumented
	AllowPivotTables *bool `json:"allowPivotTables,omitempty"`
	// AllowSort undocumented
	AllowSort *bool `json:"allowSort,omitempty"`
}

// IWorkbookWorksheetProtectionOptions interface type for workbookWorksheetProtectionOptions
type IWorkbookWorksheetProtectionOptions interface {
	PWorkbookWorksheetProtectionOptions() *WorkbookWorksheetProtectionOptions
}

// PWorkbookWorksheetProtectionOptions pointer method for workbookWorksheetProtectionOptions
func (p *WorkbookWorksheetProtectionOptions) PWorkbookWorksheetProtectionOptions() *WorkbookWorksheetProtectionOptions {
	return p
}

// WorkingHours undocumented
type WorkingHours struct {
	// DaysOfWeek undocumented
	DaysOfWeek []DayOfWeek `json:"daysOfWeek,omitempty"`
	// StartTime undocumented
	StartTime *time.Time `json:"startTime,omitempty"`
	// EndTime undocumented
	EndTime *time.Time `json:"endTime,omitempty"`
	// TimeZone undocumented
	TimeZone *TimeZoneBase `json:"timeZone,omitempty"`
}

// IWorkingHours interface type for workingHours
type IWorkingHours interface {
	PWorkingHours() *WorkingHours
}

// PWorkingHours pointer method for workingHours
func (p *WorkingHours) PWorkingHours() *WorkingHours { return p }

// ServiceActivityHistoryItem is service endpoint type for ActivityHistoryItem
type ServiceActivityHistoryItem struct{ ServiceBase }

// ServiceAndroidManagedAppProtection is service endpoint type for AndroidManagedAppProtection
type ServiceAndroidManagedAppProtection struct{ ServiceBase }

// ServiceAppCatalogs is service endpoint type for AppCatalogs
type ServiceAppCatalogs struct{ ServiceBase }

// ServiceApplePushNotificationCertificate is service endpoint type for ApplePushNotificationCertificate
type ServiceApplePushNotificationCertificate struct{ ServiceBase }

// ServiceAuditLogRoot is service endpoint type for AuditLogRoot
type ServiceAuditLogRoot struct{ ServiceBase }

// ServiceBaseItem is service endpoint type for BaseItem
type ServiceBaseItem struct{ ServiceBase }

// ServiceCalendar is service endpoint type for Calendar
type ServiceCalendar struct{ ServiceBase }

// ServiceCalendarGroup is service endpoint type for CalendarGroup
type ServiceCalendarGroup struct{ ServiceBase }

// ServiceChannel is service endpoint type for Channel
type ServiceChannel struct{ ServiceBase }

// ServiceCollectionActivityHistoryItem is service endpoint type for CollectionActivityHistoryItem
type ServiceCollectionActivityHistoryItem struct{ ServiceBase }

// ServiceCollectionAlert is service endpoint type for CollectionAlert
type ServiceCollectionAlert struct{ ServiceBase }

// ServiceCollectionAndroidManagedAppProtection is service endpoint type for CollectionAndroidManagedAppProtection
type ServiceCollectionAndroidManagedAppProtection struct{ ServiceBase }

// ServiceCollectionAttachment is service endpoint type for CollectionAttachment
type ServiceCollectionAttachment struct{ ServiceBase }

// ServiceCollectionBaseItem is service endpoint type for CollectionBaseItem
type ServiceCollectionBaseItem struct{ ServiceBase }

// ServiceCollectionCalendar is service endpoint type for CollectionCalendar
type ServiceCollectionCalendar struct{ ServiceBase }

// ServiceCollectionCalendarGroup is service endpoint type for CollectionCalendarGroup
type ServiceCollectionCalendarGroup struct{ ServiceBase }

// ServiceCollectionChannel is service endpoint type for CollectionChannel
type ServiceCollectionChannel struct{ ServiceBase }

// ServiceCollectionColumnDefinition is service endpoint type for CollectionColumnDefinition
type ServiceCollectionColumnDefinition struct{ ServiceBase }

// ServiceCollectionColumnLink is service endpoint type for CollectionColumnLink
type ServiceCollectionColumnLink struct{ ServiceBase }

// ServiceCollectionContact is service endpoint type for CollectionContact
type ServiceCollectionContact struct{ ServiceBase }

// ServiceCollectionContactFolder is service endpoint type for CollectionContactFolder
type ServiceCollectionContactFolder struct{ ServiceBase }

// ServiceCollectionContentType is service endpoint type for CollectionContentType
type ServiceCollectionContentType struct{ ServiceBase }

// ServiceCollectionContract is service endpoint type for CollectionContract
type ServiceCollectionContract struct{ ServiceBase }

// ServiceCollectionConversation is service endpoint type for CollectionConversation
type ServiceCollectionConversation struct{ ServiceBase }

// ServiceCollectionConversationThread is service endpoint type for CollectionConversationThread
type ServiceCollectionConversationThread struct{ ServiceBase }

// ServiceCollectionDataPolicyOperation is service endpoint type for CollectionDataPolicyOperation
type ServiceCollectionDataPolicyOperation struct{ ServiceBase }

// ServiceCollectionDefaultManagedAppProtection is service endpoint type for CollectionDefaultManagedAppProtection
type ServiceCollectionDefaultManagedAppProtection struct{ ServiceBase }

// ServiceCollectionDetectedApp is service endpoint type for CollectionDetectedApp
type ServiceCollectionDetectedApp struct{ ServiceBase }

// ServiceCollectionDevice is service endpoint type for CollectionDevice
type ServiceCollectionDevice struct{ ServiceBase }

// ServiceCollectionDeviceAndAppManagementRoleAssignment is service endpoint type for CollectionDeviceAndAppManagementRoleAssignment
type ServiceCollectionDeviceAndAppManagementRoleAssignment struct{ ServiceBase }

// ServiceCollectionDeviceCategory is service endpoint type for CollectionDeviceCategory
type ServiceCollectionDeviceCategory struct{ ServiceBase }

// ServiceCollectionDeviceComplianceActionItem is service endpoint type for CollectionDeviceComplianceActionItem
type ServiceCollectionDeviceComplianceActionItem struct{ ServiceBase }

// ServiceCollectionDeviceComplianceDeviceStatus is service endpoint type for CollectionDeviceComplianceDeviceStatus
type ServiceCollectionDeviceComplianceDeviceStatus struct{ ServiceBase }

// ServiceCollectionDeviceCompliancePolicy is service endpoint type for CollectionDeviceCompliancePolicy
type ServiceCollectionDeviceCompliancePolicy struct{ ServiceBase }

// ServiceCollectionDeviceCompliancePolicyAssignment is service endpoint type for CollectionDeviceCompliancePolicyAssignment
type ServiceCollectionDeviceCompliancePolicyAssignment struct{ ServiceBase }

// ServiceCollectionDeviceCompliancePolicySettingStateSummary is service endpoint type for CollectionDeviceCompliancePolicySettingStateSummary
type ServiceCollectionDeviceCompliancePolicySettingStateSummary struct{ ServiceBase }

// ServiceCollectionDeviceCompliancePolicyState is service endpoint type for CollectionDeviceCompliancePolicyState
type ServiceCollectionDeviceCompliancePolicyState struct{ ServiceBase }

// ServiceCollectionDeviceComplianceScheduledActionForRule is service endpoint type for CollectionDeviceComplianceScheduledActionForRule
type ServiceCollectionDeviceComplianceScheduledActionForRule struct{ ServiceBase }

// ServiceCollectionDeviceComplianceSettingState is service endpoint type for CollectionDeviceComplianceSettingState
type ServiceCollectionDeviceComplianceSettingState struct{ ServiceBase }

// ServiceCollectionDeviceComplianceUserStatus is service endpoint type for CollectionDeviceComplianceUserStatus
type ServiceCollectionDeviceComplianceUserStatus struct{ ServiceBase }

// ServiceCollectionDeviceConfiguration is service endpoint type for CollectionDeviceConfiguration
type ServiceCollectionDeviceConfiguration struct{ ServiceBase }

// ServiceCollectionDeviceConfigurationAssignment is service endpoint type for CollectionDeviceConfigurationAssignment
type ServiceCollectionDeviceConfigurationAssignment struct{ ServiceBase }

// ServiceCollectionDeviceConfigurationDeviceStatus is service endpoint type for CollectionDeviceConfigurationDeviceStatus
type ServiceCollectionDeviceConfigurationDeviceStatus struct{ ServiceBase }

// ServiceCollectionDeviceConfigurationState is service endpoint type for CollectionDeviceConfigurationState
type ServiceCollectionDeviceConfigurationState struct{ ServiceBase }

// ServiceCollectionDeviceConfigurationUserStatus is service endpoint type for CollectionDeviceConfigurationUserStatus
type ServiceCollectionDeviceConfigurationUserStatus struct{ ServiceBase }

// ServiceCollectionDeviceEnrollmentConfiguration is service endpoint type for CollectionDeviceEnrollmentConfiguration
type ServiceCollectionDeviceEnrollmentConfiguration struct{ ServiceBase }

// ServiceCollectionDeviceInstallState is service endpoint type for CollectionDeviceInstallState
type ServiceCollectionDeviceInstallState struct{ ServiceBase }

// ServiceCollectionDeviceManagementExchangeConnector is service endpoint type for CollectionDeviceManagementExchangeConnector
type ServiceCollectionDeviceManagementExchangeConnector struct{ ServiceBase }

// ServiceCollectionDeviceManagementPartner is service endpoint type for CollectionDeviceManagementPartner
type ServiceCollectionDeviceManagementPartner struct{ ServiceBase }

// ServiceCollectionDeviceManagementTroubleshootingEvent is service endpoint type for CollectionDeviceManagementTroubleshootingEvent
type ServiceCollectionDeviceManagementTroubleshootingEvent struct{ ServiceBase }

// ServiceCollectionDirectoryAudit is service endpoint type for CollectionDirectoryAudit
type ServiceCollectionDirectoryAudit struct{ ServiceBase }

// ServiceCollectionDirectoryObject is service endpoint type for CollectionDirectoryObject
type ServiceCollectionDirectoryObject struct{ ServiceBase }

// ServiceCollectionDirectoryRole is service endpoint type for CollectionDirectoryRole
type ServiceCollectionDirectoryRole struct{ ServiceBase }

// ServiceCollectionDirectoryRoleTemplate is service endpoint type for CollectionDirectoryRoleTemplate
type ServiceCollectionDirectoryRoleTemplate struct{ ServiceBase }

// ServiceCollectionDomain is service endpoint type for CollectionDomain
type ServiceCollectionDomain struct{ ServiceBase }

// ServiceCollectionDomainDnsRecord is service endpoint type for CollectionDomainDnsRecord
type ServiceCollectionDomainDnsRecord struct{ ServiceBase }

// ServiceCollectionDrive is service endpoint type for CollectionDrive
type ServiceCollectionDrive struct{ ServiceBase }

// ServiceCollectionDriveItem is service endpoint type for CollectionDriveItem
type ServiceCollectionDriveItem struct{ ServiceBase }

// ServiceCollectionDriveItemVersion is service endpoint type for CollectionDriveItemVersion
type ServiceCollectionDriveItemVersion struct{ ServiceBase }

// ServiceCollectionEducationClass is service endpoint type for CollectionEducationClass
type ServiceCollectionEducationClass struct{ ServiceBase }

// ServiceCollectionEducationSchool is service endpoint type for CollectionEducationSchool
type ServiceCollectionEducationSchool struct{ ServiceBase }

// ServiceCollectionEducationUser is service endpoint type for CollectionEducationUser
type ServiceCollectionEducationUser struct{ ServiceBase }

// ServiceCollectionEnrollmentConfigurationAssignment is service endpoint type for CollectionEnrollmentConfigurationAssignment
type ServiceCollectionEnrollmentConfigurationAssignment struct{ ServiceBase }

// ServiceCollectionEvent is service endpoint type for CollectionEvent
type ServiceCollectionEvent struct{ ServiceBase }

// ServiceCollectionExtension is service endpoint type for CollectionExtension
type ServiceCollectionExtension struct{ ServiceBase }

// ServiceCollectionGroup is service endpoint type for CollectionGroup
type ServiceCollectionGroup struct{ ServiceBase }

// ServiceCollectionGroupLifecyclePolicy is service endpoint type for CollectionGroupLifecyclePolicy
type ServiceCollectionGroupLifecyclePolicy struct{ ServiceBase }

// ServiceCollectionGroupSetting is service endpoint type for CollectionGroupSetting
type ServiceCollectionGroupSetting struct{ ServiceBase }

// ServiceCollectionGroupSettingTemplate is service endpoint type for CollectionGroupSettingTemplate
type ServiceCollectionGroupSettingTemplate struct{ ServiceBase }

// ServiceCollectionIdentityProvider is service endpoint type for CollectionIdentityProvider
type ServiceCollectionIdentityProvider struct{ ServiceBase }

// ServiceCollectionInferenceClassificationOverride is service endpoint type for CollectionInferenceClassificationOverride
type ServiceCollectionInferenceClassificationOverride struct{ ServiceBase }

// ServiceCollectionInvitation is service endpoint type for CollectionInvitation
type ServiceCollectionInvitation struct{ ServiceBase }

// ServiceCollectionIosManagedAppProtection is service endpoint type for CollectionIosManagedAppProtection
type ServiceCollectionIosManagedAppProtection struct{ ServiceBase }

// ServiceCollectionIosUpdateDeviceStatus is service endpoint type for CollectionIosUpdateDeviceStatus
type ServiceCollectionIosUpdateDeviceStatus struct{ ServiceBase }

// ServiceCollectionItemActivity is service endpoint type for CollectionItemActivity
type ServiceCollectionItemActivity struct{ ServiceBase }

// ServiceCollectionItemActivityStat is service endpoint type for CollectionItemActivityStat
type ServiceCollectionItemActivityStat struct{ ServiceBase }

// ServiceCollectionLicenseDetails is service endpoint type for CollectionLicenseDetails
type ServiceCollectionLicenseDetails struct{ ServiceBase }

// ServiceCollectionList is service endpoint type for CollectionList
type ServiceCollectionList struct{ ServiceBase }

// ServiceCollectionListItem is service endpoint type for CollectionListItem
type ServiceCollectionListItem struct{ ServiceBase }

// ServiceCollectionListItemVersion is service endpoint type for CollectionListItemVersion
type ServiceCollectionListItemVersion struct{ ServiceBase }

// ServiceCollectionLocalizedNotificationMessage is service endpoint type for CollectionLocalizedNotificationMessage
type ServiceCollectionLocalizedNotificationMessage struct{ ServiceBase }

// ServiceCollectionMailFolder is service endpoint type for CollectionMailFolder
type ServiceCollectionMailFolder struct{ ServiceBase }

// ServiceCollectionManagedAppOperation is service endpoint type for CollectionManagedAppOperation
type ServiceCollectionManagedAppOperation struct{ ServiceBase }

// ServiceCollectionManagedAppPolicy is service endpoint type for CollectionManagedAppPolicy
type ServiceCollectionManagedAppPolicy struct{ ServiceBase }

// ServiceCollectionManagedAppRegistration is service endpoint type for CollectionManagedAppRegistration
type ServiceCollectionManagedAppRegistration struct{ ServiceBase }

// ServiceCollectionManagedAppStatus is service endpoint type for CollectionManagedAppStatus
type ServiceCollectionManagedAppStatus struct{ ServiceBase }

// ServiceCollectionManagedDevice is service endpoint type for CollectionManagedDevice
type ServiceCollectionManagedDevice struct{ ServiceBase }

// ServiceCollectionManagedDeviceMobileAppConfiguration is service endpoint type for CollectionManagedDeviceMobileAppConfiguration
type ServiceCollectionManagedDeviceMobileAppConfiguration struct{ ServiceBase }

// ServiceCollectionManagedDeviceMobileAppConfigurationAssignment is service endpoint type for CollectionManagedDeviceMobileAppConfigurationAssignment
type ServiceCollectionManagedDeviceMobileAppConfigurationAssignment struct{ ServiceBase }

// ServiceCollectionManagedDeviceMobileAppConfigurationDeviceStatus is service endpoint type for CollectionManagedDeviceMobileAppConfigurationDeviceStatus
type ServiceCollectionManagedDeviceMobileAppConfigurationDeviceStatus struct{ ServiceBase }

// ServiceCollectionManagedDeviceMobileAppConfigurationUserStatus is service endpoint type for CollectionManagedDeviceMobileAppConfigurationUserStatus
type ServiceCollectionManagedDeviceMobileAppConfigurationUserStatus struct{ ServiceBase }

// ServiceCollectionManagedEBook is service endpoint type for CollectionManagedEBook
type ServiceCollectionManagedEBook struct{ ServiceBase }

// ServiceCollectionManagedEBookAssignment is service endpoint type for CollectionManagedEBookAssignment
type ServiceCollectionManagedEBookAssignment struct{ ServiceBase }

// ServiceCollectionManagedMobileApp is service endpoint type for CollectionManagedMobileApp
type ServiceCollectionManagedMobileApp struct{ ServiceBase }

// ServiceCollectionMdmWindowsInformationProtectionPolicy is service endpoint type for CollectionMdmWindowsInformationProtectionPolicy
type ServiceCollectionMdmWindowsInformationProtectionPolicy struct{ ServiceBase }

// ServiceCollectionMessage is service endpoint type for CollectionMessage
type ServiceCollectionMessage struct{ ServiceBase }

// ServiceCollectionMessageRule is service endpoint type for CollectionMessageRule
type ServiceCollectionMessageRule struct{ ServiceBase }

// ServiceCollectionMobileApp is service endpoint type for CollectionMobileApp
type ServiceCollectionMobileApp struct{ ServiceBase }

// ServiceCollectionMobileAppAssignment is service endpoint type for CollectionMobileAppAssignment
type ServiceCollectionMobileAppAssignment struct{ ServiceBase }

// ServiceCollectionMobileAppCategory is service endpoint type for CollectionMobileAppCategory
type ServiceCollectionMobileAppCategory struct{ ServiceBase }

// ServiceCollectionMobileAppContent is service endpoint type for CollectionMobileAppContent
type ServiceCollectionMobileAppContent struct{ ServiceBase }

// ServiceCollectionMobileAppContentFile is service endpoint type for CollectionMobileAppContentFile
type ServiceCollectionMobileAppContentFile struct{ ServiceBase }

// ServiceCollectionMobileThreatDefenseConnector is service endpoint type for CollectionMobileThreatDefenseConnector
type ServiceCollectionMobileThreatDefenseConnector struct{ ServiceBase }

// ServiceCollectionMultiValueLegacyExtendedProperty is service endpoint type for CollectionMultiValueLegacyExtendedProperty
type ServiceCollectionMultiValueLegacyExtendedProperty struct{ ServiceBase }

// ServiceCollectionNotebook is service endpoint type for CollectionNotebook
type ServiceCollectionNotebook struct{ ServiceBase }

// ServiceCollectionNotificationMessageTemplate is service endpoint type for CollectionNotificationMessageTemplate
type ServiceCollectionNotificationMessageTemplate struct{ ServiceBase }

// ServiceCollectionOnenoteOperation is service endpoint type for CollectionOnenoteOperation
type ServiceCollectionOnenoteOperation struct{ ServiceBase }

// ServiceCollectionOnenotePage is service endpoint type for CollectionOnenotePage
type ServiceCollectionOnenotePage struct{ ServiceBase }

// ServiceCollectionOnenoteResource is service endpoint type for CollectionOnenoteResource
type ServiceCollectionOnenoteResource struct{ ServiceBase }

// ServiceCollectionOnenoteSection is service endpoint type for CollectionOnenoteSection
type ServiceCollectionOnenoteSection struct{ ServiceBase }

// ServiceCollectionOrganization is service endpoint type for CollectionOrganization
type ServiceCollectionOrganization struct{ ServiceBase }

// ServiceCollectionOutlookCategory is service endpoint type for CollectionOutlookCategory
type ServiceCollectionOutlookCategory struct{ ServiceBase }

// ServiceCollectionPermission is service endpoint type for CollectionPermission
type ServiceCollectionPermission struct{ ServiceBase }

// ServiceCollectionPerson is service endpoint type for CollectionPerson
type ServiceCollectionPerson struct{ ServiceBase }

// ServiceCollectionPlannerBucket is service endpoint type for CollectionPlannerBucket
type ServiceCollectionPlannerBucket struct{ ServiceBase }

// ServiceCollectionPlannerPlan is service endpoint type for CollectionPlannerPlan
type ServiceCollectionPlannerPlan struct{ ServiceBase }

// ServiceCollectionPlannerTask is service endpoint type for CollectionPlannerTask
type ServiceCollectionPlannerTask struct{ ServiceBase }

// ServiceCollectionPost is service endpoint type for CollectionPost
type ServiceCollectionPost struct{ ServiceBase }

// ServiceCollectionProfilePhoto is service endpoint type for CollectionProfilePhoto
type ServiceCollectionProfilePhoto struct{ ServiceBase }

// ServiceCollectionRemoteAssistancePartner is service endpoint type for CollectionRemoteAssistancePartner
type ServiceCollectionRemoteAssistancePartner struct{ ServiceBase }

// ServiceCollectionResourceOperation is service endpoint type for CollectionResourceOperation
type ServiceCollectionResourceOperation struct{ ServiceBase }

// ServiceCollectionRestrictedSignIn is service endpoint type for CollectionRestrictedSignIn
type ServiceCollectionRestrictedSignIn struct{ ServiceBase }

// ServiceCollectionRoleAssignment is service endpoint type for CollectionRoleAssignment
type ServiceCollectionRoleAssignment struct{ ServiceBase }

// ServiceCollectionRoleDefinition is service endpoint type for CollectionRoleDefinition
type ServiceCollectionRoleDefinition struct{ ServiceBase }

// ServiceCollectionSchemaExtension is service endpoint type for CollectionSchemaExtension
type ServiceCollectionSchemaExtension struct{ ServiceBase }

// ServiceCollectionSectionGroup is service endpoint type for CollectionSectionGroup
type ServiceCollectionSectionGroup struct{ ServiceBase }

// ServiceCollectionSecureScore is service endpoint type for CollectionSecureScore
type ServiceCollectionSecureScore struct{ ServiceBase }

// ServiceCollectionSecureScoreControlProfile is service endpoint type for CollectionSecureScoreControlProfile
type ServiceCollectionSecureScoreControlProfile struct{ ServiceBase }

// ServiceCollectionSettingStateDeviceSummary is service endpoint type for CollectionSettingStateDeviceSummary
type ServiceCollectionSettingStateDeviceSummary struct{ ServiceBase }

// ServiceCollectionSharedDriveItem is service endpoint type for CollectionSharedDriveItem
type ServiceCollectionSharedDriveItem struct{ ServiceBase }

// ServiceCollectionSharedInsight is service endpoint type for CollectionSharedInsight
type ServiceCollectionSharedInsight struct{ ServiceBase }

// ServiceCollectionSignIn is service endpoint type for CollectionSignIn
type ServiceCollectionSignIn struct{ ServiceBase }

// ServiceCollectionSingleValueLegacyExtendedProperty is service endpoint type for CollectionSingleValueLegacyExtendedProperty
type ServiceCollectionSingleValueLegacyExtendedProperty struct{ ServiceBase }

// ServiceCollectionSite is service endpoint type for CollectionSite
type ServiceCollectionSite struct{ ServiceBase }

// ServiceCollectionSubscribedSku is service endpoint type for CollectionSubscribedSku
type ServiceCollectionSubscribedSku struct{ ServiceBase }

// ServiceCollectionSubscription is service endpoint type for CollectionSubscription
type ServiceCollectionSubscription struct{ ServiceBase }

// ServiceCollectionTargetedManagedAppConfiguration is service endpoint type for CollectionTargetedManagedAppConfiguration
type ServiceCollectionTargetedManagedAppConfiguration struct{ ServiceBase }

// ServiceCollectionTargetedManagedAppPolicyAssignment is service endpoint type for CollectionTargetedManagedAppPolicyAssignment
type ServiceCollectionTargetedManagedAppPolicyAssignment struct{ ServiceBase }

// ServiceCollectionTeam is service endpoint type for CollectionTeam
type ServiceCollectionTeam struct{ ServiceBase }

// ServiceCollectionTeamsApp is service endpoint type for CollectionTeamsApp
type ServiceCollectionTeamsApp struct{ ServiceBase }

// ServiceCollectionTeamsAppDefinition is service endpoint type for CollectionTeamsAppDefinition
type ServiceCollectionTeamsAppDefinition struct{ ServiceBase }

// ServiceCollectionTeamsAppInstallation is service endpoint type for CollectionTeamsAppInstallation
type ServiceCollectionTeamsAppInstallation struct{ ServiceBase }

// ServiceCollectionTeamsAsyncOperation is service endpoint type for CollectionTeamsAsyncOperation
type ServiceCollectionTeamsAsyncOperation struct{ ServiceBase }

// ServiceCollectionTeamsTab is service endpoint type for CollectionTeamsTab
type ServiceCollectionTeamsTab struct{ ServiceBase }

// ServiceCollectionTelecomExpenseManagementPartner is service endpoint type for CollectionTelecomExpenseManagementPartner
type ServiceCollectionTelecomExpenseManagementPartner struct{ ServiceBase }

// ServiceCollectionTermsAndConditions is service endpoint type for CollectionTermsAndConditions
type ServiceCollectionTermsAndConditions struct{ ServiceBase }

// ServiceCollectionTermsAndConditionsAcceptanceStatus is service endpoint type for CollectionTermsAndConditionsAcceptanceStatus
type ServiceCollectionTermsAndConditionsAcceptanceStatus struct{ ServiceBase }

// ServiceCollectionTermsAndConditionsAssignment is service endpoint type for CollectionTermsAndConditionsAssignment
type ServiceCollectionTermsAndConditionsAssignment struct{ ServiceBase }

// ServiceCollectionThumbnailSet is service endpoint type for CollectionThumbnailSet
type ServiceCollectionThumbnailSet struct{ ServiceBase }

// ServiceCollectionTrending is service endpoint type for CollectionTrending
type ServiceCollectionTrending struct{ ServiceBase }

// ServiceCollectionUsedInsight is service endpoint type for CollectionUsedInsight
type ServiceCollectionUsedInsight struct{ ServiceBase }

// ServiceCollectionUser is service endpoint type for CollectionUser
type ServiceCollectionUser struct{ ServiceBase }

// ServiceCollectionUserActivity is service endpoint type for CollectionUserActivity
type ServiceCollectionUserActivity struct{ ServiceBase }

// ServiceCollectionUserInstallStateSummary is service endpoint type for CollectionUserInstallStateSummary
type ServiceCollectionUserInstallStateSummary struct{ ServiceBase }

// ServiceCollectionVppToken is service endpoint type for CollectionVppToken
type ServiceCollectionVppToken struct{ ServiceBase }

// ServiceCollectionWindowsInformationProtectionAppLearningSummary is service endpoint type for CollectionWindowsInformationProtectionAppLearningSummary
type ServiceCollectionWindowsInformationProtectionAppLearningSummary struct{ ServiceBase }

// ServiceCollectionWindowsInformationProtectionAppLockerFile is service endpoint type for CollectionWindowsInformationProtectionAppLockerFile
type ServiceCollectionWindowsInformationProtectionAppLockerFile struct{ ServiceBase }

// ServiceCollectionWindowsInformationProtectionNetworkLearningSummary is service endpoint type for CollectionWindowsInformationProtectionNetworkLearningSummary
type ServiceCollectionWindowsInformationProtectionNetworkLearningSummary struct{ ServiceBase }

// ServiceCollectionWindowsInformationProtectionPolicy is service endpoint type for CollectionWindowsInformationProtectionPolicy
type ServiceCollectionWindowsInformationProtectionPolicy struct{ ServiceBase }

// ServiceCollectionWorkbookChart is service endpoint type for CollectionWorkbookChart
type ServiceCollectionWorkbookChart struct{ ServiceBase }

// ServiceCollectionWorkbookChartPoint is service endpoint type for CollectionWorkbookChartPoint
type ServiceCollectionWorkbookChartPoint struct{ ServiceBase }

// ServiceCollectionWorkbookChartSeries is service endpoint type for CollectionWorkbookChartSeries
type ServiceCollectionWorkbookChartSeries struct{ ServiceBase }

// ServiceCollectionWorkbookComment is service endpoint type for CollectionWorkbookComment
type ServiceCollectionWorkbookComment struct{ ServiceBase }

// ServiceCollectionWorkbookCommentReply is service endpoint type for CollectionWorkbookCommentReply
type ServiceCollectionWorkbookCommentReply struct{ ServiceBase }

// ServiceCollectionWorkbookNamedItem is service endpoint type for CollectionWorkbookNamedItem
type ServiceCollectionWorkbookNamedItem struct{ ServiceBase }

// ServiceCollectionWorkbookPivotTable is service endpoint type for CollectionWorkbookPivotTable
type ServiceCollectionWorkbookPivotTable struct{ ServiceBase }

// ServiceCollectionWorkbookRangeBorder is service endpoint type for CollectionWorkbookRangeBorder
type ServiceCollectionWorkbookRangeBorder struct{ ServiceBase }

// ServiceCollectionWorkbookRangeView is service endpoint type for CollectionWorkbookRangeView
type ServiceCollectionWorkbookRangeView struct{ ServiceBase }

// ServiceCollectionWorkbookTable is service endpoint type for CollectionWorkbookTable
type ServiceCollectionWorkbookTable struct{ ServiceBase }

// ServiceCollectionWorkbookTableColumn is service endpoint type for CollectionWorkbookTableColumn
type ServiceCollectionWorkbookTableColumn struct{ ServiceBase }

// ServiceCollectionWorkbookTableRow is service endpoint type for CollectionWorkbookTableRow
type ServiceCollectionWorkbookTableRow struct{ ServiceBase }

// ServiceCollectionWorkbookWorksheet is service endpoint type for CollectionWorkbookWorksheet
type ServiceCollectionWorkbookWorksheet struct{ ServiceBase }

// ServiceContact is service endpoint type for Contact
type ServiceContact struct{ ServiceBase }

// ServiceContactFolder is service endpoint type for ContactFolder
type ServiceContactFolder struct{ ServiceBase }

// ServiceContentType is service endpoint type for ContentType
type ServiceContentType struct{ ServiceBase }

// ServiceContract is service endpoint type for Contract
type ServiceContract struct{ ServiceBase }

// ServiceConversation is service endpoint type for Conversation
type ServiceConversation struct{ ServiceBase }

// ServiceConversationThread is service endpoint type for ConversationThread
type ServiceConversationThread struct{ ServiceBase }

// ServiceDataPolicyOperation is service endpoint type for DataPolicyOperation
type ServiceDataPolicyOperation struct{ ServiceBase }

// ServiceDefaultManagedAppProtection is service endpoint type for DefaultManagedAppProtection
type ServiceDefaultManagedAppProtection struct{ ServiceBase }

// ServiceDetectedApp is service endpoint type for DetectedApp
type ServiceDetectedApp struct{ ServiceBase }

// ServiceDevice is service endpoint type for Device
type ServiceDevice struct{ ServiceBase }

// ServiceDeviceAppManagement is service endpoint type for DeviceAppManagement
type ServiceDeviceAppManagement struct{ ServiceBase }

// ServiceDeviceCategory is service endpoint type for DeviceCategory
type ServiceDeviceCategory struct{ ServiceBase }

// ServiceDeviceComplianceDeviceOverview is service endpoint type for DeviceComplianceDeviceOverview
type ServiceDeviceComplianceDeviceOverview struct{ ServiceBase }

// ServiceDeviceCompliancePolicy is service endpoint type for DeviceCompliancePolicy
type ServiceDeviceCompliancePolicy struct{ ServiceBase }

// ServiceDeviceCompliancePolicyDeviceStateSummary is service endpoint type for DeviceCompliancePolicyDeviceStateSummary
type ServiceDeviceCompliancePolicyDeviceStateSummary struct{ ServiceBase }

// ServiceDeviceCompliancePolicySettingStateSummary is service endpoint type for DeviceCompliancePolicySettingStateSummary
type ServiceDeviceCompliancePolicySettingStateSummary struct{ ServiceBase }

// ServiceDeviceComplianceScheduledActionForRule is service endpoint type for DeviceComplianceScheduledActionForRule
type ServiceDeviceComplianceScheduledActionForRule struct{ ServiceBase }

// ServiceDeviceComplianceUserOverview is service endpoint type for DeviceComplianceUserOverview
type ServiceDeviceComplianceUserOverview struct{ ServiceBase }

// ServiceDeviceConfiguration is service endpoint type for DeviceConfiguration
type ServiceDeviceConfiguration struct{ ServiceBase }

// ServiceDeviceConfigurationDeviceOverview is service endpoint type for DeviceConfigurationDeviceOverview
type ServiceDeviceConfigurationDeviceOverview struct{ ServiceBase }

// ServiceDeviceConfigurationDeviceStateSummary is service endpoint type for DeviceConfigurationDeviceStateSummary
type ServiceDeviceConfigurationDeviceStateSummary struct{ ServiceBase }

// ServiceDeviceConfigurationUserOverview is service endpoint type for DeviceConfigurationUserOverview
type ServiceDeviceConfigurationUserOverview struct{ ServiceBase }

// ServiceDeviceEnrollmentConfiguration is service endpoint type for DeviceEnrollmentConfiguration
type ServiceDeviceEnrollmentConfiguration struct{ ServiceBase }

// ServiceDeviceManagement is service endpoint type for DeviceManagement
type ServiceDeviceManagement struct{ ServiceBase }

// ServiceDirectory is service endpoint type for Directory
type ServiceDirectory struct{ ServiceBase }

// ServiceDirectoryObject is service endpoint type for DirectoryObject
type ServiceDirectoryObject struct{ ServiceBase }

// ServiceDirectoryRole is service endpoint type for DirectoryRole
type ServiceDirectoryRole struct{ ServiceBase }

// ServiceDirectoryRoleTemplate is service endpoint type for DirectoryRoleTemplate
type ServiceDirectoryRoleTemplate struct{ ServiceBase }

// ServiceDomain is service endpoint type for Domain
type ServiceDomain struct{ ServiceBase }

// ServiceDomainDnsRecord is service endpoint type for DomainDnsRecord
type ServiceDomainDnsRecord struct{ ServiceBase }

// ServiceDrive is service endpoint type for Drive
type ServiceDrive struct{ ServiceBase }

// ServiceDriveItem is service endpoint type for DriveItem
type ServiceDriveItem struct{ ServiceBase }

// ServiceEBookInstallSummary is service endpoint type for EBookInstallSummary
type ServiceEBookInstallSummary struct{ ServiceBase }

// ServiceEducationClass is service endpoint type for EducationClass
type ServiceEducationClass struct{ ServiceBase }

// ServiceEducationRoot is service endpoint type for EducationRoot
type ServiceEducationRoot struct{ ServiceBase }

// ServiceEducationSchool is service endpoint type for EducationSchool
type ServiceEducationSchool struct{ ServiceBase }

// ServiceEducationUser is service endpoint type for EducationUser
type ServiceEducationUser struct{ ServiceBase }

// ServiceEntity is service endpoint type for Entity
type ServiceEntity struct{ ServiceBase }

// ServiceEvent is service endpoint type for Event
type ServiceEvent struct{ ServiceBase }

// ServiceEventMessage is service endpoint type for EventMessage
type ServiceEventMessage struct{ ServiceBase }

// ServiceFieldValueSet is service endpoint type for FieldValueSet
type ServiceFieldValueSet struct{ ServiceBase }

// ServiceGroup is service endpoint type for Group
type ServiceGroup struct{ ServiceBase }

// ServiceGroupLifecyclePolicy is service endpoint type for GroupLifecyclePolicy
type ServiceGroupLifecyclePolicy struct{ ServiceBase }

// ServiceGroupSetting is service endpoint type for GroupSetting
type ServiceGroupSetting struct{ ServiceBase }

// ServiceGroupSettingTemplate is service endpoint type for GroupSettingTemplate
type ServiceGroupSettingTemplate struct{ ServiceBase }

// ServiceIdentityProvider is service endpoint type for IdentityProvider
type ServiceIdentityProvider struct{ ServiceBase }

// ServiceInferenceClassification is service endpoint type for InferenceClassification
type ServiceInferenceClassification struct{ ServiceBase }

// ServiceInvitation is service endpoint type for Invitation
type ServiceInvitation struct{ ServiceBase }

// ServiceIosManagedAppProtection is service endpoint type for IosManagedAppProtection
type ServiceIosManagedAppProtection struct{ ServiceBase }

// ServiceItemActivity is service endpoint type for ItemActivity
type ServiceItemActivity struct{ ServiceBase }

// ServiceItemActivityStat is service endpoint type for ItemActivityStat
type ServiceItemActivityStat struct{ ServiceBase }

// ServiceItemAnalytics is service endpoint type for ItemAnalytics
type ServiceItemAnalytics struct{ ServiceBase }

// ServiceItemAttachment is service endpoint type for ItemAttachment
type ServiceItemAttachment struct{ ServiceBase }

// ServiceList is service endpoint type for List
type ServiceList struct{ ServiceBase }

// ServiceListItem is service endpoint type for ListItem
type ServiceListItem struct{ ServiceBase }

// ServiceListItemVersion is service endpoint type for ListItemVersion
type ServiceListItemVersion struct{ ServiceBase }

// ServiceMailFolder is service endpoint type for MailFolder
type ServiceMailFolder struct{ ServiceBase }

// ServiceManagedAppPolicyDeploymentSummary is service endpoint type for ManagedAppPolicyDeploymentSummary
type ServiceManagedAppPolicyDeploymentSummary struct{ ServiceBase }

// ServiceManagedAppRegistration is service endpoint type for ManagedAppRegistration
type ServiceManagedAppRegistration struct{ ServiceBase }

// ServiceManagedDevice is service endpoint type for ManagedDevice
type ServiceManagedDevice struct{ ServiceBase }

// ServiceManagedDeviceMobileAppConfiguration is service endpoint type for ManagedDeviceMobileAppConfiguration
type ServiceManagedDeviceMobileAppConfiguration struct{ ServiceBase }

// ServiceManagedDeviceMobileAppConfigurationDeviceSummary is service endpoint type for ManagedDeviceMobileAppConfigurationDeviceSummary
type ServiceManagedDeviceMobileAppConfigurationDeviceSummary struct{ ServiceBase }

// ServiceManagedDeviceMobileAppConfigurationUserSummary is service endpoint type for ManagedDeviceMobileAppConfigurationUserSummary
type ServiceManagedDeviceMobileAppConfigurationUserSummary struct{ ServiceBase }

// ServiceManagedDeviceOverview is service endpoint type for ManagedDeviceOverview
type ServiceManagedDeviceOverview struct{ ServiceBase }

// ServiceManagedEBook is service endpoint type for ManagedEBook
type ServiceManagedEBook struct{ ServiceBase }

// ServiceManagedMobileLobApp is service endpoint type for ManagedMobileLobApp
type ServiceManagedMobileLobApp struct{ ServiceBase }

// ServiceMessage is service endpoint type for Message
type ServiceMessage struct{ ServiceBase }

// ServiceMobileApp is service endpoint type for MobileApp
type ServiceMobileApp struct{ ServiceBase }

// ServiceMobileAppContent is service endpoint type for MobileAppContent
type ServiceMobileAppContent struct{ ServiceBase }

// ServiceMobileLobApp is service endpoint type for MobileLobApp
type ServiceMobileLobApp struct{ ServiceBase }

// ServiceNotebook is service endpoint type for Notebook
type ServiceNotebook struct{ ServiceBase }

// ServiceNotificationMessageTemplate is service endpoint type for NotificationMessageTemplate
type ServiceNotificationMessageTemplate struct{ ServiceBase }

// ServiceOfficeGraphInsights is service endpoint type for OfficeGraphInsights
type ServiceOfficeGraphInsights struct{ ServiceBase }

// ServiceOnPremisesConditionalAccessSettings is service endpoint type for OnPremisesConditionalAccessSettings
type ServiceOnPremisesConditionalAccessSettings struct{ ServiceBase }

// ServiceOnenote is service endpoint type for Onenote
type ServiceOnenote struct{ ServiceBase }

// ServiceOnenotePage is service endpoint type for OnenotePage
type ServiceOnenotePage struct{ ServiceBase }

// ServiceOnenoteSection is service endpoint type for OnenoteSection
type ServiceOnenoteSection struct{ ServiceBase }

// ServiceOrganization is service endpoint type for Organization
type ServiceOrganization struct{ ServiceBase }

// ServiceOutlookItem is service endpoint type for OutlookItem
type ServiceOutlookItem struct{ ServiceBase }

// ServiceOutlookUser is service endpoint type for OutlookUser
type ServiceOutlookUser struct{ ServiceBase }

// ServicePlanner is service endpoint type for Planner
type ServicePlanner struct{ ServiceBase }

// ServicePlannerAssignedToTaskBoardTaskFormat is service endpoint type for PlannerAssignedToTaskBoardTaskFormat
type ServicePlannerAssignedToTaskBoardTaskFormat struct{ ServiceBase }

// ServicePlannerBucket is service endpoint type for PlannerBucket
type ServicePlannerBucket struct{ ServiceBase }

// ServicePlannerBucketTaskBoardTaskFormat is service endpoint type for PlannerBucketTaskBoardTaskFormat
type ServicePlannerBucketTaskBoardTaskFormat struct{ ServiceBase }

// ServicePlannerGroup is service endpoint type for PlannerGroup
type ServicePlannerGroup struct{ ServiceBase }

// ServicePlannerPlan is service endpoint type for PlannerPlan
type ServicePlannerPlan struct{ ServiceBase }

// ServicePlannerPlanDetails is service endpoint type for PlannerPlanDetails
type ServicePlannerPlanDetails struct{ ServiceBase }

// ServicePlannerProgressTaskBoardTaskFormat is service endpoint type for PlannerProgressTaskBoardTaskFormat
type ServicePlannerProgressTaskBoardTaskFormat struct{ ServiceBase }

// ServicePlannerTask is service endpoint type for PlannerTask
type ServicePlannerTask struct{ ServiceBase }

// ServicePlannerTaskDetails is service endpoint type for PlannerTaskDetails
type ServicePlannerTaskDetails struct{ ServiceBase }

// ServicePlannerUser is service endpoint type for PlannerUser
type ServicePlannerUser struct{ ServiceBase }

// ServicePost is service endpoint type for Post
type ServicePost struct{ ServiceBase }

// ServiceProfilePhoto is service endpoint type for ProfilePhoto
type ServiceProfilePhoto struct{ ServiceBase }

// ServiceReportRoot is service endpoint type for ReportRoot
type ServiceReportRoot struct{ ServiceBase }

// ServiceRoleAssignment is service endpoint type for RoleAssignment
type ServiceRoleAssignment struct{ ServiceBase }

// ServiceRoleDefinition is service endpoint type for RoleDefinition
type ServiceRoleDefinition struct{ ServiceBase }

// ServiceSchemaExtension is service endpoint type for SchemaExtension
type ServiceSchemaExtension struct{ ServiceBase }

// ServiceSectionGroup is service endpoint type for SectionGroup
type ServiceSectionGroup struct{ ServiceBase }

// ServiceSecurity is service endpoint type for Security
type ServiceSecurity struct{ ServiceBase }

// ServiceSharedDriveItem is service endpoint type for SharedDriveItem
type ServiceSharedDriveItem struct{ ServiceBase }

// ServiceSharedInsight is service endpoint type for SharedInsight
type ServiceSharedInsight struct{ ServiceBase }

// ServiceSite is service endpoint type for Site
type ServiceSite struct{ ServiceBase }

// ServiceSoftwareUpdateStatusSummary is service endpoint type for SoftwareUpdateStatusSummary
type ServiceSoftwareUpdateStatusSummary struct{ ServiceBase }

// ServiceSubscribedSku is service endpoint type for SubscribedSku
type ServiceSubscribedSku struct{ ServiceBase }

// ServiceSubscription is service endpoint type for Subscription
type ServiceSubscription struct{ ServiceBase }

// ServiceTargetedManagedAppConfiguration is service endpoint type for TargetedManagedAppConfiguration
type ServiceTargetedManagedAppConfiguration struct{ ServiceBase }

// ServiceTargetedManagedAppProtection is service endpoint type for TargetedManagedAppProtection
type ServiceTargetedManagedAppProtection struct{ ServiceBase }

// ServiceTeam is service endpoint type for Team
type ServiceTeam struct{ ServiceBase }

// ServiceTeamsApp is service endpoint type for TeamsApp
type ServiceTeamsApp struct{ ServiceBase }

// ServiceTeamsAppDefinition is service endpoint type for TeamsAppDefinition
type ServiceTeamsAppDefinition struct{ ServiceBase }

// ServiceTeamsAppInstallation is service endpoint type for TeamsAppInstallation
type ServiceTeamsAppInstallation struct{ ServiceBase }

// ServiceTeamsTab is service endpoint type for TeamsTab
type ServiceTeamsTab struct{ ServiceBase }

// ServiceTermsAndConditions is service endpoint type for TermsAndConditions
type ServiceTermsAndConditions struct{ ServiceBase }

// ServiceTermsAndConditionsAcceptanceStatus is service endpoint type for TermsAndConditionsAcceptanceStatus
type ServiceTermsAndConditionsAcceptanceStatus struct{ ServiceBase }

// ServiceTrending is service endpoint type for Trending
type ServiceTrending struct{ ServiceBase }

// ServiceUsedInsight is service endpoint type for UsedInsight
type ServiceUsedInsight struct{ ServiceBase }

// ServiceUser is service endpoint type for User
type ServiceUser struct{ ServiceBase }

// ServiceUserActivity is service endpoint type for UserActivity
type ServiceUserActivity struct{ ServiceBase }

// ServiceUserInstallStateSummary is service endpoint type for UserInstallStateSummary
type ServiceUserInstallStateSummary struct{ ServiceBase }

// ServiceUserSettings is service endpoint type for UserSettings
type ServiceUserSettings struct{ ServiceBase }

// ServiceWindowsInformationProtection is service endpoint type for WindowsInformationProtection
type ServiceWindowsInformationProtection struct{ ServiceBase }

// ServiceWorkbook is service endpoint type for Workbook
type ServiceWorkbook struct{ ServiceBase }

// ServiceWorkbookApplication is service endpoint type for WorkbookApplication
type ServiceWorkbookApplication struct{ ServiceBase }

// ServiceWorkbookChart is service endpoint type for WorkbookChart
type ServiceWorkbookChart struct{ ServiceBase }

// ServiceWorkbookChartAreaFormat is service endpoint type for WorkbookChartAreaFormat
type ServiceWorkbookChartAreaFormat struct{ ServiceBase }

// ServiceWorkbookChartAxes is service endpoint type for WorkbookChartAxes
type ServiceWorkbookChartAxes struct{ ServiceBase }

// ServiceWorkbookChartAxis is service endpoint type for WorkbookChartAxis
type ServiceWorkbookChartAxis struct{ ServiceBase }

// ServiceWorkbookChartAxisFormat is service endpoint type for WorkbookChartAxisFormat
type ServiceWorkbookChartAxisFormat struct{ ServiceBase }

// ServiceWorkbookChartAxisTitle is service endpoint type for WorkbookChartAxisTitle
type ServiceWorkbookChartAxisTitle struct{ ServiceBase }

// ServiceWorkbookChartAxisTitleFormat is service endpoint type for WorkbookChartAxisTitleFormat
type ServiceWorkbookChartAxisTitleFormat struct{ ServiceBase }

// ServiceWorkbookChartDataLabelFormat is service endpoint type for WorkbookChartDataLabelFormat
type ServiceWorkbookChartDataLabelFormat struct{ ServiceBase }

// ServiceWorkbookChartDataLabels is service endpoint type for WorkbookChartDataLabels
type ServiceWorkbookChartDataLabels struct{ ServiceBase }

// ServiceWorkbookChartFill is service endpoint type for WorkbookChartFill
type ServiceWorkbookChartFill struct{ ServiceBase }

// ServiceWorkbookChartFont is service endpoint type for WorkbookChartFont
type ServiceWorkbookChartFont struct{ ServiceBase }

// ServiceWorkbookChartGridlines is service endpoint type for WorkbookChartGridlines
type ServiceWorkbookChartGridlines struct{ ServiceBase }

// ServiceWorkbookChartGridlinesFormat is service endpoint type for WorkbookChartGridlinesFormat
type ServiceWorkbookChartGridlinesFormat struct{ ServiceBase }

// ServiceWorkbookChartLegend is service endpoint type for WorkbookChartLegend
type ServiceWorkbookChartLegend struct{ ServiceBase }

// ServiceWorkbookChartLegendFormat is service endpoint type for WorkbookChartLegendFormat
type ServiceWorkbookChartLegendFormat struct{ ServiceBase }

// ServiceWorkbookChartLineFormat is service endpoint type for WorkbookChartLineFormat
type ServiceWorkbookChartLineFormat struct{ ServiceBase }

// ServiceWorkbookChartPoint is service endpoint type for WorkbookChartPoint
type ServiceWorkbookChartPoint struct{ ServiceBase }

// ServiceWorkbookChartPointFormat is service endpoint type for WorkbookChartPointFormat
type ServiceWorkbookChartPointFormat struct{ ServiceBase }

// ServiceWorkbookChartSeries is service endpoint type for WorkbookChartSeries
type ServiceWorkbookChartSeries struct{ ServiceBase }

// ServiceWorkbookChartSeriesFormat is service endpoint type for WorkbookChartSeriesFormat
type ServiceWorkbookChartSeriesFormat struct{ ServiceBase }

// ServiceWorkbookChartTitle is service endpoint type for WorkbookChartTitle
type ServiceWorkbookChartTitle struct{ ServiceBase }

// ServiceWorkbookChartTitleFormat is service endpoint type for WorkbookChartTitleFormat
type ServiceWorkbookChartTitleFormat struct{ ServiceBase }

// ServiceWorkbookComment is service endpoint type for WorkbookComment
type ServiceWorkbookComment struct{ ServiceBase }

// ServiceWorkbookFilter is service endpoint type for WorkbookFilter
type ServiceWorkbookFilter struct{ ServiceBase }

// ServiceWorkbookFormatProtection is service endpoint type for WorkbookFormatProtection
type ServiceWorkbookFormatProtection struct{ ServiceBase }

// ServiceWorkbookFunctions is service endpoint type for WorkbookFunctions
type ServiceWorkbookFunctions struct{ ServiceBase }

// ServiceWorkbookNamedItem is service endpoint type for WorkbookNamedItem
type ServiceWorkbookNamedItem struct{ ServiceBase }

// ServiceWorkbookPivotTable is service endpoint type for WorkbookPivotTable
type ServiceWorkbookPivotTable struct{ ServiceBase }

// ServiceWorkbookRange is service endpoint type for WorkbookRange
type ServiceWorkbookRange struct{ ServiceBase }

// ServiceWorkbookRangeFill is service endpoint type for WorkbookRangeFill
type ServiceWorkbookRangeFill struct{ ServiceBase }

// ServiceWorkbookRangeFont is service endpoint type for WorkbookRangeFont
type ServiceWorkbookRangeFont struct{ ServiceBase }

// ServiceWorkbookRangeFormat is service endpoint type for WorkbookRangeFormat
type ServiceWorkbookRangeFormat struct{ ServiceBase }

// ServiceWorkbookRangeSort is service endpoint type for WorkbookRangeSort
type ServiceWorkbookRangeSort struct{ ServiceBase }

// ServiceWorkbookRangeView is service endpoint type for WorkbookRangeView
type ServiceWorkbookRangeView struct{ ServiceBase }

// ServiceWorkbookTable is service endpoint type for WorkbookTable
type ServiceWorkbookTable struct{ ServiceBase }

// ServiceWorkbookTableColumn is service endpoint type for WorkbookTableColumn
type ServiceWorkbookTableColumn struct{ ServiceBase }

// ServiceWorkbookTableSort is service endpoint type for WorkbookTableSort
type ServiceWorkbookTableSort struct{ ServiceBase }

// ServiceWorkbookWorksheet is service endpoint type for WorkbookWorksheet
type ServiceWorkbookWorksheet struct{ ServiceBase }

// ServiceWorkbookWorksheetProtection is service endpoint type for WorkbookWorksheetProtection
type ServiceWorkbookWorksheetProtection struct{ ServiceBase }

// Contracts returns service entity set endpoint for Contract
func (s *Service) Contracts() *ServiceCollectionContract {
	ss := &ServiceCollectionContract{ServiceBase: s.ServiceBase}
	ss.baseURL += "/contracts"
	return ss
}

// ID returns service service endpoint for Contract
func (s *ServiceCollectionContract) ID(id string) *ServiceContract {
	ss := &ServiceContract{ServiceBase: s.ServiceBase}
	ss.baseURL += "/" + id
	return ss
}

// DataPolicyOperations returns service entity set endpoint for DataPolicyOperation
func (s *Service) DataPolicyOperations() *ServiceCollectionDataPolicyOperation {
	ss := &ServiceCollectionDataPolicyOperation{ServiceBase: s.ServiceBase}
	ss.baseURL += "/dataPolicyOperations"
	return ss
}

// ID returns service service endpoint for DataPolicyOperation
func (s *ServiceCollectionDataPolicyOperation) ID(id string) *ServiceDataPolicyOperation {
	ss := &ServiceDataPolicyOperation{ServiceBase: s.ServiceBase}
	ss.baseURL += "/" + id
	return ss
}

// Devices returns service entity set endpoint for Device
func (s *Service) Devices() *ServiceCollectionDevice {
	ss := &ServiceCollectionDevice{ServiceBase: s.ServiceBase}
	ss.baseURL += "/devices"
	return ss
}

// ID returns service service endpoint for Device
func (s *ServiceCollectionDevice) ID(id string) *ServiceDevice {
	ss := &ServiceDevice{ServiceBase: s.ServiceBase}
	ss.baseURL += "/" + id
	return ss
}

// DirectoryObjects returns service entity set endpoint for DirectoryObject
func (s *Service) DirectoryObjects() *ServiceCollectionDirectoryObject {
	ss := &ServiceCollectionDirectoryObject{ServiceBase: s.ServiceBase}
	ss.baseURL += "/directoryObjects"
	return ss
}

// ID returns service service endpoint for DirectoryObject
func (s *ServiceCollectionDirectoryObject) ID(id string) *ServiceDirectoryObject {
	ss := &ServiceDirectoryObject{ServiceBase: s.ServiceBase}
	ss.baseURL += "/" + id
	return ss
}

// DirectoryRoleTemplates returns service entity set endpoint for DirectoryRoleTemplate
func (s *Service) DirectoryRoleTemplates() *ServiceCollectionDirectoryRoleTemplate {
	ss := &ServiceCollectionDirectoryRoleTemplate{ServiceBase: s.ServiceBase}
	ss.baseURL += "/directoryRoleTemplates"
	return ss
}

// ID returns service service endpoint for DirectoryRoleTemplate
func (s *ServiceCollectionDirectoryRoleTemplate) ID(id string) *ServiceDirectoryRoleTemplate {
	ss := &ServiceDirectoryRoleTemplate{ServiceBase: s.ServiceBase}
	ss.baseURL += "/" + id
	return ss
}

// DirectoryRoles returns service entity set endpoint for DirectoryRole
func (s *Service) DirectoryRoles() *ServiceCollectionDirectoryRole {
	ss := &ServiceCollectionDirectoryRole{ServiceBase: s.ServiceBase}
	ss.baseURL += "/directoryRoles"
	return ss
}

// ID returns service service endpoint for DirectoryRole
func (s *ServiceCollectionDirectoryRole) ID(id string) *ServiceDirectoryRole {
	ss := &ServiceDirectoryRole{ServiceBase: s.ServiceBase}
	ss.baseURL += "/" + id
	return ss
}

// DomainDnsRecords returns service entity set endpoint for DomainDnsRecord
func (s *Service) DomainDnsRecords() *ServiceCollectionDomainDnsRecord {
	ss := &ServiceCollectionDomainDnsRecord{ServiceBase: s.ServiceBase}
	ss.baseURL += "/domainDnsRecords"
	return ss
}

// ID returns service service endpoint for DomainDnsRecord
func (s *ServiceCollectionDomainDnsRecord) ID(id string) *ServiceDomainDnsRecord {
	ss := &ServiceDomainDnsRecord{ServiceBase: s.ServiceBase}
	ss.baseURL += "/" + id
	return ss
}

// Domains returns service entity set endpoint for Domain
func (s *Service) Domains() *ServiceCollectionDomain {
	ss := &ServiceCollectionDomain{ServiceBase: s.ServiceBase}
	ss.baseURL += "/domains"
	return ss
}

// ID returns service service endpoint for Domain
func (s *ServiceCollectionDomain) ID(id string) *ServiceDomain {
	ss := &ServiceDomain{ServiceBase: s.ServiceBase}
	ss.baseURL += "/" + id
	return ss
}

// Drives returns service entity set endpoint for Drive
func (s *Service) Drives() *ServiceCollectionDrive {
	ss := &ServiceCollectionDrive{ServiceBase: s.ServiceBase}
	ss.baseURL += "/drives"
	return ss
}

// ID returns service service endpoint for Drive
func (s *ServiceCollectionDrive) ID(id string) *ServiceDrive {
	ss := &ServiceDrive{ServiceBase: s.ServiceBase}
	ss.baseURL += "/" + id
	return ss
}

// GroupLifecyclePolicies returns service entity set endpoint for GroupLifecyclePolicy
func (s *Service) GroupLifecyclePolicies() *ServiceCollectionGroupLifecyclePolicy {
	ss := &ServiceCollectionGroupLifecyclePolicy{ServiceBase: s.ServiceBase}
	ss.baseURL += "/groupLifecyclePolicies"
	return ss
}

// ID returns service service endpoint for GroupLifecyclePolicy
func (s *ServiceCollectionGroupLifecyclePolicy) ID(id string) *ServiceGroupLifecyclePolicy {
	ss := &ServiceGroupLifecyclePolicy{ServiceBase: s.ServiceBase}
	ss.baseURL += "/" + id
	return ss
}

// GroupSettingTemplates returns service entity set endpoint for GroupSettingTemplate
func (s *Service) GroupSettingTemplates() *ServiceCollectionGroupSettingTemplate {
	ss := &ServiceCollectionGroupSettingTemplate{ServiceBase: s.ServiceBase}
	ss.baseURL += "/groupSettingTemplates"
	return ss
}

// ID returns service service endpoint for GroupSettingTemplate
func (s *ServiceCollectionGroupSettingTemplate) ID(id string) *ServiceGroupSettingTemplate {
	ss := &ServiceGroupSettingTemplate{ServiceBase: s.ServiceBase}
	ss.baseURL += "/" + id
	return ss
}

// GroupSettings returns service entity set endpoint for GroupSetting
func (s *Service) GroupSettings() *ServiceCollectionGroupSetting {
	ss := &ServiceCollectionGroupSetting{ServiceBase: s.ServiceBase}
	ss.baseURL += "/groupSettings"
	return ss
}

// ID returns service service endpoint for GroupSetting
func (s *ServiceCollectionGroupSetting) ID(id string) *ServiceGroupSetting {
	ss := &ServiceGroupSetting{ServiceBase: s.ServiceBase}
	ss.baseURL += "/" + id
	return ss
}

// Groups returns service entity set endpoint for Group
func (s *Service) Groups() *ServiceCollectionGroup {
	ss := &ServiceCollectionGroup{ServiceBase: s.ServiceBase}
	ss.baseURL += "/groups"
	return ss
}

// ID returns service service endpoint for Group
func (s *ServiceCollectionGroup) ID(id string) *ServiceGroup {
	ss := &ServiceGroup{ServiceBase: s.ServiceBase}
	ss.baseURL += "/" + id
	return ss
}

// IdentityProviders returns service entity set endpoint for IdentityProvider
func (s *Service) IdentityProviders() *ServiceCollectionIdentityProvider {
	ss := &ServiceCollectionIdentityProvider{ServiceBase: s.ServiceBase}
	ss.baseURL += "/identityProviders"
	return ss
}

// ID returns service service endpoint for IdentityProvider
func (s *ServiceCollectionIdentityProvider) ID(id string) *ServiceIdentityProvider {
	ss := &ServiceIdentityProvider{ServiceBase: s.ServiceBase}
	ss.baseURL += "/" + id
	return ss
}

// Invitations returns service entity set endpoint for Invitation
func (s *Service) Invitations() *ServiceCollectionInvitation {
	ss := &ServiceCollectionInvitation{ServiceBase: s.ServiceBase}
	ss.baseURL += "/invitations"
	return ss
}

// ID returns service service endpoint for Invitation
func (s *ServiceCollectionInvitation) ID(id string) *ServiceInvitation {
	ss := &ServiceInvitation{ServiceBase: s.ServiceBase}
	ss.baseURL += "/" + id
	return ss
}

// Organization returns service entity set endpoint for Organization
func (s *Service) Organization() *ServiceCollectionOrganization {
	ss := &ServiceCollectionOrganization{ServiceBase: s.ServiceBase}
	ss.baseURL += "/organization"
	return ss
}

// ID returns service service endpoint for Organization
func (s *ServiceCollectionOrganization) ID(id string) *ServiceOrganization {
	ss := &ServiceOrganization{ServiceBase: s.ServiceBase}
	ss.baseURL += "/" + id
	return ss
}

// SchemaExtensions returns service entity set endpoint for SchemaExtension
func (s *Service) SchemaExtensions() *ServiceCollectionSchemaExtension {
	ss := &ServiceCollectionSchemaExtension{ServiceBase: s.ServiceBase}
	ss.baseURL += "/schemaExtensions"
	return ss
}

// ID returns service service endpoint for SchemaExtension
func (s *ServiceCollectionSchemaExtension) ID(id string) *ServiceSchemaExtension {
	ss := &ServiceSchemaExtension{ServiceBase: s.ServiceBase}
	ss.baseURL += "/" + id
	return ss
}

// Shares returns service entity set endpoint for SharedDriveItem
func (s *Service) Shares() *ServiceCollectionSharedDriveItem {
	ss := &ServiceCollectionSharedDriveItem{ServiceBase: s.ServiceBase}
	ss.baseURL += "/shares"
	return ss
}

// ID returns service service endpoint for SharedDriveItem
func (s *ServiceCollectionSharedDriveItem) ID(id string) *ServiceSharedDriveItem {
	ss := &ServiceSharedDriveItem{ServiceBase: s.ServiceBase}
	ss.baseURL += "/" + id
	return ss
}

// Sites returns service entity set endpoint for Site
func (s *Service) Sites() *ServiceCollectionSite {
	ss := &ServiceCollectionSite{ServiceBase: s.ServiceBase}
	ss.baseURL += "/sites"
	return ss
}

// ID returns service service endpoint for Site
func (s *ServiceCollectionSite) ID(id string) *ServiceSite {
	ss := &ServiceSite{ServiceBase: s.ServiceBase}
	ss.baseURL += "/" + id
	return ss
}

// SubscribedSkus returns service entity set endpoint for SubscribedSku
func (s *Service) SubscribedSkus() *ServiceCollectionSubscribedSku {
	ss := &ServiceCollectionSubscribedSku{ServiceBase: s.ServiceBase}
	ss.baseURL += "/subscribedSkus"
	return ss
}

// ID returns service service endpoint for SubscribedSku
func (s *ServiceCollectionSubscribedSku) ID(id string) *ServiceSubscribedSku {
	ss := &ServiceSubscribedSku{ServiceBase: s.ServiceBase}
	ss.baseURL += "/" + id
	return ss
}

// Subscriptions returns service entity set endpoint for Subscription
func (s *Service) Subscriptions() *ServiceCollectionSubscription {
	ss := &ServiceCollectionSubscription{ServiceBase: s.ServiceBase}
	ss.baseURL += "/subscriptions"
	return ss
}

// ID returns service service endpoint for Subscription
func (s *ServiceCollectionSubscription) ID(id string) *ServiceSubscription {
	ss := &ServiceSubscription{ServiceBase: s.ServiceBase}
	ss.baseURL += "/" + id
	return ss
}

// Teams returns service entity set endpoint for Team
func (s *Service) Teams() *ServiceCollectionTeam {
	ss := &ServiceCollectionTeam{ServiceBase: s.ServiceBase}
	ss.baseURL += "/teams"
	return ss
}

// ID returns service service endpoint for Team
func (s *ServiceCollectionTeam) ID(id string) *ServiceTeam {
	ss := &ServiceTeam{ServiceBase: s.ServiceBase}
	ss.baseURL += "/" + id
	return ss
}

// Users returns service entity set endpoint for User
func (s *Service) Users() *ServiceCollectionUser {
	ss := &ServiceCollectionUser{ServiceBase: s.ServiceBase}
	ss.baseURL += "/users"
	return ss
}

// ID returns service service endpoint for User
func (s *ServiceCollectionUser) ID(id string) *ServiceUser {
	ss := &ServiceUser{ServiceBase: s.ServiceBase}
	ss.baseURL += "/" + id
	return ss
}

// Workbooks returns service entity set endpoint for DriveItem
func (s *Service) Workbooks() *ServiceCollectionDriveItem {
	ss := &ServiceCollectionDriveItem{ServiceBase: s.ServiceBase}
	ss.baseURL += "/workbooks"
	return ss
}

// ID returns service service endpoint for DriveItem
func (s *ServiceCollectionDriveItem) ID(id string) *ServiceDriveItem {
	ss := &ServiceDriveItem{ServiceBase: s.ServiceBase}
	ss.baseURL += "/" + id
	return ss
}

// Security returns service singleton endpoint for Security
func (s *Service) Security() *ServiceSecurity {
	ss := &ServiceSecurity{ServiceBase: s.ServiceBase}
	ss.baseURL += "/Security"
	return ss
}

// AppCatalogs returns service singleton endpoint for AppCatalogs
func (s *Service) AppCatalogs() *ServiceAppCatalogs {
	ss := &ServiceAppCatalogs{ServiceBase: s.ServiceBase}
	ss.baseURL += "/appCatalogs"
	return ss
}

// AuditLogs returns service singleton endpoint for AuditLogRoot
func (s *Service) AuditLogs() *ServiceAuditLogRoot {
	ss := &ServiceAuditLogRoot{ServiceBase: s.ServiceBase}
	ss.baseURL += "/auditLogs"
	return ss
}

// DeviceAppManagement returns service singleton endpoint for DeviceAppManagement
func (s *Service) DeviceAppManagement() *ServiceDeviceAppManagement {
	ss := &ServiceDeviceAppManagement{ServiceBase: s.ServiceBase}
	ss.baseURL += "/deviceAppManagement"
	return ss
}

// DeviceManagement returns service singleton endpoint for DeviceManagement
func (s *Service) DeviceManagement() *ServiceDeviceManagement {
	ss := &ServiceDeviceManagement{ServiceBase: s.ServiceBase}
	ss.baseURL += "/deviceManagement"
	return ss
}

// Directory returns service singleton endpoint for Directory
func (s *Service) Directory() *ServiceDirectory {
	ss := &ServiceDirectory{ServiceBase: s.ServiceBase}
	ss.baseURL += "/directory"
	return ss
}

// Drive returns service singleton endpoint for Drive
func (s *Service) Drive() *ServiceDrive {
	ss := &ServiceDrive{ServiceBase: s.ServiceBase}
	ss.baseURL += "/drive"
	return ss
}

// Education returns service singleton endpoint for EducationRoot
func (s *Service) Education() *ServiceEducationRoot {
	ss := &ServiceEducationRoot{ServiceBase: s.ServiceBase}
	ss.baseURL += "/education"
	return ss
}

// Me returns service singleton endpoint for User
func (s *Service) Me() *ServiceUser {
	ss := &ServiceUser{ServiceBase: s.ServiceBase}
	ss.baseURL += "/me"
	return ss
}

// Planner returns service singleton endpoint for Planner
func (s *Service) Planner() *ServicePlanner {
	ss := &ServicePlanner{ServiceBase: s.ServiceBase}
	ss.baseURL += "/planner"
	return ss
}

// Reports returns service singleton endpoint for ReportRoot
func (s *Service) Reports() *ServiceReportRoot {
	ss := &ServiceReportRoot{ServiceBase: s.ServiceBase}
	ss.baseURL += "/reports"
	return ss
}

// Activity returns service endpoint for UserActivity
func (s *ServiceActivityHistoryItem) Activity() *ServiceUserActivity {
	ss := &ServiceUserActivity{ServiceBase: s.ServiceBase}
	ss.baseURL += "/activity"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for ActivityHistoryItem
func (s *ServiceActivityHistoryItem) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceActivityHistoryItem) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for ActivityHistoryItem
func (s *ServiceActivityHistoryItem) DoRequestWithPath(method, path string, obj interface{}) (*ActivityHistoryItem, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *ActivityHistoryItem
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceActivityHistoryItem) DoRequest(method string, obj interface{}) (*ActivityHistoryItem, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceActivityHistoryItem) GetWithPath(path string) (*ActivityHistoryItem, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceActivityHistoryItem) Get() (*ActivityHistoryItem, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceActivityHistoryItem) PostWithPath(path string) (*ActivityHistoryItem, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceActivityHistoryItem) Post() (*ActivityHistoryItem, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for ActivityHistoryItem collection with addtional path
func (s *ServiceCollectionActivityHistoryItem) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionActivityHistoryItem) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for ActivityHistoryItem
func (s *ServiceCollectionActivityHistoryItem) DoRequestWithPath(method, path string, obj interface{}) (*ActivityHistoryItem, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *ActivityHistoryItem
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionActivityHistoryItem) DoRequest(method string, obj interface{}) (*ActivityHistoryItem, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for ActivityHistoryItem collection
func (s *ServiceCollectionActivityHistoryItem) DoPagingNext(res *http.Response) ([]ActivityHistoryItem, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []ActivityHistoryItem
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for ActivityHistoryItem collection
func (s *ServiceCollectionActivityHistoryItem) DoPagingWithPath(method, path string, obj interface{}) ([]ActivityHistoryItem, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionActivityHistoryItem) DoPaging(method string, obj interface{}) ([]ActivityHistoryItem, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionActivityHistoryItem) GetWithPath(path string) ([]ActivityHistoryItem, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionActivityHistoryItem) Get() ([]ActivityHistoryItem, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionActivityHistoryItem) PostWithPath(path string, obj interface{}) (*ActivityHistoryItem, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionActivityHistoryItem) Post(obj interface{}) (*ActivityHistoryItem, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for Alert collection with addtional path
func (s *ServiceCollectionAlert) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionAlert) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for Alert
func (s *ServiceCollectionAlert) DoRequestWithPath(method, path string, obj interface{}) (*Alert, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *Alert
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionAlert) DoRequest(method string, obj interface{}) (*Alert, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for Alert collection
func (s *ServiceCollectionAlert) DoPagingNext(res *http.Response) ([]Alert, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []Alert
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for Alert collection
func (s *ServiceCollectionAlert) DoPagingWithPath(method, path string, obj interface{}) ([]Alert, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionAlert) DoPaging(method string, obj interface{}) ([]Alert, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionAlert) GetWithPath(path string) ([]Alert, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionAlert) Get() ([]Alert, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionAlert) PostWithPath(path string, obj interface{}) (*Alert, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionAlert) Post(obj interface{}) (*Alert, error) {
	return s.PostWithPath("", obj)
}

// Apps returns service endpoint for CollectionManagedMobileApp
func (s *ServiceAndroidManagedAppProtection) Apps() *ServiceCollectionManagedMobileApp {
	ss := &ServiceCollectionManagedMobileApp{ServiceBase: s.ServiceBase}
	ss.baseURL += "/apps"
	return ss
}

// DeploymentSummary returns service endpoint for ManagedAppPolicyDeploymentSummary
func (s *ServiceAndroidManagedAppProtection) DeploymentSummary() *ServiceManagedAppPolicyDeploymentSummary {
	ss := &ServiceManagedAppPolicyDeploymentSummary{ServiceBase: s.ServiceBase}
	ss.baseURL += "/deploymentSummary"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for AndroidManagedAppProtection
func (s *ServiceAndroidManagedAppProtection) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceAndroidManagedAppProtection) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for AndroidManagedAppProtection
func (s *ServiceAndroidManagedAppProtection) DoRequestWithPath(method, path string, obj interface{}) (*AndroidManagedAppProtection, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *AndroidManagedAppProtection
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceAndroidManagedAppProtection) DoRequest(method string, obj interface{}) (*AndroidManagedAppProtection, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceAndroidManagedAppProtection) GetWithPath(path string) (*AndroidManagedAppProtection, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceAndroidManagedAppProtection) Get() (*AndroidManagedAppProtection, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceAndroidManagedAppProtection) PostWithPath(path string) (*AndroidManagedAppProtection, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceAndroidManagedAppProtection) Post() (*AndroidManagedAppProtection, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for AndroidManagedAppProtection collection with addtional path
func (s *ServiceCollectionAndroidManagedAppProtection) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionAndroidManagedAppProtection) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for AndroidManagedAppProtection
func (s *ServiceCollectionAndroidManagedAppProtection) DoRequestWithPath(method, path string, obj interface{}) (*AndroidManagedAppProtection, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *AndroidManagedAppProtection
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionAndroidManagedAppProtection) DoRequest(method string, obj interface{}) (*AndroidManagedAppProtection, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for AndroidManagedAppProtection collection
func (s *ServiceCollectionAndroidManagedAppProtection) DoPagingNext(res *http.Response) ([]AndroidManagedAppProtection, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []AndroidManagedAppProtection
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for AndroidManagedAppProtection collection
func (s *ServiceCollectionAndroidManagedAppProtection) DoPagingWithPath(method, path string, obj interface{}) ([]AndroidManagedAppProtection, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionAndroidManagedAppProtection) DoPaging(method string, obj interface{}) ([]AndroidManagedAppProtection, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionAndroidManagedAppProtection) GetWithPath(path string) ([]AndroidManagedAppProtection, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionAndroidManagedAppProtection) Get() ([]AndroidManagedAppProtection, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionAndroidManagedAppProtection) PostWithPath(path string, obj interface{}) (*AndroidManagedAppProtection, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionAndroidManagedAppProtection) Post(obj interface{}) (*AndroidManagedAppProtection, error) {
	return s.PostWithPath("", obj)
}

// TeamsApps returns service endpoint for CollectionTeamsApp
func (s *ServiceAppCatalogs) TeamsApps() *ServiceCollectionTeamsApp {
	ss := &ServiceCollectionTeamsApp{ServiceBase: s.ServiceBase}
	ss.baseURL += "/teamsApps"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for AppCatalogs
func (s *ServiceAppCatalogs) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceAppCatalogs) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for AppCatalogs
func (s *ServiceAppCatalogs) DoRequestWithPath(method, path string, obj interface{}) (*AppCatalogs, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *AppCatalogs
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceAppCatalogs) DoRequest(method string, obj interface{}) (*AppCatalogs, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceAppCatalogs) GetWithPath(path string) (*AppCatalogs, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceAppCatalogs) Get() (*AppCatalogs, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceAppCatalogs) PostWithPath(path string) (*AppCatalogs, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceAppCatalogs) Post() (*AppCatalogs, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for ApplePushNotificationCertificate
func (s *ServiceApplePushNotificationCertificate) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceApplePushNotificationCertificate) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for ApplePushNotificationCertificate
func (s *ServiceApplePushNotificationCertificate) DoRequestWithPath(method, path string, obj interface{}) (*ApplePushNotificationCertificate, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *ApplePushNotificationCertificate
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceApplePushNotificationCertificate) DoRequest(method string, obj interface{}) (*ApplePushNotificationCertificate, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceApplePushNotificationCertificate) GetWithPath(path string) (*ApplePushNotificationCertificate, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceApplePushNotificationCertificate) Get() (*ApplePushNotificationCertificate, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceApplePushNotificationCertificate) PostWithPath(path string) (*ApplePushNotificationCertificate, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceApplePushNotificationCertificate) Post() (*ApplePushNotificationCertificate, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for Attachment collection with addtional path
func (s *ServiceCollectionAttachment) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionAttachment) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for Attachment
func (s *ServiceCollectionAttachment) DoRequestWithPath(method, path string, obj interface{}) (*Attachment, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *Attachment
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionAttachment) DoRequest(method string, obj interface{}) (*Attachment, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for Attachment collection
func (s *ServiceCollectionAttachment) DoPagingNext(res *http.Response) ([]Attachment, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []Attachment
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for Attachment collection
func (s *ServiceCollectionAttachment) DoPagingWithPath(method, path string, obj interface{}) ([]Attachment, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionAttachment) DoPaging(method string, obj interface{}) ([]Attachment, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionAttachment) GetWithPath(path string) ([]Attachment, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionAttachment) Get() ([]Attachment, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionAttachment) PostWithPath(path string, obj interface{}) (*Attachment, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionAttachment) Post(obj interface{}) (*Attachment, error) {
	return s.PostWithPath("", obj)
}

// DirectoryAudits returns service endpoint for CollectionDirectoryAudit
func (s *ServiceAuditLogRoot) DirectoryAudits() *ServiceCollectionDirectoryAudit {
	ss := &ServiceCollectionDirectoryAudit{ServiceBase: s.ServiceBase}
	ss.baseURL += "/directoryAudits"
	return ss
}

// RestrictedSignIns returns service endpoint for CollectionRestrictedSignIn
func (s *ServiceAuditLogRoot) RestrictedSignIns() *ServiceCollectionRestrictedSignIn {
	ss := &ServiceCollectionRestrictedSignIn{ServiceBase: s.ServiceBase}
	ss.baseURL += "/restrictedSignIns"
	return ss
}

// SignIns returns service endpoint for CollectionSignIn
func (s *ServiceAuditLogRoot) SignIns() *ServiceCollectionSignIn {
	ss := &ServiceCollectionSignIn{ServiceBase: s.ServiceBase}
	ss.baseURL += "/signIns"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for AuditLogRoot
func (s *ServiceAuditLogRoot) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceAuditLogRoot) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for AuditLogRoot
func (s *ServiceAuditLogRoot) DoRequestWithPath(method, path string, obj interface{}) (*AuditLogRoot, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *AuditLogRoot
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceAuditLogRoot) DoRequest(method string, obj interface{}) (*AuditLogRoot, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceAuditLogRoot) GetWithPath(path string) (*AuditLogRoot, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceAuditLogRoot) Get() (*AuditLogRoot, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceAuditLogRoot) PostWithPath(path string) (*AuditLogRoot, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceAuditLogRoot) Post() (*AuditLogRoot, error) {
	return s.PostWithPath("")
}

// CreatedByUser returns service endpoint for User
func (s *ServiceBaseItem) CreatedByUser() *ServiceUser {
	ss := &ServiceUser{ServiceBase: s.ServiceBase}
	ss.baseURL += "/createdByUser"
	return ss
}

// LastModifiedByUser returns service endpoint for User
func (s *ServiceBaseItem) LastModifiedByUser() *ServiceUser {
	ss := &ServiceUser{ServiceBase: s.ServiceBase}
	ss.baseURL += "/lastModifiedByUser"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for BaseItem
func (s *ServiceBaseItem) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceBaseItem) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for BaseItem
func (s *ServiceBaseItem) DoRequestWithPath(method, path string, obj interface{}) (*BaseItem, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *BaseItem
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceBaseItem) DoRequest(method string, obj interface{}) (*BaseItem, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceBaseItem) GetWithPath(path string) (*BaseItem, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceBaseItem) Get() (*BaseItem, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceBaseItem) PostWithPath(path string) (*BaseItem, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceBaseItem) Post() (*BaseItem, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for BaseItem collection with addtional path
func (s *ServiceCollectionBaseItem) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionBaseItem) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for BaseItem
func (s *ServiceCollectionBaseItem) DoRequestWithPath(method, path string, obj interface{}) (*BaseItem, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *BaseItem
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionBaseItem) DoRequest(method string, obj interface{}) (*BaseItem, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for BaseItem collection
func (s *ServiceCollectionBaseItem) DoPagingNext(res *http.Response) ([]BaseItem, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []BaseItem
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for BaseItem collection
func (s *ServiceCollectionBaseItem) DoPagingWithPath(method, path string, obj interface{}) ([]BaseItem, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionBaseItem) DoPaging(method string, obj interface{}) ([]BaseItem, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionBaseItem) GetWithPath(path string) ([]BaseItem, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionBaseItem) Get() ([]BaseItem, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionBaseItem) PostWithPath(path string, obj interface{}) (*BaseItem, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionBaseItem) Post(obj interface{}) (*BaseItem, error) {
	return s.PostWithPath("", obj)
}

// CalendarView returns service endpoint for CollectionEvent
func (s *ServiceCalendar) CalendarView() *ServiceCollectionEvent {
	ss := &ServiceCollectionEvent{ServiceBase: s.ServiceBase}
	ss.baseURL += "/calendarView"
	return ss
}

// Events returns service endpoint for CollectionEvent
func (s *ServiceCalendar) Events() *ServiceCollectionEvent {
	ss := &ServiceCollectionEvent{ServiceBase: s.ServiceBase}
	ss.baseURL += "/events"
	return ss
}

// MultiValueExtendedProperties returns service endpoint for CollectionMultiValueLegacyExtendedProperty
func (s *ServiceCalendar) MultiValueExtendedProperties() *ServiceCollectionMultiValueLegacyExtendedProperty {
	ss := &ServiceCollectionMultiValueLegacyExtendedProperty{ServiceBase: s.ServiceBase}
	ss.baseURL += "/multiValueExtendedProperties"
	return ss
}

// SingleValueExtendedProperties returns service endpoint for CollectionSingleValueLegacyExtendedProperty
func (s *ServiceCalendar) SingleValueExtendedProperties() *ServiceCollectionSingleValueLegacyExtendedProperty {
	ss := &ServiceCollectionSingleValueLegacyExtendedProperty{ServiceBase: s.ServiceBase}
	ss.baseURL += "/singleValueExtendedProperties"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for Calendar
func (s *ServiceCalendar) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCalendar) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for Calendar
func (s *ServiceCalendar) DoRequestWithPath(method, path string, obj interface{}) (*Calendar, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *Calendar
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCalendar) DoRequest(method string, obj interface{}) (*Calendar, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceCalendar) GetWithPath(path string) (*Calendar, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCalendar) Get() (*Calendar, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceCalendar) PostWithPath(path string) (*Calendar, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCalendar) Post() (*Calendar, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for Calendar collection with addtional path
func (s *ServiceCollectionCalendar) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionCalendar) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for Calendar
func (s *ServiceCollectionCalendar) DoRequestWithPath(method, path string, obj interface{}) (*Calendar, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *Calendar
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionCalendar) DoRequest(method string, obj interface{}) (*Calendar, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for Calendar collection
func (s *ServiceCollectionCalendar) DoPagingNext(res *http.Response) ([]Calendar, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []Calendar
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for Calendar collection
func (s *ServiceCollectionCalendar) DoPagingWithPath(method, path string, obj interface{}) ([]Calendar, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionCalendar) DoPaging(method string, obj interface{}) ([]Calendar, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionCalendar) GetWithPath(path string) ([]Calendar, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionCalendar) Get() ([]Calendar, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionCalendar) PostWithPath(path string, obj interface{}) (*Calendar, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionCalendar) Post(obj interface{}) (*Calendar, error) {
	return s.PostWithPath("", obj)
}

// Calendars returns service endpoint for CollectionCalendar
func (s *ServiceCalendarGroup) Calendars() *ServiceCollectionCalendar {
	ss := &ServiceCollectionCalendar{ServiceBase: s.ServiceBase}
	ss.baseURL += "/calendars"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for CalendarGroup
func (s *ServiceCalendarGroup) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCalendarGroup) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for CalendarGroup
func (s *ServiceCalendarGroup) DoRequestWithPath(method, path string, obj interface{}) (*CalendarGroup, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *CalendarGroup
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCalendarGroup) DoRequest(method string, obj interface{}) (*CalendarGroup, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceCalendarGroup) GetWithPath(path string) (*CalendarGroup, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCalendarGroup) Get() (*CalendarGroup, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceCalendarGroup) PostWithPath(path string) (*CalendarGroup, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCalendarGroup) Post() (*CalendarGroup, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for CalendarGroup collection with addtional path
func (s *ServiceCollectionCalendarGroup) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionCalendarGroup) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for CalendarGroup
func (s *ServiceCollectionCalendarGroup) DoRequestWithPath(method, path string, obj interface{}) (*CalendarGroup, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *CalendarGroup
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionCalendarGroup) DoRequest(method string, obj interface{}) (*CalendarGroup, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for CalendarGroup collection
func (s *ServiceCollectionCalendarGroup) DoPagingNext(res *http.Response) ([]CalendarGroup, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []CalendarGroup
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for CalendarGroup collection
func (s *ServiceCollectionCalendarGroup) DoPagingWithPath(method, path string, obj interface{}) ([]CalendarGroup, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionCalendarGroup) DoPaging(method string, obj interface{}) ([]CalendarGroup, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionCalendarGroup) GetWithPath(path string) ([]CalendarGroup, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionCalendarGroup) Get() ([]CalendarGroup, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionCalendarGroup) PostWithPath(path string, obj interface{}) (*CalendarGroup, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionCalendarGroup) Post(obj interface{}) (*CalendarGroup, error) {
	return s.PostWithPath("", obj)
}

// Tabs returns service endpoint for CollectionTeamsTab
func (s *ServiceChannel) Tabs() *ServiceCollectionTeamsTab {
	ss := &ServiceCollectionTeamsTab{ServiceBase: s.ServiceBase}
	ss.baseURL += "/tabs"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for Channel
func (s *ServiceChannel) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceChannel) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for Channel
func (s *ServiceChannel) DoRequestWithPath(method, path string, obj interface{}) (*Channel, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *Channel
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceChannel) DoRequest(method string, obj interface{}) (*Channel, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceChannel) GetWithPath(path string) (*Channel, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceChannel) Get() (*Channel, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceChannel) PostWithPath(path string) (*Channel, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceChannel) Post() (*Channel, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for Channel collection with addtional path
func (s *ServiceCollectionChannel) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionChannel) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for Channel
func (s *ServiceCollectionChannel) DoRequestWithPath(method, path string, obj interface{}) (*Channel, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *Channel
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionChannel) DoRequest(method string, obj interface{}) (*Channel, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for Channel collection
func (s *ServiceCollectionChannel) DoPagingNext(res *http.Response) ([]Channel, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []Channel
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for Channel collection
func (s *ServiceCollectionChannel) DoPagingWithPath(method, path string, obj interface{}) ([]Channel, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionChannel) DoPaging(method string, obj interface{}) ([]Channel, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionChannel) GetWithPath(path string) ([]Channel, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionChannel) Get() ([]Channel, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionChannel) PostWithPath(path string, obj interface{}) (*Channel, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionChannel) Post(obj interface{}) (*Channel, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for ColumnDefinition collection with addtional path
func (s *ServiceCollectionColumnDefinition) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionColumnDefinition) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for ColumnDefinition
func (s *ServiceCollectionColumnDefinition) DoRequestWithPath(method, path string, obj interface{}) (*ColumnDefinition, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *ColumnDefinition
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionColumnDefinition) DoRequest(method string, obj interface{}) (*ColumnDefinition, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for ColumnDefinition collection
func (s *ServiceCollectionColumnDefinition) DoPagingNext(res *http.Response) ([]ColumnDefinition, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []ColumnDefinition
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for ColumnDefinition collection
func (s *ServiceCollectionColumnDefinition) DoPagingWithPath(method, path string, obj interface{}) ([]ColumnDefinition, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionColumnDefinition) DoPaging(method string, obj interface{}) ([]ColumnDefinition, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionColumnDefinition) GetWithPath(path string) ([]ColumnDefinition, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionColumnDefinition) Get() ([]ColumnDefinition, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionColumnDefinition) PostWithPath(path string, obj interface{}) (*ColumnDefinition, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionColumnDefinition) Post(obj interface{}) (*ColumnDefinition, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for ColumnLink collection with addtional path
func (s *ServiceCollectionColumnLink) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionColumnLink) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for ColumnLink
func (s *ServiceCollectionColumnLink) DoRequestWithPath(method, path string, obj interface{}) (*ColumnLink, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *ColumnLink
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionColumnLink) DoRequest(method string, obj interface{}) (*ColumnLink, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for ColumnLink collection
func (s *ServiceCollectionColumnLink) DoPagingNext(res *http.Response) ([]ColumnLink, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []ColumnLink
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for ColumnLink collection
func (s *ServiceCollectionColumnLink) DoPagingWithPath(method, path string, obj interface{}) ([]ColumnLink, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionColumnLink) DoPaging(method string, obj interface{}) ([]ColumnLink, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionColumnLink) GetWithPath(path string) ([]ColumnLink, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionColumnLink) Get() ([]ColumnLink, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionColumnLink) PostWithPath(path string, obj interface{}) (*ColumnLink, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionColumnLink) Post(obj interface{}) (*ColumnLink, error) {
	return s.PostWithPath("", obj)
}

// Extensions returns service endpoint for CollectionExtension
func (s *ServiceContact) Extensions() *ServiceCollectionExtension {
	ss := &ServiceCollectionExtension{ServiceBase: s.ServiceBase}
	ss.baseURL += "/extensions"
	return ss
}

// MultiValueExtendedProperties returns service endpoint for CollectionMultiValueLegacyExtendedProperty
func (s *ServiceContact) MultiValueExtendedProperties() *ServiceCollectionMultiValueLegacyExtendedProperty {
	ss := &ServiceCollectionMultiValueLegacyExtendedProperty{ServiceBase: s.ServiceBase}
	ss.baseURL += "/multiValueExtendedProperties"
	return ss
}

// Photo returns service endpoint for ProfilePhoto
func (s *ServiceContact) Photo() *ServiceProfilePhoto {
	ss := &ServiceProfilePhoto{ServiceBase: s.ServiceBase}
	ss.baseURL += "/photo"
	return ss
}

// SingleValueExtendedProperties returns service endpoint for CollectionSingleValueLegacyExtendedProperty
func (s *ServiceContact) SingleValueExtendedProperties() *ServiceCollectionSingleValueLegacyExtendedProperty {
	ss := &ServiceCollectionSingleValueLegacyExtendedProperty{ServiceBase: s.ServiceBase}
	ss.baseURL += "/singleValueExtendedProperties"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for Contact
func (s *ServiceContact) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceContact) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for Contact
func (s *ServiceContact) DoRequestWithPath(method, path string, obj interface{}) (*Contact, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *Contact
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceContact) DoRequest(method string, obj interface{}) (*Contact, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceContact) GetWithPath(path string) (*Contact, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceContact) Get() (*Contact, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceContact) PostWithPath(path string) (*Contact, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceContact) Post() (*Contact, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for Contact collection with addtional path
func (s *ServiceCollectionContact) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionContact) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for Contact
func (s *ServiceCollectionContact) DoRequestWithPath(method, path string, obj interface{}) (*Contact, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *Contact
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionContact) DoRequest(method string, obj interface{}) (*Contact, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for Contact collection
func (s *ServiceCollectionContact) DoPagingNext(res *http.Response) ([]Contact, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []Contact
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for Contact collection
func (s *ServiceCollectionContact) DoPagingWithPath(method, path string, obj interface{}) ([]Contact, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionContact) DoPaging(method string, obj interface{}) ([]Contact, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionContact) GetWithPath(path string) ([]Contact, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionContact) Get() ([]Contact, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionContact) PostWithPath(path string, obj interface{}) (*Contact, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionContact) Post(obj interface{}) (*Contact, error) {
	return s.PostWithPath("", obj)
}

// ChildFolders returns service endpoint for CollectionContactFolder
func (s *ServiceContactFolder) ChildFolders() *ServiceCollectionContactFolder {
	ss := &ServiceCollectionContactFolder{ServiceBase: s.ServiceBase}
	ss.baseURL += "/childFolders"
	return ss
}

// Contacts returns service endpoint for CollectionContact
func (s *ServiceContactFolder) Contacts() *ServiceCollectionContact {
	ss := &ServiceCollectionContact{ServiceBase: s.ServiceBase}
	ss.baseURL += "/contacts"
	return ss
}

// MultiValueExtendedProperties returns service endpoint for CollectionMultiValueLegacyExtendedProperty
func (s *ServiceContactFolder) MultiValueExtendedProperties() *ServiceCollectionMultiValueLegacyExtendedProperty {
	ss := &ServiceCollectionMultiValueLegacyExtendedProperty{ServiceBase: s.ServiceBase}
	ss.baseURL += "/multiValueExtendedProperties"
	return ss
}

// SingleValueExtendedProperties returns service endpoint for CollectionSingleValueLegacyExtendedProperty
func (s *ServiceContactFolder) SingleValueExtendedProperties() *ServiceCollectionSingleValueLegacyExtendedProperty {
	ss := &ServiceCollectionSingleValueLegacyExtendedProperty{ServiceBase: s.ServiceBase}
	ss.baseURL += "/singleValueExtendedProperties"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for ContactFolder
func (s *ServiceContactFolder) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceContactFolder) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for ContactFolder
func (s *ServiceContactFolder) DoRequestWithPath(method, path string, obj interface{}) (*ContactFolder, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *ContactFolder
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceContactFolder) DoRequest(method string, obj interface{}) (*ContactFolder, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceContactFolder) GetWithPath(path string) (*ContactFolder, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceContactFolder) Get() (*ContactFolder, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceContactFolder) PostWithPath(path string) (*ContactFolder, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceContactFolder) Post() (*ContactFolder, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for ContactFolder collection with addtional path
func (s *ServiceCollectionContactFolder) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionContactFolder) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for ContactFolder
func (s *ServiceCollectionContactFolder) DoRequestWithPath(method, path string, obj interface{}) (*ContactFolder, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *ContactFolder
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionContactFolder) DoRequest(method string, obj interface{}) (*ContactFolder, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for ContactFolder collection
func (s *ServiceCollectionContactFolder) DoPagingNext(res *http.Response) ([]ContactFolder, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []ContactFolder
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for ContactFolder collection
func (s *ServiceCollectionContactFolder) DoPagingWithPath(method, path string, obj interface{}) ([]ContactFolder, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionContactFolder) DoPaging(method string, obj interface{}) ([]ContactFolder, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionContactFolder) GetWithPath(path string) ([]ContactFolder, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionContactFolder) Get() ([]ContactFolder, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionContactFolder) PostWithPath(path string, obj interface{}) (*ContactFolder, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionContactFolder) Post(obj interface{}) (*ContactFolder, error) {
	return s.PostWithPath("", obj)
}

// ColumnLinks returns service endpoint for CollectionColumnLink
func (s *ServiceContentType) ColumnLinks() *ServiceCollectionColumnLink {
	ss := &ServiceCollectionColumnLink{ServiceBase: s.ServiceBase}
	ss.baseURL += "/columnLinks"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for ContentType
func (s *ServiceContentType) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceContentType) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for ContentType
func (s *ServiceContentType) DoRequestWithPath(method, path string, obj interface{}) (*ContentType, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *ContentType
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceContentType) DoRequest(method string, obj interface{}) (*ContentType, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceContentType) GetWithPath(path string) (*ContentType, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceContentType) Get() (*ContentType, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceContentType) PostWithPath(path string) (*ContentType, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceContentType) Post() (*ContentType, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for ContentType collection with addtional path
func (s *ServiceCollectionContentType) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionContentType) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for ContentType
func (s *ServiceCollectionContentType) DoRequestWithPath(method, path string, obj interface{}) (*ContentType, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *ContentType
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionContentType) DoRequest(method string, obj interface{}) (*ContentType, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for ContentType collection
func (s *ServiceCollectionContentType) DoPagingNext(res *http.Response) ([]ContentType, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []ContentType
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for ContentType collection
func (s *ServiceCollectionContentType) DoPagingWithPath(method, path string, obj interface{}) ([]ContentType, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionContentType) DoPaging(method string, obj interface{}) ([]ContentType, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionContentType) GetWithPath(path string) ([]ContentType, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionContentType) Get() ([]ContentType, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionContentType) PostWithPath(path string, obj interface{}) (*ContentType, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionContentType) Post(obj interface{}) (*ContentType, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for Contract
func (s *ServiceContract) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceContract) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for Contract
func (s *ServiceContract) DoRequestWithPath(method, path string, obj interface{}) (*Contract, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *Contract
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceContract) DoRequest(method string, obj interface{}) (*Contract, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceContract) GetWithPath(path string) (*Contract, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceContract) Get() (*Contract, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceContract) PostWithPath(path string) (*Contract, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceContract) Post() (*Contract, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for Contract collection with addtional path
func (s *ServiceCollectionContract) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionContract) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for Contract
func (s *ServiceCollectionContract) DoRequestWithPath(method, path string, obj interface{}) (*Contract, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *Contract
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionContract) DoRequest(method string, obj interface{}) (*Contract, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for Contract collection
func (s *ServiceCollectionContract) DoPagingNext(res *http.Response) ([]Contract, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []Contract
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for Contract collection
func (s *ServiceCollectionContract) DoPagingWithPath(method, path string, obj interface{}) ([]Contract, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionContract) DoPaging(method string, obj interface{}) ([]Contract, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionContract) GetWithPath(path string) ([]Contract, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionContract) Get() ([]Contract, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionContract) PostWithPath(path string, obj interface{}) (*Contract, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionContract) Post(obj interface{}) (*Contract, error) {
	return s.PostWithPath("", obj)
}

// Threads returns service endpoint for CollectionConversationThread
func (s *ServiceConversation) Threads() *ServiceCollectionConversationThread {
	ss := &ServiceCollectionConversationThread{ServiceBase: s.ServiceBase}
	ss.baseURL += "/threads"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for Conversation
func (s *ServiceConversation) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceConversation) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for Conversation
func (s *ServiceConversation) DoRequestWithPath(method, path string, obj interface{}) (*Conversation, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *Conversation
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceConversation) DoRequest(method string, obj interface{}) (*Conversation, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceConversation) GetWithPath(path string) (*Conversation, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceConversation) Get() (*Conversation, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceConversation) PostWithPath(path string) (*Conversation, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceConversation) Post() (*Conversation, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for Conversation collection with addtional path
func (s *ServiceCollectionConversation) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionConversation) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for Conversation
func (s *ServiceCollectionConversation) DoRequestWithPath(method, path string, obj interface{}) (*Conversation, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *Conversation
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionConversation) DoRequest(method string, obj interface{}) (*Conversation, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for Conversation collection
func (s *ServiceCollectionConversation) DoPagingNext(res *http.Response) ([]Conversation, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []Conversation
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for Conversation collection
func (s *ServiceCollectionConversation) DoPagingWithPath(method, path string, obj interface{}) ([]Conversation, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionConversation) DoPaging(method string, obj interface{}) ([]Conversation, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionConversation) GetWithPath(path string) ([]Conversation, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionConversation) Get() ([]Conversation, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionConversation) PostWithPath(path string, obj interface{}) (*Conversation, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionConversation) Post(obj interface{}) (*Conversation, error) {
	return s.PostWithPath("", obj)
}

// Posts returns service endpoint for CollectionPost
func (s *ServiceConversationThread) Posts() *ServiceCollectionPost {
	ss := &ServiceCollectionPost{ServiceBase: s.ServiceBase}
	ss.baseURL += "/posts"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for ConversationThread
func (s *ServiceConversationThread) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceConversationThread) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for ConversationThread
func (s *ServiceConversationThread) DoRequestWithPath(method, path string, obj interface{}) (*ConversationThread, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *ConversationThread
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceConversationThread) DoRequest(method string, obj interface{}) (*ConversationThread, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceConversationThread) GetWithPath(path string) (*ConversationThread, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceConversationThread) Get() (*ConversationThread, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceConversationThread) PostWithPath(path string) (*ConversationThread, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceConversationThread) Post() (*ConversationThread, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for ConversationThread collection with addtional path
func (s *ServiceCollectionConversationThread) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionConversationThread) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for ConversationThread
func (s *ServiceCollectionConversationThread) DoRequestWithPath(method, path string, obj interface{}) (*ConversationThread, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *ConversationThread
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionConversationThread) DoRequest(method string, obj interface{}) (*ConversationThread, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for ConversationThread collection
func (s *ServiceCollectionConversationThread) DoPagingNext(res *http.Response) ([]ConversationThread, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []ConversationThread
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for ConversationThread collection
func (s *ServiceCollectionConversationThread) DoPagingWithPath(method, path string, obj interface{}) ([]ConversationThread, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionConversationThread) DoPaging(method string, obj interface{}) ([]ConversationThread, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionConversationThread) GetWithPath(path string) ([]ConversationThread, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionConversationThread) Get() ([]ConversationThread, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionConversationThread) PostWithPath(path string, obj interface{}) (*ConversationThread, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionConversationThread) Post(obj interface{}) (*ConversationThread, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for DataPolicyOperation
func (s *ServiceDataPolicyOperation) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceDataPolicyOperation) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for DataPolicyOperation
func (s *ServiceDataPolicyOperation) DoRequestWithPath(method, path string, obj interface{}) (*DataPolicyOperation, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *DataPolicyOperation
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceDataPolicyOperation) DoRequest(method string, obj interface{}) (*DataPolicyOperation, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceDataPolicyOperation) GetWithPath(path string) (*DataPolicyOperation, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceDataPolicyOperation) Get() (*DataPolicyOperation, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceDataPolicyOperation) PostWithPath(path string) (*DataPolicyOperation, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceDataPolicyOperation) Post() (*DataPolicyOperation, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for DataPolicyOperation collection with addtional path
func (s *ServiceCollectionDataPolicyOperation) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionDataPolicyOperation) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for DataPolicyOperation
func (s *ServiceCollectionDataPolicyOperation) DoRequestWithPath(method, path string, obj interface{}) (*DataPolicyOperation, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *DataPolicyOperation
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionDataPolicyOperation) DoRequest(method string, obj interface{}) (*DataPolicyOperation, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for DataPolicyOperation collection
func (s *ServiceCollectionDataPolicyOperation) DoPagingNext(res *http.Response) ([]DataPolicyOperation, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []DataPolicyOperation
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for DataPolicyOperation collection
func (s *ServiceCollectionDataPolicyOperation) DoPagingWithPath(method, path string, obj interface{}) ([]DataPolicyOperation, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionDataPolicyOperation) DoPaging(method string, obj interface{}) ([]DataPolicyOperation, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionDataPolicyOperation) GetWithPath(path string) ([]DataPolicyOperation, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionDataPolicyOperation) Get() ([]DataPolicyOperation, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionDataPolicyOperation) PostWithPath(path string, obj interface{}) (*DataPolicyOperation, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionDataPolicyOperation) Post(obj interface{}) (*DataPolicyOperation, error) {
	return s.PostWithPath("", obj)
}

// Apps returns service endpoint for CollectionManagedMobileApp
func (s *ServiceDefaultManagedAppProtection) Apps() *ServiceCollectionManagedMobileApp {
	ss := &ServiceCollectionManagedMobileApp{ServiceBase: s.ServiceBase}
	ss.baseURL += "/apps"
	return ss
}

// DeploymentSummary returns service endpoint for ManagedAppPolicyDeploymentSummary
func (s *ServiceDefaultManagedAppProtection) DeploymentSummary() *ServiceManagedAppPolicyDeploymentSummary {
	ss := &ServiceManagedAppPolicyDeploymentSummary{ServiceBase: s.ServiceBase}
	ss.baseURL += "/deploymentSummary"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for DefaultManagedAppProtection
func (s *ServiceDefaultManagedAppProtection) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceDefaultManagedAppProtection) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for DefaultManagedAppProtection
func (s *ServiceDefaultManagedAppProtection) DoRequestWithPath(method, path string, obj interface{}) (*DefaultManagedAppProtection, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *DefaultManagedAppProtection
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceDefaultManagedAppProtection) DoRequest(method string, obj interface{}) (*DefaultManagedAppProtection, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceDefaultManagedAppProtection) GetWithPath(path string) (*DefaultManagedAppProtection, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceDefaultManagedAppProtection) Get() (*DefaultManagedAppProtection, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceDefaultManagedAppProtection) PostWithPath(path string) (*DefaultManagedAppProtection, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceDefaultManagedAppProtection) Post() (*DefaultManagedAppProtection, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for DefaultManagedAppProtection collection with addtional path
func (s *ServiceCollectionDefaultManagedAppProtection) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionDefaultManagedAppProtection) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for DefaultManagedAppProtection
func (s *ServiceCollectionDefaultManagedAppProtection) DoRequestWithPath(method, path string, obj interface{}) (*DefaultManagedAppProtection, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *DefaultManagedAppProtection
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionDefaultManagedAppProtection) DoRequest(method string, obj interface{}) (*DefaultManagedAppProtection, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for DefaultManagedAppProtection collection
func (s *ServiceCollectionDefaultManagedAppProtection) DoPagingNext(res *http.Response) ([]DefaultManagedAppProtection, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []DefaultManagedAppProtection
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for DefaultManagedAppProtection collection
func (s *ServiceCollectionDefaultManagedAppProtection) DoPagingWithPath(method, path string, obj interface{}) ([]DefaultManagedAppProtection, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionDefaultManagedAppProtection) DoPaging(method string, obj interface{}) ([]DefaultManagedAppProtection, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionDefaultManagedAppProtection) GetWithPath(path string) ([]DefaultManagedAppProtection, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionDefaultManagedAppProtection) Get() ([]DefaultManagedAppProtection, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionDefaultManagedAppProtection) PostWithPath(path string, obj interface{}) (*DefaultManagedAppProtection, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionDefaultManagedAppProtection) Post(obj interface{}) (*DefaultManagedAppProtection, error) {
	return s.PostWithPath("", obj)
}

// ManagedDevices returns service endpoint for CollectionManagedDevice
func (s *ServiceDetectedApp) ManagedDevices() *ServiceCollectionManagedDevice {
	ss := &ServiceCollectionManagedDevice{ServiceBase: s.ServiceBase}
	ss.baseURL += "/managedDevices"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for DetectedApp
func (s *ServiceDetectedApp) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceDetectedApp) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for DetectedApp
func (s *ServiceDetectedApp) DoRequestWithPath(method, path string, obj interface{}) (*DetectedApp, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *DetectedApp
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceDetectedApp) DoRequest(method string, obj interface{}) (*DetectedApp, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceDetectedApp) GetWithPath(path string) (*DetectedApp, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceDetectedApp) Get() (*DetectedApp, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceDetectedApp) PostWithPath(path string) (*DetectedApp, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceDetectedApp) Post() (*DetectedApp, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for DetectedApp collection with addtional path
func (s *ServiceCollectionDetectedApp) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionDetectedApp) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for DetectedApp
func (s *ServiceCollectionDetectedApp) DoRequestWithPath(method, path string, obj interface{}) (*DetectedApp, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *DetectedApp
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionDetectedApp) DoRequest(method string, obj interface{}) (*DetectedApp, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for DetectedApp collection
func (s *ServiceCollectionDetectedApp) DoPagingNext(res *http.Response) ([]DetectedApp, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []DetectedApp
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for DetectedApp collection
func (s *ServiceCollectionDetectedApp) DoPagingWithPath(method, path string, obj interface{}) ([]DetectedApp, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionDetectedApp) DoPaging(method string, obj interface{}) ([]DetectedApp, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionDetectedApp) GetWithPath(path string) ([]DetectedApp, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionDetectedApp) Get() ([]DetectedApp, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionDetectedApp) PostWithPath(path string, obj interface{}) (*DetectedApp, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionDetectedApp) Post(obj interface{}) (*DetectedApp, error) {
	return s.PostWithPath("", obj)
}

// Extensions returns service endpoint for CollectionExtension
func (s *ServiceDevice) Extensions() *ServiceCollectionExtension {
	ss := &ServiceCollectionExtension{ServiceBase: s.ServiceBase}
	ss.baseURL += "/extensions"
	return ss
}

// MemberOf returns service endpoint for CollectionDirectoryObject
func (s *ServiceDevice) MemberOf() *ServiceCollectionDirectoryObject {
	ss := &ServiceCollectionDirectoryObject{ServiceBase: s.ServiceBase}
	ss.baseURL += "/memberOf"
	return ss
}

// RegisteredOwners returns service endpoint for CollectionDirectoryObject
func (s *ServiceDevice) RegisteredOwners() *ServiceCollectionDirectoryObject {
	ss := &ServiceCollectionDirectoryObject{ServiceBase: s.ServiceBase}
	ss.baseURL += "/registeredOwners"
	return ss
}

// RegisteredUsers returns service endpoint for CollectionDirectoryObject
func (s *ServiceDevice) RegisteredUsers() *ServiceCollectionDirectoryObject {
	ss := &ServiceCollectionDirectoryObject{ServiceBase: s.ServiceBase}
	ss.baseURL += "/registeredUsers"
	return ss
}

// TransitiveMemberOf returns service endpoint for CollectionDirectoryObject
func (s *ServiceDevice) TransitiveMemberOf() *ServiceCollectionDirectoryObject {
	ss := &ServiceCollectionDirectoryObject{ServiceBase: s.ServiceBase}
	ss.baseURL += "/transitiveMemberOf"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for Device
func (s *ServiceDevice) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceDevice) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for Device
func (s *ServiceDevice) DoRequestWithPath(method, path string, obj interface{}) (*Device, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *Device
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceDevice) DoRequest(method string, obj interface{}) (*Device, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceDevice) GetWithPath(path string) (*Device, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceDevice) Get() (*Device, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceDevice) PostWithPath(path string) (*Device, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceDevice) Post() (*Device, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for Device collection with addtional path
func (s *ServiceCollectionDevice) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionDevice) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for Device
func (s *ServiceCollectionDevice) DoRequestWithPath(method, path string, obj interface{}) (*Device, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *Device
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionDevice) DoRequest(method string, obj interface{}) (*Device, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for Device collection
func (s *ServiceCollectionDevice) DoPagingNext(res *http.Response) ([]Device, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []Device
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for Device collection
func (s *ServiceCollectionDevice) DoPagingWithPath(method, path string, obj interface{}) ([]Device, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionDevice) DoPaging(method string, obj interface{}) ([]Device, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionDevice) GetWithPath(path string) ([]Device, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionDevice) Get() ([]Device, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionDevice) PostWithPath(path string, obj interface{}) (*Device, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionDevice) Post(obj interface{}) (*Device, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for DeviceAndAppManagementRoleAssignment collection with addtional path
func (s *ServiceCollectionDeviceAndAppManagementRoleAssignment) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionDeviceAndAppManagementRoleAssignment) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for DeviceAndAppManagementRoleAssignment
func (s *ServiceCollectionDeviceAndAppManagementRoleAssignment) DoRequestWithPath(method, path string, obj interface{}) (*DeviceAndAppManagementRoleAssignment, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *DeviceAndAppManagementRoleAssignment
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionDeviceAndAppManagementRoleAssignment) DoRequest(method string, obj interface{}) (*DeviceAndAppManagementRoleAssignment, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for DeviceAndAppManagementRoleAssignment collection
func (s *ServiceCollectionDeviceAndAppManagementRoleAssignment) DoPagingNext(res *http.Response) ([]DeviceAndAppManagementRoleAssignment, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []DeviceAndAppManagementRoleAssignment
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for DeviceAndAppManagementRoleAssignment collection
func (s *ServiceCollectionDeviceAndAppManagementRoleAssignment) DoPagingWithPath(method, path string, obj interface{}) ([]DeviceAndAppManagementRoleAssignment, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionDeviceAndAppManagementRoleAssignment) DoPaging(method string, obj interface{}) ([]DeviceAndAppManagementRoleAssignment, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionDeviceAndAppManagementRoleAssignment) GetWithPath(path string) ([]DeviceAndAppManagementRoleAssignment, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionDeviceAndAppManagementRoleAssignment) Get() ([]DeviceAndAppManagementRoleAssignment, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionDeviceAndAppManagementRoleAssignment) PostWithPath(path string, obj interface{}) (*DeviceAndAppManagementRoleAssignment, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionDeviceAndAppManagementRoleAssignment) Post(obj interface{}) (*DeviceAndAppManagementRoleAssignment, error) {
	return s.PostWithPath("", obj)
}

// AndroidManagedAppProtections returns service endpoint for CollectionAndroidManagedAppProtection
func (s *ServiceDeviceAppManagement) AndroidManagedAppProtections() *ServiceCollectionAndroidManagedAppProtection {
	ss := &ServiceCollectionAndroidManagedAppProtection{ServiceBase: s.ServiceBase}
	ss.baseURL += "/androidManagedAppProtections"
	return ss
}

// DefaultManagedAppProtections returns service endpoint for CollectionDefaultManagedAppProtection
func (s *ServiceDeviceAppManagement) DefaultManagedAppProtections() *ServiceCollectionDefaultManagedAppProtection {
	ss := &ServiceCollectionDefaultManagedAppProtection{ServiceBase: s.ServiceBase}
	ss.baseURL += "/defaultManagedAppProtections"
	return ss
}

// IosManagedAppProtections returns service endpoint for CollectionIosManagedAppProtection
func (s *ServiceDeviceAppManagement) IosManagedAppProtections() *ServiceCollectionIosManagedAppProtection {
	ss := &ServiceCollectionIosManagedAppProtection{ServiceBase: s.ServiceBase}
	ss.baseURL += "/iosManagedAppProtections"
	return ss
}

// ManagedAppPolicies returns service endpoint for CollectionManagedAppPolicy
func (s *ServiceDeviceAppManagement) ManagedAppPolicies() *ServiceCollectionManagedAppPolicy {
	ss := &ServiceCollectionManagedAppPolicy{ServiceBase: s.ServiceBase}
	ss.baseURL += "/managedAppPolicies"
	return ss
}

// ManagedAppRegistrations returns service endpoint for CollectionManagedAppRegistration
func (s *ServiceDeviceAppManagement) ManagedAppRegistrations() *ServiceCollectionManagedAppRegistration {
	ss := &ServiceCollectionManagedAppRegistration{ServiceBase: s.ServiceBase}
	ss.baseURL += "/managedAppRegistrations"
	return ss
}

// ManagedAppStatuses returns service endpoint for CollectionManagedAppStatus
func (s *ServiceDeviceAppManagement) ManagedAppStatuses() *ServiceCollectionManagedAppStatus {
	ss := &ServiceCollectionManagedAppStatus{ServiceBase: s.ServiceBase}
	ss.baseURL += "/managedAppStatuses"
	return ss
}

// ManagedEBooks returns service endpoint for CollectionManagedEBook
func (s *ServiceDeviceAppManagement) ManagedEBooks() *ServiceCollectionManagedEBook {
	ss := &ServiceCollectionManagedEBook{ServiceBase: s.ServiceBase}
	ss.baseURL += "/managedEBooks"
	return ss
}

// MdmWindowsInformationProtectionPolicies returns service endpoint for CollectionMdmWindowsInformationProtectionPolicy
func (s *ServiceDeviceAppManagement) MdmWindowsInformationProtectionPolicies() *ServiceCollectionMdmWindowsInformationProtectionPolicy {
	ss := &ServiceCollectionMdmWindowsInformationProtectionPolicy{ServiceBase: s.ServiceBase}
	ss.baseURL += "/mdmWindowsInformationProtectionPolicies"
	return ss
}

// MobileAppCategories returns service endpoint for CollectionMobileAppCategory
func (s *ServiceDeviceAppManagement) MobileAppCategories() *ServiceCollectionMobileAppCategory {
	ss := &ServiceCollectionMobileAppCategory{ServiceBase: s.ServiceBase}
	ss.baseURL += "/mobileAppCategories"
	return ss
}

// MobileAppConfigurations returns service endpoint for CollectionManagedDeviceMobileAppConfiguration
func (s *ServiceDeviceAppManagement) MobileAppConfigurations() *ServiceCollectionManagedDeviceMobileAppConfiguration {
	ss := &ServiceCollectionManagedDeviceMobileAppConfiguration{ServiceBase: s.ServiceBase}
	ss.baseURL += "/mobileAppConfigurations"
	return ss
}

// MobileApps returns service endpoint for CollectionMobileApp
func (s *ServiceDeviceAppManagement) MobileApps() *ServiceCollectionMobileApp {
	ss := &ServiceCollectionMobileApp{ServiceBase: s.ServiceBase}
	ss.baseURL += "/mobileApps"
	return ss
}

// TargetedManagedAppConfigurations returns service endpoint for CollectionTargetedManagedAppConfiguration
func (s *ServiceDeviceAppManagement) TargetedManagedAppConfigurations() *ServiceCollectionTargetedManagedAppConfiguration {
	ss := &ServiceCollectionTargetedManagedAppConfiguration{ServiceBase: s.ServiceBase}
	ss.baseURL += "/targetedManagedAppConfigurations"
	return ss
}

// VppTokens returns service endpoint for CollectionVppToken
func (s *ServiceDeviceAppManagement) VppTokens() *ServiceCollectionVppToken {
	ss := &ServiceCollectionVppToken{ServiceBase: s.ServiceBase}
	ss.baseURL += "/vppTokens"
	return ss
}

// WindowsInformationProtectionPolicies returns service endpoint for CollectionWindowsInformationProtectionPolicy
func (s *ServiceDeviceAppManagement) WindowsInformationProtectionPolicies() *ServiceCollectionWindowsInformationProtectionPolicy {
	ss := &ServiceCollectionWindowsInformationProtectionPolicy{ServiceBase: s.ServiceBase}
	ss.baseURL += "/windowsInformationProtectionPolicies"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for DeviceAppManagement
func (s *ServiceDeviceAppManagement) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceDeviceAppManagement) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for DeviceAppManagement
func (s *ServiceDeviceAppManagement) DoRequestWithPath(method, path string, obj interface{}) (*DeviceAppManagement, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *DeviceAppManagement
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceDeviceAppManagement) DoRequest(method string, obj interface{}) (*DeviceAppManagement, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceDeviceAppManagement) GetWithPath(path string) (*DeviceAppManagement, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceDeviceAppManagement) Get() (*DeviceAppManagement, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceDeviceAppManagement) PostWithPath(path string) (*DeviceAppManagement, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceDeviceAppManagement) Post() (*DeviceAppManagement, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for DeviceCategory
func (s *ServiceDeviceCategory) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceDeviceCategory) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for DeviceCategory
func (s *ServiceDeviceCategory) DoRequestWithPath(method, path string, obj interface{}) (*DeviceCategory, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *DeviceCategory
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceDeviceCategory) DoRequest(method string, obj interface{}) (*DeviceCategory, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceDeviceCategory) GetWithPath(path string) (*DeviceCategory, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceDeviceCategory) Get() (*DeviceCategory, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceDeviceCategory) PostWithPath(path string) (*DeviceCategory, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceDeviceCategory) Post() (*DeviceCategory, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for DeviceCategory collection with addtional path
func (s *ServiceCollectionDeviceCategory) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionDeviceCategory) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for DeviceCategory
func (s *ServiceCollectionDeviceCategory) DoRequestWithPath(method, path string, obj interface{}) (*DeviceCategory, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *DeviceCategory
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionDeviceCategory) DoRequest(method string, obj interface{}) (*DeviceCategory, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for DeviceCategory collection
func (s *ServiceCollectionDeviceCategory) DoPagingNext(res *http.Response) ([]DeviceCategory, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []DeviceCategory
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for DeviceCategory collection
func (s *ServiceCollectionDeviceCategory) DoPagingWithPath(method, path string, obj interface{}) ([]DeviceCategory, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionDeviceCategory) DoPaging(method string, obj interface{}) ([]DeviceCategory, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionDeviceCategory) GetWithPath(path string) ([]DeviceCategory, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionDeviceCategory) Get() ([]DeviceCategory, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionDeviceCategory) PostWithPath(path string, obj interface{}) (*DeviceCategory, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionDeviceCategory) Post(obj interface{}) (*DeviceCategory, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for DeviceComplianceActionItem collection with addtional path
func (s *ServiceCollectionDeviceComplianceActionItem) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionDeviceComplianceActionItem) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for DeviceComplianceActionItem
func (s *ServiceCollectionDeviceComplianceActionItem) DoRequestWithPath(method, path string, obj interface{}) (*DeviceComplianceActionItem, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *DeviceComplianceActionItem
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionDeviceComplianceActionItem) DoRequest(method string, obj interface{}) (*DeviceComplianceActionItem, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for DeviceComplianceActionItem collection
func (s *ServiceCollectionDeviceComplianceActionItem) DoPagingNext(res *http.Response) ([]DeviceComplianceActionItem, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []DeviceComplianceActionItem
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for DeviceComplianceActionItem collection
func (s *ServiceCollectionDeviceComplianceActionItem) DoPagingWithPath(method, path string, obj interface{}) ([]DeviceComplianceActionItem, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionDeviceComplianceActionItem) DoPaging(method string, obj interface{}) ([]DeviceComplianceActionItem, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionDeviceComplianceActionItem) GetWithPath(path string) ([]DeviceComplianceActionItem, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionDeviceComplianceActionItem) Get() ([]DeviceComplianceActionItem, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionDeviceComplianceActionItem) PostWithPath(path string, obj interface{}) (*DeviceComplianceActionItem, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionDeviceComplianceActionItem) Post(obj interface{}) (*DeviceComplianceActionItem, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for DeviceComplianceDeviceOverview
func (s *ServiceDeviceComplianceDeviceOverview) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceDeviceComplianceDeviceOverview) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for DeviceComplianceDeviceOverview
func (s *ServiceDeviceComplianceDeviceOverview) DoRequestWithPath(method, path string, obj interface{}) (*DeviceComplianceDeviceOverview, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *DeviceComplianceDeviceOverview
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceDeviceComplianceDeviceOverview) DoRequest(method string, obj interface{}) (*DeviceComplianceDeviceOverview, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceDeviceComplianceDeviceOverview) GetWithPath(path string) (*DeviceComplianceDeviceOverview, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceDeviceComplianceDeviceOverview) Get() (*DeviceComplianceDeviceOverview, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceDeviceComplianceDeviceOverview) PostWithPath(path string) (*DeviceComplianceDeviceOverview, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceDeviceComplianceDeviceOverview) Post() (*DeviceComplianceDeviceOverview, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for DeviceComplianceDeviceStatus collection with addtional path
func (s *ServiceCollectionDeviceComplianceDeviceStatus) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionDeviceComplianceDeviceStatus) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for DeviceComplianceDeviceStatus
func (s *ServiceCollectionDeviceComplianceDeviceStatus) DoRequestWithPath(method, path string, obj interface{}) (*DeviceComplianceDeviceStatus, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *DeviceComplianceDeviceStatus
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionDeviceComplianceDeviceStatus) DoRequest(method string, obj interface{}) (*DeviceComplianceDeviceStatus, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for DeviceComplianceDeviceStatus collection
func (s *ServiceCollectionDeviceComplianceDeviceStatus) DoPagingNext(res *http.Response) ([]DeviceComplianceDeviceStatus, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []DeviceComplianceDeviceStatus
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for DeviceComplianceDeviceStatus collection
func (s *ServiceCollectionDeviceComplianceDeviceStatus) DoPagingWithPath(method, path string, obj interface{}) ([]DeviceComplianceDeviceStatus, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionDeviceComplianceDeviceStatus) DoPaging(method string, obj interface{}) ([]DeviceComplianceDeviceStatus, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionDeviceComplianceDeviceStatus) GetWithPath(path string) ([]DeviceComplianceDeviceStatus, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionDeviceComplianceDeviceStatus) Get() ([]DeviceComplianceDeviceStatus, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionDeviceComplianceDeviceStatus) PostWithPath(path string, obj interface{}) (*DeviceComplianceDeviceStatus, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionDeviceComplianceDeviceStatus) Post(obj interface{}) (*DeviceComplianceDeviceStatus, error) {
	return s.PostWithPath("", obj)
}

// Assignments returns service endpoint for CollectionDeviceCompliancePolicyAssignment
func (s *ServiceDeviceCompliancePolicy) Assignments() *ServiceCollectionDeviceCompliancePolicyAssignment {
	ss := &ServiceCollectionDeviceCompliancePolicyAssignment{ServiceBase: s.ServiceBase}
	ss.baseURL += "/assignments"
	return ss
}

// DeviceSettingStateSummaries returns service endpoint for CollectionSettingStateDeviceSummary
func (s *ServiceDeviceCompliancePolicy) DeviceSettingStateSummaries() *ServiceCollectionSettingStateDeviceSummary {
	ss := &ServiceCollectionSettingStateDeviceSummary{ServiceBase: s.ServiceBase}
	ss.baseURL += "/deviceSettingStateSummaries"
	return ss
}

// DeviceStatusOverview returns service endpoint for DeviceComplianceDeviceOverview
func (s *ServiceDeviceCompliancePolicy) DeviceStatusOverview() *ServiceDeviceComplianceDeviceOverview {
	ss := &ServiceDeviceComplianceDeviceOverview{ServiceBase: s.ServiceBase}
	ss.baseURL += "/deviceStatusOverview"
	return ss
}

// DeviceStatuses returns service endpoint for CollectionDeviceComplianceDeviceStatus
func (s *ServiceDeviceCompliancePolicy) DeviceStatuses() *ServiceCollectionDeviceComplianceDeviceStatus {
	ss := &ServiceCollectionDeviceComplianceDeviceStatus{ServiceBase: s.ServiceBase}
	ss.baseURL += "/deviceStatuses"
	return ss
}

// ScheduledActionsForRule returns service endpoint for CollectionDeviceComplianceScheduledActionForRule
func (s *ServiceDeviceCompliancePolicy) ScheduledActionsForRule() *ServiceCollectionDeviceComplianceScheduledActionForRule {
	ss := &ServiceCollectionDeviceComplianceScheduledActionForRule{ServiceBase: s.ServiceBase}
	ss.baseURL += "/scheduledActionsForRule"
	return ss
}

// UserStatusOverview returns service endpoint for DeviceComplianceUserOverview
func (s *ServiceDeviceCompliancePolicy) UserStatusOverview() *ServiceDeviceComplianceUserOverview {
	ss := &ServiceDeviceComplianceUserOverview{ServiceBase: s.ServiceBase}
	ss.baseURL += "/userStatusOverview"
	return ss
}

// UserStatuses returns service endpoint for CollectionDeviceComplianceUserStatus
func (s *ServiceDeviceCompliancePolicy) UserStatuses() *ServiceCollectionDeviceComplianceUserStatus {
	ss := &ServiceCollectionDeviceComplianceUserStatus{ServiceBase: s.ServiceBase}
	ss.baseURL += "/userStatuses"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for DeviceCompliancePolicy
func (s *ServiceDeviceCompliancePolicy) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceDeviceCompliancePolicy) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for DeviceCompliancePolicy
func (s *ServiceDeviceCompliancePolicy) DoRequestWithPath(method, path string, obj interface{}) (*DeviceCompliancePolicy, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *DeviceCompliancePolicy
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceDeviceCompliancePolicy) DoRequest(method string, obj interface{}) (*DeviceCompliancePolicy, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceDeviceCompliancePolicy) GetWithPath(path string) (*DeviceCompliancePolicy, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceDeviceCompliancePolicy) Get() (*DeviceCompliancePolicy, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceDeviceCompliancePolicy) PostWithPath(path string) (*DeviceCompliancePolicy, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceDeviceCompliancePolicy) Post() (*DeviceCompliancePolicy, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for DeviceCompliancePolicy collection with addtional path
func (s *ServiceCollectionDeviceCompliancePolicy) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionDeviceCompliancePolicy) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for DeviceCompliancePolicy
func (s *ServiceCollectionDeviceCompliancePolicy) DoRequestWithPath(method, path string, obj interface{}) (*DeviceCompliancePolicy, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *DeviceCompliancePolicy
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionDeviceCompliancePolicy) DoRequest(method string, obj interface{}) (*DeviceCompliancePolicy, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for DeviceCompliancePolicy collection
func (s *ServiceCollectionDeviceCompliancePolicy) DoPagingNext(res *http.Response) ([]DeviceCompliancePolicy, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []DeviceCompliancePolicy
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for DeviceCompliancePolicy collection
func (s *ServiceCollectionDeviceCompliancePolicy) DoPagingWithPath(method, path string, obj interface{}) ([]DeviceCompliancePolicy, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionDeviceCompliancePolicy) DoPaging(method string, obj interface{}) ([]DeviceCompliancePolicy, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionDeviceCompliancePolicy) GetWithPath(path string) ([]DeviceCompliancePolicy, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionDeviceCompliancePolicy) Get() ([]DeviceCompliancePolicy, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionDeviceCompliancePolicy) PostWithPath(path string, obj interface{}) (*DeviceCompliancePolicy, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionDeviceCompliancePolicy) Post(obj interface{}) (*DeviceCompliancePolicy, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for DeviceCompliancePolicyAssignment collection with addtional path
func (s *ServiceCollectionDeviceCompliancePolicyAssignment) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionDeviceCompliancePolicyAssignment) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for DeviceCompliancePolicyAssignment
func (s *ServiceCollectionDeviceCompliancePolicyAssignment) DoRequestWithPath(method, path string, obj interface{}) (*DeviceCompliancePolicyAssignment, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *DeviceCompliancePolicyAssignment
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionDeviceCompliancePolicyAssignment) DoRequest(method string, obj interface{}) (*DeviceCompliancePolicyAssignment, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for DeviceCompliancePolicyAssignment collection
func (s *ServiceCollectionDeviceCompliancePolicyAssignment) DoPagingNext(res *http.Response) ([]DeviceCompliancePolicyAssignment, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []DeviceCompliancePolicyAssignment
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for DeviceCompliancePolicyAssignment collection
func (s *ServiceCollectionDeviceCompliancePolicyAssignment) DoPagingWithPath(method, path string, obj interface{}) ([]DeviceCompliancePolicyAssignment, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionDeviceCompliancePolicyAssignment) DoPaging(method string, obj interface{}) ([]DeviceCompliancePolicyAssignment, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionDeviceCompliancePolicyAssignment) GetWithPath(path string) ([]DeviceCompliancePolicyAssignment, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionDeviceCompliancePolicyAssignment) Get() ([]DeviceCompliancePolicyAssignment, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionDeviceCompliancePolicyAssignment) PostWithPath(path string, obj interface{}) (*DeviceCompliancePolicyAssignment, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionDeviceCompliancePolicyAssignment) Post(obj interface{}) (*DeviceCompliancePolicyAssignment, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for DeviceCompliancePolicyDeviceStateSummary
func (s *ServiceDeviceCompliancePolicyDeviceStateSummary) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceDeviceCompliancePolicyDeviceStateSummary) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for DeviceCompliancePolicyDeviceStateSummary
func (s *ServiceDeviceCompliancePolicyDeviceStateSummary) DoRequestWithPath(method, path string, obj interface{}) (*DeviceCompliancePolicyDeviceStateSummary, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *DeviceCompliancePolicyDeviceStateSummary
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceDeviceCompliancePolicyDeviceStateSummary) DoRequest(method string, obj interface{}) (*DeviceCompliancePolicyDeviceStateSummary, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceDeviceCompliancePolicyDeviceStateSummary) GetWithPath(path string) (*DeviceCompliancePolicyDeviceStateSummary, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceDeviceCompliancePolicyDeviceStateSummary) Get() (*DeviceCompliancePolicyDeviceStateSummary, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceDeviceCompliancePolicyDeviceStateSummary) PostWithPath(path string) (*DeviceCompliancePolicyDeviceStateSummary, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceDeviceCompliancePolicyDeviceStateSummary) Post() (*DeviceCompliancePolicyDeviceStateSummary, error) {
	return s.PostWithPath("")
}

// DeviceComplianceSettingStates returns service endpoint for CollectionDeviceComplianceSettingState
func (s *ServiceDeviceCompliancePolicySettingStateSummary) DeviceComplianceSettingStates() *ServiceCollectionDeviceComplianceSettingState {
	ss := &ServiceCollectionDeviceComplianceSettingState{ServiceBase: s.ServiceBase}
	ss.baseURL += "/deviceComplianceSettingStates"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for DeviceCompliancePolicySettingStateSummary
func (s *ServiceDeviceCompliancePolicySettingStateSummary) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceDeviceCompliancePolicySettingStateSummary) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for DeviceCompliancePolicySettingStateSummary
func (s *ServiceDeviceCompliancePolicySettingStateSummary) DoRequestWithPath(method, path string, obj interface{}) (*DeviceCompliancePolicySettingStateSummary, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *DeviceCompliancePolicySettingStateSummary
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceDeviceCompliancePolicySettingStateSummary) DoRequest(method string, obj interface{}) (*DeviceCompliancePolicySettingStateSummary, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceDeviceCompliancePolicySettingStateSummary) GetWithPath(path string) (*DeviceCompliancePolicySettingStateSummary, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceDeviceCompliancePolicySettingStateSummary) Get() (*DeviceCompliancePolicySettingStateSummary, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceDeviceCompliancePolicySettingStateSummary) PostWithPath(path string) (*DeviceCompliancePolicySettingStateSummary, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceDeviceCompliancePolicySettingStateSummary) Post() (*DeviceCompliancePolicySettingStateSummary, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for DeviceCompliancePolicySettingStateSummary collection with addtional path
func (s *ServiceCollectionDeviceCompliancePolicySettingStateSummary) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionDeviceCompliancePolicySettingStateSummary) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for DeviceCompliancePolicySettingStateSummary
func (s *ServiceCollectionDeviceCompliancePolicySettingStateSummary) DoRequestWithPath(method, path string, obj interface{}) (*DeviceCompliancePolicySettingStateSummary, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *DeviceCompliancePolicySettingStateSummary
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionDeviceCompliancePolicySettingStateSummary) DoRequest(method string, obj interface{}) (*DeviceCompliancePolicySettingStateSummary, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for DeviceCompliancePolicySettingStateSummary collection
func (s *ServiceCollectionDeviceCompliancePolicySettingStateSummary) DoPagingNext(res *http.Response) ([]DeviceCompliancePolicySettingStateSummary, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []DeviceCompliancePolicySettingStateSummary
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for DeviceCompliancePolicySettingStateSummary collection
func (s *ServiceCollectionDeviceCompliancePolicySettingStateSummary) DoPagingWithPath(method, path string, obj interface{}) ([]DeviceCompliancePolicySettingStateSummary, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionDeviceCompliancePolicySettingStateSummary) DoPaging(method string, obj interface{}) ([]DeviceCompliancePolicySettingStateSummary, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionDeviceCompliancePolicySettingStateSummary) GetWithPath(path string) ([]DeviceCompliancePolicySettingStateSummary, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionDeviceCompliancePolicySettingStateSummary) Get() ([]DeviceCompliancePolicySettingStateSummary, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionDeviceCompliancePolicySettingStateSummary) PostWithPath(path string, obj interface{}) (*DeviceCompliancePolicySettingStateSummary, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionDeviceCompliancePolicySettingStateSummary) Post(obj interface{}) (*DeviceCompliancePolicySettingStateSummary, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for DeviceCompliancePolicyState collection with addtional path
func (s *ServiceCollectionDeviceCompliancePolicyState) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionDeviceCompliancePolicyState) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for DeviceCompliancePolicyState
func (s *ServiceCollectionDeviceCompliancePolicyState) DoRequestWithPath(method, path string, obj interface{}) (*DeviceCompliancePolicyState, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *DeviceCompliancePolicyState
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionDeviceCompliancePolicyState) DoRequest(method string, obj interface{}) (*DeviceCompliancePolicyState, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for DeviceCompliancePolicyState collection
func (s *ServiceCollectionDeviceCompliancePolicyState) DoPagingNext(res *http.Response) ([]DeviceCompliancePolicyState, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []DeviceCompliancePolicyState
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for DeviceCompliancePolicyState collection
func (s *ServiceCollectionDeviceCompliancePolicyState) DoPagingWithPath(method, path string, obj interface{}) ([]DeviceCompliancePolicyState, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionDeviceCompliancePolicyState) DoPaging(method string, obj interface{}) ([]DeviceCompliancePolicyState, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionDeviceCompliancePolicyState) GetWithPath(path string) ([]DeviceCompliancePolicyState, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionDeviceCompliancePolicyState) Get() ([]DeviceCompliancePolicyState, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionDeviceCompliancePolicyState) PostWithPath(path string, obj interface{}) (*DeviceCompliancePolicyState, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionDeviceCompliancePolicyState) Post(obj interface{}) (*DeviceCompliancePolicyState, error) {
	return s.PostWithPath("", obj)
}

// ScheduledActionConfigurations returns service endpoint for CollectionDeviceComplianceActionItem
func (s *ServiceDeviceComplianceScheduledActionForRule) ScheduledActionConfigurations() *ServiceCollectionDeviceComplianceActionItem {
	ss := &ServiceCollectionDeviceComplianceActionItem{ServiceBase: s.ServiceBase}
	ss.baseURL += "/scheduledActionConfigurations"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for DeviceComplianceScheduledActionForRule
func (s *ServiceDeviceComplianceScheduledActionForRule) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceDeviceComplianceScheduledActionForRule) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for DeviceComplianceScheduledActionForRule
func (s *ServiceDeviceComplianceScheduledActionForRule) DoRequestWithPath(method, path string, obj interface{}) (*DeviceComplianceScheduledActionForRule, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *DeviceComplianceScheduledActionForRule
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceDeviceComplianceScheduledActionForRule) DoRequest(method string, obj interface{}) (*DeviceComplianceScheduledActionForRule, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceDeviceComplianceScheduledActionForRule) GetWithPath(path string) (*DeviceComplianceScheduledActionForRule, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceDeviceComplianceScheduledActionForRule) Get() (*DeviceComplianceScheduledActionForRule, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceDeviceComplianceScheduledActionForRule) PostWithPath(path string) (*DeviceComplianceScheduledActionForRule, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceDeviceComplianceScheduledActionForRule) Post() (*DeviceComplianceScheduledActionForRule, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for DeviceComplianceScheduledActionForRule collection with addtional path
func (s *ServiceCollectionDeviceComplianceScheduledActionForRule) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionDeviceComplianceScheduledActionForRule) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for DeviceComplianceScheduledActionForRule
func (s *ServiceCollectionDeviceComplianceScheduledActionForRule) DoRequestWithPath(method, path string, obj interface{}) (*DeviceComplianceScheduledActionForRule, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *DeviceComplianceScheduledActionForRule
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionDeviceComplianceScheduledActionForRule) DoRequest(method string, obj interface{}) (*DeviceComplianceScheduledActionForRule, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for DeviceComplianceScheduledActionForRule collection
func (s *ServiceCollectionDeviceComplianceScheduledActionForRule) DoPagingNext(res *http.Response) ([]DeviceComplianceScheduledActionForRule, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []DeviceComplianceScheduledActionForRule
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for DeviceComplianceScheduledActionForRule collection
func (s *ServiceCollectionDeviceComplianceScheduledActionForRule) DoPagingWithPath(method, path string, obj interface{}) ([]DeviceComplianceScheduledActionForRule, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionDeviceComplianceScheduledActionForRule) DoPaging(method string, obj interface{}) ([]DeviceComplianceScheduledActionForRule, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionDeviceComplianceScheduledActionForRule) GetWithPath(path string) ([]DeviceComplianceScheduledActionForRule, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionDeviceComplianceScheduledActionForRule) Get() ([]DeviceComplianceScheduledActionForRule, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionDeviceComplianceScheduledActionForRule) PostWithPath(path string, obj interface{}) (*DeviceComplianceScheduledActionForRule, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionDeviceComplianceScheduledActionForRule) Post(obj interface{}) (*DeviceComplianceScheduledActionForRule, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for DeviceComplianceSettingState collection with addtional path
func (s *ServiceCollectionDeviceComplianceSettingState) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionDeviceComplianceSettingState) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for DeviceComplianceSettingState
func (s *ServiceCollectionDeviceComplianceSettingState) DoRequestWithPath(method, path string, obj interface{}) (*DeviceComplianceSettingState, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *DeviceComplianceSettingState
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionDeviceComplianceSettingState) DoRequest(method string, obj interface{}) (*DeviceComplianceSettingState, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for DeviceComplianceSettingState collection
func (s *ServiceCollectionDeviceComplianceSettingState) DoPagingNext(res *http.Response) ([]DeviceComplianceSettingState, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []DeviceComplianceSettingState
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for DeviceComplianceSettingState collection
func (s *ServiceCollectionDeviceComplianceSettingState) DoPagingWithPath(method, path string, obj interface{}) ([]DeviceComplianceSettingState, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionDeviceComplianceSettingState) DoPaging(method string, obj interface{}) ([]DeviceComplianceSettingState, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionDeviceComplianceSettingState) GetWithPath(path string) ([]DeviceComplianceSettingState, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionDeviceComplianceSettingState) Get() ([]DeviceComplianceSettingState, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionDeviceComplianceSettingState) PostWithPath(path string, obj interface{}) (*DeviceComplianceSettingState, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionDeviceComplianceSettingState) Post(obj interface{}) (*DeviceComplianceSettingState, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for DeviceComplianceUserOverview
func (s *ServiceDeviceComplianceUserOverview) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceDeviceComplianceUserOverview) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for DeviceComplianceUserOverview
func (s *ServiceDeviceComplianceUserOverview) DoRequestWithPath(method, path string, obj interface{}) (*DeviceComplianceUserOverview, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *DeviceComplianceUserOverview
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceDeviceComplianceUserOverview) DoRequest(method string, obj interface{}) (*DeviceComplianceUserOverview, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceDeviceComplianceUserOverview) GetWithPath(path string) (*DeviceComplianceUserOverview, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceDeviceComplianceUserOverview) Get() (*DeviceComplianceUserOverview, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceDeviceComplianceUserOverview) PostWithPath(path string) (*DeviceComplianceUserOverview, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceDeviceComplianceUserOverview) Post() (*DeviceComplianceUserOverview, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for DeviceComplianceUserStatus collection with addtional path
func (s *ServiceCollectionDeviceComplianceUserStatus) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionDeviceComplianceUserStatus) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for DeviceComplianceUserStatus
func (s *ServiceCollectionDeviceComplianceUserStatus) DoRequestWithPath(method, path string, obj interface{}) (*DeviceComplianceUserStatus, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *DeviceComplianceUserStatus
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionDeviceComplianceUserStatus) DoRequest(method string, obj interface{}) (*DeviceComplianceUserStatus, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for DeviceComplianceUserStatus collection
func (s *ServiceCollectionDeviceComplianceUserStatus) DoPagingNext(res *http.Response) ([]DeviceComplianceUserStatus, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []DeviceComplianceUserStatus
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for DeviceComplianceUserStatus collection
func (s *ServiceCollectionDeviceComplianceUserStatus) DoPagingWithPath(method, path string, obj interface{}) ([]DeviceComplianceUserStatus, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionDeviceComplianceUserStatus) DoPaging(method string, obj interface{}) ([]DeviceComplianceUserStatus, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionDeviceComplianceUserStatus) GetWithPath(path string) ([]DeviceComplianceUserStatus, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionDeviceComplianceUserStatus) Get() ([]DeviceComplianceUserStatus, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionDeviceComplianceUserStatus) PostWithPath(path string, obj interface{}) (*DeviceComplianceUserStatus, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionDeviceComplianceUserStatus) Post(obj interface{}) (*DeviceComplianceUserStatus, error) {
	return s.PostWithPath("", obj)
}

// Assignments returns service endpoint for CollectionDeviceConfigurationAssignment
func (s *ServiceDeviceConfiguration) Assignments() *ServiceCollectionDeviceConfigurationAssignment {
	ss := &ServiceCollectionDeviceConfigurationAssignment{ServiceBase: s.ServiceBase}
	ss.baseURL += "/assignments"
	return ss
}

// DeviceSettingStateSummaries returns service endpoint for CollectionSettingStateDeviceSummary
func (s *ServiceDeviceConfiguration) DeviceSettingStateSummaries() *ServiceCollectionSettingStateDeviceSummary {
	ss := &ServiceCollectionSettingStateDeviceSummary{ServiceBase: s.ServiceBase}
	ss.baseURL += "/deviceSettingStateSummaries"
	return ss
}

// DeviceStatusOverview returns service endpoint for DeviceConfigurationDeviceOverview
func (s *ServiceDeviceConfiguration) DeviceStatusOverview() *ServiceDeviceConfigurationDeviceOverview {
	ss := &ServiceDeviceConfigurationDeviceOverview{ServiceBase: s.ServiceBase}
	ss.baseURL += "/deviceStatusOverview"
	return ss
}

// DeviceStatuses returns service endpoint for CollectionDeviceConfigurationDeviceStatus
func (s *ServiceDeviceConfiguration) DeviceStatuses() *ServiceCollectionDeviceConfigurationDeviceStatus {
	ss := &ServiceCollectionDeviceConfigurationDeviceStatus{ServiceBase: s.ServiceBase}
	ss.baseURL += "/deviceStatuses"
	return ss
}

// UserStatusOverview returns service endpoint for DeviceConfigurationUserOverview
func (s *ServiceDeviceConfiguration) UserStatusOverview() *ServiceDeviceConfigurationUserOverview {
	ss := &ServiceDeviceConfigurationUserOverview{ServiceBase: s.ServiceBase}
	ss.baseURL += "/userStatusOverview"
	return ss
}

// UserStatuses returns service endpoint for CollectionDeviceConfigurationUserStatus
func (s *ServiceDeviceConfiguration) UserStatuses() *ServiceCollectionDeviceConfigurationUserStatus {
	ss := &ServiceCollectionDeviceConfigurationUserStatus{ServiceBase: s.ServiceBase}
	ss.baseURL += "/userStatuses"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for DeviceConfiguration
func (s *ServiceDeviceConfiguration) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceDeviceConfiguration) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for DeviceConfiguration
func (s *ServiceDeviceConfiguration) DoRequestWithPath(method, path string, obj interface{}) (*DeviceConfiguration, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *DeviceConfiguration
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceDeviceConfiguration) DoRequest(method string, obj interface{}) (*DeviceConfiguration, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceDeviceConfiguration) GetWithPath(path string) (*DeviceConfiguration, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceDeviceConfiguration) Get() (*DeviceConfiguration, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceDeviceConfiguration) PostWithPath(path string) (*DeviceConfiguration, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceDeviceConfiguration) Post() (*DeviceConfiguration, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for DeviceConfiguration collection with addtional path
func (s *ServiceCollectionDeviceConfiguration) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionDeviceConfiguration) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for DeviceConfiguration
func (s *ServiceCollectionDeviceConfiguration) DoRequestWithPath(method, path string, obj interface{}) (*DeviceConfiguration, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *DeviceConfiguration
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionDeviceConfiguration) DoRequest(method string, obj interface{}) (*DeviceConfiguration, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for DeviceConfiguration collection
func (s *ServiceCollectionDeviceConfiguration) DoPagingNext(res *http.Response) ([]DeviceConfiguration, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []DeviceConfiguration
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for DeviceConfiguration collection
func (s *ServiceCollectionDeviceConfiguration) DoPagingWithPath(method, path string, obj interface{}) ([]DeviceConfiguration, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionDeviceConfiguration) DoPaging(method string, obj interface{}) ([]DeviceConfiguration, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionDeviceConfiguration) GetWithPath(path string) ([]DeviceConfiguration, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionDeviceConfiguration) Get() ([]DeviceConfiguration, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionDeviceConfiguration) PostWithPath(path string, obj interface{}) (*DeviceConfiguration, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionDeviceConfiguration) Post(obj interface{}) (*DeviceConfiguration, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for DeviceConfigurationAssignment collection with addtional path
func (s *ServiceCollectionDeviceConfigurationAssignment) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionDeviceConfigurationAssignment) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for DeviceConfigurationAssignment
func (s *ServiceCollectionDeviceConfigurationAssignment) DoRequestWithPath(method, path string, obj interface{}) (*DeviceConfigurationAssignment, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *DeviceConfigurationAssignment
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionDeviceConfigurationAssignment) DoRequest(method string, obj interface{}) (*DeviceConfigurationAssignment, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for DeviceConfigurationAssignment collection
func (s *ServiceCollectionDeviceConfigurationAssignment) DoPagingNext(res *http.Response) ([]DeviceConfigurationAssignment, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []DeviceConfigurationAssignment
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for DeviceConfigurationAssignment collection
func (s *ServiceCollectionDeviceConfigurationAssignment) DoPagingWithPath(method, path string, obj interface{}) ([]DeviceConfigurationAssignment, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionDeviceConfigurationAssignment) DoPaging(method string, obj interface{}) ([]DeviceConfigurationAssignment, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionDeviceConfigurationAssignment) GetWithPath(path string) ([]DeviceConfigurationAssignment, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionDeviceConfigurationAssignment) Get() ([]DeviceConfigurationAssignment, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionDeviceConfigurationAssignment) PostWithPath(path string, obj interface{}) (*DeviceConfigurationAssignment, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionDeviceConfigurationAssignment) Post(obj interface{}) (*DeviceConfigurationAssignment, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for DeviceConfigurationDeviceOverview
func (s *ServiceDeviceConfigurationDeviceOverview) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceDeviceConfigurationDeviceOverview) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for DeviceConfigurationDeviceOverview
func (s *ServiceDeviceConfigurationDeviceOverview) DoRequestWithPath(method, path string, obj interface{}) (*DeviceConfigurationDeviceOverview, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *DeviceConfigurationDeviceOverview
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceDeviceConfigurationDeviceOverview) DoRequest(method string, obj interface{}) (*DeviceConfigurationDeviceOverview, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceDeviceConfigurationDeviceOverview) GetWithPath(path string) (*DeviceConfigurationDeviceOverview, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceDeviceConfigurationDeviceOverview) Get() (*DeviceConfigurationDeviceOverview, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceDeviceConfigurationDeviceOverview) PostWithPath(path string) (*DeviceConfigurationDeviceOverview, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceDeviceConfigurationDeviceOverview) Post() (*DeviceConfigurationDeviceOverview, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for DeviceConfigurationDeviceStateSummary
func (s *ServiceDeviceConfigurationDeviceStateSummary) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceDeviceConfigurationDeviceStateSummary) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for DeviceConfigurationDeviceStateSummary
func (s *ServiceDeviceConfigurationDeviceStateSummary) DoRequestWithPath(method, path string, obj interface{}) (*DeviceConfigurationDeviceStateSummary, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *DeviceConfigurationDeviceStateSummary
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceDeviceConfigurationDeviceStateSummary) DoRequest(method string, obj interface{}) (*DeviceConfigurationDeviceStateSummary, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceDeviceConfigurationDeviceStateSummary) GetWithPath(path string) (*DeviceConfigurationDeviceStateSummary, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceDeviceConfigurationDeviceStateSummary) Get() (*DeviceConfigurationDeviceStateSummary, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceDeviceConfigurationDeviceStateSummary) PostWithPath(path string) (*DeviceConfigurationDeviceStateSummary, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceDeviceConfigurationDeviceStateSummary) Post() (*DeviceConfigurationDeviceStateSummary, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for DeviceConfigurationDeviceStatus collection with addtional path
func (s *ServiceCollectionDeviceConfigurationDeviceStatus) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionDeviceConfigurationDeviceStatus) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for DeviceConfigurationDeviceStatus
func (s *ServiceCollectionDeviceConfigurationDeviceStatus) DoRequestWithPath(method, path string, obj interface{}) (*DeviceConfigurationDeviceStatus, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *DeviceConfigurationDeviceStatus
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionDeviceConfigurationDeviceStatus) DoRequest(method string, obj interface{}) (*DeviceConfigurationDeviceStatus, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for DeviceConfigurationDeviceStatus collection
func (s *ServiceCollectionDeviceConfigurationDeviceStatus) DoPagingNext(res *http.Response) ([]DeviceConfigurationDeviceStatus, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []DeviceConfigurationDeviceStatus
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for DeviceConfigurationDeviceStatus collection
func (s *ServiceCollectionDeviceConfigurationDeviceStatus) DoPagingWithPath(method, path string, obj interface{}) ([]DeviceConfigurationDeviceStatus, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionDeviceConfigurationDeviceStatus) DoPaging(method string, obj interface{}) ([]DeviceConfigurationDeviceStatus, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionDeviceConfigurationDeviceStatus) GetWithPath(path string) ([]DeviceConfigurationDeviceStatus, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionDeviceConfigurationDeviceStatus) Get() ([]DeviceConfigurationDeviceStatus, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionDeviceConfigurationDeviceStatus) PostWithPath(path string, obj interface{}) (*DeviceConfigurationDeviceStatus, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionDeviceConfigurationDeviceStatus) Post(obj interface{}) (*DeviceConfigurationDeviceStatus, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for DeviceConfigurationState collection with addtional path
func (s *ServiceCollectionDeviceConfigurationState) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionDeviceConfigurationState) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for DeviceConfigurationState
func (s *ServiceCollectionDeviceConfigurationState) DoRequestWithPath(method, path string, obj interface{}) (*DeviceConfigurationState, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *DeviceConfigurationState
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionDeviceConfigurationState) DoRequest(method string, obj interface{}) (*DeviceConfigurationState, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for DeviceConfigurationState collection
func (s *ServiceCollectionDeviceConfigurationState) DoPagingNext(res *http.Response) ([]DeviceConfigurationState, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []DeviceConfigurationState
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for DeviceConfigurationState collection
func (s *ServiceCollectionDeviceConfigurationState) DoPagingWithPath(method, path string, obj interface{}) ([]DeviceConfigurationState, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionDeviceConfigurationState) DoPaging(method string, obj interface{}) ([]DeviceConfigurationState, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionDeviceConfigurationState) GetWithPath(path string) ([]DeviceConfigurationState, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionDeviceConfigurationState) Get() ([]DeviceConfigurationState, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionDeviceConfigurationState) PostWithPath(path string, obj interface{}) (*DeviceConfigurationState, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionDeviceConfigurationState) Post(obj interface{}) (*DeviceConfigurationState, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for DeviceConfigurationUserOverview
func (s *ServiceDeviceConfigurationUserOverview) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceDeviceConfigurationUserOverview) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for DeviceConfigurationUserOverview
func (s *ServiceDeviceConfigurationUserOverview) DoRequestWithPath(method, path string, obj interface{}) (*DeviceConfigurationUserOverview, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *DeviceConfigurationUserOverview
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceDeviceConfigurationUserOverview) DoRequest(method string, obj interface{}) (*DeviceConfigurationUserOverview, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceDeviceConfigurationUserOverview) GetWithPath(path string) (*DeviceConfigurationUserOverview, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceDeviceConfigurationUserOverview) Get() (*DeviceConfigurationUserOverview, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceDeviceConfigurationUserOverview) PostWithPath(path string) (*DeviceConfigurationUserOverview, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceDeviceConfigurationUserOverview) Post() (*DeviceConfigurationUserOverview, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for DeviceConfigurationUserStatus collection with addtional path
func (s *ServiceCollectionDeviceConfigurationUserStatus) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionDeviceConfigurationUserStatus) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for DeviceConfigurationUserStatus
func (s *ServiceCollectionDeviceConfigurationUserStatus) DoRequestWithPath(method, path string, obj interface{}) (*DeviceConfigurationUserStatus, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *DeviceConfigurationUserStatus
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionDeviceConfigurationUserStatus) DoRequest(method string, obj interface{}) (*DeviceConfigurationUserStatus, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for DeviceConfigurationUserStatus collection
func (s *ServiceCollectionDeviceConfigurationUserStatus) DoPagingNext(res *http.Response) ([]DeviceConfigurationUserStatus, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []DeviceConfigurationUserStatus
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for DeviceConfigurationUserStatus collection
func (s *ServiceCollectionDeviceConfigurationUserStatus) DoPagingWithPath(method, path string, obj interface{}) ([]DeviceConfigurationUserStatus, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionDeviceConfigurationUserStatus) DoPaging(method string, obj interface{}) ([]DeviceConfigurationUserStatus, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionDeviceConfigurationUserStatus) GetWithPath(path string) ([]DeviceConfigurationUserStatus, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionDeviceConfigurationUserStatus) Get() ([]DeviceConfigurationUserStatus, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionDeviceConfigurationUserStatus) PostWithPath(path string, obj interface{}) (*DeviceConfigurationUserStatus, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionDeviceConfigurationUserStatus) Post(obj interface{}) (*DeviceConfigurationUserStatus, error) {
	return s.PostWithPath("", obj)
}

// Assignments returns service endpoint for CollectionEnrollmentConfigurationAssignment
func (s *ServiceDeviceEnrollmentConfiguration) Assignments() *ServiceCollectionEnrollmentConfigurationAssignment {
	ss := &ServiceCollectionEnrollmentConfigurationAssignment{ServiceBase: s.ServiceBase}
	ss.baseURL += "/assignments"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for DeviceEnrollmentConfiguration
func (s *ServiceDeviceEnrollmentConfiguration) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceDeviceEnrollmentConfiguration) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for DeviceEnrollmentConfiguration
func (s *ServiceDeviceEnrollmentConfiguration) DoRequestWithPath(method, path string, obj interface{}) (*DeviceEnrollmentConfiguration, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *DeviceEnrollmentConfiguration
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceDeviceEnrollmentConfiguration) DoRequest(method string, obj interface{}) (*DeviceEnrollmentConfiguration, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceDeviceEnrollmentConfiguration) GetWithPath(path string) (*DeviceEnrollmentConfiguration, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceDeviceEnrollmentConfiguration) Get() (*DeviceEnrollmentConfiguration, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceDeviceEnrollmentConfiguration) PostWithPath(path string) (*DeviceEnrollmentConfiguration, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceDeviceEnrollmentConfiguration) Post() (*DeviceEnrollmentConfiguration, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for DeviceEnrollmentConfiguration collection with addtional path
func (s *ServiceCollectionDeviceEnrollmentConfiguration) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionDeviceEnrollmentConfiguration) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for DeviceEnrollmentConfiguration
func (s *ServiceCollectionDeviceEnrollmentConfiguration) DoRequestWithPath(method, path string, obj interface{}) (*DeviceEnrollmentConfiguration, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *DeviceEnrollmentConfiguration
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionDeviceEnrollmentConfiguration) DoRequest(method string, obj interface{}) (*DeviceEnrollmentConfiguration, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for DeviceEnrollmentConfiguration collection
func (s *ServiceCollectionDeviceEnrollmentConfiguration) DoPagingNext(res *http.Response) ([]DeviceEnrollmentConfiguration, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []DeviceEnrollmentConfiguration
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for DeviceEnrollmentConfiguration collection
func (s *ServiceCollectionDeviceEnrollmentConfiguration) DoPagingWithPath(method, path string, obj interface{}) ([]DeviceEnrollmentConfiguration, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionDeviceEnrollmentConfiguration) DoPaging(method string, obj interface{}) ([]DeviceEnrollmentConfiguration, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionDeviceEnrollmentConfiguration) GetWithPath(path string) ([]DeviceEnrollmentConfiguration, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionDeviceEnrollmentConfiguration) Get() ([]DeviceEnrollmentConfiguration, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionDeviceEnrollmentConfiguration) PostWithPath(path string, obj interface{}) (*DeviceEnrollmentConfiguration, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionDeviceEnrollmentConfiguration) Post(obj interface{}) (*DeviceEnrollmentConfiguration, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for DeviceInstallState collection with addtional path
func (s *ServiceCollectionDeviceInstallState) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionDeviceInstallState) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for DeviceInstallState
func (s *ServiceCollectionDeviceInstallState) DoRequestWithPath(method, path string, obj interface{}) (*DeviceInstallState, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *DeviceInstallState
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionDeviceInstallState) DoRequest(method string, obj interface{}) (*DeviceInstallState, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for DeviceInstallState collection
func (s *ServiceCollectionDeviceInstallState) DoPagingNext(res *http.Response) ([]DeviceInstallState, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []DeviceInstallState
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for DeviceInstallState collection
func (s *ServiceCollectionDeviceInstallState) DoPagingWithPath(method, path string, obj interface{}) ([]DeviceInstallState, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionDeviceInstallState) DoPaging(method string, obj interface{}) ([]DeviceInstallState, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionDeviceInstallState) GetWithPath(path string) ([]DeviceInstallState, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionDeviceInstallState) Get() ([]DeviceInstallState, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionDeviceInstallState) PostWithPath(path string, obj interface{}) (*DeviceInstallState, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionDeviceInstallState) Post(obj interface{}) (*DeviceInstallState, error) {
	return s.PostWithPath("", obj)
}

// ApplePushNotificationCertificate returns service endpoint for ApplePushNotificationCertificate
func (s *ServiceDeviceManagement) ApplePushNotificationCertificate() *ServiceApplePushNotificationCertificate {
	ss := &ServiceApplePushNotificationCertificate{ServiceBase: s.ServiceBase}
	ss.baseURL += "/applePushNotificationCertificate"
	return ss
}

// ConditionalAccessSettings returns service endpoint for OnPremisesConditionalAccessSettings
func (s *ServiceDeviceManagement) ConditionalAccessSettings() *ServiceOnPremisesConditionalAccessSettings {
	ss := &ServiceOnPremisesConditionalAccessSettings{ServiceBase: s.ServiceBase}
	ss.baseURL += "/conditionalAccessSettings"
	return ss
}

// DetectedApps returns service endpoint for CollectionDetectedApp
func (s *ServiceDeviceManagement) DetectedApps() *ServiceCollectionDetectedApp {
	ss := &ServiceCollectionDetectedApp{ServiceBase: s.ServiceBase}
	ss.baseURL += "/detectedApps"
	return ss
}

// DeviceCategories returns service endpoint for CollectionDeviceCategory
func (s *ServiceDeviceManagement) DeviceCategories() *ServiceCollectionDeviceCategory {
	ss := &ServiceCollectionDeviceCategory{ServiceBase: s.ServiceBase}
	ss.baseURL += "/deviceCategories"
	return ss
}

// DeviceCompliancePolicies returns service endpoint for CollectionDeviceCompliancePolicy
func (s *ServiceDeviceManagement) DeviceCompliancePolicies() *ServiceCollectionDeviceCompliancePolicy {
	ss := &ServiceCollectionDeviceCompliancePolicy{ServiceBase: s.ServiceBase}
	ss.baseURL += "/deviceCompliancePolicies"
	return ss
}

// DeviceCompliancePolicyDeviceStateSummary returns service endpoint for DeviceCompliancePolicyDeviceStateSummary
func (s *ServiceDeviceManagement) DeviceCompliancePolicyDeviceStateSummary() *ServiceDeviceCompliancePolicyDeviceStateSummary {
	ss := &ServiceDeviceCompliancePolicyDeviceStateSummary{ServiceBase: s.ServiceBase}
	ss.baseURL += "/deviceCompliancePolicyDeviceStateSummary"
	return ss
}

// DeviceCompliancePolicySettingStateSummaries returns service endpoint for CollectionDeviceCompliancePolicySettingStateSummary
func (s *ServiceDeviceManagement) DeviceCompliancePolicySettingStateSummaries() *ServiceCollectionDeviceCompliancePolicySettingStateSummary {
	ss := &ServiceCollectionDeviceCompliancePolicySettingStateSummary{ServiceBase: s.ServiceBase}
	ss.baseURL += "/deviceCompliancePolicySettingStateSummaries"
	return ss
}

// DeviceConfigurationDeviceStateSummaries returns service endpoint for DeviceConfigurationDeviceStateSummary
func (s *ServiceDeviceManagement) DeviceConfigurationDeviceStateSummaries() *ServiceDeviceConfigurationDeviceStateSummary {
	ss := &ServiceDeviceConfigurationDeviceStateSummary{ServiceBase: s.ServiceBase}
	ss.baseURL += "/deviceConfigurationDeviceStateSummaries"
	return ss
}

// DeviceConfigurations returns service endpoint for CollectionDeviceConfiguration
func (s *ServiceDeviceManagement) DeviceConfigurations() *ServiceCollectionDeviceConfiguration {
	ss := &ServiceCollectionDeviceConfiguration{ServiceBase: s.ServiceBase}
	ss.baseURL += "/deviceConfigurations"
	return ss
}

// DeviceEnrollmentConfigurations returns service endpoint for CollectionDeviceEnrollmentConfiguration
func (s *ServiceDeviceManagement) DeviceEnrollmentConfigurations() *ServiceCollectionDeviceEnrollmentConfiguration {
	ss := &ServiceCollectionDeviceEnrollmentConfiguration{ServiceBase: s.ServiceBase}
	ss.baseURL += "/deviceEnrollmentConfigurations"
	return ss
}

// DeviceManagementPartners returns service endpoint for CollectionDeviceManagementPartner
func (s *ServiceDeviceManagement) DeviceManagementPartners() *ServiceCollectionDeviceManagementPartner {
	ss := &ServiceCollectionDeviceManagementPartner{ServiceBase: s.ServiceBase}
	ss.baseURL += "/deviceManagementPartners"
	return ss
}

// ExchangeConnectors returns service endpoint for CollectionDeviceManagementExchangeConnector
func (s *ServiceDeviceManagement) ExchangeConnectors() *ServiceCollectionDeviceManagementExchangeConnector {
	ss := &ServiceCollectionDeviceManagementExchangeConnector{ServiceBase: s.ServiceBase}
	ss.baseURL += "/exchangeConnectors"
	return ss
}

// IosUpdateStatuses returns service endpoint for CollectionIosUpdateDeviceStatus
func (s *ServiceDeviceManagement) IosUpdateStatuses() *ServiceCollectionIosUpdateDeviceStatus {
	ss := &ServiceCollectionIosUpdateDeviceStatus{ServiceBase: s.ServiceBase}
	ss.baseURL += "/iosUpdateStatuses"
	return ss
}

// ManagedDeviceOverview returns service endpoint for ManagedDeviceOverview
func (s *ServiceDeviceManagement) ManagedDeviceOverview() *ServiceManagedDeviceOverview {
	ss := &ServiceManagedDeviceOverview{ServiceBase: s.ServiceBase}
	ss.baseURL += "/managedDeviceOverview"
	return ss
}

// ManagedDevices returns service endpoint for CollectionManagedDevice
func (s *ServiceDeviceManagement) ManagedDevices() *ServiceCollectionManagedDevice {
	ss := &ServiceCollectionManagedDevice{ServiceBase: s.ServiceBase}
	ss.baseURL += "/managedDevices"
	return ss
}

// MobileThreatDefenseConnectors returns service endpoint for CollectionMobileThreatDefenseConnector
func (s *ServiceDeviceManagement) MobileThreatDefenseConnectors() *ServiceCollectionMobileThreatDefenseConnector {
	ss := &ServiceCollectionMobileThreatDefenseConnector{ServiceBase: s.ServiceBase}
	ss.baseURL += "/mobileThreatDefenseConnectors"
	return ss
}

// NotificationMessageTemplates returns service endpoint for CollectionNotificationMessageTemplate
func (s *ServiceDeviceManagement) NotificationMessageTemplates() *ServiceCollectionNotificationMessageTemplate {
	ss := &ServiceCollectionNotificationMessageTemplate{ServiceBase: s.ServiceBase}
	ss.baseURL += "/notificationMessageTemplates"
	return ss
}

// RemoteAssistancePartners returns service endpoint for CollectionRemoteAssistancePartner
func (s *ServiceDeviceManagement) RemoteAssistancePartners() *ServiceCollectionRemoteAssistancePartner {
	ss := &ServiceCollectionRemoteAssistancePartner{ServiceBase: s.ServiceBase}
	ss.baseURL += "/remoteAssistancePartners"
	return ss
}

// ResourceOperations returns service endpoint for CollectionResourceOperation
func (s *ServiceDeviceManagement) ResourceOperations() *ServiceCollectionResourceOperation {
	ss := &ServiceCollectionResourceOperation{ServiceBase: s.ServiceBase}
	ss.baseURL += "/resourceOperations"
	return ss
}

// RoleAssignments returns service endpoint for CollectionDeviceAndAppManagementRoleAssignment
func (s *ServiceDeviceManagement) RoleAssignments() *ServiceCollectionDeviceAndAppManagementRoleAssignment {
	ss := &ServiceCollectionDeviceAndAppManagementRoleAssignment{ServiceBase: s.ServiceBase}
	ss.baseURL += "/roleAssignments"
	return ss
}

// RoleDefinitions returns service endpoint for CollectionRoleDefinition
func (s *ServiceDeviceManagement) RoleDefinitions() *ServiceCollectionRoleDefinition {
	ss := &ServiceCollectionRoleDefinition{ServiceBase: s.ServiceBase}
	ss.baseURL += "/roleDefinitions"
	return ss
}

// SoftwareUpdateStatusSummary returns service endpoint for SoftwareUpdateStatusSummary
func (s *ServiceDeviceManagement) SoftwareUpdateStatusSummary() *ServiceSoftwareUpdateStatusSummary {
	ss := &ServiceSoftwareUpdateStatusSummary{ServiceBase: s.ServiceBase}
	ss.baseURL += "/softwareUpdateStatusSummary"
	return ss
}

// TelecomExpenseManagementPartners returns service endpoint for CollectionTelecomExpenseManagementPartner
func (s *ServiceDeviceManagement) TelecomExpenseManagementPartners() *ServiceCollectionTelecomExpenseManagementPartner {
	ss := &ServiceCollectionTelecomExpenseManagementPartner{ServiceBase: s.ServiceBase}
	ss.baseURL += "/telecomExpenseManagementPartners"
	return ss
}

// TermsAndConditions returns service endpoint for CollectionTermsAndConditions
func (s *ServiceDeviceManagement) TermsAndConditions() *ServiceCollectionTermsAndConditions {
	ss := &ServiceCollectionTermsAndConditions{ServiceBase: s.ServiceBase}
	ss.baseURL += "/termsAndConditions"
	return ss
}

// TroubleshootingEvents returns service endpoint for CollectionDeviceManagementTroubleshootingEvent
func (s *ServiceDeviceManagement) TroubleshootingEvents() *ServiceCollectionDeviceManagementTroubleshootingEvent {
	ss := &ServiceCollectionDeviceManagementTroubleshootingEvent{ServiceBase: s.ServiceBase}
	ss.baseURL += "/troubleshootingEvents"
	return ss
}

// WindowsInformationProtectionAppLearningSummaries returns service endpoint for CollectionWindowsInformationProtectionAppLearningSummary
func (s *ServiceDeviceManagement) WindowsInformationProtectionAppLearningSummaries() *ServiceCollectionWindowsInformationProtectionAppLearningSummary {
	ss := &ServiceCollectionWindowsInformationProtectionAppLearningSummary{ServiceBase: s.ServiceBase}
	ss.baseURL += "/windowsInformationProtectionAppLearningSummaries"
	return ss
}

// WindowsInformationProtectionNetworkLearningSummaries returns service endpoint for CollectionWindowsInformationProtectionNetworkLearningSummary
func (s *ServiceDeviceManagement) WindowsInformationProtectionNetworkLearningSummaries() *ServiceCollectionWindowsInformationProtectionNetworkLearningSummary {
	ss := &ServiceCollectionWindowsInformationProtectionNetworkLearningSummary{ServiceBase: s.ServiceBase}
	ss.baseURL += "/windowsInformationProtectionNetworkLearningSummaries"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for DeviceManagement
func (s *ServiceDeviceManagement) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceDeviceManagement) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for DeviceManagement
func (s *ServiceDeviceManagement) DoRequestWithPath(method, path string, obj interface{}) (*DeviceManagement, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *DeviceManagement
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceDeviceManagement) DoRequest(method string, obj interface{}) (*DeviceManagement, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceDeviceManagement) GetWithPath(path string) (*DeviceManagement, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceDeviceManagement) Get() (*DeviceManagement, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceDeviceManagement) PostWithPath(path string) (*DeviceManagement, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceDeviceManagement) Post() (*DeviceManagement, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for DeviceManagementExchangeConnector collection with addtional path
func (s *ServiceCollectionDeviceManagementExchangeConnector) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionDeviceManagementExchangeConnector) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for DeviceManagementExchangeConnector
func (s *ServiceCollectionDeviceManagementExchangeConnector) DoRequestWithPath(method, path string, obj interface{}) (*DeviceManagementExchangeConnector, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *DeviceManagementExchangeConnector
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionDeviceManagementExchangeConnector) DoRequest(method string, obj interface{}) (*DeviceManagementExchangeConnector, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for DeviceManagementExchangeConnector collection
func (s *ServiceCollectionDeviceManagementExchangeConnector) DoPagingNext(res *http.Response) ([]DeviceManagementExchangeConnector, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []DeviceManagementExchangeConnector
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for DeviceManagementExchangeConnector collection
func (s *ServiceCollectionDeviceManagementExchangeConnector) DoPagingWithPath(method, path string, obj interface{}) ([]DeviceManagementExchangeConnector, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionDeviceManagementExchangeConnector) DoPaging(method string, obj interface{}) ([]DeviceManagementExchangeConnector, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionDeviceManagementExchangeConnector) GetWithPath(path string) ([]DeviceManagementExchangeConnector, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionDeviceManagementExchangeConnector) Get() ([]DeviceManagementExchangeConnector, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionDeviceManagementExchangeConnector) PostWithPath(path string, obj interface{}) (*DeviceManagementExchangeConnector, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionDeviceManagementExchangeConnector) Post(obj interface{}) (*DeviceManagementExchangeConnector, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for DeviceManagementPartner collection with addtional path
func (s *ServiceCollectionDeviceManagementPartner) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionDeviceManagementPartner) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for DeviceManagementPartner
func (s *ServiceCollectionDeviceManagementPartner) DoRequestWithPath(method, path string, obj interface{}) (*DeviceManagementPartner, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *DeviceManagementPartner
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionDeviceManagementPartner) DoRequest(method string, obj interface{}) (*DeviceManagementPartner, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for DeviceManagementPartner collection
func (s *ServiceCollectionDeviceManagementPartner) DoPagingNext(res *http.Response) ([]DeviceManagementPartner, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []DeviceManagementPartner
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for DeviceManagementPartner collection
func (s *ServiceCollectionDeviceManagementPartner) DoPagingWithPath(method, path string, obj interface{}) ([]DeviceManagementPartner, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionDeviceManagementPartner) DoPaging(method string, obj interface{}) ([]DeviceManagementPartner, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionDeviceManagementPartner) GetWithPath(path string) ([]DeviceManagementPartner, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionDeviceManagementPartner) Get() ([]DeviceManagementPartner, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionDeviceManagementPartner) PostWithPath(path string, obj interface{}) (*DeviceManagementPartner, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionDeviceManagementPartner) Post(obj interface{}) (*DeviceManagementPartner, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for DeviceManagementTroubleshootingEvent collection with addtional path
func (s *ServiceCollectionDeviceManagementTroubleshootingEvent) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionDeviceManagementTroubleshootingEvent) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for DeviceManagementTroubleshootingEvent
func (s *ServiceCollectionDeviceManagementTroubleshootingEvent) DoRequestWithPath(method, path string, obj interface{}) (*DeviceManagementTroubleshootingEvent, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *DeviceManagementTroubleshootingEvent
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionDeviceManagementTroubleshootingEvent) DoRequest(method string, obj interface{}) (*DeviceManagementTroubleshootingEvent, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for DeviceManagementTroubleshootingEvent collection
func (s *ServiceCollectionDeviceManagementTroubleshootingEvent) DoPagingNext(res *http.Response) ([]DeviceManagementTroubleshootingEvent, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []DeviceManagementTroubleshootingEvent
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for DeviceManagementTroubleshootingEvent collection
func (s *ServiceCollectionDeviceManagementTroubleshootingEvent) DoPagingWithPath(method, path string, obj interface{}) ([]DeviceManagementTroubleshootingEvent, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionDeviceManagementTroubleshootingEvent) DoPaging(method string, obj interface{}) ([]DeviceManagementTroubleshootingEvent, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionDeviceManagementTroubleshootingEvent) GetWithPath(path string) ([]DeviceManagementTroubleshootingEvent, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionDeviceManagementTroubleshootingEvent) Get() ([]DeviceManagementTroubleshootingEvent, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionDeviceManagementTroubleshootingEvent) PostWithPath(path string, obj interface{}) (*DeviceManagementTroubleshootingEvent, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionDeviceManagementTroubleshootingEvent) Post(obj interface{}) (*DeviceManagementTroubleshootingEvent, error) {
	return s.PostWithPath("", obj)
}

// DeletedItems returns service endpoint for CollectionDirectoryObject
func (s *ServiceDirectory) DeletedItems() *ServiceCollectionDirectoryObject {
	ss := &ServiceCollectionDirectoryObject{ServiceBase: s.ServiceBase}
	ss.baseURL += "/deletedItems"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for Directory
func (s *ServiceDirectory) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceDirectory) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for Directory
func (s *ServiceDirectory) DoRequestWithPath(method, path string, obj interface{}) (*Directory, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *Directory
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceDirectory) DoRequest(method string, obj interface{}) (*Directory, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceDirectory) GetWithPath(path string) (*Directory, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceDirectory) Get() (*Directory, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceDirectory) PostWithPath(path string) (*Directory, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceDirectory) Post() (*Directory, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for DirectoryAudit collection with addtional path
func (s *ServiceCollectionDirectoryAudit) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionDirectoryAudit) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for DirectoryAudit
func (s *ServiceCollectionDirectoryAudit) DoRequestWithPath(method, path string, obj interface{}) (*DirectoryAudit, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *DirectoryAudit
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionDirectoryAudit) DoRequest(method string, obj interface{}) (*DirectoryAudit, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for DirectoryAudit collection
func (s *ServiceCollectionDirectoryAudit) DoPagingNext(res *http.Response) ([]DirectoryAudit, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []DirectoryAudit
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for DirectoryAudit collection
func (s *ServiceCollectionDirectoryAudit) DoPagingWithPath(method, path string, obj interface{}) ([]DirectoryAudit, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionDirectoryAudit) DoPaging(method string, obj interface{}) ([]DirectoryAudit, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionDirectoryAudit) GetWithPath(path string) ([]DirectoryAudit, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionDirectoryAudit) Get() ([]DirectoryAudit, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionDirectoryAudit) PostWithPath(path string, obj interface{}) (*DirectoryAudit, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionDirectoryAudit) Post(obj interface{}) (*DirectoryAudit, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for DirectoryObject
func (s *ServiceDirectoryObject) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceDirectoryObject) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for DirectoryObject
func (s *ServiceDirectoryObject) DoRequestWithPath(method, path string, obj interface{}) (*DirectoryObject, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *DirectoryObject
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceDirectoryObject) DoRequest(method string, obj interface{}) (*DirectoryObject, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceDirectoryObject) GetWithPath(path string) (*DirectoryObject, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceDirectoryObject) Get() (*DirectoryObject, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceDirectoryObject) PostWithPath(path string) (*DirectoryObject, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceDirectoryObject) Post() (*DirectoryObject, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for DirectoryObject collection with addtional path
func (s *ServiceCollectionDirectoryObject) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionDirectoryObject) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for DirectoryObject
func (s *ServiceCollectionDirectoryObject) DoRequestWithPath(method, path string, obj interface{}) (*DirectoryObject, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *DirectoryObject
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionDirectoryObject) DoRequest(method string, obj interface{}) (*DirectoryObject, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for DirectoryObject collection
func (s *ServiceCollectionDirectoryObject) DoPagingNext(res *http.Response) ([]DirectoryObject, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []DirectoryObject
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for DirectoryObject collection
func (s *ServiceCollectionDirectoryObject) DoPagingWithPath(method, path string, obj interface{}) ([]DirectoryObject, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionDirectoryObject) DoPaging(method string, obj interface{}) ([]DirectoryObject, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionDirectoryObject) GetWithPath(path string) ([]DirectoryObject, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionDirectoryObject) Get() ([]DirectoryObject, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionDirectoryObject) PostWithPath(path string, obj interface{}) (*DirectoryObject, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionDirectoryObject) Post(obj interface{}) (*DirectoryObject, error) {
	return s.PostWithPath("", obj)
}

// Members returns service endpoint for CollectionDirectoryObject
func (s *ServiceDirectoryRole) Members() *ServiceCollectionDirectoryObject {
	ss := &ServiceCollectionDirectoryObject{ServiceBase: s.ServiceBase}
	ss.baseURL += "/members"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for DirectoryRole
func (s *ServiceDirectoryRole) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceDirectoryRole) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for DirectoryRole
func (s *ServiceDirectoryRole) DoRequestWithPath(method, path string, obj interface{}) (*DirectoryRole, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *DirectoryRole
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceDirectoryRole) DoRequest(method string, obj interface{}) (*DirectoryRole, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceDirectoryRole) GetWithPath(path string) (*DirectoryRole, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceDirectoryRole) Get() (*DirectoryRole, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceDirectoryRole) PostWithPath(path string) (*DirectoryRole, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceDirectoryRole) Post() (*DirectoryRole, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for DirectoryRole collection with addtional path
func (s *ServiceCollectionDirectoryRole) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionDirectoryRole) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for DirectoryRole
func (s *ServiceCollectionDirectoryRole) DoRequestWithPath(method, path string, obj interface{}) (*DirectoryRole, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *DirectoryRole
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionDirectoryRole) DoRequest(method string, obj interface{}) (*DirectoryRole, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for DirectoryRole collection
func (s *ServiceCollectionDirectoryRole) DoPagingNext(res *http.Response) ([]DirectoryRole, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []DirectoryRole
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for DirectoryRole collection
func (s *ServiceCollectionDirectoryRole) DoPagingWithPath(method, path string, obj interface{}) ([]DirectoryRole, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionDirectoryRole) DoPaging(method string, obj interface{}) ([]DirectoryRole, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionDirectoryRole) GetWithPath(path string) ([]DirectoryRole, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionDirectoryRole) Get() ([]DirectoryRole, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionDirectoryRole) PostWithPath(path string, obj interface{}) (*DirectoryRole, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionDirectoryRole) Post(obj interface{}) (*DirectoryRole, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for DirectoryRoleTemplate
func (s *ServiceDirectoryRoleTemplate) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceDirectoryRoleTemplate) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for DirectoryRoleTemplate
func (s *ServiceDirectoryRoleTemplate) DoRequestWithPath(method, path string, obj interface{}) (*DirectoryRoleTemplate, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *DirectoryRoleTemplate
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceDirectoryRoleTemplate) DoRequest(method string, obj interface{}) (*DirectoryRoleTemplate, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceDirectoryRoleTemplate) GetWithPath(path string) (*DirectoryRoleTemplate, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceDirectoryRoleTemplate) Get() (*DirectoryRoleTemplate, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceDirectoryRoleTemplate) PostWithPath(path string) (*DirectoryRoleTemplate, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceDirectoryRoleTemplate) Post() (*DirectoryRoleTemplate, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for DirectoryRoleTemplate collection with addtional path
func (s *ServiceCollectionDirectoryRoleTemplate) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionDirectoryRoleTemplate) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for DirectoryRoleTemplate
func (s *ServiceCollectionDirectoryRoleTemplate) DoRequestWithPath(method, path string, obj interface{}) (*DirectoryRoleTemplate, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *DirectoryRoleTemplate
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionDirectoryRoleTemplate) DoRequest(method string, obj interface{}) (*DirectoryRoleTemplate, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for DirectoryRoleTemplate collection
func (s *ServiceCollectionDirectoryRoleTemplate) DoPagingNext(res *http.Response) ([]DirectoryRoleTemplate, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []DirectoryRoleTemplate
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for DirectoryRoleTemplate collection
func (s *ServiceCollectionDirectoryRoleTemplate) DoPagingWithPath(method, path string, obj interface{}) ([]DirectoryRoleTemplate, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionDirectoryRoleTemplate) DoPaging(method string, obj interface{}) ([]DirectoryRoleTemplate, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionDirectoryRoleTemplate) GetWithPath(path string) ([]DirectoryRoleTemplate, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionDirectoryRoleTemplate) Get() ([]DirectoryRoleTemplate, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionDirectoryRoleTemplate) PostWithPath(path string, obj interface{}) (*DirectoryRoleTemplate, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionDirectoryRoleTemplate) Post(obj interface{}) (*DirectoryRoleTemplate, error) {
	return s.PostWithPath("", obj)
}

// DomainNameReferences returns service endpoint for CollectionDirectoryObject
func (s *ServiceDomain) DomainNameReferences() *ServiceCollectionDirectoryObject {
	ss := &ServiceCollectionDirectoryObject{ServiceBase: s.ServiceBase}
	ss.baseURL += "/domainNameReferences"
	return ss
}

// ServiceConfigurationRecords returns service endpoint for CollectionDomainDnsRecord
func (s *ServiceDomain) ServiceConfigurationRecords() *ServiceCollectionDomainDnsRecord {
	ss := &ServiceCollectionDomainDnsRecord{ServiceBase: s.ServiceBase}
	ss.baseURL += "/serviceConfigurationRecords"
	return ss
}

// VerificationDnsRecords returns service endpoint for CollectionDomainDnsRecord
func (s *ServiceDomain) VerificationDnsRecords() *ServiceCollectionDomainDnsRecord {
	ss := &ServiceCollectionDomainDnsRecord{ServiceBase: s.ServiceBase}
	ss.baseURL += "/verificationDnsRecords"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for Domain
func (s *ServiceDomain) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceDomain) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for Domain
func (s *ServiceDomain) DoRequestWithPath(method, path string, obj interface{}) (*Domain, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *Domain
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceDomain) DoRequest(method string, obj interface{}) (*Domain, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceDomain) GetWithPath(path string) (*Domain, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceDomain) Get() (*Domain, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceDomain) PostWithPath(path string) (*Domain, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceDomain) Post() (*Domain, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for Domain collection with addtional path
func (s *ServiceCollectionDomain) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionDomain) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for Domain
func (s *ServiceCollectionDomain) DoRequestWithPath(method, path string, obj interface{}) (*Domain, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *Domain
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionDomain) DoRequest(method string, obj interface{}) (*Domain, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for Domain collection
func (s *ServiceCollectionDomain) DoPagingNext(res *http.Response) ([]Domain, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []Domain
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for Domain collection
func (s *ServiceCollectionDomain) DoPagingWithPath(method, path string, obj interface{}) ([]Domain, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionDomain) DoPaging(method string, obj interface{}) ([]Domain, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionDomain) GetWithPath(path string) ([]Domain, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionDomain) Get() ([]Domain, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionDomain) PostWithPath(path string, obj interface{}) (*Domain, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionDomain) Post(obj interface{}) (*Domain, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for DomainDnsRecord
func (s *ServiceDomainDnsRecord) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceDomainDnsRecord) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for DomainDnsRecord
func (s *ServiceDomainDnsRecord) DoRequestWithPath(method, path string, obj interface{}) (*DomainDnsRecord, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *DomainDnsRecord
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceDomainDnsRecord) DoRequest(method string, obj interface{}) (*DomainDnsRecord, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceDomainDnsRecord) GetWithPath(path string) (*DomainDnsRecord, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceDomainDnsRecord) Get() (*DomainDnsRecord, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceDomainDnsRecord) PostWithPath(path string) (*DomainDnsRecord, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceDomainDnsRecord) Post() (*DomainDnsRecord, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for DomainDnsRecord collection with addtional path
func (s *ServiceCollectionDomainDnsRecord) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionDomainDnsRecord) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for DomainDnsRecord
func (s *ServiceCollectionDomainDnsRecord) DoRequestWithPath(method, path string, obj interface{}) (*DomainDnsRecord, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *DomainDnsRecord
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionDomainDnsRecord) DoRequest(method string, obj interface{}) (*DomainDnsRecord, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for DomainDnsRecord collection
func (s *ServiceCollectionDomainDnsRecord) DoPagingNext(res *http.Response) ([]DomainDnsRecord, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []DomainDnsRecord
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for DomainDnsRecord collection
func (s *ServiceCollectionDomainDnsRecord) DoPagingWithPath(method, path string, obj interface{}) ([]DomainDnsRecord, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionDomainDnsRecord) DoPaging(method string, obj interface{}) ([]DomainDnsRecord, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionDomainDnsRecord) GetWithPath(path string) ([]DomainDnsRecord, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionDomainDnsRecord) Get() ([]DomainDnsRecord, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionDomainDnsRecord) PostWithPath(path string, obj interface{}) (*DomainDnsRecord, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionDomainDnsRecord) Post(obj interface{}) (*DomainDnsRecord, error) {
	return s.PostWithPath("", obj)
}

// Items returns service endpoint for CollectionDriveItem
func (s *ServiceDrive) Items() *ServiceCollectionDriveItem {
	ss := &ServiceCollectionDriveItem{ServiceBase: s.ServiceBase}
	ss.baseURL += "/items"
	return ss
}

// List returns service endpoint for List
func (s *ServiceDrive) List() *ServiceList {
	ss := &ServiceList{ServiceBase: s.ServiceBase}
	ss.baseURL += "/list"
	return ss
}

// Root returns service endpoint for DriveItem
func (s *ServiceDrive) Root() *ServiceDriveItem {
	ss := &ServiceDriveItem{ServiceBase: s.ServiceBase}
	ss.baseURL += "/root"
	return ss
}

// Special returns service endpoint for CollectionDriveItem
func (s *ServiceDrive) Special() *ServiceCollectionDriveItem {
	ss := &ServiceCollectionDriveItem{ServiceBase: s.ServiceBase}
	ss.baseURL += "/special"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for Drive
func (s *ServiceDrive) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceDrive) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for Drive
func (s *ServiceDrive) DoRequestWithPath(method, path string, obj interface{}) (*Drive, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *Drive
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceDrive) DoRequest(method string, obj interface{}) (*Drive, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceDrive) GetWithPath(path string) (*Drive, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceDrive) Get() (*Drive, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceDrive) PostWithPath(path string) (*Drive, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceDrive) Post() (*Drive, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for Drive collection with addtional path
func (s *ServiceCollectionDrive) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionDrive) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for Drive
func (s *ServiceCollectionDrive) DoRequestWithPath(method, path string, obj interface{}) (*Drive, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *Drive
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionDrive) DoRequest(method string, obj interface{}) (*Drive, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for Drive collection
func (s *ServiceCollectionDrive) DoPagingNext(res *http.Response) ([]Drive, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []Drive
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for Drive collection
func (s *ServiceCollectionDrive) DoPagingWithPath(method, path string, obj interface{}) ([]Drive, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionDrive) DoPaging(method string, obj interface{}) ([]Drive, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionDrive) GetWithPath(path string) ([]Drive, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionDrive) Get() ([]Drive, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionDrive) PostWithPath(path string, obj interface{}) (*Drive, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionDrive) Post(obj interface{}) (*Drive, error) {
	return s.PostWithPath("", obj)
}

// Analytics returns service endpoint for ItemAnalytics
func (s *ServiceDriveItem) Analytics() *ServiceItemAnalytics {
	ss := &ServiceItemAnalytics{ServiceBase: s.ServiceBase}
	ss.baseURL += "/analytics"
	return ss
}

// Children returns service endpoint for CollectionDriveItem
func (s *ServiceDriveItem) Children() *ServiceCollectionDriveItem {
	ss := &ServiceCollectionDriveItem{ServiceBase: s.ServiceBase}
	ss.baseURL += "/children"
	return ss
}

// ListItem returns service endpoint for ListItem
func (s *ServiceDriveItem) ListItem() *ServiceListItem {
	ss := &ServiceListItem{ServiceBase: s.ServiceBase}
	ss.baseURL += "/listItem"
	return ss
}

// Permissions returns service endpoint for CollectionPermission
func (s *ServiceDriveItem) Permissions() *ServiceCollectionPermission {
	ss := &ServiceCollectionPermission{ServiceBase: s.ServiceBase}
	ss.baseURL += "/permissions"
	return ss
}

// Subscriptions returns service endpoint for CollectionSubscription
func (s *ServiceDriveItem) Subscriptions() *ServiceCollectionSubscription {
	ss := &ServiceCollectionSubscription{ServiceBase: s.ServiceBase}
	ss.baseURL += "/subscriptions"
	return ss
}

// Thumbnails returns service endpoint for CollectionThumbnailSet
func (s *ServiceDriveItem) Thumbnails() *ServiceCollectionThumbnailSet {
	ss := &ServiceCollectionThumbnailSet{ServiceBase: s.ServiceBase}
	ss.baseURL += "/thumbnails"
	return ss
}

// Versions returns service endpoint for CollectionDriveItemVersion
func (s *ServiceDriveItem) Versions() *ServiceCollectionDriveItemVersion {
	ss := &ServiceCollectionDriveItemVersion{ServiceBase: s.ServiceBase}
	ss.baseURL += "/versions"
	return ss
}

// Workbook returns service endpoint for Workbook
func (s *ServiceDriveItem) Workbook() *ServiceWorkbook {
	ss := &ServiceWorkbook{ServiceBase: s.ServiceBase}
	ss.baseURL += "/workbook"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for DriveItem
func (s *ServiceDriveItem) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceDriveItem) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for DriveItem
func (s *ServiceDriveItem) DoRequestWithPath(method, path string, obj interface{}) (*DriveItem, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *DriveItem
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceDriveItem) DoRequest(method string, obj interface{}) (*DriveItem, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceDriveItem) GetWithPath(path string) (*DriveItem, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceDriveItem) Get() (*DriveItem, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceDriveItem) PostWithPath(path string) (*DriveItem, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceDriveItem) Post() (*DriveItem, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for DriveItem collection with addtional path
func (s *ServiceCollectionDriveItem) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionDriveItem) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for DriveItem
func (s *ServiceCollectionDriveItem) DoRequestWithPath(method, path string, obj interface{}) (*DriveItem, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *DriveItem
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionDriveItem) DoRequest(method string, obj interface{}) (*DriveItem, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for DriveItem collection
func (s *ServiceCollectionDriveItem) DoPagingNext(res *http.Response) ([]DriveItem, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []DriveItem
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for DriveItem collection
func (s *ServiceCollectionDriveItem) DoPagingWithPath(method, path string, obj interface{}) ([]DriveItem, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionDriveItem) DoPaging(method string, obj interface{}) ([]DriveItem, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionDriveItem) GetWithPath(path string) ([]DriveItem, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionDriveItem) Get() ([]DriveItem, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionDriveItem) PostWithPath(path string, obj interface{}) (*DriveItem, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionDriveItem) Post(obj interface{}) (*DriveItem, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for DriveItemVersion collection with addtional path
func (s *ServiceCollectionDriveItemVersion) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionDriveItemVersion) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for DriveItemVersion
func (s *ServiceCollectionDriveItemVersion) DoRequestWithPath(method, path string, obj interface{}) (*DriveItemVersion, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *DriveItemVersion
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionDriveItemVersion) DoRequest(method string, obj interface{}) (*DriveItemVersion, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for DriveItemVersion collection
func (s *ServiceCollectionDriveItemVersion) DoPagingNext(res *http.Response) ([]DriveItemVersion, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []DriveItemVersion
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for DriveItemVersion collection
func (s *ServiceCollectionDriveItemVersion) DoPagingWithPath(method, path string, obj interface{}) ([]DriveItemVersion, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionDriveItemVersion) DoPaging(method string, obj interface{}) ([]DriveItemVersion, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionDriveItemVersion) GetWithPath(path string) ([]DriveItemVersion, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionDriveItemVersion) Get() ([]DriveItemVersion, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionDriveItemVersion) PostWithPath(path string, obj interface{}) (*DriveItemVersion, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionDriveItemVersion) Post(obj interface{}) (*DriveItemVersion, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for EBookInstallSummary
func (s *ServiceEBookInstallSummary) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceEBookInstallSummary) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for EBookInstallSummary
func (s *ServiceEBookInstallSummary) DoRequestWithPath(method, path string, obj interface{}) (*EBookInstallSummary, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *EBookInstallSummary
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceEBookInstallSummary) DoRequest(method string, obj interface{}) (*EBookInstallSummary, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceEBookInstallSummary) GetWithPath(path string) (*EBookInstallSummary, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceEBookInstallSummary) Get() (*EBookInstallSummary, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceEBookInstallSummary) PostWithPath(path string) (*EBookInstallSummary, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceEBookInstallSummary) Post() (*EBookInstallSummary, error) {
	return s.PostWithPath("")
}

// Group returns service endpoint for Group
func (s *ServiceEducationClass) Group() *ServiceGroup {
	ss := &ServiceGroup{ServiceBase: s.ServiceBase}
	ss.baseURL += "/group"
	return ss
}

// Members returns service endpoint for CollectionEducationUser
func (s *ServiceEducationClass) Members() *ServiceCollectionEducationUser {
	ss := &ServiceCollectionEducationUser{ServiceBase: s.ServiceBase}
	ss.baseURL += "/members"
	return ss
}

// Schools returns service endpoint for CollectionEducationSchool
func (s *ServiceEducationClass) Schools() *ServiceCollectionEducationSchool {
	ss := &ServiceCollectionEducationSchool{ServiceBase: s.ServiceBase}
	ss.baseURL += "/schools"
	return ss
}

// Teachers returns service endpoint for CollectionEducationUser
func (s *ServiceEducationClass) Teachers() *ServiceCollectionEducationUser {
	ss := &ServiceCollectionEducationUser{ServiceBase: s.ServiceBase}
	ss.baseURL += "/teachers"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for EducationClass
func (s *ServiceEducationClass) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceEducationClass) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for EducationClass
func (s *ServiceEducationClass) DoRequestWithPath(method, path string, obj interface{}) (*EducationClass, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *EducationClass
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceEducationClass) DoRequest(method string, obj interface{}) (*EducationClass, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceEducationClass) GetWithPath(path string) (*EducationClass, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceEducationClass) Get() (*EducationClass, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceEducationClass) PostWithPath(path string) (*EducationClass, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceEducationClass) Post() (*EducationClass, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for EducationClass collection with addtional path
func (s *ServiceCollectionEducationClass) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionEducationClass) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for EducationClass
func (s *ServiceCollectionEducationClass) DoRequestWithPath(method, path string, obj interface{}) (*EducationClass, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *EducationClass
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionEducationClass) DoRequest(method string, obj interface{}) (*EducationClass, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for EducationClass collection
func (s *ServiceCollectionEducationClass) DoPagingNext(res *http.Response) ([]EducationClass, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []EducationClass
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for EducationClass collection
func (s *ServiceCollectionEducationClass) DoPagingWithPath(method, path string, obj interface{}) ([]EducationClass, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionEducationClass) DoPaging(method string, obj interface{}) ([]EducationClass, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionEducationClass) GetWithPath(path string) ([]EducationClass, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionEducationClass) Get() ([]EducationClass, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionEducationClass) PostWithPath(path string, obj interface{}) (*EducationClass, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionEducationClass) Post(obj interface{}) (*EducationClass, error) {
	return s.PostWithPath("", obj)
}

// Classes returns service endpoint for CollectionEducationClass
func (s *ServiceEducationRoot) Classes() *ServiceCollectionEducationClass {
	ss := &ServiceCollectionEducationClass{ServiceBase: s.ServiceBase}
	ss.baseURL += "/classes"
	return ss
}

// Me returns service endpoint for EducationUser
func (s *ServiceEducationRoot) Me() *ServiceEducationUser {
	ss := &ServiceEducationUser{ServiceBase: s.ServiceBase}
	ss.baseURL += "/me"
	return ss
}

// Schools returns service endpoint for CollectionEducationSchool
func (s *ServiceEducationRoot) Schools() *ServiceCollectionEducationSchool {
	ss := &ServiceCollectionEducationSchool{ServiceBase: s.ServiceBase}
	ss.baseURL += "/schools"
	return ss
}

// Users returns service endpoint for CollectionEducationUser
func (s *ServiceEducationRoot) Users() *ServiceCollectionEducationUser {
	ss := &ServiceCollectionEducationUser{ServiceBase: s.ServiceBase}
	ss.baseURL += "/users"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for EducationRoot
func (s *ServiceEducationRoot) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceEducationRoot) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for EducationRoot
func (s *ServiceEducationRoot) DoRequestWithPath(method, path string, obj interface{}) (*EducationRoot, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *EducationRoot
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceEducationRoot) DoRequest(method string, obj interface{}) (*EducationRoot, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceEducationRoot) GetWithPath(path string) (*EducationRoot, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceEducationRoot) Get() (*EducationRoot, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceEducationRoot) PostWithPath(path string) (*EducationRoot, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceEducationRoot) Post() (*EducationRoot, error) {
	return s.PostWithPath("")
}

// Classes returns service endpoint for CollectionEducationClass
func (s *ServiceEducationSchool) Classes() *ServiceCollectionEducationClass {
	ss := &ServiceCollectionEducationClass{ServiceBase: s.ServiceBase}
	ss.baseURL += "/classes"
	return ss
}

// Users returns service endpoint for CollectionEducationUser
func (s *ServiceEducationSchool) Users() *ServiceCollectionEducationUser {
	ss := &ServiceCollectionEducationUser{ServiceBase: s.ServiceBase}
	ss.baseURL += "/users"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for EducationSchool
func (s *ServiceEducationSchool) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceEducationSchool) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for EducationSchool
func (s *ServiceEducationSchool) DoRequestWithPath(method, path string, obj interface{}) (*EducationSchool, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *EducationSchool
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceEducationSchool) DoRequest(method string, obj interface{}) (*EducationSchool, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceEducationSchool) GetWithPath(path string) (*EducationSchool, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceEducationSchool) Get() (*EducationSchool, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceEducationSchool) PostWithPath(path string) (*EducationSchool, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceEducationSchool) Post() (*EducationSchool, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for EducationSchool collection with addtional path
func (s *ServiceCollectionEducationSchool) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionEducationSchool) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for EducationSchool
func (s *ServiceCollectionEducationSchool) DoRequestWithPath(method, path string, obj interface{}) (*EducationSchool, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *EducationSchool
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionEducationSchool) DoRequest(method string, obj interface{}) (*EducationSchool, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for EducationSchool collection
func (s *ServiceCollectionEducationSchool) DoPagingNext(res *http.Response) ([]EducationSchool, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []EducationSchool
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for EducationSchool collection
func (s *ServiceCollectionEducationSchool) DoPagingWithPath(method, path string, obj interface{}) ([]EducationSchool, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionEducationSchool) DoPaging(method string, obj interface{}) ([]EducationSchool, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionEducationSchool) GetWithPath(path string) ([]EducationSchool, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionEducationSchool) Get() ([]EducationSchool, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionEducationSchool) PostWithPath(path string, obj interface{}) (*EducationSchool, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionEducationSchool) Post(obj interface{}) (*EducationSchool, error) {
	return s.PostWithPath("", obj)
}

// Classes returns service endpoint for CollectionEducationClass
func (s *ServiceEducationUser) Classes() *ServiceCollectionEducationClass {
	ss := &ServiceCollectionEducationClass{ServiceBase: s.ServiceBase}
	ss.baseURL += "/classes"
	return ss
}

// Schools returns service endpoint for CollectionEducationSchool
func (s *ServiceEducationUser) Schools() *ServiceCollectionEducationSchool {
	ss := &ServiceCollectionEducationSchool{ServiceBase: s.ServiceBase}
	ss.baseURL += "/schools"
	return ss
}

// User returns service endpoint for User
func (s *ServiceEducationUser) User() *ServiceUser {
	ss := &ServiceUser{ServiceBase: s.ServiceBase}
	ss.baseURL += "/user"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for EducationUser
func (s *ServiceEducationUser) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceEducationUser) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for EducationUser
func (s *ServiceEducationUser) DoRequestWithPath(method, path string, obj interface{}) (*EducationUser, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *EducationUser
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceEducationUser) DoRequest(method string, obj interface{}) (*EducationUser, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceEducationUser) GetWithPath(path string) (*EducationUser, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceEducationUser) Get() (*EducationUser, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceEducationUser) PostWithPath(path string) (*EducationUser, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceEducationUser) Post() (*EducationUser, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for EducationUser collection with addtional path
func (s *ServiceCollectionEducationUser) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionEducationUser) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for EducationUser
func (s *ServiceCollectionEducationUser) DoRequestWithPath(method, path string, obj interface{}) (*EducationUser, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *EducationUser
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionEducationUser) DoRequest(method string, obj interface{}) (*EducationUser, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for EducationUser collection
func (s *ServiceCollectionEducationUser) DoPagingNext(res *http.Response) ([]EducationUser, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []EducationUser
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for EducationUser collection
func (s *ServiceCollectionEducationUser) DoPagingWithPath(method, path string, obj interface{}) ([]EducationUser, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionEducationUser) DoPaging(method string, obj interface{}) ([]EducationUser, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionEducationUser) GetWithPath(path string) ([]EducationUser, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionEducationUser) Get() ([]EducationUser, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionEducationUser) PostWithPath(path string, obj interface{}) (*EducationUser, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionEducationUser) Post(obj interface{}) (*EducationUser, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for EnrollmentConfigurationAssignment collection with addtional path
func (s *ServiceCollectionEnrollmentConfigurationAssignment) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionEnrollmentConfigurationAssignment) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for EnrollmentConfigurationAssignment
func (s *ServiceCollectionEnrollmentConfigurationAssignment) DoRequestWithPath(method, path string, obj interface{}) (*EnrollmentConfigurationAssignment, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *EnrollmentConfigurationAssignment
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionEnrollmentConfigurationAssignment) DoRequest(method string, obj interface{}) (*EnrollmentConfigurationAssignment, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for EnrollmentConfigurationAssignment collection
func (s *ServiceCollectionEnrollmentConfigurationAssignment) DoPagingNext(res *http.Response) ([]EnrollmentConfigurationAssignment, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []EnrollmentConfigurationAssignment
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for EnrollmentConfigurationAssignment collection
func (s *ServiceCollectionEnrollmentConfigurationAssignment) DoPagingWithPath(method, path string, obj interface{}) ([]EnrollmentConfigurationAssignment, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionEnrollmentConfigurationAssignment) DoPaging(method string, obj interface{}) ([]EnrollmentConfigurationAssignment, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionEnrollmentConfigurationAssignment) GetWithPath(path string) ([]EnrollmentConfigurationAssignment, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionEnrollmentConfigurationAssignment) Get() ([]EnrollmentConfigurationAssignment, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionEnrollmentConfigurationAssignment) PostWithPath(path string, obj interface{}) (*EnrollmentConfigurationAssignment, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionEnrollmentConfigurationAssignment) Post(obj interface{}) (*EnrollmentConfigurationAssignment, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for Entity
func (s *ServiceEntity) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceEntity) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for Entity
func (s *ServiceEntity) DoRequestWithPath(method, path string, obj interface{}) (*Entity, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *Entity
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceEntity) DoRequest(method string, obj interface{}) (*Entity, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceEntity) GetWithPath(path string) (*Entity, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceEntity) Get() (*Entity, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceEntity) PostWithPath(path string) (*Entity, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceEntity) Post() (*Entity, error) {
	return s.PostWithPath("")
}

// Attachments returns service endpoint for CollectionAttachment
func (s *ServiceEvent) Attachments() *ServiceCollectionAttachment {
	ss := &ServiceCollectionAttachment{ServiceBase: s.ServiceBase}
	ss.baseURL += "/attachments"
	return ss
}

// Calendar returns service endpoint for Calendar
func (s *ServiceEvent) Calendar() *ServiceCalendar {
	ss := &ServiceCalendar{ServiceBase: s.ServiceBase}
	ss.baseURL += "/calendar"
	return ss
}

// Extensions returns service endpoint for CollectionExtension
func (s *ServiceEvent) Extensions() *ServiceCollectionExtension {
	ss := &ServiceCollectionExtension{ServiceBase: s.ServiceBase}
	ss.baseURL += "/extensions"
	return ss
}

// Instances returns service endpoint for CollectionEvent
func (s *ServiceEvent) Instances() *ServiceCollectionEvent {
	ss := &ServiceCollectionEvent{ServiceBase: s.ServiceBase}
	ss.baseURL += "/instances"
	return ss
}

// MultiValueExtendedProperties returns service endpoint for CollectionMultiValueLegacyExtendedProperty
func (s *ServiceEvent) MultiValueExtendedProperties() *ServiceCollectionMultiValueLegacyExtendedProperty {
	ss := &ServiceCollectionMultiValueLegacyExtendedProperty{ServiceBase: s.ServiceBase}
	ss.baseURL += "/multiValueExtendedProperties"
	return ss
}

// SingleValueExtendedProperties returns service endpoint for CollectionSingleValueLegacyExtendedProperty
func (s *ServiceEvent) SingleValueExtendedProperties() *ServiceCollectionSingleValueLegacyExtendedProperty {
	ss := &ServiceCollectionSingleValueLegacyExtendedProperty{ServiceBase: s.ServiceBase}
	ss.baseURL += "/singleValueExtendedProperties"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for Event
func (s *ServiceEvent) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceEvent) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for Event
func (s *ServiceEvent) DoRequestWithPath(method, path string, obj interface{}) (*Event, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *Event
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceEvent) DoRequest(method string, obj interface{}) (*Event, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceEvent) GetWithPath(path string) (*Event, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceEvent) Get() (*Event, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceEvent) PostWithPath(path string) (*Event, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceEvent) Post() (*Event, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for Event collection with addtional path
func (s *ServiceCollectionEvent) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionEvent) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for Event
func (s *ServiceCollectionEvent) DoRequestWithPath(method, path string, obj interface{}) (*Event, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *Event
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionEvent) DoRequest(method string, obj interface{}) (*Event, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for Event collection
func (s *ServiceCollectionEvent) DoPagingNext(res *http.Response) ([]Event, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []Event
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for Event collection
func (s *ServiceCollectionEvent) DoPagingWithPath(method, path string, obj interface{}) ([]Event, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionEvent) DoPaging(method string, obj interface{}) ([]Event, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionEvent) GetWithPath(path string) ([]Event, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionEvent) Get() ([]Event, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionEvent) PostWithPath(path string, obj interface{}) (*Event, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionEvent) Post(obj interface{}) (*Event, error) {
	return s.PostWithPath("", obj)
}

// Event returns service endpoint for Event
func (s *ServiceEventMessage) Event() *ServiceEvent {
	ss := &ServiceEvent{ServiceBase: s.ServiceBase}
	ss.baseURL += "/event"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for EventMessage
func (s *ServiceEventMessage) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceEventMessage) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for EventMessage
func (s *ServiceEventMessage) DoRequestWithPath(method, path string, obj interface{}) (*EventMessage, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *EventMessage
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceEventMessage) DoRequest(method string, obj interface{}) (*EventMessage, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceEventMessage) GetWithPath(path string) (*EventMessage, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceEventMessage) Get() (*EventMessage, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceEventMessage) PostWithPath(path string) (*EventMessage, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceEventMessage) Post() (*EventMessage, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for Extension collection with addtional path
func (s *ServiceCollectionExtension) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionExtension) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for Extension
func (s *ServiceCollectionExtension) DoRequestWithPath(method, path string, obj interface{}) (*Extension, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *Extension
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionExtension) DoRequest(method string, obj interface{}) (*Extension, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for Extension collection
func (s *ServiceCollectionExtension) DoPagingNext(res *http.Response) ([]Extension, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []Extension
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for Extension collection
func (s *ServiceCollectionExtension) DoPagingWithPath(method, path string, obj interface{}) ([]Extension, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionExtension) DoPaging(method string, obj interface{}) ([]Extension, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionExtension) GetWithPath(path string) ([]Extension, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionExtension) Get() ([]Extension, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionExtension) PostWithPath(path string, obj interface{}) (*Extension, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionExtension) Post(obj interface{}) (*Extension, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for FieldValueSet
func (s *ServiceFieldValueSet) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceFieldValueSet) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for FieldValueSet
func (s *ServiceFieldValueSet) DoRequestWithPath(method, path string, obj interface{}) (*FieldValueSet, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *FieldValueSet
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceFieldValueSet) DoRequest(method string, obj interface{}) (*FieldValueSet, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceFieldValueSet) GetWithPath(path string) (*FieldValueSet, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceFieldValueSet) Get() (*FieldValueSet, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceFieldValueSet) PostWithPath(path string) (*FieldValueSet, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceFieldValueSet) Post() (*FieldValueSet, error) {
	return s.PostWithPath("")
}

// AcceptedSenders returns service endpoint for CollectionDirectoryObject
func (s *ServiceGroup) AcceptedSenders() *ServiceCollectionDirectoryObject {
	ss := &ServiceCollectionDirectoryObject{ServiceBase: s.ServiceBase}
	ss.baseURL += "/acceptedSenders"
	return ss
}

// Calendar returns service endpoint for Calendar
func (s *ServiceGroup) Calendar() *ServiceCalendar {
	ss := &ServiceCalendar{ServiceBase: s.ServiceBase}
	ss.baseURL += "/calendar"
	return ss
}

// CalendarView returns service endpoint for CollectionEvent
func (s *ServiceGroup) CalendarView() *ServiceCollectionEvent {
	ss := &ServiceCollectionEvent{ServiceBase: s.ServiceBase}
	ss.baseURL += "/calendarView"
	return ss
}

// Conversations returns service endpoint for CollectionConversation
func (s *ServiceGroup) Conversations() *ServiceCollectionConversation {
	ss := &ServiceCollectionConversation{ServiceBase: s.ServiceBase}
	ss.baseURL += "/conversations"
	return ss
}

// CreatedOnBehalfOf returns service endpoint for DirectoryObject
func (s *ServiceGroup) CreatedOnBehalfOf() *ServiceDirectoryObject {
	ss := &ServiceDirectoryObject{ServiceBase: s.ServiceBase}
	ss.baseURL += "/createdOnBehalfOf"
	return ss
}

// Drive returns service endpoint for Drive
func (s *ServiceGroup) Drive() *ServiceDrive {
	ss := &ServiceDrive{ServiceBase: s.ServiceBase}
	ss.baseURL += "/drive"
	return ss
}

// Drives returns service endpoint for CollectionDrive
func (s *ServiceGroup) Drives() *ServiceCollectionDrive {
	ss := &ServiceCollectionDrive{ServiceBase: s.ServiceBase}
	ss.baseURL += "/drives"
	return ss
}

// Events returns service endpoint for CollectionEvent
func (s *ServiceGroup) Events() *ServiceCollectionEvent {
	ss := &ServiceCollectionEvent{ServiceBase: s.ServiceBase}
	ss.baseURL += "/events"
	return ss
}

// Extensions returns service endpoint for CollectionExtension
func (s *ServiceGroup) Extensions() *ServiceCollectionExtension {
	ss := &ServiceCollectionExtension{ServiceBase: s.ServiceBase}
	ss.baseURL += "/extensions"
	return ss
}

// GroupLifecyclePolicies returns service endpoint for CollectionGroupLifecyclePolicy
func (s *ServiceGroup) GroupLifecyclePolicies() *ServiceCollectionGroupLifecyclePolicy {
	ss := &ServiceCollectionGroupLifecyclePolicy{ServiceBase: s.ServiceBase}
	ss.baseURL += "/groupLifecyclePolicies"
	return ss
}

// MemberOf returns service endpoint for CollectionDirectoryObject
func (s *ServiceGroup) MemberOf() *ServiceCollectionDirectoryObject {
	ss := &ServiceCollectionDirectoryObject{ServiceBase: s.ServiceBase}
	ss.baseURL += "/memberOf"
	return ss
}

// Members returns service endpoint for CollectionDirectoryObject
func (s *ServiceGroup) Members() *ServiceCollectionDirectoryObject {
	ss := &ServiceCollectionDirectoryObject{ServiceBase: s.ServiceBase}
	ss.baseURL += "/members"
	return ss
}

// MembersWithLicenseErrors returns service endpoint for CollectionDirectoryObject
func (s *ServiceGroup) MembersWithLicenseErrors() *ServiceCollectionDirectoryObject {
	ss := &ServiceCollectionDirectoryObject{ServiceBase: s.ServiceBase}
	ss.baseURL += "/membersWithLicenseErrors"
	return ss
}

// Onenote returns service endpoint for Onenote
func (s *ServiceGroup) Onenote() *ServiceOnenote {
	ss := &ServiceOnenote{ServiceBase: s.ServiceBase}
	ss.baseURL += "/onenote"
	return ss
}

// Owners returns service endpoint for CollectionDirectoryObject
func (s *ServiceGroup) Owners() *ServiceCollectionDirectoryObject {
	ss := &ServiceCollectionDirectoryObject{ServiceBase: s.ServiceBase}
	ss.baseURL += "/owners"
	return ss
}

// Photo returns service endpoint for ProfilePhoto
func (s *ServiceGroup) Photo() *ServiceProfilePhoto {
	ss := &ServiceProfilePhoto{ServiceBase: s.ServiceBase}
	ss.baseURL += "/photo"
	return ss
}

// Photos returns service endpoint for CollectionProfilePhoto
func (s *ServiceGroup) Photos() *ServiceCollectionProfilePhoto {
	ss := &ServiceCollectionProfilePhoto{ServiceBase: s.ServiceBase}
	ss.baseURL += "/photos"
	return ss
}

// Planner returns service endpoint for PlannerGroup
func (s *ServiceGroup) Planner() *ServicePlannerGroup {
	ss := &ServicePlannerGroup{ServiceBase: s.ServiceBase}
	ss.baseURL += "/planner"
	return ss
}

// RejectedSenders returns service endpoint for CollectionDirectoryObject
func (s *ServiceGroup) RejectedSenders() *ServiceCollectionDirectoryObject {
	ss := &ServiceCollectionDirectoryObject{ServiceBase: s.ServiceBase}
	ss.baseURL += "/rejectedSenders"
	return ss
}

// Settings returns service endpoint for CollectionGroupSetting
func (s *ServiceGroup) Settings() *ServiceCollectionGroupSetting {
	ss := &ServiceCollectionGroupSetting{ServiceBase: s.ServiceBase}
	ss.baseURL += "/settings"
	return ss
}

// Sites returns service endpoint for CollectionSite
func (s *ServiceGroup) Sites() *ServiceCollectionSite {
	ss := &ServiceCollectionSite{ServiceBase: s.ServiceBase}
	ss.baseURL += "/sites"
	return ss
}

// Team returns service endpoint for Team
func (s *ServiceGroup) Team() *ServiceTeam {
	ss := &ServiceTeam{ServiceBase: s.ServiceBase}
	ss.baseURL += "/team"
	return ss
}

// Threads returns service endpoint for CollectionConversationThread
func (s *ServiceGroup) Threads() *ServiceCollectionConversationThread {
	ss := &ServiceCollectionConversationThread{ServiceBase: s.ServiceBase}
	ss.baseURL += "/threads"
	return ss
}

// TransitiveMemberOf returns service endpoint for CollectionDirectoryObject
func (s *ServiceGroup) TransitiveMemberOf() *ServiceCollectionDirectoryObject {
	ss := &ServiceCollectionDirectoryObject{ServiceBase: s.ServiceBase}
	ss.baseURL += "/transitiveMemberOf"
	return ss
}

// TransitiveMembers returns service endpoint for CollectionDirectoryObject
func (s *ServiceGroup) TransitiveMembers() *ServiceCollectionDirectoryObject {
	ss := &ServiceCollectionDirectoryObject{ServiceBase: s.ServiceBase}
	ss.baseURL += "/transitiveMembers"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for Group
func (s *ServiceGroup) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceGroup) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for Group
func (s *ServiceGroup) DoRequestWithPath(method, path string, obj interface{}) (*Group, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *Group
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceGroup) DoRequest(method string, obj interface{}) (*Group, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceGroup) GetWithPath(path string) (*Group, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceGroup) Get() (*Group, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceGroup) PostWithPath(path string) (*Group, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceGroup) Post() (*Group, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for Group collection with addtional path
func (s *ServiceCollectionGroup) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionGroup) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for Group
func (s *ServiceCollectionGroup) DoRequestWithPath(method, path string, obj interface{}) (*Group, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *Group
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionGroup) DoRequest(method string, obj interface{}) (*Group, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for Group collection
func (s *ServiceCollectionGroup) DoPagingNext(res *http.Response) ([]Group, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []Group
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for Group collection
func (s *ServiceCollectionGroup) DoPagingWithPath(method, path string, obj interface{}) ([]Group, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionGroup) DoPaging(method string, obj interface{}) ([]Group, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionGroup) GetWithPath(path string) ([]Group, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionGroup) Get() ([]Group, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionGroup) PostWithPath(path string, obj interface{}) (*Group, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionGroup) Post(obj interface{}) (*Group, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for GroupLifecyclePolicy
func (s *ServiceGroupLifecyclePolicy) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceGroupLifecyclePolicy) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for GroupLifecyclePolicy
func (s *ServiceGroupLifecyclePolicy) DoRequestWithPath(method, path string, obj interface{}) (*GroupLifecyclePolicy, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *GroupLifecyclePolicy
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceGroupLifecyclePolicy) DoRequest(method string, obj interface{}) (*GroupLifecyclePolicy, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceGroupLifecyclePolicy) GetWithPath(path string) (*GroupLifecyclePolicy, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceGroupLifecyclePolicy) Get() (*GroupLifecyclePolicy, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceGroupLifecyclePolicy) PostWithPath(path string) (*GroupLifecyclePolicy, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceGroupLifecyclePolicy) Post() (*GroupLifecyclePolicy, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for GroupLifecyclePolicy collection with addtional path
func (s *ServiceCollectionGroupLifecyclePolicy) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionGroupLifecyclePolicy) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for GroupLifecyclePolicy
func (s *ServiceCollectionGroupLifecyclePolicy) DoRequestWithPath(method, path string, obj interface{}) (*GroupLifecyclePolicy, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *GroupLifecyclePolicy
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionGroupLifecyclePolicy) DoRequest(method string, obj interface{}) (*GroupLifecyclePolicy, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for GroupLifecyclePolicy collection
func (s *ServiceCollectionGroupLifecyclePolicy) DoPagingNext(res *http.Response) ([]GroupLifecyclePolicy, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []GroupLifecyclePolicy
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for GroupLifecyclePolicy collection
func (s *ServiceCollectionGroupLifecyclePolicy) DoPagingWithPath(method, path string, obj interface{}) ([]GroupLifecyclePolicy, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionGroupLifecyclePolicy) DoPaging(method string, obj interface{}) ([]GroupLifecyclePolicy, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionGroupLifecyclePolicy) GetWithPath(path string) ([]GroupLifecyclePolicy, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionGroupLifecyclePolicy) Get() ([]GroupLifecyclePolicy, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionGroupLifecyclePolicy) PostWithPath(path string, obj interface{}) (*GroupLifecyclePolicy, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionGroupLifecyclePolicy) Post(obj interface{}) (*GroupLifecyclePolicy, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for GroupSetting
func (s *ServiceGroupSetting) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceGroupSetting) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for GroupSetting
func (s *ServiceGroupSetting) DoRequestWithPath(method, path string, obj interface{}) (*GroupSetting, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *GroupSetting
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceGroupSetting) DoRequest(method string, obj interface{}) (*GroupSetting, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceGroupSetting) GetWithPath(path string) (*GroupSetting, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceGroupSetting) Get() (*GroupSetting, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceGroupSetting) PostWithPath(path string) (*GroupSetting, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceGroupSetting) Post() (*GroupSetting, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for GroupSetting collection with addtional path
func (s *ServiceCollectionGroupSetting) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionGroupSetting) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for GroupSetting
func (s *ServiceCollectionGroupSetting) DoRequestWithPath(method, path string, obj interface{}) (*GroupSetting, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *GroupSetting
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionGroupSetting) DoRequest(method string, obj interface{}) (*GroupSetting, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for GroupSetting collection
func (s *ServiceCollectionGroupSetting) DoPagingNext(res *http.Response) ([]GroupSetting, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []GroupSetting
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for GroupSetting collection
func (s *ServiceCollectionGroupSetting) DoPagingWithPath(method, path string, obj interface{}) ([]GroupSetting, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionGroupSetting) DoPaging(method string, obj interface{}) ([]GroupSetting, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionGroupSetting) GetWithPath(path string) ([]GroupSetting, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionGroupSetting) Get() ([]GroupSetting, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionGroupSetting) PostWithPath(path string, obj interface{}) (*GroupSetting, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionGroupSetting) Post(obj interface{}) (*GroupSetting, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for GroupSettingTemplate
func (s *ServiceGroupSettingTemplate) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceGroupSettingTemplate) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for GroupSettingTemplate
func (s *ServiceGroupSettingTemplate) DoRequestWithPath(method, path string, obj interface{}) (*GroupSettingTemplate, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *GroupSettingTemplate
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceGroupSettingTemplate) DoRequest(method string, obj interface{}) (*GroupSettingTemplate, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceGroupSettingTemplate) GetWithPath(path string) (*GroupSettingTemplate, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceGroupSettingTemplate) Get() (*GroupSettingTemplate, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceGroupSettingTemplate) PostWithPath(path string) (*GroupSettingTemplate, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceGroupSettingTemplate) Post() (*GroupSettingTemplate, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for GroupSettingTemplate collection with addtional path
func (s *ServiceCollectionGroupSettingTemplate) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionGroupSettingTemplate) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for GroupSettingTemplate
func (s *ServiceCollectionGroupSettingTemplate) DoRequestWithPath(method, path string, obj interface{}) (*GroupSettingTemplate, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *GroupSettingTemplate
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionGroupSettingTemplate) DoRequest(method string, obj interface{}) (*GroupSettingTemplate, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for GroupSettingTemplate collection
func (s *ServiceCollectionGroupSettingTemplate) DoPagingNext(res *http.Response) ([]GroupSettingTemplate, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []GroupSettingTemplate
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for GroupSettingTemplate collection
func (s *ServiceCollectionGroupSettingTemplate) DoPagingWithPath(method, path string, obj interface{}) ([]GroupSettingTemplate, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionGroupSettingTemplate) DoPaging(method string, obj interface{}) ([]GroupSettingTemplate, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionGroupSettingTemplate) GetWithPath(path string) ([]GroupSettingTemplate, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionGroupSettingTemplate) Get() ([]GroupSettingTemplate, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionGroupSettingTemplate) PostWithPath(path string, obj interface{}) (*GroupSettingTemplate, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionGroupSettingTemplate) Post(obj interface{}) (*GroupSettingTemplate, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for IdentityProvider
func (s *ServiceIdentityProvider) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceIdentityProvider) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for IdentityProvider
func (s *ServiceIdentityProvider) DoRequestWithPath(method, path string, obj interface{}) (*IdentityProvider, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *IdentityProvider
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceIdentityProvider) DoRequest(method string, obj interface{}) (*IdentityProvider, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceIdentityProvider) GetWithPath(path string) (*IdentityProvider, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceIdentityProvider) Get() (*IdentityProvider, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceIdentityProvider) PostWithPath(path string) (*IdentityProvider, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceIdentityProvider) Post() (*IdentityProvider, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for IdentityProvider collection with addtional path
func (s *ServiceCollectionIdentityProvider) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionIdentityProvider) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for IdentityProvider
func (s *ServiceCollectionIdentityProvider) DoRequestWithPath(method, path string, obj interface{}) (*IdentityProvider, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *IdentityProvider
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionIdentityProvider) DoRequest(method string, obj interface{}) (*IdentityProvider, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for IdentityProvider collection
func (s *ServiceCollectionIdentityProvider) DoPagingNext(res *http.Response) ([]IdentityProvider, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []IdentityProvider
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for IdentityProvider collection
func (s *ServiceCollectionIdentityProvider) DoPagingWithPath(method, path string, obj interface{}) ([]IdentityProvider, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionIdentityProvider) DoPaging(method string, obj interface{}) ([]IdentityProvider, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionIdentityProvider) GetWithPath(path string) ([]IdentityProvider, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionIdentityProvider) Get() ([]IdentityProvider, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionIdentityProvider) PostWithPath(path string, obj interface{}) (*IdentityProvider, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionIdentityProvider) Post(obj interface{}) (*IdentityProvider, error) {
	return s.PostWithPath("", obj)
}

// Overrides returns service endpoint for CollectionInferenceClassificationOverride
func (s *ServiceInferenceClassification) Overrides() *ServiceCollectionInferenceClassificationOverride {
	ss := &ServiceCollectionInferenceClassificationOverride{ServiceBase: s.ServiceBase}
	ss.baseURL += "/overrides"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for InferenceClassification
func (s *ServiceInferenceClassification) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceInferenceClassification) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for InferenceClassification
func (s *ServiceInferenceClassification) DoRequestWithPath(method, path string, obj interface{}) (*InferenceClassification, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *InferenceClassification
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceInferenceClassification) DoRequest(method string, obj interface{}) (*InferenceClassification, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceInferenceClassification) GetWithPath(path string) (*InferenceClassification, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceInferenceClassification) Get() (*InferenceClassification, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceInferenceClassification) PostWithPath(path string) (*InferenceClassification, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceInferenceClassification) Post() (*InferenceClassification, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for InferenceClassificationOverride collection with addtional path
func (s *ServiceCollectionInferenceClassificationOverride) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionInferenceClassificationOverride) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for InferenceClassificationOverride
func (s *ServiceCollectionInferenceClassificationOverride) DoRequestWithPath(method, path string, obj interface{}) (*InferenceClassificationOverride, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *InferenceClassificationOverride
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionInferenceClassificationOverride) DoRequest(method string, obj interface{}) (*InferenceClassificationOverride, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for InferenceClassificationOverride collection
func (s *ServiceCollectionInferenceClassificationOverride) DoPagingNext(res *http.Response) ([]InferenceClassificationOverride, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []InferenceClassificationOverride
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for InferenceClassificationOverride collection
func (s *ServiceCollectionInferenceClassificationOverride) DoPagingWithPath(method, path string, obj interface{}) ([]InferenceClassificationOverride, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionInferenceClassificationOverride) DoPaging(method string, obj interface{}) ([]InferenceClassificationOverride, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionInferenceClassificationOverride) GetWithPath(path string) ([]InferenceClassificationOverride, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionInferenceClassificationOverride) Get() ([]InferenceClassificationOverride, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionInferenceClassificationOverride) PostWithPath(path string, obj interface{}) (*InferenceClassificationOverride, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionInferenceClassificationOverride) Post(obj interface{}) (*InferenceClassificationOverride, error) {
	return s.PostWithPath("", obj)
}

// InvitedUser returns service endpoint for User
func (s *ServiceInvitation) InvitedUser() *ServiceUser {
	ss := &ServiceUser{ServiceBase: s.ServiceBase}
	ss.baseURL += "/invitedUser"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for Invitation
func (s *ServiceInvitation) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceInvitation) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for Invitation
func (s *ServiceInvitation) DoRequestWithPath(method, path string, obj interface{}) (*Invitation, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *Invitation
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceInvitation) DoRequest(method string, obj interface{}) (*Invitation, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceInvitation) GetWithPath(path string) (*Invitation, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceInvitation) Get() (*Invitation, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceInvitation) PostWithPath(path string) (*Invitation, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceInvitation) Post() (*Invitation, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for Invitation collection with addtional path
func (s *ServiceCollectionInvitation) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionInvitation) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for Invitation
func (s *ServiceCollectionInvitation) DoRequestWithPath(method, path string, obj interface{}) (*Invitation, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *Invitation
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionInvitation) DoRequest(method string, obj interface{}) (*Invitation, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for Invitation collection
func (s *ServiceCollectionInvitation) DoPagingNext(res *http.Response) ([]Invitation, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []Invitation
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for Invitation collection
func (s *ServiceCollectionInvitation) DoPagingWithPath(method, path string, obj interface{}) ([]Invitation, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionInvitation) DoPaging(method string, obj interface{}) ([]Invitation, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionInvitation) GetWithPath(path string) ([]Invitation, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionInvitation) Get() ([]Invitation, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionInvitation) PostWithPath(path string, obj interface{}) (*Invitation, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionInvitation) Post(obj interface{}) (*Invitation, error) {
	return s.PostWithPath("", obj)
}

// Apps returns service endpoint for CollectionManagedMobileApp
func (s *ServiceIosManagedAppProtection) Apps() *ServiceCollectionManagedMobileApp {
	ss := &ServiceCollectionManagedMobileApp{ServiceBase: s.ServiceBase}
	ss.baseURL += "/apps"
	return ss
}

// DeploymentSummary returns service endpoint for ManagedAppPolicyDeploymentSummary
func (s *ServiceIosManagedAppProtection) DeploymentSummary() *ServiceManagedAppPolicyDeploymentSummary {
	ss := &ServiceManagedAppPolicyDeploymentSummary{ServiceBase: s.ServiceBase}
	ss.baseURL += "/deploymentSummary"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for IosManagedAppProtection
func (s *ServiceIosManagedAppProtection) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceIosManagedAppProtection) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for IosManagedAppProtection
func (s *ServiceIosManagedAppProtection) DoRequestWithPath(method, path string, obj interface{}) (*IosManagedAppProtection, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *IosManagedAppProtection
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceIosManagedAppProtection) DoRequest(method string, obj interface{}) (*IosManagedAppProtection, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceIosManagedAppProtection) GetWithPath(path string) (*IosManagedAppProtection, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceIosManagedAppProtection) Get() (*IosManagedAppProtection, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceIosManagedAppProtection) PostWithPath(path string) (*IosManagedAppProtection, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceIosManagedAppProtection) Post() (*IosManagedAppProtection, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for IosManagedAppProtection collection with addtional path
func (s *ServiceCollectionIosManagedAppProtection) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionIosManagedAppProtection) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for IosManagedAppProtection
func (s *ServiceCollectionIosManagedAppProtection) DoRequestWithPath(method, path string, obj interface{}) (*IosManagedAppProtection, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *IosManagedAppProtection
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionIosManagedAppProtection) DoRequest(method string, obj interface{}) (*IosManagedAppProtection, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for IosManagedAppProtection collection
func (s *ServiceCollectionIosManagedAppProtection) DoPagingNext(res *http.Response) ([]IosManagedAppProtection, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []IosManagedAppProtection
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for IosManagedAppProtection collection
func (s *ServiceCollectionIosManagedAppProtection) DoPagingWithPath(method, path string, obj interface{}) ([]IosManagedAppProtection, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionIosManagedAppProtection) DoPaging(method string, obj interface{}) ([]IosManagedAppProtection, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionIosManagedAppProtection) GetWithPath(path string) ([]IosManagedAppProtection, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionIosManagedAppProtection) Get() ([]IosManagedAppProtection, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionIosManagedAppProtection) PostWithPath(path string, obj interface{}) (*IosManagedAppProtection, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionIosManagedAppProtection) Post(obj interface{}) (*IosManagedAppProtection, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for IosUpdateDeviceStatus collection with addtional path
func (s *ServiceCollectionIosUpdateDeviceStatus) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionIosUpdateDeviceStatus) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for IosUpdateDeviceStatus
func (s *ServiceCollectionIosUpdateDeviceStatus) DoRequestWithPath(method, path string, obj interface{}) (*IosUpdateDeviceStatus, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *IosUpdateDeviceStatus
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionIosUpdateDeviceStatus) DoRequest(method string, obj interface{}) (*IosUpdateDeviceStatus, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for IosUpdateDeviceStatus collection
func (s *ServiceCollectionIosUpdateDeviceStatus) DoPagingNext(res *http.Response) ([]IosUpdateDeviceStatus, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []IosUpdateDeviceStatus
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for IosUpdateDeviceStatus collection
func (s *ServiceCollectionIosUpdateDeviceStatus) DoPagingWithPath(method, path string, obj interface{}) ([]IosUpdateDeviceStatus, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionIosUpdateDeviceStatus) DoPaging(method string, obj interface{}) ([]IosUpdateDeviceStatus, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionIosUpdateDeviceStatus) GetWithPath(path string) ([]IosUpdateDeviceStatus, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionIosUpdateDeviceStatus) Get() ([]IosUpdateDeviceStatus, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionIosUpdateDeviceStatus) PostWithPath(path string, obj interface{}) (*IosUpdateDeviceStatus, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionIosUpdateDeviceStatus) Post(obj interface{}) (*IosUpdateDeviceStatus, error) {
	return s.PostWithPath("", obj)
}

// DriveItem returns service endpoint for DriveItem
func (s *ServiceItemActivity) DriveItem() *ServiceDriveItem {
	ss := &ServiceDriveItem{ServiceBase: s.ServiceBase}
	ss.baseURL += "/driveItem"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for ItemActivity
func (s *ServiceItemActivity) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceItemActivity) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for ItemActivity
func (s *ServiceItemActivity) DoRequestWithPath(method, path string, obj interface{}) (*ItemActivity, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *ItemActivity
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceItemActivity) DoRequest(method string, obj interface{}) (*ItemActivity, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceItemActivity) GetWithPath(path string) (*ItemActivity, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceItemActivity) Get() (*ItemActivity, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceItemActivity) PostWithPath(path string) (*ItemActivity, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceItemActivity) Post() (*ItemActivity, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for ItemActivity collection with addtional path
func (s *ServiceCollectionItemActivity) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionItemActivity) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for ItemActivity
func (s *ServiceCollectionItemActivity) DoRequestWithPath(method, path string, obj interface{}) (*ItemActivity, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *ItemActivity
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionItemActivity) DoRequest(method string, obj interface{}) (*ItemActivity, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for ItemActivity collection
func (s *ServiceCollectionItemActivity) DoPagingNext(res *http.Response) ([]ItemActivity, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []ItemActivity
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for ItemActivity collection
func (s *ServiceCollectionItemActivity) DoPagingWithPath(method, path string, obj interface{}) ([]ItemActivity, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionItemActivity) DoPaging(method string, obj interface{}) ([]ItemActivity, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionItemActivity) GetWithPath(path string) ([]ItemActivity, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionItemActivity) Get() ([]ItemActivity, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionItemActivity) PostWithPath(path string, obj interface{}) (*ItemActivity, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionItemActivity) Post(obj interface{}) (*ItemActivity, error) {
	return s.PostWithPath("", obj)
}

// Activities returns service endpoint for CollectionItemActivity
func (s *ServiceItemActivityStat) Activities() *ServiceCollectionItemActivity {
	ss := &ServiceCollectionItemActivity{ServiceBase: s.ServiceBase}
	ss.baseURL += "/activities"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for ItemActivityStat
func (s *ServiceItemActivityStat) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceItemActivityStat) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for ItemActivityStat
func (s *ServiceItemActivityStat) DoRequestWithPath(method, path string, obj interface{}) (*ItemActivityStat, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *ItemActivityStat
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceItemActivityStat) DoRequest(method string, obj interface{}) (*ItemActivityStat, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceItemActivityStat) GetWithPath(path string) (*ItemActivityStat, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceItemActivityStat) Get() (*ItemActivityStat, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceItemActivityStat) PostWithPath(path string) (*ItemActivityStat, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceItemActivityStat) Post() (*ItemActivityStat, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for ItemActivityStat collection with addtional path
func (s *ServiceCollectionItemActivityStat) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionItemActivityStat) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for ItemActivityStat
func (s *ServiceCollectionItemActivityStat) DoRequestWithPath(method, path string, obj interface{}) (*ItemActivityStat, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *ItemActivityStat
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionItemActivityStat) DoRequest(method string, obj interface{}) (*ItemActivityStat, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for ItemActivityStat collection
func (s *ServiceCollectionItemActivityStat) DoPagingNext(res *http.Response) ([]ItemActivityStat, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []ItemActivityStat
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for ItemActivityStat collection
func (s *ServiceCollectionItemActivityStat) DoPagingWithPath(method, path string, obj interface{}) ([]ItemActivityStat, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionItemActivityStat) DoPaging(method string, obj interface{}) ([]ItemActivityStat, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionItemActivityStat) GetWithPath(path string) ([]ItemActivityStat, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionItemActivityStat) Get() ([]ItemActivityStat, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionItemActivityStat) PostWithPath(path string, obj interface{}) (*ItemActivityStat, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionItemActivityStat) Post(obj interface{}) (*ItemActivityStat, error) {
	return s.PostWithPath("", obj)
}

// AllTime returns service endpoint for ItemActivityStat
func (s *ServiceItemAnalytics) AllTime() *ServiceItemActivityStat {
	ss := &ServiceItemActivityStat{ServiceBase: s.ServiceBase}
	ss.baseURL += "/allTime"
	return ss
}

// ItemActivityStats returns service endpoint for CollectionItemActivityStat
func (s *ServiceItemAnalytics) ItemActivityStats() *ServiceCollectionItemActivityStat {
	ss := &ServiceCollectionItemActivityStat{ServiceBase: s.ServiceBase}
	ss.baseURL += "/itemActivityStats"
	return ss
}

// LastSevenDays returns service endpoint for ItemActivityStat
func (s *ServiceItemAnalytics) LastSevenDays() *ServiceItemActivityStat {
	ss := &ServiceItemActivityStat{ServiceBase: s.ServiceBase}
	ss.baseURL += "/lastSevenDays"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for ItemAnalytics
func (s *ServiceItemAnalytics) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceItemAnalytics) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for ItemAnalytics
func (s *ServiceItemAnalytics) DoRequestWithPath(method, path string, obj interface{}) (*ItemAnalytics, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *ItemAnalytics
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceItemAnalytics) DoRequest(method string, obj interface{}) (*ItemAnalytics, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceItemAnalytics) GetWithPath(path string) (*ItemAnalytics, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceItemAnalytics) Get() (*ItemAnalytics, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceItemAnalytics) PostWithPath(path string) (*ItemAnalytics, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceItemAnalytics) Post() (*ItemAnalytics, error) {
	return s.PostWithPath("")
}

// Item returns service endpoint for OutlookItem
func (s *ServiceItemAttachment) Item() *ServiceOutlookItem {
	ss := &ServiceOutlookItem{ServiceBase: s.ServiceBase}
	ss.baseURL += "/item"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for ItemAttachment
func (s *ServiceItemAttachment) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceItemAttachment) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for ItemAttachment
func (s *ServiceItemAttachment) DoRequestWithPath(method, path string, obj interface{}) (*ItemAttachment, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *ItemAttachment
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceItemAttachment) DoRequest(method string, obj interface{}) (*ItemAttachment, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceItemAttachment) GetWithPath(path string) (*ItemAttachment, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceItemAttachment) Get() (*ItemAttachment, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceItemAttachment) PostWithPath(path string) (*ItemAttachment, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceItemAttachment) Post() (*ItemAttachment, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for LicenseDetails collection with addtional path
func (s *ServiceCollectionLicenseDetails) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionLicenseDetails) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for LicenseDetails
func (s *ServiceCollectionLicenseDetails) DoRequestWithPath(method, path string, obj interface{}) (*LicenseDetails, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *LicenseDetails
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionLicenseDetails) DoRequest(method string, obj interface{}) (*LicenseDetails, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for LicenseDetails collection
func (s *ServiceCollectionLicenseDetails) DoPagingNext(res *http.Response) ([]LicenseDetails, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []LicenseDetails
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for LicenseDetails collection
func (s *ServiceCollectionLicenseDetails) DoPagingWithPath(method, path string, obj interface{}) ([]LicenseDetails, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionLicenseDetails) DoPaging(method string, obj interface{}) ([]LicenseDetails, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionLicenseDetails) GetWithPath(path string) ([]LicenseDetails, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionLicenseDetails) Get() ([]LicenseDetails, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionLicenseDetails) PostWithPath(path string, obj interface{}) (*LicenseDetails, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionLicenseDetails) Post(obj interface{}) (*LicenseDetails, error) {
	return s.PostWithPath("", obj)
}

// Columns returns service endpoint for CollectionColumnDefinition
func (s *ServiceList) Columns() *ServiceCollectionColumnDefinition {
	ss := &ServiceCollectionColumnDefinition{ServiceBase: s.ServiceBase}
	ss.baseURL += "/columns"
	return ss
}

// ContentTypes returns service endpoint for CollectionContentType
func (s *ServiceList) ContentTypes() *ServiceCollectionContentType {
	ss := &ServiceCollectionContentType{ServiceBase: s.ServiceBase}
	ss.baseURL += "/contentTypes"
	return ss
}

// Drive returns service endpoint for Drive
func (s *ServiceList) Drive() *ServiceDrive {
	ss := &ServiceDrive{ServiceBase: s.ServiceBase}
	ss.baseURL += "/drive"
	return ss
}

// Items returns service endpoint for CollectionListItem
func (s *ServiceList) Items() *ServiceCollectionListItem {
	ss := &ServiceCollectionListItem{ServiceBase: s.ServiceBase}
	ss.baseURL += "/items"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for List
func (s *ServiceList) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceList) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for List
func (s *ServiceList) DoRequestWithPath(method, path string, obj interface{}) (*List, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *List
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceList) DoRequest(method string, obj interface{}) (*List, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceList) GetWithPath(path string) (*List, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceList) Get() (*List, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceList) PostWithPath(path string) (*List, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceList) Post() (*List, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for List collection with addtional path
func (s *ServiceCollectionList) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionList) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for List
func (s *ServiceCollectionList) DoRequestWithPath(method, path string, obj interface{}) (*List, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *List
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionList) DoRequest(method string, obj interface{}) (*List, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for List collection
func (s *ServiceCollectionList) DoPagingNext(res *http.Response) ([]List, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []List
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for List collection
func (s *ServiceCollectionList) DoPagingWithPath(method, path string, obj interface{}) ([]List, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionList) DoPaging(method string, obj interface{}) ([]List, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionList) GetWithPath(path string) ([]List, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionList) Get() ([]List, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionList) PostWithPath(path string, obj interface{}) (*List, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionList) Post(obj interface{}) (*List, error) {
	return s.PostWithPath("", obj)
}

// Analytics returns service endpoint for ItemAnalytics
func (s *ServiceListItem) Analytics() *ServiceItemAnalytics {
	ss := &ServiceItemAnalytics{ServiceBase: s.ServiceBase}
	ss.baseURL += "/analytics"
	return ss
}

// DriveItem returns service endpoint for DriveItem
func (s *ServiceListItem) DriveItem() *ServiceDriveItem {
	ss := &ServiceDriveItem{ServiceBase: s.ServiceBase}
	ss.baseURL += "/driveItem"
	return ss
}

// Fields returns service endpoint for FieldValueSet
func (s *ServiceListItem) Fields() *ServiceFieldValueSet {
	ss := &ServiceFieldValueSet{ServiceBase: s.ServiceBase}
	ss.baseURL += "/fields"
	return ss
}

// Versions returns service endpoint for CollectionListItemVersion
func (s *ServiceListItem) Versions() *ServiceCollectionListItemVersion {
	ss := &ServiceCollectionListItemVersion{ServiceBase: s.ServiceBase}
	ss.baseURL += "/versions"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for ListItem
func (s *ServiceListItem) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceListItem) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for ListItem
func (s *ServiceListItem) DoRequestWithPath(method, path string, obj interface{}) (*ListItem, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *ListItem
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceListItem) DoRequest(method string, obj interface{}) (*ListItem, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceListItem) GetWithPath(path string) (*ListItem, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceListItem) Get() (*ListItem, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceListItem) PostWithPath(path string) (*ListItem, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceListItem) Post() (*ListItem, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for ListItem collection with addtional path
func (s *ServiceCollectionListItem) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionListItem) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for ListItem
func (s *ServiceCollectionListItem) DoRequestWithPath(method, path string, obj interface{}) (*ListItem, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *ListItem
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionListItem) DoRequest(method string, obj interface{}) (*ListItem, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for ListItem collection
func (s *ServiceCollectionListItem) DoPagingNext(res *http.Response) ([]ListItem, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []ListItem
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for ListItem collection
func (s *ServiceCollectionListItem) DoPagingWithPath(method, path string, obj interface{}) ([]ListItem, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionListItem) DoPaging(method string, obj interface{}) ([]ListItem, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionListItem) GetWithPath(path string) ([]ListItem, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionListItem) Get() ([]ListItem, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionListItem) PostWithPath(path string, obj interface{}) (*ListItem, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionListItem) Post(obj interface{}) (*ListItem, error) {
	return s.PostWithPath("", obj)
}

// Fields returns service endpoint for FieldValueSet
func (s *ServiceListItemVersion) Fields() *ServiceFieldValueSet {
	ss := &ServiceFieldValueSet{ServiceBase: s.ServiceBase}
	ss.baseURL += "/fields"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for ListItemVersion
func (s *ServiceListItemVersion) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceListItemVersion) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for ListItemVersion
func (s *ServiceListItemVersion) DoRequestWithPath(method, path string, obj interface{}) (*ListItemVersion, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *ListItemVersion
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceListItemVersion) DoRequest(method string, obj interface{}) (*ListItemVersion, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceListItemVersion) GetWithPath(path string) (*ListItemVersion, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceListItemVersion) Get() (*ListItemVersion, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceListItemVersion) PostWithPath(path string) (*ListItemVersion, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceListItemVersion) Post() (*ListItemVersion, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for ListItemVersion collection with addtional path
func (s *ServiceCollectionListItemVersion) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionListItemVersion) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for ListItemVersion
func (s *ServiceCollectionListItemVersion) DoRequestWithPath(method, path string, obj interface{}) (*ListItemVersion, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *ListItemVersion
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionListItemVersion) DoRequest(method string, obj interface{}) (*ListItemVersion, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for ListItemVersion collection
func (s *ServiceCollectionListItemVersion) DoPagingNext(res *http.Response) ([]ListItemVersion, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []ListItemVersion
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for ListItemVersion collection
func (s *ServiceCollectionListItemVersion) DoPagingWithPath(method, path string, obj interface{}) ([]ListItemVersion, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionListItemVersion) DoPaging(method string, obj interface{}) ([]ListItemVersion, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionListItemVersion) GetWithPath(path string) ([]ListItemVersion, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionListItemVersion) Get() ([]ListItemVersion, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionListItemVersion) PostWithPath(path string, obj interface{}) (*ListItemVersion, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionListItemVersion) Post(obj interface{}) (*ListItemVersion, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for LocalizedNotificationMessage collection with addtional path
func (s *ServiceCollectionLocalizedNotificationMessage) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionLocalizedNotificationMessage) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for LocalizedNotificationMessage
func (s *ServiceCollectionLocalizedNotificationMessage) DoRequestWithPath(method, path string, obj interface{}) (*LocalizedNotificationMessage, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *LocalizedNotificationMessage
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionLocalizedNotificationMessage) DoRequest(method string, obj interface{}) (*LocalizedNotificationMessage, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for LocalizedNotificationMessage collection
func (s *ServiceCollectionLocalizedNotificationMessage) DoPagingNext(res *http.Response) ([]LocalizedNotificationMessage, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []LocalizedNotificationMessage
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for LocalizedNotificationMessage collection
func (s *ServiceCollectionLocalizedNotificationMessage) DoPagingWithPath(method, path string, obj interface{}) ([]LocalizedNotificationMessage, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionLocalizedNotificationMessage) DoPaging(method string, obj interface{}) ([]LocalizedNotificationMessage, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionLocalizedNotificationMessage) GetWithPath(path string) ([]LocalizedNotificationMessage, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionLocalizedNotificationMessage) Get() ([]LocalizedNotificationMessage, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionLocalizedNotificationMessage) PostWithPath(path string, obj interface{}) (*LocalizedNotificationMessage, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionLocalizedNotificationMessage) Post(obj interface{}) (*LocalizedNotificationMessage, error) {
	return s.PostWithPath("", obj)
}

// ChildFolders returns service endpoint for CollectionMailFolder
func (s *ServiceMailFolder) ChildFolders() *ServiceCollectionMailFolder {
	ss := &ServiceCollectionMailFolder{ServiceBase: s.ServiceBase}
	ss.baseURL += "/childFolders"
	return ss
}

// MessageRules returns service endpoint for CollectionMessageRule
func (s *ServiceMailFolder) MessageRules() *ServiceCollectionMessageRule {
	ss := &ServiceCollectionMessageRule{ServiceBase: s.ServiceBase}
	ss.baseURL += "/messageRules"
	return ss
}

// Messages returns service endpoint for CollectionMessage
func (s *ServiceMailFolder) Messages() *ServiceCollectionMessage {
	ss := &ServiceCollectionMessage{ServiceBase: s.ServiceBase}
	ss.baseURL += "/messages"
	return ss
}

// MultiValueExtendedProperties returns service endpoint for CollectionMultiValueLegacyExtendedProperty
func (s *ServiceMailFolder) MultiValueExtendedProperties() *ServiceCollectionMultiValueLegacyExtendedProperty {
	ss := &ServiceCollectionMultiValueLegacyExtendedProperty{ServiceBase: s.ServiceBase}
	ss.baseURL += "/multiValueExtendedProperties"
	return ss
}

// SingleValueExtendedProperties returns service endpoint for CollectionSingleValueLegacyExtendedProperty
func (s *ServiceMailFolder) SingleValueExtendedProperties() *ServiceCollectionSingleValueLegacyExtendedProperty {
	ss := &ServiceCollectionSingleValueLegacyExtendedProperty{ServiceBase: s.ServiceBase}
	ss.baseURL += "/singleValueExtendedProperties"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for MailFolder
func (s *ServiceMailFolder) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceMailFolder) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for MailFolder
func (s *ServiceMailFolder) DoRequestWithPath(method, path string, obj interface{}) (*MailFolder, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *MailFolder
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceMailFolder) DoRequest(method string, obj interface{}) (*MailFolder, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceMailFolder) GetWithPath(path string) (*MailFolder, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceMailFolder) Get() (*MailFolder, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceMailFolder) PostWithPath(path string) (*MailFolder, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceMailFolder) Post() (*MailFolder, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for MailFolder collection with addtional path
func (s *ServiceCollectionMailFolder) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionMailFolder) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for MailFolder
func (s *ServiceCollectionMailFolder) DoRequestWithPath(method, path string, obj interface{}) (*MailFolder, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *MailFolder
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionMailFolder) DoRequest(method string, obj interface{}) (*MailFolder, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for MailFolder collection
func (s *ServiceCollectionMailFolder) DoPagingNext(res *http.Response) ([]MailFolder, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []MailFolder
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for MailFolder collection
func (s *ServiceCollectionMailFolder) DoPagingWithPath(method, path string, obj interface{}) ([]MailFolder, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionMailFolder) DoPaging(method string, obj interface{}) ([]MailFolder, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionMailFolder) GetWithPath(path string) ([]MailFolder, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionMailFolder) Get() ([]MailFolder, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionMailFolder) PostWithPath(path string, obj interface{}) (*MailFolder, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionMailFolder) Post(obj interface{}) (*MailFolder, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for ManagedAppOperation collection with addtional path
func (s *ServiceCollectionManagedAppOperation) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionManagedAppOperation) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for ManagedAppOperation
func (s *ServiceCollectionManagedAppOperation) DoRequestWithPath(method, path string, obj interface{}) (*ManagedAppOperation, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *ManagedAppOperation
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionManagedAppOperation) DoRequest(method string, obj interface{}) (*ManagedAppOperation, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for ManagedAppOperation collection
func (s *ServiceCollectionManagedAppOperation) DoPagingNext(res *http.Response) ([]ManagedAppOperation, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []ManagedAppOperation
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for ManagedAppOperation collection
func (s *ServiceCollectionManagedAppOperation) DoPagingWithPath(method, path string, obj interface{}) ([]ManagedAppOperation, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionManagedAppOperation) DoPaging(method string, obj interface{}) ([]ManagedAppOperation, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionManagedAppOperation) GetWithPath(path string) ([]ManagedAppOperation, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionManagedAppOperation) Get() ([]ManagedAppOperation, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionManagedAppOperation) PostWithPath(path string, obj interface{}) (*ManagedAppOperation, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionManagedAppOperation) Post(obj interface{}) (*ManagedAppOperation, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for ManagedAppPolicy collection with addtional path
func (s *ServiceCollectionManagedAppPolicy) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionManagedAppPolicy) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for ManagedAppPolicy
func (s *ServiceCollectionManagedAppPolicy) DoRequestWithPath(method, path string, obj interface{}) (*ManagedAppPolicy, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *ManagedAppPolicy
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionManagedAppPolicy) DoRequest(method string, obj interface{}) (*ManagedAppPolicy, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for ManagedAppPolicy collection
func (s *ServiceCollectionManagedAppPolicy) DoPagingNext(res *http.Response) ([]ManagedAppPolicy, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []ManagedAppPolicy
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for ManagedAppPolicy collection
func (s *ServiceCollectionManagedAppPolicy) DoPagingWithPath(method, path string, obj interface{}) ([]ManagedAppPolicy, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionManagedAppPolicy) DoPaging(method string, obj interface{}) ([]ManagedAppPolicy, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionManagedAppPolicy) GetWithPath(path string) ([]ManagedAppPolicy, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionManagedAppPolicy) Get() ([]ManagedAppPolicy, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionManagedAppPolicy) PostWithPath(path string, obj interface{}) (*ManagedAppPolicy, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionManagedAppPolicy) Post(obj interface{}) (*ManagedAppPolicy, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for ManagedAppPolicyDeploymentSummary
func (s *ServiceManagedAppPolicyDeploymentSummary) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceManagedAppPolicyDeploymentSummary) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for ManagedAppPolicyDeploymentSummary
func (s *ServiceManagedAppPolicyDeploymentSummary) DoRequestWithPath(method, path string, obj interface{}) (*ManagedAppPolicyDeploymentSummary, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *ManagedAppPolicyDeploymentSummary
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceManagedAppPolicyDeploymentSummary) DoRequest(method string, obj interface{}) (*ManagedAppPolicyDeploymentSummary, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceManagedAppPolicyDeploymentSummary) GetWithPath(path string) (*ManagedAppPolicyDeploymentSummary, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceManagedAppPolicyDeploymentSummary) Get() (*ManagedAppPolicyDeploymentSummary, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceManagedAppPolicyDeploymentSummary) PostWithPath(path string) (*ManagedAppPolicyDeploymentSummary, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceManagedAppPolicyDeploymentSummary) Post() (*ManagedAppPolicyDeploymentSummary, error) {
	return s.PostWithPath("")
}

// AppliedPolicies returns service endpoint for CollectionManagedAppPolicy
func (s *ServiceManagedAppRegistration) AppliedPolicies() *ServiceCollectionManagedAppPolicy {
	ss := &ServiceCollectionManagedAppPolicy{ServiceBase: s.ServiceBase}
	ss.baseURL += "/appliedPolicies"
	return ss
}

// IntendedPolicies returns service endpoint for CollectionManagedAppPolicy
func (s *ServiceManagedAppRegistration) IntendedPolicies() *ServiceCollectionManagedAppPolicy {
	ss := &ServiceCollectionManagedAppPolicy{ServiceBase: s.ServiceBase}
	ss.baseURL += "/intendedPolicies"
	return ss
}

// Operations returns service endpoint for CollectionManagedAppOperation
func (s *ServiceManagedAppRegistration) Operations() *ServiceCollectionManagedAppOperation {
	ss := &ServiceCollectionManagedAppOperation{ServiceBase: s.ServiceBase}
	ss.baseURL += "/operations"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for ManagedAppRegistration
func (s *ServiceManagedAppRegistration) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceManagedAppRegistration) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for ManagedAppRegistration
func (s *ServiceManagedAppRegistration) DoRequestWithPath(method, path string, obj interface{}) (*ManagedAppRegistration, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *ManagedAppRegistration
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceManagedAppRegistration) DoRequest(method string, obj interface{}) (*ManagedAppRegistration, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceManagedAppRegistration) GetWithPath(path string) (*ManagedAppRegistration, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceManagedAppRegistration) Get() (*ManagedAppRegistration, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceManagedAppRegistration) PostWithPath(path string) (*ManagedAppRegistration, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceManagedAppRegistration) Post() (*ManagedAppRegistration, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for ManagedAppRegistration collection with addtional path
func (s *ServiceCollectionManagedAppRegistration) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionManagedAppRegistration) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for ManagedAppRegistration
func (s *ServiceCollectionManagedAppRegistration) DoRequestWithPath(method, path string, obj interface{}) (*ManagedAppRegistration, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *ManagedAppRegistration
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionManagedAppRegistration) DoRequest(method string, obj interface{}) (*ManagedAppRegistration, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for ManagedAppRegistration collection
func (s *ServiceCollectionManagedAppRegistration) DoPagingNext(res *http.Response) ([]ManagedAppRegistration, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []ManagedAppRegistration
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for ManagedAppRegistration collection
func (s *ServiceCollectionManagedAppRegistration) DoPagingWithPath(method, path string, obj interface{}) ([]ManagedAppRegistration, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionManagedAppRegistration) DoPaging(method string, obj interface{}) ([]ManagedAppRegistration, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionManagedAppRegistration) GetWithPath(path string) ([]ManagedAppRegistration, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionManagedAppRegistration) Get() ([]ManagedAppRegistration, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionManagedAppRegistration) PostWithPath(path string, obj interface{}) (*ManagedAppRegistration, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionManagedAppRegistration) Post(obj interface{}) (*ManagedAppRegistration, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for ManagedAppStatus collection with addtional path
func (s *ServiceCollectionManagedAppStatus) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionManagedAppStatus) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for ManagedAppStatus
func (s *ServiceCollectionManagedAppStatus) DoRequestWithPath(method, path string, obj interface{}) (*ManagedAppStatus, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *ManagedAppStatus
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionManagedAppStatus) DoRequest(method string, obj interface{}) (*ManagedAppStatus, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for ManagedAppStatus collection
func (s *ServiceCollectionManagedAppStatus) DoPagingNext(res *http.Response) ([]ManagedAppStatus, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []ManagedAppStatus
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for ManagedAppStatus collection
func (s *ServiceCollectionManagedAppStatus) DoPagingWithPath(method, path string, obj interface{}) ([]ManagedAppStatus, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionManagedAppStatus) DoPaging(method string, obj interface{}) ([]ManagedAppStatus, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionManagedAppStatus) GetWithPath(path string) ([]ManagedAppStatus, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionManagedAppStatus) Get() ([]ManagedAppStatus, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionManagedAppStatus) PostWithPath(path string, obj interface{}) (*ManagedAppStatus, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionManagedAppStatus) Post(obj interface{}) (*ManagedAppStatus, error) {
	return s.PostWithPath("", obj)
}

// DeviceCategory returns service endpoint for DeviceCategory
func (s *ServiceManagedDevice) DeviceCategory() *ServiceDeviceCategory {
	ss := &ServiceDeviceCategory{ServiceBase: s.ServiceBase}
	ss.baseURL += "/deviceCategory"
	return ss
}

// DeviceCompliancePolicyStates returns service endpoint for CollectionDeviceCompliancePolicyState
func (s *ServiceManagedDevice) DeviceCompliancePolicyStates() *ServiceCollectionDeviceCompliancePolicyState {
	ss := &ServiceCollectionDeviceCompliancePolicyState{ServiceBase: s.ServiceBase}
	ss.baseURL += "/deviceCompliancePolicyStates"
	return ss
}

// DeviceConfigurationStates returns service endpoint for CollectionDeviceConfigurationState
func (s *ServiceManagedDevice) DeviceConfigurationStates() *ServiceCollectionDeviceConfigurationState {
	ss := &ServiceCollectionDeviceConfigurationState{ServiceBase: s.ServiceBase}
	ss.baseURL += "/deviceConfigurationStates"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for ManagedDevice
func (s *ServiceManagedDevice) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceManagedDevice) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for ManagedDevice
func (s *ServiceManagedDevice) DoRequestWithPath(method, path string, obj interface{}) (*ManagedDevice, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *ManagedDevice
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceManagedDevice) DoRequest(method string, obj interface{}) (*ManagedDevice, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceManagedDevice) GetWithPath(path string) (*ManagedDevice, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceManagedDevice) Get() (*ManagedDevice, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceManagedDevice) PostWithPath(path string) (*ManagedDevice, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceManagedDevice) Post() (*ManagedDevice, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for ManagedDevice collection with addtional path
func (s *ServiceCollectionManagedDevice) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionManagedDevice) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for ManagedDevice
func (s *ServiceCollectionManagedDevice) DoRequestWithPath(method, path string, obj interface{}) (*ManagedDevice, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *ManagedDevice
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionManagedDevice) DoRequest(method string, obj interface{}) (*ManagedDevice, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for ManagedDevice collection
func (s *ServiceCollectionManagedDevice) DoPagingNext(res *http.Response) ([]ManagedDevice, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []ManagedDevice
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for ManagedDevice collection
func (s *ServiceCollectionManagedDevice) DoPagingWithPath(method, path string, obj interface{}) ([]ManagedDevice, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionManagedDevice) DoPaging(method string, obj interface{}) ([]ManagedDevice, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionManagedDevice) GetWithPath(path string) ([]ManagedDevice, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionManagedDevice) Get() ([]ManagedDevice, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionManagedDevice) PostWithPath(path string, obj interface{}) (*ManagedDevice, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionManagedDevice) Post(obj interface{}) (*ManagedDevice, error) {
	return s.PostWithPath("", obj)
}

// Assignments returns service endpoint for CollectionManagedDeviceMobileAppConfigurationAssignment
func (s *ServiceManagedDeviceMobileAppConfiguration) Assignments() *ServiceCollectionManagedDeviceMobileAppConfigurationAssignment {
	ss := &ServiceCollectionManagedDeviceMobileAppConfigurationAssignment{ServiceBase: s.ServiceBase}
	ss.baseURL += "/assignments"
	return ss
}

// DeviceStatusSummary returns service endpoint for ManagedDeviceMobileAppConfigurationDeviceSummary
func (s *ServiceManagedDeviceMobileAppConfiguration) DeviceStatusSummary() *ServiceManagedDeviceMobileAppConfigurationDeviceSummary {
	ss := &ServiceManagedDeviceMobileAppConfigurationDeviceSummary{ServiceBase: s.ServiceBase}
	ss.baseURL += "/deviceStatusSummary"
	return ss
}

// DeviceStatuses returns service endpoint for CollectionManagedDeviceMobileAppConfigurationDeviceStatus
func (s *ServiceManagedDeviceMobileAppConfiguration) DeviceStatuses() *ServiceCollectionManagedDeviceMobileAppConfigurationDeviceStatus {
	ss := &ServiceCollectionManagedDeviceMobileAppConfigurationDeviceStatus{ServiceBase: s.ServiceBase}
	ss.baseURL += "/deviceStatuses"
	return ss
}

// UserStatusSummary returns service endpoint for ManagedDeviceMobileAppConfigurationUserSummary
func (s *ServiceManagedDeviceMobileAppConfiguration) UserStatusSummary() *ServiceManagedDeviceMobileAppConfigurationUserSummary {
	ss := &ServiceManagedDeviceMobileAppConfigurationUserSummary{ServiceBase: s.ServiceBase}
	ss.baseURL += "/userStatusSummary"
	return ss
}

// UserStatuses returns service endpoint for CollectionManagedDeviceMobileAppConfigurationUserStatus
func (s *ServiceManagedDeviceMobileAppConfiguration) UserStatuses() *ServiceCollectionManagedDeviceMobileAppConfigurationUserStatus {
	ss := &ServiceCollectionManagedDeviceMobileAppConfigurationUserStatus{ServiceBase: s.ServiceBase}
	ss.baseURL += "/userStatuses"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for ManagedDeviceMobileAppConfiguration
func (s *ServiceManagedDeviceMobileAppConfiguration) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceManagedDeviceMobileAppConfiguration) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for ManagedDeviceMobileAppConfiguration
func (s *ServiceManagedDeviceMobileAppConfiguration) DoRequestWithPath(method, path string, obj interface{}) (*ManagedDeviceMobileAppConfiguration, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *ManagedDeviceMobileAppConfiguration
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceManagedDeviceMobileAppConfiguration) DoRequest(method string, obj interface{}) (*ManagedDeviceMobileAppConfiguration, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceManagedDeviceMobileAppConfiguration) GetWithPath(path string) (*ManagedDeviceMobileAppConfiguration, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceManagedDeviceMobileAppConfiguration) Get() (*ManagedDeviceMobileAppConfiguration, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceManagedDeviceMobileAppConfiguration) PostWithPath(path string) (*ManagedDeviceMobileAppConfiguration, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceManagedDeviceMobileAppConfiguration) Post() (*ManagedDeviceMobileAppConfiguration, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for ManagedDeviceMobileAppConfiguration collection with addtional path
func (s *ServiceCollectionManagedDeviceMobileAppConfiguration) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionManagedDeviceMobileAppConfiguration) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for ManagedDeviceMobileAppConfiguration
func (s *ServiceCollectionManagedDeviceMobileAppConfiguration) DoRequestWithPath(method, path string, obj interface{}) (*ManagedDeviceMobileAppConfiguration, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *ManagedDeviceMobileAppConfiguration
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionManagedDeviceMobileAppConfiguration) DoRequest(method string, obj interface{}) (*ManagedDeviceMobileAppConfiguration, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for ManagedDeviceMobileAppConfiguration collection
func (s *ServiceCollectionManagedDeviceMobileAppConfiguration) DoPagingNext(res *http.Response) ([]ManagedDeviceMobileAppConfiguration, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []ManagedDeviceMobileAppConfiguration
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for ManagedDeviceMobileAppConfiguration collection
func (s *ServiceCollectionManagedDeviceMobileAppConfiguration) DoPagingWithPath(method, path string, obj interface{}) ([]ManagedDeviceMobileAppConfiguration, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionManagedDeviceMobileAppConfiguration) DoPaging(method string, obj interface{}) ([]ManagedDeviceMobileAppConfiguration, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionManagedDeviceMobileAppConfiguration) GetWithPath(path string) ([]ManagedDeviceMobileAppConfiguration, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionManagedDeviceMobileAppConfiguration) Get() ([]ManagedDeviceMobileAppConfiguration, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionManagedDeviceMobileAppConfiguration) PostWithPath(path string, obj interface{}) (*ManagedDeviceMobileAppConfiguration, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionManagedDeviceMobileAppConfiguration) Post(obj interface{}) (*ManagedDeviceMobileAppConfiguration, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for ManagedDeviceMobileAppConfigurationAssignment collection with addtional path
func (s *ServiceCollectionManagedDeviceMobileAppConfigurationAssignment) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionManagedDeviceMobileAppConfigurationAssignment) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for ManagedDeviceMobileAppConfigurationAssignment
func (s *ServiceCollectionManagedDeviceMobileAppConfigurationAssignment) DoRequestWithPath(method, path string, obj interface{}) (*ManagedDeviceMobileAppConfigurationAssignment, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *ManagedDeviceMobileAppConfigurationAssignment
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionManagedDeviceMobileAppConfigurationAssignment) DoRequest(method string, obj interface{}) (*ManagedDeviceMobileAppConfigurationAssignment, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for ManagedDeviceMobileAppConfigurationAssignment collection
func (s *ServiceCollectionManagedDeviceMobileAppConfigurationAssignment) DoPagingNext(res *http.Response) ([]ManagedDeviceMobileAppConfigurationAssignment, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []ManagedDeviceMobileAppConfigurationAssignment
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for ManagedDeviceMobileAppConfigurationAssignment collection
func (s *ServiceCollectionManagedDeviceMobileAppConfigurationAssignment) DoPagingWithPath(method, path string, obj interface{}) ([]ManagedDeviceMobileAppConfigurationAssignment, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionManagedDeviceMobileAppConfigurationAssignment) DoPaging(method string, obj interface{}) ([]ManagedDeviceMobileAppConfigurationAssignment, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionManagedDeviceMobileAppConfigurationAssignment) GetWithPath(path string) ([]ManagedDeviceMobileAppConfigurationAssignment, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionManagedDeviceMobileAppConfigurationAssignment) Get() ([]ManagedDeviceMobileAppConfigurationAssignment, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionManagedDeviceMobileAppConfigurationAssignment) PostWithPath(path string, obj interface{}) (*ManagedDeviceMobileAppConfigurationAssignment, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionManagedDeviceMobileAppConfigurationAssignment) Post(obj interface{}) (*ManagedDeviceMobileAppConfigurationAssignment, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for ManagedDeviceMobileAppConfigurationDeviceStatus collection with addtional path
func (s *ServiceCollectionManagedDeviceMobileAppConfigurationDeviceStatus) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionManagedDeviceMobileAppConfigurationDeviceStatus) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for ManagedDeviceMobileAppConfigurationDeviceStatus
func (s *ServiceCollectionManagedDeviceMobileAppConfigurationDeviceStatus) DoRequestWithPath(method, path string, obj interface{}) (*ManagedDeviceMobileAppConfigurationDeviceStatus, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *ManagedDeviceMobileAppConfigurationDeviceStatus
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionManagedDeviceMobileAppConfigurationDeviceStatus) DoRequest(method string, obj interface{}) (*ManagedDeviceMobileAppConfigurationDeviceStatus, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for ManagedDeviceMobileAppConfigurationDeviceStatus collection
func (s *ServiceCollectionManagedDeviceMobileAppConfigurationDeviceStatus) DoPagingNext(res *http.Response) ([]ManagedDeviceMobileAppConfigurationDeviceStatus, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []ManagedDeviceMobileAppConfigurationDeviceStatus
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for ManagedDeviceMobileAppConfigurationDeviceStatus collection
func (s *ServiceCollectionManagedDeviceMobileAppConfigurationDeviceStatus) DoPagingWithPath(method, path string, obj interface{}) ([]ManagedDeviceMobileAppConfigurationDeviceStatus, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionManagedDeviceMobileAppConfigurationDeviceStatus) DoPaging(method string, obj interface{}) ([]ManagedDeviceMobileAppConfigurationDeviceStatus, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionManagedDeviceMobileAppConfigurationDeviceStatus) GetWithPath(path string) ([]ManagedDeviceMobileAppConfigurationDeviceStatus, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionManagedDeviceMobileAppConfigurationDeviceStatus) Get() ([]ManagedDeviceMobileAppConfigurationDeviceStatus, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionManagedDeviceMobileAppConfigurationDeviceStatus) PostWithPath(path string, obj interface{}) (*ManagedDeviceMobileAppConfigurationDeviceStatus, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionManagedDeviceMobileAppConfigurationDeviceStatus) Post(obj interface{}) (*ManagedDeviceMobileAppConfigurationDeviceStatus, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for ManagedDeviceMobileAppConfigurationDeviceSummary
func (s *ServiceManagedDeviceMobileAppConfigurationDeviceSummary) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceManagedDeviceMobileAppConfigurationDeviceSummary) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for ManagedDeviceMobileAppConfigurationDeviceSummary
func (s *ServiceManagedDeviceMobileAppConfigurationDeviceSummary) DoRequestWithPath(method, path string, obj interface{}) (*ManagedDeviceMobileAppConfigurationDeviceSummary, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *ManagedDeviceMobileAppConfigurationDeviceSummary
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceManagedDeviceMobileAppConfigurationDeviceSummary) DoRequest(method string, obj interface{}) (*ManagedDeviceMobileAppConfigurationDeviceSummary, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceManagedDeviceMobileAppConfigurationDeviceSummary) GetWithPath(path string) (*ManagedDeviceMobileAppConfigurationDeviceSummary, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceManagedDeviceMobileAppConfigurationDeviceSummary) Get() (*ManagedDeviceMobileAppConfigurationDeviceSummary, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceManagedDeviceMobileAppConfigurationDeviceSummary) PostWithPath(path string) (*ManagedDeviceMobileAppConfigurationDeviceSummary, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceManagedDeviceMobileAppConfigurationDeviceSummary) Post() (*ManagedDeviceMobileAppConfigurationDeviceSummary, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for ManagedDeviceMobileAppConfigurationUserStatus collection with addtional path
func (s *ServiceCollectionManagedDeviceMobileAppConfigurationUserStatus) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionManagedDeviceMobileAppConfigurationUserStatus) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for ManagedDeviceMobileAppConfigurationUserStatus
func (s *ServiceCollectionManagedDeviceMobileAppConfigurationUserStatus) DoRequestWithPath(method, path string, obj interface{}) (*ManagedDeviceMobileAppConfigurationUserStatus, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *ManagedDeviceMobileAppConfigurationUserStatus
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionManagedDeviceMobileAppConfigurationUserStatus) DoRequest(method string, obj interface{}) (*ManagedDeviceMobileAppConfigurationUserStatus, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for ManagedDeviceMobileAppConfigurationUserStatus collection
func (s *ServiceCollectionManagedDeviceMobileAppConfigurationUserStatus) DoPagingNext(res *http.Response) ([]ManagedDeviceMobileAppConfigurationUserStatus, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []ManagedDeviceMobileAppConfigurationUserStatus
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for ManagedDeviceMobileAppConfigurationUserStatus collection
func (s *ServiceCollectionManagedDeviceMobileAppConfigurationUserStatus) DoPagingWithPath(method, path string, obj interface{}) ([]ManagedDeviceMobileAppConfigurationUserStatus, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionManagedDeviceMobileAppConfigurationUserStatus) DoPaging(method string, obj interface{}) ([]ManagedDeviceMobileAppConfigurationUserStatus, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionManagedDeviceMobileAppConfigurationUserStatus) GetWithPath(path string) ([]ManagedDeviceMobileAppConfigurationUserStatus, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionManagedDeviceMobileAppConfigurationUserStatus) Get() ([]ManagedDeviceMobileAppConfigurationUserStatus, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionManagedDeviceMobileAppConfigurationUserStatus) PostWithPath(path string, obj interface{}) (*ManagedDeviceMobileAppConfigurationUserStatus, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionManagedDeviceMobileAppConfigurationUserStatus) Post(obj interface{}) (*ManagedDeviceMobileAppConfigurationUserStatus, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for ManagedDeviceMobileAppConfigurationUserSummary
func (s *ServiceManagedDeviceMobileAppConfigurationUserSummary) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceManagedDeviceMobileAppConfigurationUserSummary) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for ManagedDeviceMobileAppConfigurationUserSummary
func (s *ServiceManagedDeviceMobileAppConfigurationUserSummary) DoRequestWithPath(method, path string, obj interface{}) (*ManagedDeviceMobileAppConfigurationUserSummary, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *ManagedDeviceMobileAppConfigurationUserSummary
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceManagedDeviceMobileAppConfigurationUserSummary) DoRequest(method string, obj interface{}) (*ManagedDeviceMobileAppConfigurationUserSummary, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceManagedDeviceMobileAppConfigurationUserSummary) GetWithPath(path string) (*ManagedDeviceMobileAppConfigurationUserSummary, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceManagedDeviceMobileAppConfigurationUserSummary) Get() (*ManagedDeviceMobileAppConfigurationUserSummary, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceManagedDeviceMobileAppConfigurationUserSummary) PostWithPath(path string) (*ManagedDeviceMobileAppConfigurationUserSummary, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceManagedDeviceMobileAppConfigurationUserSummary) Post() (*ManagedDeviceMobileAppConfigurationUserSummary, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for ManagedDeviceOverview
func (s *ServiceManagedDeviceOverview) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceManagedDeviceOverview) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for ManagedDeviceOverview
func (s *ServiceManagedDeviceOverview) DoRequestWithPath(method, path string, obj interface{}) (*ManagedDeviceOverview, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *ManagedDeviceOverview
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceManagedDeviceOverview) DoRequest(method string, obj interface{}) (*ManagedDeviceOverview, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceManagedDeviceOverview) GetWithPath(path string) (*ManagedDeviceOverview, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceManagedDeviceOverview) Get() (*ManagedDeviceOverview, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceManagedDeviceOverview) PostWithPath(path string) (*ManagedDeviceOverview, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceManagedDeviceOverview) Post() (*ManagedDeviceOverview, error) {
	return s.PostWithPath("")
}

// Assignments returns service endpoint for CollectionManagedEBookAssignment
func (s *ServiceManagedEBook) Assignments() *ServiceCollectionManagedEBookAssignment {
	ss := &ServiceCollectionManagedEBookAssignment{ServiceBase: s.ServiceBase}
	ss.baseURL += "/assignments"
	return ss
}

// DeviceStates returns service endpoint for CollectionDeviceInstallState
func (s *ServiceManagedEBook) DeviceStates() *ServiceCollectionDeviceInstallState {
	ss := &ServiceCollectionDeviceInstallState{ServiceBase: s.ServiceBase}
	ss.baseURL += "/deviceStates"
	return ss
}

// InstallSummary returns service endpoint for EBookInstallSummary
func (s *ServiceManagedEBook) InstallSummary() *ServiceEBookInstallSummary {
	ss := &ServiceEBookInstallSummary{ServiceBase: s.ServiceBase}
	ss.baseURL += "/installSummary"
	return ss
}

// UserStateSummary returns service endpoint for CollectionUserInstallStateSummary
func (s *ServiceManagedEBook) UserStateSummary() *ServiceCollectionUserInstallStateSummary {
	ss := &ServiceCollectionUserInstallStateSummary{ServiceBase: s.ServiceBase}
	ss.baseURL += "/userStateSummary"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for ManagedEBook
func (s *ServiceManagedEBook) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceManagedEBook) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for ManagedEBook
func (s *ServiceManagedEBook) DoRequestWithPath(method, path string, obj interface{}) (*ManagedEBook, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *ManagedEBook
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceManagedEBook) DoRequest(method string, obj interface{}) (*ManagedEBook, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceManagedEBook) GetWithPath(path string) (*ManagedEBook, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceManagedEBook) Get() (*ManagedEBook, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceManagedEBook) PostWithPath(path string) (*ManagedEBook, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceManagedEBook) Post() (*ManagedEBook, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for ManagedEBook collection with addtional path
func (s *ServiceCollectionManagedEBook) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionManagedEBook) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for ManagedEBook
func (s *ServiceCollectionManagedEBook) DoRequestWithPath(method, path string, obj interface{}) (*ManagedEBook, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *ManagedEBook
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionManagedEBook) DoRequest(method string, obj interface{}) (*ManagedEBook, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for ManagedEBook collection
func (s *ServiceCollectionManagedEBook) DoPagingNext(res *http.Response) ([]ManagedEBook, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []ManagedEBook
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for ManagedEBook collection
func (s *ServiceCollectionManagedEBook) DoPagingWithPath(method, path string, obj interface{}) ([]ManagedEBook, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionManagedEBook) DoPaging(method string, obj interface{}) ([]ManagedEBook, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionManagedEBook) GetWithPath(path string) ([]ManagedEBook, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionManagedEBook) Get() ([]ManagedEBook, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionManagedEBook) PostWithPath(path string, obj interface{}) (*ManagedEBook, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionManagedEBook) Post(obj interface{}) (*ManagedEBook, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for ManagedEBookAssignment collection with addtional path
func (s *ServiceCollectionManagedEBookAssignment) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionManagedEBookAssignment) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for ManagedEBookAssignment
func (s *ServiceCollectionManagedEBookAssignment) DoRequestWithPath(method, path string, obj interface{}) (*ManagedEBookAssignment, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *ManagedEBookAssignment
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionManagedEBookAssignment) DoRequest(method string, obj interface{}) (*ManagedEBookAssignment, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for ManagedEBookAssignment collection
func (s *ServiceCollectionManagedEBookAssignment) DoPagingNext(res *http.Response) ([]ManagedEBookAssignment, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []ManagedEBookAssignment
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for ManagedEBookAssignment collection
func (s *ServiceCollectionManagedEBookAssignment) DoPagingWithPath(method, path string, obj interface{}) ([]ManagedEBookAssignment, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionManagedEBookAssignment) DoPaging(method string, obj interface{}) ([]ManagedEBookAssignment, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionManagedEBookAssignment) GetWithPath(path string) ([]ManagedEBookAssignment, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionManagedEBookAssignment) Get() ([]ManagedEBookAssignment, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionManagedEBookAssignment) PostWithPath(path string, obj interface{}) (*ManagedEBookAssignment, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionManagedEBookAssignment) Post(obj interface{}) (*ManagedEBookAssignment, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for ManagedMobileApp collection with addtional path
func (s *ServiceCollectionManagedMobileApp) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionManagedMobileApp) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for ManagedMobileApp
func (s *ServiceCollectionManagedMobileApp) DoRequestWithPath(method, path string, obj interface{}) (*ManagedMobileApp, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *ManagedMobileApp
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionManagedMobileApp) DoRequest(method string, obj interface{}) (*ManagedMobileApp, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for ManagedMobileApp collection
func (s *ServiceCollectionManagedMobileApp) DoPagingNext(res *http.Response) ([]ManagedMobileApp, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []ManagedMobileApp
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for ManagedMobileApp collection
func (s *ServiceCollectionManagedMobileApp) DoPagingWithPath(method, path string, obj interface{}) ([]ManagedMobileApp, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionManagedMobileApp) DoPaging(method string, obj interface{}) ([]ManagedMobileApp, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionManagedMobileApp) GetWithPath(path string) ([]ManagedMobileApp, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionManagedMobileApp) Get() ([]ManagedMobileApp, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionManagedMobileApp) PostWithPath(path string, obj interface{}) (*ManagedMobileApp, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionManagedMobileApp) Post(obj interface{}) (*ManagedMobileApp, error) {
	return s.PostWithPath("", obj)
}

// ContentVersions returns service endpoint for CollectionMobileAppContent
func (s *ServiceManagedMobileLobApp) ContentVersions() *ServiceCollectionMobileAppContent {
	ss := &ServiceCollectionMobileAppContent{ServiceBase: s.ServiceBase}
	ss.baseURL += "/contentVersions"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for ManagedMobileLobApp
func (s *ServiceManagedMobileLobApp) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceManagedMobileLobApp) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for ManagedMobileLobApp
func (s *ServiceManagedMobileLobApp) DoRequestWithPath(method, path string, obj interface{}) (*ManagedMobileLobApp, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *ManagedMobileLobApp
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceManagedMobileLobApp) DoRequest(method string, obj interface{}) (*ManagedMobileLobApp, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceManagedMobileLobApp) GetWithPath(path string) (*ManagedMobileLobApp, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceManagedMobileLobApp) Get() (*ManagedMobileLobApp, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceManagedMobileLobApp) PostWithPath(path string) (*ManagedMobileLobApp, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceManagedMobileLobApp) Post() (*ManagedMobileLobApp, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for MdmWindowsInformationProtectionPolicy collection with addtional path
func (s *ServiceCollectionMdmWindowsInformationProtectionPolicy) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionMdmWindowsInformationProtectionPolicy) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for MdmWindowsInformationProtectionPolicy
func (s *ServiceCollectionMdmWindowsInformationProtectionPolicy) DoRequestWithPath(method, path string, obj interface{}) (*MdmWindowsInformationProtectionPolicy, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *MdmWindowsInformationProtectionPolicy
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionMdmWindowsInformationProtectionPolicy) DoRequest(method string, obj interface{}) (*MdmWindowsInformationProtectionPolicy, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for MdmWindowsInformationProtectionPolicy collection
func (s *ServiceCollectionMdmWindowsInformationProtectionPolicy) DoPagingNext(res *http.Response) ([]MdmWindowsInformationProtectionPolicy, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []MdmWindowsInformationProtectionPolicy
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for MdmWindowsInformationProtectionPolicy collection
func (s *ServiceCollectionMdmWindowsInformationProtectionPolicy) DoPagingWithPath(method, path string, obj interface{}) ([]MdmWindowsInformationProtectionPolicy, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionMdmWindowsInformationProtectionPolicy) DoPaging(method string, obj interface{}) ([]MdmWindowsInformationProtectionPolicy, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionMdmWindowsInformationProtectionPolicy) GetWithPath(path string) ([]MdmWindowsInformationProtectionPolicy, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionMdmWindowsInformationProtectionPolicy) Get() ([]MdmWindowsInformationProtectionPolicy, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionMdmWindowsInformationProtectionPolicy) PostWithPath(path string, obj interface{}) (*MdmWindowsInformationProtectionPolicy, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionMdmWindowsInformationProtectionPolicy) Post(obj interface{}) (*MdmWindowsInformationProtectionPolicy, error) {
	return s.PostWithPath("", obj)
}

// Attachments returns service endpoint for CollectionAttachment
func (s *ServiceMessage) Attachments() *ServiceCollectionAttachment {
	ss := &ServiceCollectionAttachment{ServiceBase: s.ServiceBase}
	ss.baseURL += "/attachments"
	return ss
}

// Extensions returns service endpoint for CollectionExtension
func (s *ServiceMessage) Extensions() *ServiceCollectionExtension {
	ss := &ServiceCollectionExtension{ServiceBase: s.ServiceBase}
	ss.baseURL += "/extensions"
	return ss
}

// MultiValueExtendedProperties returns service endpoint for CollectionMultiValueLegacyExtendedProperty
func (s *ServiceMessage) MultiValueExtendedProperties() *ServiceCollectionMultiValueLegacyExtendedProperty {
	ss := &ServiceCollectionMultiValueLegacyExtendedProperty{ServiceBase: s.ServiceBase}
	ss.baseURL += "/multiValueExtendedProperties"
	return ss
}

// SingleValueExtendedProperties returns service endpoint for CollectionSingleValueLegacyExtendedProperty
func (s *ServiceMessage) SingleValueExtendedProperties() *ServiceCollectionSingleValueLegacyExtendedProperty {
	ss := &ServiceCollectionSingleValueLegacyExtendedProperty{ServiceBase: s.ServiceBase}
	ss.baseURL += "/singleValueExtendedProperties"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for Message
func (s *ServiceMessage) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceMessage) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for Message
func (s *ServiceMessage) DoRequestWithPath(method, path string, obj interface{}) (*Message, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *Message
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceMessage) DoRequest(method string, obj interface{}) (*Message, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceMessage) GetWithPath(path string) (*Message, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceMessage) Get() (*Message, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceMessage) PostWithPath(path string) (*Message, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceMessage) Post() (*Message, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for Message collection with addtional path
func (s *ServiceCollectionMessage) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionMessage) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for Message
func (s *ServiceCollectionMessage) DoRequestWithPath(method, path string, obj interface{}) (*Message, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *Message
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionMessage) DoRequest(method string, obj interface{}) (*Message, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for Message collection
func (s *ServiceCollectionMessage) DoPagingNext(res *http.Response) ([]Message, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []Message
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for Message collection
func (s *ServiceCollectionMessage) DoPagingWithPath(method, path string, obj interface{}) ([]Message, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionMessage) DoPaging(method string, obj interface{}) ([]Message, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionMessage) GetWithPath(path string) ([]Message, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionMessage) Get() ([]Message, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionMessage) PostWithPath(path string, obj interface{}) (*Message, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionMessage) Post(obj interface{}) (*Message, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for MessageRule collection with addtional path
func (s *ServiceCollectionMessageRule) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionMessageRule) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for MessageRule
func (s *ServiceCollectionMessageRule) DoRequestWithPath(method, path string, obj interface{}) (*MessageRule, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *MessageRule
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionMessageRule) DoRequest(method string, obj interface{}) (*MessageRule, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for MessageRule collection
func (s *ServiceCollectionMessageRule) DoPagingNext(res *http.Response) ([]MessageRule, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []MessageRule
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for MessageRule collection
func (s *ServiceCollectionMessageRule) DoPagingWithPath(method, path string, obj interface{}) ([]MessageRule, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionMessageRule) DoPaging(method string, obj interface{}) ([]MessageRule, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionMessageRule) GetWithPath(path string) ([]MessageRule, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionMessageRule) Get() ([]MessageRule, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionMessageRule) PostWithPath(path string, obj interface{}) (*MessageRule, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionMessageRule) Post(obj interface{}) (*MessageRule, error) {
	return s.PostWithPath("", obj)
}

// Assignments returns service endpoint for CollectionMobileAppAssignment
func (s *ServiceMobileApp) Assignments() *ServiceCollectionMobileAppAssignment {
	ss := &ServiceCollectionMobileAppAssignment{ServiceBase: s.ServiceBase}
	ss.baseURL += "/assignments"
	return ss
}

// Categories returns service endpoint for CollectionMobileAppCategory
func (s *ServiceMobileApp) Categories() *ServiceCollectionMobileAppCategory {
	ss := &ServiceCollectionMobileAppCategory{ServiceBase: s.ServiceBase}
	ss.baseURL += "/categories"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for MobileApp
func (s *ServiceMobileApp) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceMobileApp) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for MobileApp
func (s *ServiceMobileApp) DoRequestWithPath(method, path string, obj interface{}) (*MobileApp, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *MobileApp
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceMobileApp) DoRequest(method string, obj interface{}) (*MobileApp, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceMobileApp) GetWithPath(path string) (*MobileApp, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceMobileApp) Get() (*MobileApp, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceMobileApp) PostWithPath(path string) (*MobileApp, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceMobileApp) Post() (*MobileApp, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for MobileApp collection with addtional path
func (s *ServiceCollectionMobileApp) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionMobileApp) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for MobileApp
func (s *ServiceCollectionMobileApp) DoRequestWithPath(method, path string, obj interface{}) (*MobileApp, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *MobileApp
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionMobileApp) DoRequest(method string, obj interface{}) (*MobileApp, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for MobileApp collection
func (s *ServiceCollectionMobileApp) DoPagingNext(res *http.Response) ([]MobileApp, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []MobileApp
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for MobileApp collection
func (s *ServiceCollectionMobileApp) DoPagingWithPath(method, path string, obj interface{}) ([]MobileApp, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionMobileApp) DoPaging(method string, obj interface{}) ([]MobileApp, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionMobileApp) GetWithPath(path string) ([]MobileApp, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionMobileApp) Get() ([]MobileApp, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionMobileApp) PostWithPath(path string, obj interface{}) (*MobileApp, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionMobileApp) Post(obj interface{}) (*MobileApp, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for MobileAppAssignment collection with addtional path
func (s *ServiceCollectionMobileAppAssignment) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionMobileAppAssignment) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for MobileAppAssignment
func (s *ServiceCollectionMobileAppAssignment) DoRequestWithPath(method, path string, obj interface{}) (*MobileAppAssignment, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *MobileAppAssignment
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionMobileAppAssignment) DoRequest(method string, obj interface{}) (*MobileAppAssignment, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for MobileAppAssignment collection
func (s *ServiceCollectionMobileAppAssignment) DoPagingNext(res *http.Response) ([]MobileAppAssignment, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []MobileAppAssignment
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for MobileAppAssignment collection
func (s *ServiceCollectionMobileAppAssignment) DoPagingWithPath(method, path string, obj interface{}) ([]MobileAppAssignment, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionMobileAppAssignment) DoPaging(method string, obj interface{}) ([]MobileAppAssignment, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionMobileAppAssignment) GetWithPath(path string) ([]MobileAppAssignment, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionMobileAppAssignment) Get() ([]MobileAppAssignment, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionMobileAppAssignment) PostWithPath(path string, obj interface{}) (*MobileAppAssignment, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionMobileAppAssignment) Post(obj interface{}) (*MobileAppAssignment, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for MobileAppCategory collection with addtional path
func (s *ServiceCollectionMobileAppCategory) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionMobileAppCategory) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for MobileAppCategory
func (s *ServiceCollectionMobileAppCategory) DoRequestWithPath(method, path string, obj interface{}) (*MobileAppCategory, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *MobileAppCategory
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionMobileAppCategory) DoRequest(method string, obj interface{}) (*MobileAppCategory, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for MobileAppCategory collection
func (s *ServiceCollectionMobileAppCategory) DoPagingNext(res *http.Response) ([]MobileAppCategory, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []MobileAppCategory
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for MobileAppCategory collection
func (s *ServiceCollectionMobileAppCategory) DoPagingWithPath(method, path string, obj interface{}) ([]MobileAppCategory, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionMobileAppCategory) DoPaging(method string, obj interface{}) ([]MobileAppCategory, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionMobileAppCategory) GetWithPath(path string) ([]MobileAppCategory, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionMobileAppCategory) Get() ([]MobileAppCategory, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionMobileAppCategory) PostWithPath(path string, obj interface{}) (*MobileAppCategory, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionMobileAppCategory) Post(obj interface{}) (*MobileAppCategory, error) {
	return s.PostWithPath("", obj)
}

// Files returns service endpoint for CollectionMobileAppContentFile
func (s *ServiceMobileAppContent) Files() *ServiceCollectionMobileAppContentFile {
	ss := &ServiceCollectionMobileAppContentFile{ServiceBase: s.ServiceBase}
	ss.baseURL += "/files"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for MobileAppContent
func (s *ServiceMobileAppContent) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceMobileAppContent) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for MobileAppContent
func (s *ServiceMobileAppContent) DoRequestWithPath(method, path string, obj interface{}) (*MobileAppContent, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *MobileAppContent
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceMobileAppContent) DoRequest(method string, obj interface{}) (*MobileAppContent, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceMobileAppContent) GetWithPath(path string) (*MobileAppContent, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceMobileAppContent) Get() (*MobileAppContent, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceMobileAppContent) PostWithPath(path string) (*MobileAppContent, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceMobileAppContent) Post() (*MobileAppContent, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for MobileAppContent collection with addtional path
func (s *ServiceCollectionMobileAppContent) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionMobileAppContent) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for MobileAppContent
func (s *ServiceCollectionMobileAppContent) DoRequestWithPath(method, path string, obj interface{}) (*MobileAppContent, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *MobileAppContent
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionMobileAppContent) DoRequest(method string, obj interface{}) (*MobileAppContent, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for MobileAppContent collection
func (s *ServiceCollectionMobileAppContent) DoPagingNext(res *http.Response) ([]MobileAppContent, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []MobileAppContent
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for MobileAppContent collection
func (s *ServiceCollectionMobileAppContent) DoPagingWithPath(method, path string, obj interface{}) ([]MobileAppContent, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionMobileAppContent) DoPaging(method string, obj interface{}) ([]MobileAppContent, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionMobileAppContent) GetWithPath(path string) ([]MobileAppContent, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionMobileAppContent) Get() ([]MobileAppContent, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionMobileAppContent) PostWithPath(path string, obj interface{}) (*MobileAppContent, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionMobileAppContent) Post(obj interface{}) (*MobileAppContent, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for MobileAppContentFile collection with addtional path
func (s *ServiceCollectionMobileAppContentFile) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionMobileAppContentFile) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for MobileAppContentFile
func (s *ServiceCollectionMobileAppContentFile) DoRequestWithPath(method, path string, obj interface{}) (*MobileAppContentFile, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *MobileAppContentFile
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionMobileAppContentFile) DoRequest(method string, obj interface{}) (*MobileAppContentFile, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for MobileAppContentFile collection
func (s *ServiceCollectionMobileAppContentFile) DoPagingNext(res *http.Response) ([]MobileAppContentFile, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []MobileAppContentFile
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for MobileAppContentFile collection
func (s *ServiceCollectionMobileAppContentFile) DoPagingWithPath(method, path string, obj interface{}) ([]MobileAppContentFile, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionMobileAppContentFile) DoPaging(method string, obj interface{}) ([]MobileAppContentFile, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionMobileAppContentFile) GetWithPath(path string) ([]MobileAppContentFile, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionMobileAppContentFile) Get() ([]MobileAppContentFile, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionMobileAppContentFile) PostWithPath(path string, obj interface{}) (*MobileAppContentFile, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionMobileAppContentFile) Post(obj interface{}) (*MobileAppContentFile, error) {
	return s.PostWithPath("", obj)
}

// ContentVersions returns service endpoint for CollectionMobileAppContent
func (s *ServiceMobileLobApp) ContentVersions() *ServiceCollectionMobileAppContent {
	ss := &ServiceCollectionMobileAppContent{ServiceBase: s.ServiceBase}
	ss.baseURL += "/contentVersions"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for MobileLobApp
func (s *ServiceMobileLobApp) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceMobileLobApp) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for MobileLobApp
func (s *ServiceMobileLobApp) DoRequestWithPath(method, path string, obj interface{}) (*MobileLobApp, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *MobileLobApp
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceMobileLobApp) DoRequest(method string, obj interface{}) (*MobileLobApp, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceMobileLobApp) GetWithPath(path string) (*MobileLobApp, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceMobileLobApp) Get() (*MobileLobApp, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceMobileLobApp) PostWithPath(path string) (*MobileLobApp, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceMobileLobApp) Post() (*MobileLobApp, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for MobileThreatDefenseConnector collection with addtional path
func (s *ServiceCollectionMobileThreatDefenseConnector) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionMobileThreatDefenseConnector) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for MobileThreatDefenseConnector
func (s *ServiceCollectionMobileThreatDefenseConnector) DoRequestWithPath(method, path string, obj interface{}) (*MobileThreatDefenseConnector, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *MobileThreatDefenseConnector
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionMobileThreatDefenseConnector) DoRequest(method string, obj interface{}) (*MobileThreatDefenseConnector, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for MobileThreatDefenseConnector collection
func (s *ServiceCollectionMobileThreatDefenseConnector) DoPagingNext(res *http.Response) ([]MobileThreatDefenseConnector, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []MobileThreatDefenseConnector
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for MobileThreatDefenseConnector collection
func (s *ServiceCollectionMobileThreatDefenseConnector) DoPagingWithPath(method, path string, obj interface{}) ([]MobileThreatDefenseConnector, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionMobileThreatDefenseConnector) DoPaging(method string, obj interface{}) ([]MobileThreatDefenseConnector, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionMobileThreatDefenseConnector) GetWithPath(path string) ([]MobileThreatDefenseConnector, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionMobileThreatDefenseConnector) Get() ([]MobileThreatDefenseConnector, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionMobileThreatDefenseConnector) PostWithPath(path string, obj interface{}) (*MobileThreatDefenseConnector, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionMobileThreatDefenseConnector) Post(obj interface{}) (*MobileThreatDefenseConnector, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for MultiValueLegacyExtendedProperty collection with addtional path
func (s *ServiceCollectionMultiValueLegacyExtendedProperty) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionMultiValueLegacyExtendedProperty) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for MultiValueLegacyExtendedProperty
func (s *ServiceCollectionMultiValueLegacyExtendedProperty) DoRequestWithPath(method, path string, obj interface{}) (*MultiValueLegacyExtendedProperty, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *MultiValueLegacyExtendedProperty
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionMultiValueLegacyExtendedProperty) DoRequest(method string, obj interface{}) (*MultiValueLegacyExtendedProperty, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for MultiValueLegacyExtendedProperty collection
func (s *ServiceCollectionMultiValueLegacyExtendedProperty) DoPagingNext(res *http.Response) ([]MultiValueLegacyExtendedProperty, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []MultiValueLegacyExtendedProperty
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for MultiValueLegacyExtendedProperty collection
func (s *ServiceCollectionMultiValueLegacyExtendedProperty) DoPagingWithPath(method, path string, obj interface{}) ([]MultiValueLegacyExtendedProperty, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionMultiValueLegacyExtendedProperty) DoPaging(method string, obj interface{}) ([]MultiValueLegacyExtendedProperty, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionMultiValueLegacyExtendedProperty) GetWithPath(path string) ([]MultiValueLegacyExtendedProperty, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionMultiValueLegacyExtendedProperty) Get() ([]MultiValueLegacyExtendedProperty, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionMultiValueLegacyExtendedProperty) PostWithPath(path string, obj interface{}) (*MultiValueLegacyExtendedProperty, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionMultiValueLegacyExtendedProperty) Post(obj interface{}) (*MultiValueLegacyExtendedProperty, error) {
	return s.PostWithPath("", obj)
}

// SectionGroups returns service endpoint for CollectionSectionGroup
func (s *ServiceNotebook) SectionGroups() *ServiceCollectionSectionGroup {
	ss := &ServiceCollectionSectionGroup{ServiceBase: s.ServiceBase}
	ss.baseURL += "/sectionGroups"
	return ss
}

// Sections returns service endpoint for CollectionOnenoteSection
func (s *ServiceNotebook) Sections() *ServiceCollectionOnenoteSection {
	ss := &ServiceCollectionOnenoteSection{ServiceBase: s.ServiceBase}
	ss.baseURL += "/sections"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for Notebook
func (s *ServiceNotebook) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceNotebook) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for Notebook
func (s *ServiceNotebook) DoRequestWithPath(method, path string, obj interface{}) (*Notebook, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *Notebook
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceNotebook) DoRequest(method string, obj interface{}) (*Notebook, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceNotebook) GetWithPath(path string) (*Notebook, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceNotebook) Get() (*Notebook, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceNotebook) PostWithPath(path string) (*Notebook, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceNotebook) Post() (*Notebook, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for Notebook collection with addtional path
func (s *ServiceCollectionNotebook) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionNotebook) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for Notebook
func (s *ServiceCollectionNotebook) DoRequestWithPath(method, path string, obj interface{}) (*Notebook, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *Notebook
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionNotebook) DoRequest(method string, obj interface{}) (*Notebook, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for Notebook collection
func (s *ServiceCollectionNotebook) DoPagingNext(res *http.Response) ([]Notebook, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []Notebook
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for Notebook collection
func (s *ServiceCollectionNotebook) DoPagingWithPath(method, path string, obj interface{}) ([]Notebook, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionNotebook) DoPaging(method string, obj interface{}) ([]Notebook, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionNotebook) GetWithPath(path string) ([]Notebook, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionNotebook) Get() ([]Notebook, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionNotebook) PostWithPath(path string, obj interface{}) (*Notebook, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionNotebook) Post(obj interface{}) (*Notebook, error) {
	return s.PostWithPath("", obj)
}

// LocalizedNotificationMessages returns service endpoint for CollectionLocalizedNotificationMessage
func (s *ServiceNotificationMessageTemplate) LocalizedNotificationMessages() *ServiceCollectionLocalizedNotificationMessage {
	ss := &ServiceCollectionLocalizedNotificationMessage{ServiceBase: s.ServiceBase}
	ss.baseURL += "/localizedNotificationMessages"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for NotificationMessageTemplate
func (s *ServiceNotificationMessageTemplate) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceNotificationMessageTemplate) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for NotificationMessageTemplate
func (s *ServiceNotificationMessageTemplate) DoRequestWithPath(method, path string, obj interface{}) (*NotificationMessageTemplate, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *NotificationMessageTemplate
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceNotificationMessageTemplate) DoRequest(method string, obj interface{}) (*NotificationMessageTemplate, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceNotificationMessageTemplate) GetWithPath(path string) (*NotificationMessageTemplate, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceNotificationMessageTemplate) Get() (*NotificationMessageTemplate, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceNotificationMessageTemplate) PostWithPath(path string) (*NotificationMessageTemplate, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceNotificationMessageTemplate) Post() (*NotificationMessageTemplate, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for NotificationMessageTemplate collection with addtional path
func (s *ServiceCollectionNotificationMessageTemplate) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionNotificationMessageTemplate) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for NotificationMessageTemplate
func (s *ServiceCollectionNotificationMessageTemplate) DoRequestWithPath(method, path string, obj interface{}) (*NotificationMessageTemplate, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *NotificationMessageTemplate
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionNotificationMessageTemplate) DoRequest(method string, obj interface{}) (*NotificationMessageTemplate, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for NotificationMessageTemplate collection
func (s *ServiceCollectionNotificationMessageTemplate) DoPagingNext(res *http.Response) ([]NotificationMessageTemplate, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []NotificationMessageTemplate
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for NotificationMessageTemplate collection
func (s *ServiceCollectionNotificationMessageTemplate) DoPagingWithPath(method, path string, obj interface{}) ([]NotificationMessageTemplate, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionNotificationMessageTemplate) DoPaging(method string, obj interface{}) ([]NotificationMessageTemplate, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionNotificationMessageTemplate) GetWithPath(path string) ([]NotificationMessageTemplate, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionNotificationMessageTemplate) Get() ([]NotificationMessageTemplate, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionNotificationMessageTemplate) PostWithPath(path string, obj interface{}) (*NotificationMessageTemplate, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionNotificationMessageTemplate) Post(obj interface{}) (*NotificationMessageTemplate, error) {
	return s.PostWithPath("", obj)
}

// Shared returns service endpoint for CollectionSharedInsight
func (s *ServiceOfficeGraphInsights) Shared() *ServiceCollectionSharedInsight {
	ss := &ServiceCollectionSharedInsight{ServiceBase: s.ServiceBase}
	ss.baseURL += "/shared"
	return ss
}

// Trending returns service endpoint for CollectionTrending
func (s *ServiceOfficeGraphInsights) Trending() *ServiceCollectionTrending {
	ss := &ServiceCollectionTrending{ServiceBase: s.ServiceBase}
	ss.baseURL += "/trending"
	return ss
}

// Used returns service endpoint for CollectionUsedInsight
func (s *ServiceOfficeGraphInsights) Used() *ServiceCollectionUsedInsight {
	ss := &ServiceCollectionUsedInsight{ServiceBase: s.ServiceBase}
	ss.baseURL += "/used"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for OfficeGraphInsights
func (s *ServiceOfficeGraphInsights) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceOfficeGraphInsights) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for OfficeGraphInsights
func (s *ServiceOfficeGraphInsights) DoRequestWithPath(method, path string, obj interface{}) (*OfficeGraphInsights, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *OfficeGraphInsights
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceOfficeGraphInsights) DoRequest(method string, obj interface{}) (*OfficeGraphInsights, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceOfficeGraphInsights) GetWithPath(path string) (*OfficeGraphInsights, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceOfficeGraphInsights) Get() (*OfficeGraphInsights, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceOfficeGraphInsights) PostWithPath(path string) (*OfficeGraphInsights, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceOfficeGraphInsights) Post() (*OfficeGraphInsights, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for OnPremisesConditionalAccessSettings
func (s *ServiceOnPremisesConditionalAccessSettings) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceOnPremisesConditionalAccessSettings) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for OnPremisesConditionalAccessSettings
func (s *ServiceOnPremisesConditionalAccessSettings) DoRequestWithPath(method, path string, obj interface{}) (*OnPremisesConditionalAccessSettings, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *OnPremisesConditionalAccessSettings
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceOnPremisesConditionalAccessSettings) DoRequest(method string, obj interface{}) (*OnPremisesConditionalAccessSettings, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceOnPremisesConditionalAccessSettings) GetWithPath(path string) (*OnPremisesConditionalAccessSettings, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceOnPremisesConditionalAccessSettings) Get() (*OnPremisesConditionalAccessSettings, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceOnPremisesConditionalAccessSettings) PostWithPath(path string) (*OnPremisesConditionalAccessSettings, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceOnPremisesConditionalAccessSettings) Post() (*OnPremisesConditionalAccessSettings, error) {
	return s.PostWithPath("")
}

// Notebooks returns service endpoint for CollectionNotebook
func (s *ServiceOnenote) Notebooks() *ServiceCollectionNotebook {
	ss := &ServiceCollectionNotebook{ServiceBase: s.ServiceBase}
	ss.baseURL += "/notebooks"
	return ss
}

// Operations returns service endpoint for CollectionOnenoteOperation
func (s *ServiceOnenote) Operations() *ServiceCollectionOnenoteOperation {
	ss := &ServiceCollectionOnenoteOperation{ServiceBase: s.ServiceBase}
	ss.baseURL += "/operations"
	return ss
}

// Pages returns service endpoint for CollectionOnenotePage
func (s *ServiceOnenote) Pages() *ServiceCollectionOnenotePage {
	ss := &ServiceCollectionOnenotePage{ServiceBase: s.ServiceBase}
	ss.baseURL += "/pages"
	return ss
}

// Resources returns service endpoint for CollectionOnenoteResource
func (s *ServiceOnenote) Resources() *ServiceCollectionOnenoteResource {
	ss := &ServiceCollectionOnenoteResource{ServiceBase: s.ServiceBase}
	ss.baseURL += "/resources"
	return ss
}

// SectionGroups returns service endpoint for CollectionSectionGroup
func (s *ServiceOnenote) SectionGroups() *ServiceCollectionSectionGroup {
	ss := &ServiceCollectionSectionGroup{ServiceBase: s.ServiceBase}
	ss.baseURL += "/sectionGroups"
	return ss
}

// Sections returns service endpoint for CollectionOnenoteSection
func (s *ServiceOnenote) Sections() *ServiceCollectionOnenoteSection {
	ss := &ServiceCollectionOnenoteSection{ServiceBase: s.ServiceBase}
	ss.baseURL += "/sections"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for Onenote
func (s *ServiceOnenote) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceOnenote) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for Onenote
func (s *ServiceOnenote) DoRequestWithPath(method, path string, obj interface{}) (*Onenote, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *Onenote
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceOnenote) DoRequest(method string, obj interface{}) (*Onenote, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceOnenote) GetWithPath(path string) (*Onenote, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceOnenote) Get() (*Onenote, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceOnenote) PostWithPath(path string) (*Onenote, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceOnenote) Post() (*Onenote, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for OnenoteOperation collection with addtional path
func (s *ServiceCollectionOnenoteOperation) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionOnenoteOperation) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for OnenoteOperation
func (s *ServiceCollectionOnenoteOperation) DoRequestWithPath(method, path string, obj interface{}) (*OnenoteOperation, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *OnenoteOperation
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionOnenoteOperation) DoRequest(method string, obj interface{}) (*OnenoteOperation, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for OnenoteOperation collection
func (s *ServiceCollectionOnenoteOperation) DoPagingNext(res *http.Response) ([]OnenoteOperation, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []OnenoteOperation
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for OnenoteOperation collection
func (s *ServiceCollectionOnenoteOperation) DoPagingWithPath(method, path string, obj interface{}) ([]OnenoteOperation, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionOnenoteOperation) DoPaging(method string, obj interface{}) ([]OnenoteOperation, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionOnenoteOperation) GetWithPath(path string) ([]OnenoteOperation, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionOnenoteOperation) Get() ([]OnenoteOperation, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionOnenoteOperation) PostWithPath(path string, obj interface{}) (*OnenoteOperation, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionOnenoteOperation) Post(obj interface{}) (*OnenoteOperation, error) {
	return s.PostWithPath("", obj)
}

// ParentNotebook returns service endpoint for Notebook
func (s *ServiceOnenotePage) ParentNotebook() *ServiceNotebook {
	ss := &ServiceNotebook{ServiceBase: s.ServiceBase}
	ss.baseURL += "/parentNotebook"
	return ss
}

// ParentSection returns service endpoint for OnenoteSection
func (s *ServiceOnenotePage) ParentSection() *ServiceOnenoteSection {
	ss := &ServiceOnenoteSection{ServiceBase: s.ServiceBase}
	ss.baseURL += "/parentSection"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for OnenotePage
func (s *ServiceOnenotePage) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceOnenotePage) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for OnenotePage
func (s *ServiceOnenotePage) DoRequestWithPath(method, path string, obj interface{}) (*OnenotePage, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *OnenotePage
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceOnenotePage) DoRequest(method string, obj interface{}) (*OnenotePage, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceOnenotePage) GetWithPath(path string) (*OnenotePage, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceOnenotePage) Get() (*OnenotePage, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceOnenotePage) PostWithPath(path string) (*OnenotePage, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceOnenotePage) Post() (*OnenotePage, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for OnenotePage collection with addtional path
func (s *ServiceCollectionOnenotePage) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionOnenotePage) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for OnenotePage
func (s *ServiceCollectionOnenotePage) DoRequestWithPath(method, path string, obj interface{}) (*OnenotePage, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *OnenotePage
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionOnenotePage) DoRequest(method string, obj interface{}) (*OnenotePage, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for OnenotePage collection
func (s *ServiceCollectionOnenotePage) DoPagingNext(res *http.Response) ([]OnenotePage, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []OnenotePage
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for OnenotePage collection
func (s *ServiceCollectionOnenotePage) DoPagingWithPath(method, path string, obj interface{}) ([]OnenotePage, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionOnenotePage) DoPaging(method string, obj interface{}) ([]OnenotePage, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionOnenotePage) GetWithPath(path string) ([]OnenotePage, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionOnenotePage) Get() ([]OnenotePage, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionOnenotePage) PostWithPath(path string, obj interface{}) (*OnenotePage, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionOnenotePage) Post(obj interface{}) (*OnenotePage, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for OnenoteResource collection with addtional path
func (s *ServiceCollectionOnenoteResource) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionOnenoteResource) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for OnenoteResource
func (s *ServiceCollectionOnenoteResource) DoRequestWithPath(method, path string, obj interface{}) (*OnenoteResource, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *OnenoteResource
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionOnenoteResource) DoRequest(method string, obj interface{}) (*OnenoteResource, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for OnenoteResource collection
func (s *ServiceCollectionOnenoteResource) DoPagingNext(res *http.Response) ([]OnenoteResource, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []OnenoteResource
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for OnenoteResource collection
func (s *ServiceCollectionOnenoteResource) DoPagingWithPath(method, path string, obj interface{}) ([]OnenoteResource, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionOnenoteResource) DoPaging(method string, obj interface{}) ([]OnenoteResource, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionOnenoteResource) GetWithPath(path string) ([]OnenoteResource, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionOnenoteResource) Get() ([]OnenoteResource, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionOnenoteResource) PostWithPath(path string, obj interface{}) (*OnenoteResource, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionOnenoteResource) Post(obj interface{}) (*OnenoteResource, error) {
	return s.PostWithPath("", obj)
}

// Pages returns service endpoint for CollectionOnenotePage
func (s *ServiceOnenoteSection) Pages() *ServiceCollectionOnenotePage {
	ss := &ServiceCollectionOnenotePage{ServiceBase: s.ServiceBase}
	ss.baseURL += "/pages"
	return ss
}

// ParentNotebook returns service endpoint for Notebook
func (s *ServiceOnenoteSection) ParentNotebook() *ServiceNotebook {
	ss := &ServiceNotebook{ServiceBase: s.ServiceBase}
	ss.baseURL += "/parentNotebook"
	return ss
}

// ParentSectionGroup returns service endpoint for SectionGroup
func (s *ServiceOnenoteSection) ParentSectionGroup() *ServiceSectionGroup {
	ss := &ServiceSectionGroup{ServiceBase: s.ServiceBase}
	ss.baseURL += "/parentSectionGroup"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for OnenoteSection
func (s *ServiceOnenoteSection) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceOnenoteSection) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for OnenoteSection
func (s *ServiceOnenoteSection) DoRequestWithPath(method, path string, obj interface{}) (*OnenoteSection, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *OnenoteSection
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceOnenoteSection) DoRequest(method string, obj interface{}) (*OnenoteSection, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceOnenoteSection) GetWithPath(path string) (*OnenoteSection, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceOnenoteSection) Get() (*OnenoteSection, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceOnenoteSection) PostWithPath(path string) (*OnenoteSection, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceOnenoteSection) Post() (*OnenoteSection, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for OnenoteSection collection with addtional path
func (s *ServiceCollectionOnenoteSection) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionOnenoteSection) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for OnenoteSection
func (s *ServiceCollectionOnenoteSection) DoRequestWithPath(method, path string, obj interface{}) (*OnenoteSection, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *OnenoteSection
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionOnenoteSection) DoRequest(method string, obj interface{}) (*OnenoteSection, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for OnenoteSection collection
func (s *ServiceCollectionOnenoteSection) DoPagingNext(res *http.Response) ([]OnenoteSection, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []OnenoteSection
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for OnenoteSection collection
func (s *ServiceCollectionOnenoteSection) DoPagingWithPath(method, path string, obj interface{}) ([]OnenoteSection, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionOnenoteSection) DoPaging(method string, obj interface{}) ([]OnenoteSection, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionOnenoteSection) GetWithPath(path string) ([]OnenoteSection, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionOnenoteSection) Get() ([]OnenoteSection, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionOnenoteSection) PostWithPath(path string, obj interface{}) (*OnenoteSection, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionOnenoteSection) Post(obj interface{}) (*OnenoteSection, error) {
	return s.PostWithPath("", obj)
}

// Extensions returns service endpoint for CollectionExtension
func (s *ServiceOrganization) Extensions() *ServiceCollectionExtension {
	ss := &ServiceCollectionExtension{ServiceBase: s.ServiceBase}
	ss.baseURL += "/extensions"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for Organization
func (s *ServiceOrganization) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceOrganization) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for Organization
func (s *ServiceOrganization) DoRequestWithPath(method, path string, obj interface{}) (*Organization, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *Organization
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceOrganization) DoRequest(method string, obj interface{}) (*Organization, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceOrganization) GetWithPath(path string) (*Organization, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceOrganization) Get() (*Organization, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceOrganization) PostWithPath(path string) (*Organization, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceOrganization) Post() (*Organization, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for Organization collection with addtional path
func (s *ServiceCollectionOrganization) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionOrganization) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for Organization
func (s *ServiceCollectionOrganization) DoRequestWithPath(method, path string, obj interface{}) (*Organization, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *Organization
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionOrganization) DoRequest(method string, obj interface{}) (*Organization, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for Organization collection
func (s *ServiceCollectionOrganization) DoPagingNext(res *http.Response) ([]Organization, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []Organization
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for Organization collection
func (s *ServiceCollectionOrganization) DoPagingWithPath(method, path string, obj interface{}) ([]Organization, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionOrganization) DoPaging(method string, obj interface{}) ([]Organization, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionOrganization) GetWithPath(path string) ([]Organization, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionOrganization) Get() ([]Organization, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionOrganization) PostWithPath(path string, obj interface{}) (*Organization, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionOrganization) Post(obj interface{}) (*Organization, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for OutlookCategory collection with addtional path
func (s *ServiceCollectionOutlookCategory) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionOutlookCategory) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for OutlookCategory
func (s *ServiceCollectionOutlookCategory) DoRequestWithPath(method, path string, obj interface{}) (*OutlookCategory, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *OutlookCategory
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionOutlookCategory) DoRequest(method string, obj interface{}) (*OutlookCategory, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for OutlookCategory collection
func (s *ServiceCollectionOutlookCategory) DoPagingNext(res *http.Response) ([]OutlookCategory, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []OutlookCategory
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for OutlookCategory collection
func (s *ServiceCollectionOutlookCategory) DoPagingWithPath(method, path string, obj interface{}) ([]OutlookCategory, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionOutlookCategory) DoPaging(method string, obj interface{}) ([]OutlookCategory, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionOutlookCategory) GetWithPath(path string) ([]OutlookCategory, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionOutlookCategory) Get() ([]OutlookCategory, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionOutlookCategory) PostWithPath(path string, obj interface{}) (*OutlookCategory, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionOutlookCategory) Post(obj interface{}) (*OutlookCategory, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for OutlookItem
func (s *ServiceOutlookItem) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceOutlookItem) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for OutlookItem
func (s *ServiceOutlookItem) DoRequestWithPath(method, path string, obj interface{}) (*OutlookItem, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *OutlookItem
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceOutlookItem) DoRequest(method string, obj interface{}) (*OutlookItem, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceOutlookItem) GetWithPath(path string) (*OutlookItem, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceOutlookItem) Get() (*OutlookItem, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceOutlookItem) PostWithPath(path string) (*OutlookItem, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceOutlookItem) Post() (*OutlookItem, error) {
	return s.PostWithPath("")
}

// MasterCategories returns service endpoint for CollectionOutlookCategory
func (s *ServiceOutlookUser) MasterCategories() *ServiceCollectionOutlookCategory {
	ss := &ServiceCollectionOutlookCategory{ServiceBase: s.ServiceBase}
	ss.baseURL += "/masterCategories"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for OutlookUser
func (s *ServiceOutlookUser) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceOutlookUser) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for OutlookUser
func (s *ServiceOutlookUser) DoRequestWithPath(method, path string, obj interface{}) (*OutlookUser, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *OutlookUser
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceOutlookUser) DoRequest(method string, obj interface{}) (*OutlookUser, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceOutlookUser) GetWithPath(path string) (*OutlookUser, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceOutlookUser) Get() (*OutlookUser, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceOutlookUser) PostWithPath(path string) (*OutlookUser, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceOutlookUser) Post() (*OutlookUser, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for Permission collection with addtional path
func (s *ServiceCollectionPermission) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionPermission) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for Permission
func (s *ServiceCollectionPermission) DoRequestWithPath(method, path string, obj interface{}) (*Permission, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *Permission
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionPermission) DoRequest(method string, obj interface{}) (*Permission, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for Permission collection
func (s *ServiceCollectionPermission) DoPagingNext(res *http.Response) ([]Permission, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []Permission
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for Permission collection
func (s *ServiceCollectionPermission) DoPagingWithPath(method, path string, obj interface{}) ([]Permission, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionPermission) DoPaging(method string, obj interface{}) ([]Permission, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionPermission) GetWithPath(path string) ([]Permission, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionPermission) Get() ([]Permission, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionPermission) PostWithPath(path string, obj interface{}) (*Permission, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionPermission) Post(obj interface{}) (*Permission, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for Person collection with addtional path
func (s *ServiceCollectionPerson) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionPerson) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for Person
func (s *ServiceCollectionPerson) DoRequestWithPath(method, path string, obj interface{}) (*Person, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *Person
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionPerson) DoRequest(method string, obj interface{}) (*Person, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for Person collection
func (s *ServiceCollectionPerson) DoPagingNext(res *http.Response) ([]Person, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []Person
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for Person collection
func (s *ServiceCollectionPerson) DoPagingWithPath(method, path string, obj interface{}) ([]Person, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionPerson) DoPaging(method string, obj interface{}) ([]Person, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionPerson) GetWithPath(path string) ([]Person, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionPerson) Get() ([]Person, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionPerson) PostWithPath(path string, obj interface{}) (*Person, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionPerson) Post(obj interface{}) (*Person, error) {
	return s.PostWithPath("", obj)
}

// Buckets returns service endpoint for CollectionPlannerBucket
func (s *ServicePlanner) Buckets() *ServiceCollectionPlannerBucket {
	ss := &ServiceCollectionPlannerBucket{ServiceBase: s.ServiceBase}
	ss.baseURL += "/buckets"
	return ss
}

// Plans returns service endpoint for CollectionPlannerPlan
func (s *ServicePlanner) Plans() *ServiceCollectionPlannerPlan {
	ss := &ServiceCollectionPlannerPlan{ServiceBase: s.ServiceBase}
	ss.baseURL += "/plans"
	return ss
}

// Tasks returns service endpoint for CollectionPlannerTask
func (s *ServicePlanner) Tasks() *ServiceCollectionPlannerTask {
	ss := &ServiceCollectionPlannerTask{ServiceBase: s.ServiceBase}
	ss.baseURL += "/tasks"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for Planner
func (s *ServicePlanner) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServicePlanner) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for Planner
func (s *ServicePlanner) DoRequestWithPath(method, path string, obj interface{}) (*Planner, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *Planner
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServicePlanner) DoRequest(method string, obj interface{}) (*Planner, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServicePlanner) GetWithPath(path string) (*Planner, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServicePlanner) Get() (*Planner, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServicePlanner) PostWithPath(path string) (*Planner, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServicePlanner) Post() (*Planner, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for PlannerAssignedToTaskBoardTaskFormat
func (s *ServicePlannerAssignedToTaskBoardTaskFormat) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServicePlannerAssignedToTaskBoardTaskFormat) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for PlannerAssignedToTaskBoardTaskFormat
func (s *ServicePlannerAssignedToTaskBoardTaskFormat) DoRequestWithPath(method, path string, obj interface{}) (*PlannerAssignedToTaskBoardTaskFormat, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *PlannerAssignedToTaskBoardTaskFormat
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServicePlannerAssignedToTaskBoardTaskFormat) DoRequest(method string, obj interface{}) (*PlannerAssignedToTaskBoardTaskFormat, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServicePlannerAssignedToTaskBoardTaskFormat) GetWithPath(path string) (*PlannerAssignedToTaskBoardTaskFormat, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServicePlannerAssignedToTaskBoardTaskFormat) Get() (*PlannerAssignedToTaskBoardTaskFormat, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServicePlannerAssignedToTaskBoardTaskFormat) PostWithPath(path string) (*PlannerAssignedToTaskBoardTaskFormat, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServicePlannerAssignedToTaskBoardTaskFormat) Post() (*PlannerAssignedToTaskBoardTaskFormat, error) {
	return s.PostWithPath("")
}

// Tasks returns service endpoint for CollectionPlannerTask
func (s *ServicePlannerBucket) Tasks() *ServiceCollectionPlannerTask {
	ss := &ServiceCollectionPlannerTask{ServiceBase: s.ServiceBase}
	ss.baseURL += "/tasks"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for PlannerBucket
func (s *ServicePlannerBucket) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServicePlannerBucket) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for PlannerBucket
func (s *ServicePlannerBucket) DoRequestWithPath(method, path string, obj interface{}) (*PlannerBucket, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *PlannerBucket
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServicePlannerBucket) DoRequest(method string, obj interface{}) (*PlannerBucket, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServicePlannerBucket) GetWithPath(path string) (*PlannerBucket, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServicePlannerBucket) Get() (*PlannerBucket, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServicePlannerBucket) PostWithPath(path string) (*PlannerBucket, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServicePlannerBucket) Post() (*PlannerBucket, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for PlannerBucket collection with addtional path
func (s *ServiceCollectionPlannerBucket) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionPlannerBucket) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for PlannerBucket
func (s *ServiceCollectionPlannerBucket) DoRequestWithPath(method, path string, obj interface{}) (*PlannerBucket, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *PlannerBucket
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionPlannerBucket) DoRequest(method string, obj interface{}) (*PlannerBucket, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for PlannerBucket collection
func (s *ServiceCollectionPlannerBucket) DoPagingNext(res *http.Response) ([]PlannerBucket, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []PlannerBucket
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for PlannerBucket collection
func (s *ServiceCollectionPlannerBucket) DoPagingWithPath(method, path string, obj interface{}) ([]PlannerBucket, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionPlannerBucket) DoPaging(method string, obj interface{}) ([]PlannerBucket, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionPlannerBucket) GetWithPath(path string) ([]PlannerBucket, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionPlannerBucket) Get() ([]PlannerBucket, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionPlannerBucket) PostWithPath(path string, obj interface{}) (*PlannerBucket, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionPlannerBucket) Post(obj interface{}) (*PlannerBucket, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for PlannerBucketTaskBoardTaskFormat
func (s *ServicePlannerBucketTaskBoardTaskFormat) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServicePlannerBucketTaskBoardTaskFormat) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for PlannerBucketTaskBoardTaskFormat
func (s *ServicePlannerBucketTaskBoardTaskFormat) DoRequestWithPath(method, path string, obj interface{}) (*PlannerBucketTaskBoardTaskFormat, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *PlannerBucketTaskBoardTaskFormat
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServicePlannerBucketTaskBoardTaskFormat) DoRequest(method string, obj interface{}) (*PlannerBucketTaskBoardTaskFormat, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServicePlannerBucketTaskBoardTaskFormat) GetWithPath(path string) (*PlannerBucketTaskBoardTaskFormat, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServicePlannerBucketTaskBoardTaskFormat) Get() (*PlannerBucketTaskBoardTaskFormat, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServicePlannerBucketTaskBoardTaskFormat) PostWithPath(path string) (*PlannerBucketTaskBoardTaskFormat, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServicePlannerBucketTaskBoardTaskFormat) Post() (*PlannerBucketTaskBoardTaskFormat, error) {
	return s.PostWithPath("")
}

// Plans returns service endpoint for CollectionPlannerPlan
func (s *ServicePlannerGroup) Plans() *ServiceCollectionPlannerPlan {
	ss := &ServiceCollectionPlannerPlan{ServiceBase: s.ServiceBase}
	ss.baseURL += "/plans"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for PlannerGroup
func (s *ServicePlannerGroup) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServicePlannerGroup) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for PlannerGroup
func (s *ServicePlannerGroup) DoRequestWithPath(method, path string, obj interface{}) (*PlannerGroup, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *PlannerGroup
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServicePlannerGroup) DoRequest(method string, obj interface{}) (*PlannerGroup, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServicePlannerGroup) GetWithPath(path string) (*PlannerGroup, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServicePlannerGroup) Get() (*PlannerGroup, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServicePlannerGroup) PostWithPath(path string) (*PlannerGroup, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServicePlannerGroup) Post() (*PlannerGroup, error) {
	return s.PostWithPath("")
}

// Buckets returns service endpoint for CollectionPlannerBucket
func (s *ServicePlannerPlan) Buckets() *ServiceCollectionPlannerBucket {
	ss := &ServiceCollectionPlannerBucket{ServiceBase: s.ServiceBase}
	ss.baseURL += "/buckets"
	return ss
}

// Details returns service endpoint for PlannerPlanDetails
func (s *ServicePlannerPlan) Details() *ServicePlannerPlanDetails {
	ss := &ServicePlannerPlanDetails{ServiceBase: s.ServiceBase}
	ss.baseURL += "/details"
	return ss
}

// Tasks returns service endpoint for CollectionPlannerTask
func (s *ServicePlannerPlan) Tasks() *ServiceCollectionPlannerTask {
	ss := &ServiceCollectionPlannerTask{ServiceBase: s.ServiceBase}
	ss.baseURL += "/tasks"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for PlannerPlan
func (s *ServicePlannerPlan) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServicePlannerPlan) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for PlannerPlan
func (s *ServicePlannerPlan) DoRequestWithPath(method, path string, obj interface{}) (*PlannerPlan, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *PlannerPlan
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServicePlannerPlan) DoRequest(method string, obj interface{}) (*PlannerPlan, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServicePlannerPlan) GetWithPath(path string) (*PlannerPlan, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServicePlannerPlan) Get() (*PlannerPlan, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServicePlannerPlan) PostWithPath(path string) (*PlannerPlan, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServicePlannerPlan) Post() (*PlannerPlan, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for PlannerPlan collection with addtional path
func (s *ServiceCollectionPlannerPlan) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionPlannerPlan) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for PlannerPlan
func (s *ServiceCollectionPlannerPlan) DoRequestWithPath(method, path string, obj interface{}) (*PlannerPlan, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *PlannerPlan
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionPlannerPlan) DoRequest(method string, obj interface{}) (*PlannerPlan, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for PlannerPlan collection
func (s *ServiceCollectionPlannerPlan) DoPagingNext(res *http.Response) ([]PlannerPlan, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []PlannerPlan
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for PlannerPlan collection
func (s *ServiceCollectionPlannerPlan) DoPagingWithPath(method, path string, obj interface{}) ([]PlannerPlan, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionPlannerPlan) DoPaging(method string, obj interface{}) ([]PlannerPlan, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionPlannerPlan) GetWithPath(path string) ([]PlannerPlan, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionPlannerPlan) Get() ([]PlannerPlan, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionPlannerPlan) PostWithPath(path string, obj interface{}) (*PlannerPlan, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionPlannerPlan) Post(obj interface{}) (*PlannerPlan, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for PlannerPlanDetails
func (s *ServicePlannerPlanDetails) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServicePlannerPlanDetails) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for PlannerPlanDetails
func (s *ServicePlannerPlanDetails) DoRequestWithPath(method, path string, obj interface{}) (*PlannerPlanDetails, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *PlannerPlanDetails
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServicePlannerPlanDetails) DoRequest(method string, obj interface{}) (*PlannerPlanDetails, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServicePlannerPlanDetails) GetWithPath(path string) (*PlannerPlanDetails, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServicePlannerPlanDetails) Get() (*PlannerPlanDetails, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServicePlannerPlanDetails) PostWithPath(path string) (*PlannerPlanDetails, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServicePlannerPlanDetails) Post() (*PlannerPlanDetails, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for PlannerProgressTaskBoardTaskFormat
func (s *ServicePlannerProgressTaskBoardTaskFormat) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServicePlannerProgressTaskBoardTaskFormat) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for PlannerProgressTaskBoardTaskFormat
func (s *ServicePlannerProgressTaskBoardTaskFormat) DoRequestWithPath(method, path string, obj interface{}) (*PlannerProgressTaskBoardTaskFormat, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *PlannerProgressTaskBoardTaskFormat
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServicePlannerProgressTaskBoardTaskFormat) DoRequest(method string, obj interface{}) (*PlannerProgressTaskBoardTaskFormat, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServicePlannerProgressTaskBoardTaskFormat) GetWithPath(path string) (*PlannerProgressTaskBoardTaskFormat, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServicePlannerProgressTaskBoardTaskFormat) Get() (*PlannerProgressTaskBoardTaskFormat, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServicePlannerProgressTaskBoardTaskFormat) PostWithPath(path string) (*PlannerProgressTaskBoardTaskFormat, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServicePlannerProgressTaskBoardTaskFormat) Post() (*PlannerProgressTaskBoardTaskFormat, error) {
	return s.PostWithPath("")
}

// AssignedToTaskBoardFormat returns service endpoint for PlannerAssignedToTaskBoardTaskFormat
func (s *ServicePlannerTask) AssignedToTaskBoardFormat() *ServicePlannerAssignedToTaskBoardTaskFormat {
	ss := &ServicePlannerAssignedToTaskBoardTaskFormat{ServiceBase: s.ServiceBase}
	ss.baseURL += "/assignedToTaskBoardFormat"
	return ss
}

// BucketTaskBoardFormat returns service endpoint for PlannerBucketTaskBoardTaskFormat
func (s *ServicePlannerTask) BucketTaskBoardFormat() *ServicePlannerBucketTaskBoardTaskFormat {
	ss := &ServicePlannerBucketTaskBoardTaskFormat{ServiceBase: s.ServiceBase}
	ss.baseURL += "/bucketTaskBoardFormat"
	return ss
}

// Details returns service endpoint for PlannerTaskDetails
func (s *ServicePlannerTask) Details() *ServicePlannerTaskDetails {
	ss := &ServicePlannerTaskDetails{ServiceBase: s.ServiceBase}
	ss.baseURL += "/details"
	return ss
}

// ProgressTaskBoardFormat returns service endpoint for PlannerProgressTaskBoardTaskFormat
func (s *ServicePlannerTask) ProgressTaskBoardFormat() *ServicePlannerProgressTaskBoardTaskFormat {
	ss := &ServicePlannerProgressTaskBoardTaskFormat{ServiceBase: s.ServiceBase}
	ss.baseURL += "/progressTaskBoardFormat"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for PlannerTask
func (s *ServicePlannerTask) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServicePlannerTask) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for PlannerTask
func (s *ServicePlannerTask) DoRequestWithPath(method, path string, obj interface{}) (*PlannerTask, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *PlannerTask
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServicePlannerTask) DoRequest(method string, obj interface{}) (*PlannerTask, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServicePlannerTask) GetWithPath(path string) (*PlannerTask, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServicePlannerTask) Get() (*PlannerTask, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServicePlannerTask) PostWithPath(path string) (*PlannerTask, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServicePlannerTask) Post() (*PlannerTask, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for PlannerTask collection with addtional path
func (s *ServiceCollectionPlannerTask) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionPlannerTask) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for PlannerTask
func (s *ServiceCollectionPlannerTask) DoRequestWithPath(method, path string, obj interface{}) (*PlannerTask, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *PlannerTask
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionPlannerTask) DoRequest(method string, obj interface{}) (*PlannerTask, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for PlannerTask collection
func (s *ServiceCollectionPlannerTask) DoPagingNext(res *http.Response) ([]PlannerTask, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []PlannerTask
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for PlannerTask collection
func (s *ServiceCollectionPlannerTask) DoPagingWithPath(method, path string, obj interface{}) ([]PlannerTask, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionPlannerTask) DoPaging(method string, obj interface{}) ([]PlannerTask, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionPlannerTask) GetWithPath(path string) ([]PlannerTask, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionPlannerTask) Get() ([]PlannerTask, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionPlannerTask) PostWithPath(path string, obj interface{}) (*PlannerTask, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionPlannerTask) Post(obj interface{}) (*PlannerTask, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for PlannerTaskDetails
func (s *ServicePlannerTaskDetails) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServicePlannerTaskDetails) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for PlannerTaskDetails
func (s *ServicePlannerTaskDetails) DoRequestWithPath(method, path string, obj interface{}) (*PlannerTaskDetails, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *PlannerTaskDetails
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServicePlannerTaskDetails) DoRequest(method string, obj interface{}) (*PlannerTaskDetails, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServicePlannerTaskDetails) GetWithPath(path string) (*PlannerTaskDetails, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServicePlannerTaskDetails) Get() (*PlannerTaskDetails, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServicePlannerTaskDetails) PostWithPath(path string) (*PlannerTaskDetails, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServicePlannerTaskDetails) Post() (*PlannerTaskDetails, error) {
	return s.PostWithPath("")
}

// Plans returns service endpoint for CollectionPlannerPlan
func (s *ServicePlannerUser) Plans() *ServiceCollectionPlannerPlan {
	ss := &ServiceCollectionPlannerPlan{ServiceBase: s.ServiceBase}
	ss.baseURL += "/plans"
	return ss
}

// Tasks returns service endpoint for CollectionPlannerTask
func (s *ServicePlannerUser) Tasks() *ServiceCollectionPlannerTask {
	ss := &ServiceCollectionPlannerTask{ServiceBase: s.ServiceBase}
	ss.baseURL += "/tasks"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for PlannerUser
func (s *ServicePlannerUser) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServicePlannerUser) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for PlannerUser
func (s *ServicePlannerUser) DoRequestWithPath(method, path string, obj interface{}) (*PlannerUser, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *PlannerUser
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServicePlannerUser) DoRequest(method string, obj interface{}) (*PlannerUser, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServicePlannerUser) GetWithPath(path string) (*PlannerUser, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServicePlannerUser) Get() (*PlannerUser, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServicePlannerUser) PostWithPath(path string) (*PlannerUser, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServicePlannerUser) Post() (*PlannerUser, error) {
	return s.PostWithPath("")
}

// Attachments returns service endpoint for CollectionAttachment
func (s *ServicePost) Attachments() *ServiceCollectionAttachment {
	ss := &ServiceCollectionAttachment{ServiceBase: s.ServiceBase}
	ss.baseURL += "/attachments"
	return ss
}

// Extensions returns service endpoint for CollectionExtension
func (s *ServicePost) Extensions() *ServiceCollectionExtension {
	ss := &ServiceCollectionExtension{ServiceBase: s.ServiceBase}
	ss.baseURL += "/extensions"
	return ss
}

// InReplyTo returns service endpoint for Post
func (s *ServicePost) InReplyTo() *ServicePost {
	ss := &ServicePost{ServiceBase: s.ServiceBase}
	ss.baseURL += "/inReplyTo"
	return ss
}

// MultiValueExtendedProperties returns service endpoint for CollectionMultiValueLegacyExtendedProperty
func (s *ServicePost) MultiValueExtendedProperties() *ServiceCollectionMultiValueLegacyExtendedProperty {
	ss := &ServiceCollectionMultiValueLegacyExtendedProperty{ServiceBase: s.ServiceBase}
	ss.baseURL += "/multiValueExtendedProperties"
	return ss
}

// SingleValueExtendedProperties returns service endpoint for CollectionSingleValueLegacyExtendedProperty
func (s *ServicePost) SingleValueExtendedProperties() *ServiceCollectionSingleValueLegacyExtendedProperty {
	ss := &ServiceCollectionSingleValueLegacyExtendedProperty{ServiceBase: s.ServiceBase}
	ss.baseURL += "/singleValueExtendedProperties"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for Post
func (s *ServicePost) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServicePost) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for Post
func (s *ServicePost) DoRequestWithPath(method, path string, obj interface{}) (*Post, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *Post
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServicePost) DoRequest(method string, obj interface{}) (*Post, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServicePost) GetWithPath(path string) (*Post, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServicePost) Get() (*Post, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServicePost) PostWithPath(path string) (*Post, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServicePost) Post() (*Post, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for Post collection with addtional path
func (s *ServiceCollectionPost) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionPost) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for Post
func (s *ServiceCollectionPost) DoRequestWithPath(method, path string, obj interface{}) (*Post, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *Post
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionPost) DoRequest(method string, obj interface{}) (*Post, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for Post collection
func (s *ServiceCollectionPost) DoPagingNext(res *http.Response) ([]Post, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []Post
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for Post collection
func (s *ServiceCollectionPost) DoPagingWithPath(method, path string, obj interface{}) ([]Post, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionPost) DoPaging(method string, obj interface{}) ([]Post, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionPost) GetWithPath(path string) ([]Post, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionPost) Get() ([]Post, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionPost) PostWithPath(path string, obj interface{}) (*Post, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionPost) Post(obj interface{}) (*Post, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for ProfilePhoto
func (s *ServiceProfilePhoto) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceProfilePhoto) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for ProfilePhoto
func (s *ServiceProfilePhoto) DoRequestWithPath(method, path string, obj interface{}) (*ProfilePhoto, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *ProfilePhoto
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceProfilePhoto) DoRequest(method string, obj interface{}) (*ProfilePhoto, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceProfilePhoto) GetWithPath(path string) (*ProfilePhoto, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceProfilePhoto) Get() (*ProfilePhoto, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceProfilePhoto) PostWithPath(path string) (*ProfilePhoto, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceProfilePhoto) Post() (*ProfilePhoto, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for ProfilePhoto collection with addtional path
func (s *ServiceCollectionProfilePhoto) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionProfilePhoto) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for ProfilePhoto
func (s *ServiceCollectionProfilePhoto) DoRequestWithPath(method, path string, obj interface{}) (*ProfilePhoto, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *ProfilePhoto
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionProfilePhoto) DoRequest(method string, obj interface{}) (*ProfilePhoto, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for ProfilePhoto collection
func (s *ServiceCollectionProfilePhoto) DoPagingNext(res *http.Response) ([]ProfilePhoto, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []ProfilePhoto
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for ProfilePhoto collection
func (s *ServiceCollectionProfilePhoto) DoPagingWithPath(method, path string, obj interface{}) ([]ProfilePhoto, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionProfilePhoto) DoPaging(method string, obj interface{}) ([]ProfilePhoto, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionProfilePhoto) GetWithPath(path string) ([]ProfilePhoto, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionProfilePhoto) Get() ([]ProfilePhoto, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionProfilePhoto) PostWithPath(path string, obj interface{}) (*ProfilePhoto, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionProfilePhoto) Post(obj interface{}) (*ProfilePhoto, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for RemoteAssistancePartner collection with addtional path
func (s *ServiceCollectionRemoteAssistancePartner) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionRemoteAssistancePartner) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for RemoteAssistancePartner
func (s *ServiceCollectionRemoteAssistancePartner) DoRequestWithPath(method, path string, obj interface{}) (*RemoteAssistancePartner, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *RemoteAssistancePartner
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionRemoteAssistancePartner) DoRequest(method string, obj interface{}) (*RemoteAssistancePartner, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for RemoteAssistancePartner collection
func (s *ServiceCollectionRemoteAssistancePartner) DoPagingNext(res *http.Response) ([]RemoteAssistancePartner, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []RemoteAssistancePartner
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for RemoteAssistancePartner collection
func (s *ServiceCollectionRemoteAssistancePartner) DoPagingWithPath(method, path string, obj interface{}) ([]RemoteAssistancePartner, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionRemoteAssistancePartner) DoPaging(method string, obj interface{}) ([]RemoteAssistancePartner, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionRemoteAssistancePartner) GetWithPath(path string) ([]RemoteAssistancePartner, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionRemoteAssistancePartner) Get() ([]RemoteAssistancePartner, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionRemoteAssistancePartner) PostWithPath(path string, obj interface{}) (*RemoteAssistancePartner, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionRemoteAssistancePartner) Post(obj interface{}) (*RemoteAssistancePartner, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for ReportRoot
func (s *ServiceReportRoot) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceReportRoot) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for ReportRoot
func (s *ServiceReportRoot) DoRequestWithPath(method, path string, obj interface{}) (*ReportRoot, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *ReportRoot
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceReportRoot) DoRequest(method string, obj interface{}) (*ReportRoot, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceReportRoot) GetWithPath(path string) (*ReportRoot, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceReportRoot) Get() (*ReportRoot, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceReportRoot) PostWithPath(path string) (*ReportRoot, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceReportRoot) Post() (*ReportRoot, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for ResourceOperation collection with addtional path
func (s *ServiceCollectionResourceOperation) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionResourceOperation) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for ResourceOperation
func (s *ServiceCollectionResourceOperation) DoRequestWithPath(method, path string, obj interface{}) (*ResourceOperation, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *ResourceOperation
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionResourceOperation) DoRequest(method string, obj interface{}) (*ResourceOperation, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for ResourceOperation collection
func (s *ServiceCollectionResourceOperation) DoPagingNext(res *http.Response) ([]ResourceOperation, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []ResourceOperation
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for ResourceOperation collection
func (s *ServiceCollectionResourceOperation) DoPagingWithPath(method, path string, obj interface{}) ([]ResourceOperation, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionResourceOperation) DoPaging(method string, obj interface{}) ([]ResourceOperation, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionResourceOperation) GetWithPath(path string) ([]ResourceOperation, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionResourceOperation) Get() ([]ResourceOperation, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionResourceOperation) PostWithPath(path string, obj interface{}) (*ResourceOperation, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionResourceOperation) Post(obj interface{}) (*ResourceOperation, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for RestrictedSignIn collection with addtional path
func (s *ServiceCollectionRestrictedSignIn) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionRestrictedSignIn) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for RestrictedSignIn
func (s *ServiceCollectionRestrictedSignIn) DoRequestWithPath(method, path string, obj interface{}) (*RestrictedSignIn, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *RestrictedSignIn
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionRestrictedSignIn) DoRequest(method string, obj interface{}) (*RestrictedSignIn, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for RestrictedSignIn collection
func (s *ServiceCollectionRestrictedSignIn) DoPagingNext(res *http.Response) ([]RestrictedSignIn, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []RestrictedSignIn
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for RestrictedSignIn collection
func (s *ServiceCollectionRestrictedSignIn) DoPagingWithPath(method, path string, obj interface{}) ([]RestrictedSignIn, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionRestrictedSignIn) DoPaging(method string, obj interface{}) ([]RestrictedSignIn, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionRestrictedSignIn) GetWithPath(path string) ([]RestrictedSignIn, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionRestrictedSignIn) Get() ([]RestrictedSignIn, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionRestrictedSignIn) PostWithPath(path string, obj interface{}) (*RestrictedSignIn, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionRestrictedSignIn) Post(obj interface{}) (*RestrictedSignIn, error) {
	return s.PostWithPath("", obj)
}

// RoleDefinition returns service endpoint for RoleDefinition
func (s *ServiceRoleAssignment) RoleDefinition() *ServiceRoleDefinition {
	ss := &ServiceRoleDefinition{ServiceBase: s.ServiceBase}
	ss.baseURL += "/roleDefinition"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for RoleAssignment
func (s *ServiceRoleAssignment) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceRoleAssignment) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for RoleAssignment
func (s *ServiceRoleAssignment) DoRequestWithPath(method, path string, obj interface{}) (*RoleAssignment, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *RoleAssignment
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceRoleAssignment) DoRequest(method string, obj interface{}) (*RoleAssignment, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceRoleAssignment) GetWithPath(path string) (*RoleAssignment, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceRoleAssignment) Get() (*RoleAssignment, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceRoleAssignment) PostWithPath(path string) (*RoleAssignment, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceRoleAssignment) Post() (*RoleAssignment, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for RoleAssignment collection with addtional path
func (s *ServiceCollectionRoleAssignment) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionRoleAssignment) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for RoleAssignment
func (s *ServiceCollectionRoleAssignment) DoRequestWithPath(method, path string, obj interface{}) (*RoleAssignment, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *RoleAssignment
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionRoleAssignment) DoRequest(method string, obj interface{}) (*RoleAssignment, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for RoleAssignment collection
func (s *ServiceCollectionRoleAssignment) DoPagingNext(res *http.Response) ([]RoleAssignment, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []RoleAssignment
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for RoleAssignment collection
func (s *ServiceCollectionRoleAssignment) DoPagingWithPath(method, path string, obj interface{}) ([]RoleAssignment, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionRoleAssignment) DoPaging(method string, obj interface{}) ([]RoleAssignment, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionRoleAssignment) GetWithPath(path string) ([]RoleAssignment, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionRoleAssignment) Get() ([]RoleAssignment, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionRoleAssignment) PostWithPath(path string, obj interface{}) (*RoleAssignment, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionRoleAssignment) Post(obj interface{}) (*RoleAssignment, error) {
	return s.PostWithPath("", obj)
}

// RoleAssignments returns service endpoint for CollectionRoleAssignment
func (s *ServiceRoleDefinition) RoleAssignments() *ServiceCollectionRoleAssignment {
	ss := &ServiceCollectionRoleAssignment{ServiceBase: s.ServiceBase}
	ss.baseURL += "/roleAssignments"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for RoleDefinition
func (s *ServiceRoleDefinition) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceRoleDefinition) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for RoleDefinition
func (s *ServiceRoleDefinition) DoRequestWithPath(method, path string, obj interface{}) (*RoleDefinition, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *RoleDefinition
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceRoleDefinition) DoRequest(method string, obj interface{}) (*RoleDefinition, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceRoleDefinition) GetWithPath(path string) (*RoleDefinition, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceRoleDefinition) Get() (*RoleDefinition, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceRoleDefinition) PostWithPath(path string) (*RoleDefinition, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceRoleDefinition) Post() (*RoleDefinition, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for RoleDefinition collection with addtional path
func (s *ServiceCollectionRoleDefinition) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionRoleDefinition) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for RoleDefinition
func (s *ServiceCollectionRoleDefinition) DoRequestWithPath(method, path string, obj interface{}) (*RoleDefinition, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *RoleDefinition
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionRoleDefinition) DoRequest(method string, obj interface{}) (*RoleDefinition, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for RoleDefinition collection
func (s *ServiceCollectionRoleDefinition) DoPagingNext(res *http.Response) ([]RoleDefinition, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []RoleDefinition
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for RoleDefinition collection
func (s *ServiceCollectionRoleDefinition) DoPagingWithPath(method, path string, obj interface{}) ([]RoleDefinition, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionRoleDefinition) DoPaging(method string, obj interface{}) ([]RoleDefinition, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionRoleDefinition) GetWithPath(path string) ([]RoleDefinition, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionRoleDefinition) Get() ([]RoleDefinition, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionRoleDefinition) PostWithPath(path string, obj interface{}) (*RoleDefinition, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionRoleDefinition) Post(obj interface{}) (*RoleDefinition, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for SchemaExtension
func (s *ServiceSchemaExtension) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceSchemaExtension) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for SchemaExtension
func (s *ServiceSchemaExtension) DoRequestWithPath(method, path string, obj interface{}) (*SchemaExtension, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *SchemaExtension
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceSchemaExtension) DoRequest(method string, obj interface{}) (*SchemaExtension, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceSchemaExtension) GetWithPath(path string) (*SchemaExtension, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceSchemaExtension) Get() (*SchemaExtension, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceSchemaExtension) PostWithPath(path string) (*SchemaExtension, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceSchemaExtension) Post() (*SchemaExtension, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for SchemaExtension collection with addtional path
func (s *ServiceCollectionSchemaExtension) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionSchemaExtension) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for SchemaExtension
func (s *ServiceCollectionSchemaExtension) DoRequestWithPath(method, path string, obj interface{}) (*SchemaExtension, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *SchemaExtension
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionSchemaExtension) DoRequest(method string, obj interface{}) (*SchemaExtension, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for SchemaExtension collection
func (s *ServiceCollectionSchemaExtension) DoPagingNext(res *http.Response) ([]SchemaExtension, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []SchemaExtension
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for SchemaExtension collection
func (s *ServiceCollectionSchemaExtension) DoPagingWithPath(method, path string, obj interface{}) ([]SchemaExtension, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionSchemaExtension) DoPaging(method string, obj interface{}) ([]SchemaExtension, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionSchemaExtension) GetWithPath(path string) ([]SchemaExtension, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionSchemaExtension) Get() ([]SchemaExtension, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionSchemaExtension) PostWithPath(path string, obj interface{}) (*SchemaExtension, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionSchemaExtension) Post(obj interface{}) (*SchemaExtension, error) {
	return s.PostWithPath("", obj)
}

// ParentNotebook returns service endpoint for Notebook
func (s *ServiceSectionGroup) ParentNotebook() *ServiceNotebook {
	ss := &ServiceNotebook{ServiceBase: s.ServiceBase}
	ss.baseURL += "/parentNotebook"
	return ss
}

// ParentSectionGroup returns service endpoint for SectionGroup
func (s *ServiceSectionGroup) ParentSectionGroup() *ServiceSectionGroup {
	ss := &ServiceSectionGroup{ServiceBase: s.ServiceBase}
	ss.baseURL += "/parentSectionGroup"
	return ss
}

// SectionGroups returns service endpoint for CollectionSectionGroup
func (s *ServiceSectionGroup) SectionGroups() *ServiceCollectionSectionGroup {
	ss := &ServiceCollectionSectionGroup{ServiceBase: s.ServiceBase}
	ss.baseURL += "/sectionGroups"
	return ss
}

// Sections returns service endpoint for CollectionOnenoteSection
func (s *ServiceSectionGroup) Sections() *ServiceCollectionOnenoteSection {
	ss := &ServiceCollectionOnenoteSection{ServiceBase: s.ServiceBase}
	ss.baseURL += "/sections"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for SectionGroup
func (s *ServiceSectionGroup) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceSectionGroup) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for SectionGroup
func (s *ServiceSectionGroup) DoRequestWithPath(method, path string, obj interface{}) (*SectionGroup, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *SectionGroup
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceSectionGroup) DoRequest(method string, obj interface{}) (*SectionGroup, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceSectionGroup) GetWithPath(path string) (*SectionGroup, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceSectionGroup) Get() (*SectionGroup, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceSectionGroup) PostWithPath(path string) (*SectionGroup, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceSectionGroup) Post() (*SectionGroup, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for SectionGroup collection with addtional path
func (s *ServiceCollectionSectionGroup) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionSectionGroup) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for SectionGroup
func (s *ServiceCollectionSectionGroup) DoRequestWithPath(method, path string, obj interface{}) (*SectionGroup, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *SectionGroup
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionSectionGroup) DoRequest(method string, obj interface{}) (*SectionGroup, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for SectionGroup collection
func (s *ServiceCollectionSectionGroup) DoPagingNext(res *http.Response) ([]SectionGroup, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []SectionGroup
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for SectionGroup collection
func (s *ServiceCollectionSectionGroup) DoPagingWithPath(method, path string, obj interface{}) ([]SectionGroup, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionSectionGroup) DoPaging(method string, obj interface{}) ([]SectionGroup, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionSectionGroup) GetWithPath(path string) ([]SectionGroup, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionSectionGroup) Get() ([]SectionGroup, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionSectionGroup) PostWithPath(path string, obj interface{}) (*SectionGroup, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionSectionGroup) Post(obj interface{}) (*SectionGroup, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for SecureScore collection with addtional path
func (s *ServiceCollectionSecureScore) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionSecureScore) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for SecureScore
func (s *ServiceCollectionSecureScore) DoRequestWithPath(method, path string, obj interface{}) (*SecureScore, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *SecureScore
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionSecureScore) DoRequest(method string, obj interface{}) (*SecureScore, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for SecureScore collection
func (s *ServiceCollectionSecureScore) DoPagingNext(res *http.Response) ([]SecureScore, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []SecureScore
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for SecureScore collection
func (s *ServiceCollectionSecureScore) DoPagingWithPath(method, path string, obj interface{}) ([]SecureScore, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionSecureScore) DoPaging(method string, obj interface{}) ([]SecureScore, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionSecureScore) GetWithPath(path string) ([]SecureScore, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionSecureScore) Get() ([]SecureScore, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionSecureScore) PostWithPath(path string, obj interface{}) (*SecureScore, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionSecureScore) Post(obj interface{}) (*SecureScore, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for SecureScoreControlProfile collection with addtional path
func (s *ServiceCollectionSecureScoreControlProfile) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionSecureScoreControlProfile) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for SecureScoreControlProfile
func (s *ServiceCollectionSecureScoreControlProfile) DoRequestWithPath(method, path string, obj interface{}) (*SecureScoreControlProfile, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *SecureScoreControlProfile
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionSecureScoreControlProfile) DoRequest(method string, obj interface{}) (*SecureScoreControlProfile, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for SecureScoreControlProfile collection
func (s *ServiceCollectionSecureScoreControlProfile) DoPagingNext(res *http.Response) ([]SecureScoreControlProfile, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []SecureScoreControlProfile
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for SecureScoreControlProfile collection
func (s *ServiceCollectionSecureScoreControlProfile) DoPagingWithPath(method, path string, obj interface{}) ([]SecureScoreControlProfile, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionSecureScoreControlProfile) DoPaging(method string, obj interface{}) ([]SecureScoreControlProfile, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionSecureScoreControlProfile) GetWithPath(path string) ([]SecureScoreControlProfile, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionSecureScoreControlProfile) Get() ([]SecureScoreControlProfile, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionSecureScoreControlProfile) PostWithPath(path string, obj interface{}) (*SecureScoreControlProfile, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionSecureScoreControlProfile) Post(obj interface{}) (*SecureScoreControlProfile, error) {
	return s.PostWithPath("", obj)
}

// Alerts returns service endpoint for CollectionAlert
func (s *ServiceSecurity) Alerts() *ServiceCollectionAlert {
	ss := &ServiceCollectionAlert{ServiceBase: s.ServiceBase}
	ss.baseURL += "/alerts"
	return ss
}

// SecureScoreControlProfiles returns service endpoint for CollectionSecureScoreControlProfile
func (s *ServiceSecurity) SecureScoreControlProfiles() *ServiceCollectionSecureScoreControlProfile {
	ss := &ServiceCollectionSecureScoreControlProfile{ServiceBase: s.ServiceBase}
	ss.baseURL += "/secureScoreControlProfiles"
	return ss
}

// SecureScores returns service endpoint for CollectionSecureScore
func (s *ServiceSecurity) SecureScores() *ServiceCollectionSecureScore {
	ss := &ServiceCollectionSecureScore{ServiceBase: s.ServiceBase}
	ss.baseURL += "/secureScores"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for Security
func (s *ServiceSecurity) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceSecurity) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for Security
func (s *ServiceSecurity) DoRequestWithPath(method, path string, obj interface{}) (*Security, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *Security
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceSecurity) DoRequest(method string, obj interface{}) (*Security, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceSecurity) GetWithPath(path string) (*Security, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceSecurity) Get() (*Security, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceSecurity) PostWithPath(path string) (*Security, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceSecurity) Post() (*Security, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for SettingStateDeviceSummary collection with addtional path
func (s *ServiceCollectionSettingStateDeviceSummary) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionSettingStateDeviceSummary) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for SettingStateDeviceSummary
func (s *ServiceCollectionSettingStateDeviceSummary) DoRequestWithPath(method, path string, obj interface{}) (*SettingStateDeviceSummary, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *SettingStateDeviceSummary
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionSettingStateDeviceSummary) DoRequest(method string, obj interface{}) (*SettingStateDeviceSummary, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for SettingStateDeviceSummary collection
func (s *ServiceCollectionSettingStateDeviceSummary) DoPagingNext(res *http.Response) ([]SettingStateDeviceSummary, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []SettingStateDeviceSummary
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for SettingStateDeviceSummary collection
func (s *ServiceCollectionSettingStateDeviceSummary) DoPagingWithPath(method, path string, obj interface{}) ([]SettingStateDeviceSummary, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionSettingStateDeviceSummary) DoPaging(method string, obj interface{}) ([]SettingStateDeviceSummary, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionSettingStateDeviceSummary) GetWithPath(path string) ([]SettingStateDeviceSummary, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionSettingStateDeviceSummary) Get() ([]SettingStateDeviceSummary, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionSettingStateDeviceSummary) PostWithPath(path string, obj interface{}) (*SettingStateDeviceSummary, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionSettingStateDeviceSummary) Post(obj interface{}) (*SettingStateDeviceSummary, error) {
	return s.PostWithPath("", obj)
}

// DriveItem returns service endpoint for DriveItem
func (s *ServiceSharedDriveItem) DriveItem() *ServiceDriveItem {
	ss := &ServiceDriveItem{ServiceBase: s.ServiceBase}
	ss.baseURL += "/driveItem"
	return ss
}

// Items returns service endpoint for CollectionDriveItem
func (s *ServiceSharedDriveItem) Items() *ServiceCollectionDriveItem {
	ss := &ServiceCollectionDriveItem{ServiceBase: s.ServiceBase}
	ss.baseURL += "/items"
	return ss
}

// List returns service endpoint for List
func (s *ServiceSharedDriveItem) List() *ServiceList {
	ss := &ServiceList{ServiceBase: s.ServiceBase}
	ss.baseURL += "/list"
	return ss
}

// ListItem returns service endpoint for ListItem
func (s *ServiceSharedDriveItem) ListItem() *ServiceListItem {
	ss := &ServiceListItem{ServiceBase: s.ServiceBase}
	ss.baseURL += "/listItem"
	return ss
}

// Root returns service endpoint for DriveItem
func (s *ServiceSharedDriveItem) Root() *ServiceDriveItem {
	ss := &ServiceDriveItem{ServiceBase: s.ServiceBase}
	ss.baseURL += "/root"
	return ss
}

// Site returns service endpoint for Site
func (s *ServiceSharedDriveItem) Site() *ServiceSite {
	ss := &ServiceSite{ServiceBase: s.ServiceBase}
	ss.baseURL += "/site"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for SharedDriveItem
func (s *ServiceSharedDriveItem) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceSharedDriveItem) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for SharedDriveItem
func (s *ServiceSharedDriveItem) DoRequestWithPath(method, path string, obj interface{}) (*SharedDriveItem, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *SharedDriveItem
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceSharedDriveItem) DoRequest(method string, obj interface{}) (*SharedDriveItem, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceSharedDriveItem) GetWithPath(path string) (*SharedDriveItem, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceSharedDriveItem) Get() (*SharedDriveItem, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceSharedDriveItem) PostWithPath(path string) (*SharedDriveItem, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceSharedDriveItem) Post() (*SharedDriveItem, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for SharedDriveItem collection with addtional path
func (s *ServiceCollectionSharedDriveItem) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionSharedDriveItem) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for SharedDriveItem
func (s *ServiceCollectionSharedDriveItem) DoRequestWithPath(method, path string, obj interface{}) (*SharedDriveItem, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *SharedDriveItem
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionSharedDriveItem) DoRequest(method string, obj interface{}) (*SharedDriveItem, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for SharedDriveItem collection
func (s *ServiceCollectionSharedDriveItem) DoPagingNext(res *http.Response) ([]SharedDriveItem, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []SharedDriveItem
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for SharedDriveItem collection
func (s *ServiceCollectionSharedDriveItem) DoPagingWithPath(method, path string, obj interface{}) ([]SharedDriveItem, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionSharedDriveItem) DoPaging(method string, obj interface{}) ([]SharedDriveItem, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionSharedDriveItem) GetWithPath(path string) ([]SharedDriveItem, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionSharedDriveItem) Get() ([]SharedDriveItem, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionSharedDriveItem) PostWithPath(path string, obj interface{}) (*SharedDriveItem, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionSharedDriveItem) Post(obj interface{}) (*SharedDriveItem, error) {
	return s.PostWithPath("", obj)
}

// LastSharedMethod returns service endpoint for Entity
func (s *ServiceSharedInsight) LastSharedMethod() *ServiceEntity {
	ss := &ServiceEntity{ServiceBase: s.ServiceBase}
	ss.baseURL += "/lastSharedMethod"
	return ss
}

// Resource returns service endpoint for Entity
func (s *ServiceSharedInsight) Resource() *ServiceEntity {
	ss := &ServiceEntity{ServiceBase: s.ServiceBase}
	ss.baseURL += "/resource"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for SharedInsight
func (s *ServiceSharedInsight) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceSharedInsight) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for SharedInsight
func (s *ServiceSharedInsight) DoRequestWithPath(method, path string, obj interface{}) (*SharedInsight, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *SharedInsight
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceSharedInsight) DoRequest(method string, obj interface{}) (*SharedInsight, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceSharedInsight) GetWithPath(path string) (*SharedInsight, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceSharedInsight) Get() (*SharedInsight, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceSharedInsight) PostWithPath(path string) (*SharedInsight, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceSharedInsight) Post() (*SharedInsight, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for SharedInsight collection with addtional path
func (s *ServiceCollectionSharedInsight) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionSharedInsight) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for SharedInsight
func (s *ServiceCollectionSharedInsight) DoRequestWithPath(method, path string, obj interface{}) (*SharedInsight, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *SharedInsight
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionSharedInsight) DoRequest(method string, obj interface{}) (*SharedInsight, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for SharedInsight collection
func (s *ServiceCollectionSharedInsight) DoPagingNext(res *http.Response) ([]SharedInsight, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []SharedInsight
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for SharedInsight collection
func (s *ServiceCollectionSharedInsight) DoPagingWithPath(method, path string, obj interface{}) ([]SharedInsight, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionSharedInsight) DoPaging(method string, obj interface{}) ([]SharedInsight, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionSharedInsight) GetWithPath(path string) ([]SharedInsight, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionSharedInsight) Get() ([]SharedInsight, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionSharedInsight) PostWithPath(path string, obj interface{}) (*SharedInsight, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionSharedInsight) Post(obj interface{}) (*SharedInsight, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for SignIn collection with addtional path
func (s *ServiceCollectionSignIn) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionSignIn) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for SignIn
func (s *ServiceCollectionSignIn) DoRequestWithPath(method, path string, obj interface{}) (*SignIn, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *SignIn
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionSignIn) DoRequest(method string, obj interface{}) (*SignIn, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for SignIn collection
func (s *ServiceCollectionSignIn) DoPagingNext(res *http.Response) ([]SignIn, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []SignIn
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for SignIn collection
func (s *ServiceCollectionSignIn) DoPagingWithPath(method, path string, obj interface{}) ([]SignIn, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionSignIn) DoPaging(method string, obj interface{}) ([]SignIn, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionSignIn) GetWithPath(path string) ([]SignIn, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionSignIn) Get() ([]SignIn, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionSignIn) PostWithPath(path string, obj interface{}) (*SignIn, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionSignIn) Post(obj interface{}) (*SignIn, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for SingleValueLegacyExtendedProperty collection with addtional path
func (s *ServiceCollectionSingleValueLegacyExtendedProperty) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionSingleValueLegacyExtendedProperty) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for SingleValueLegacyExtendedProperty
func (s *ServiceCollectionSingleValueLegacyExtendedProperty) DoRequestWithPath(method, path string, obj interface{}) (*SingleValueLegacyExtendedProperty, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *SingleValueLegacyExtendedProperty
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionSingleValueLegacyExtendedProperty) DoRequest(method string, obj interface{}) (*SingleValueLegacyExtendedProperty, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for SingleValueLegacyExtendedProperty collection
func (s *ServiceCollectionSingleValueLegacyExtendedProperty) DoPagingNext(res *http.Response) ([]SingleValueLegacyExtendedProperty, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []SingleValueLegacyExtendedProperty
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for SingleValueLegacyExtendedProperty collection
func (s *ServiceCollectionSingleValueLegacyExtendedProperty) DoPagingWithPath(method, path string, obj interface{}) ([]SingleValueLegacyExtendedProperty, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionSingleValueLegacyExtendedProperty) DoPaging(method string, obj interface{}) ([]SingleValueLegacyExtendedProperty, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionSingleValueLegacyExtendedProperty) GetWithPath(path string) ([]SingleValueLegacyExtendedProperty, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionSingleValueLegacyExtendedProperty) Get() ([]SingleValueLegacyExtendedProperty, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionSingleValueLegacyExtendedProperty) PostWithPath(path string, obj interface{}) (*SingleValueLegacyExtendedProperty, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionSingleValueLegacyExtendedProperty) Post(obj interface{}) (*SingleValueLegacyExtendedProperty, error) {
	return s.PostWithPath("", obj)
}

// Analytics returns service endpoint for ItemAnalytics
func (s *ServiceSite) Analytics() *ServiceItemAnalytics {
	ss := &ServiceItemAnalytics{ServiceBase: s.ServiceBase}
	ss.baseURL += "/analytics"
	return ss
}

// Columns returns service endpoint for CollectionColumnDefinition
func (s *ServiceSite) Columns() *ServiceCollectionColumnDefinition {
	ss := &ServiceCollectionColumnDefinition{ServiceBase: s.ServiceBase}
	ss.baseURL += "/columns"
	return ss
}

// ContentTypes returns service endpoint for CollectionContentType
func (s *ServiceSite) ContentTypes() *ServiceCollectionContentType {
	ss := &ServiceCollectionContentType{ServiceBase: s.ServiceBase}
	ss.baseURL += "/contentTypes"
	return ss
}

// Drive returns service endpoint for Drive
func (s *ServiceSite) Drive() *ServiceDrive {
	ss := &ServiceDrive{ServiceBase: s.ServiceBase}
	ss.baseURL += "/drive"
	return ss
}

// Drives returns service endpoint for CollectionDrive
func (s *ServiceSite) Drives() *ServiceCollectionDrive {
	ss := &ServiceCollectionDrive{ServiceBase: s.ServiceBase}
	ss.baseURL += "/drives"
	return ss
}

// Items returns service endpoint for CollectionBaseItem
func (s *ServiceSite) Items() *ServiceCollectionBaseItem {
	ss := &ServiceCollectionBaseItem{ServiceBase: s.ServiceBase}
	ss.baseURL += "/items"
	return ss
}

// Lists returns service endpoint for CollectionList
func (s *ServiceSite) Lists() *ServiceCollectionList {
	ss := &ServiceCollectionList{ServiceBase: s.ServiceBase}
	ss.baseURL += "/lists"
	return ss
}

// Onenote returns service endpoint for Onenote
func (s *ServiceSite) Onenote() *ServiceOnenote {
	ss := &ServiceOnenote{ServiceBase: s.ServiceBase}
	ss.baseURL += "/onenote"
	return ss
}

// Sites returns service endpoint for CollectionSite
func (s *ServiceSite) Sites() *ServiceCollectionSite {
	ss := &ServiceCollectionSite{ServiceBase: s.ServiceBase}
	ss.baseURL += "/sites"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for Site
func (s *ServiceSite) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceSite) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for Site
func (s *ServiceSite) DoRequestWithPath(method, path string, obj interface{}) (*Site, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *Site
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceSite) DoRequest(method string, obj interface{}) (*Site, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceSite) GetWithPath(path string) (*Site, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceSite) Get() (*Site, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceSite) PostWithPath(path string) (*Site, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceSite) Post() (*Site, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for Site collection with addtional path
func (s *ServiceCollectionSite) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionSite) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for Site
func (s *ServiceCollectionSite) DoRequestWithPath(method, path string, obj interface{}) (*Site, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *Site
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionSite) DoRequest(method string, obj interface{}) (*Site, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for Site collection
func (s *ServiceCollectionSite) DoPagingNext(res *http.Response) ([]Site, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []Site
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for Site collection
func (s *ServiceCollectionSite) DoPagingWithPath(method, path string, obj interface{}) ([]Site, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionSite) DoPaging(method string, obj interface{}) ([]Site, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionSite) GetWithPath(path string) ([]Site, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionSite) Get() ([]Site, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionSite) PostWithPath(path string, obj interface{}) (*Site, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionSite) Post(obj interface{}) (*Site, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for SoftwareUpdateStatusSummary
func (s *ServiceSoftwareUpdateStatusSummary) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceSoftwareUpdateStatusSummary) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for SoftwareUpdateStatusSummary
func (s *ServiceSoftwareUpdateStatusSummary) DoRequestWithPath(method, path string, obj interface{}) (*SoftwareUpdateStatusSummary, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *SoftwareUpdateStatusSummary
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceSoftwareUpdateStatusSummary) DoRequest(method string, obj interface{}) (*SoftwareUpdateStatusSummary, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceSoftwareUpdateStatusSummary) GetWithPath(path string) (*SoftwareUpdateStatusSummary, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceSoftwareUpdateStatusSummary) Get() (*SoftwareUpdateStatusSummary, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceSoftwareUpdateStatusSummary) PostWithPath(path string) (*SoftwareUpdateStatusSummary, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceSoftwareUpdateStatusSummary) Post() (*SoftwareUpdateStatusSummary, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for SubscribedSku
func (s *ServiceSubscribedSku) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceSubscribedSku) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for SubscribedSku
func (s *ServiceSubscribedSku) DoRequestWithPath(method, path string, obj interface{}) (*SubscribedSku, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *SubscribedSku
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceSubscribedSku) DoRequest(method string, obj interface{}) (*SubscribedSku, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceSubscribedSku) GetWithPath(path string) (*SubscribedSku, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceSubscribedSku) Get() (*SubscribedSku, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceSubscribedSku) PostWithPath(path string) (*SubscribedSku, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceSubscribedSku) Post() (*SubscribedSku, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for SubscribedSku collection with addtional path
func (s *ServiceCollectionSubscribedSku) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionSubscribedSku) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for SubscribedSku
func (s *ServiceCollectionSubscribedSku) DoRequestWithPath(method, path string, obj interface{}) (*SubscribedSku, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *SubscribedSku
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionSubscribedSku) DoRequest(method string, obj interface{}) (*SubscribedSku, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for SubscribedSku collection
func (s *ServiceCollectionSubscribedSku) DoPagingNext(res *http.Response) ([]SubscribedSku, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []SubscribedSku
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for SubscribedSku collection
func (s *ServiceCollectionSubscribedSku) DoPagingWithPath(method, path string, obj interface{}) ([]SubscribedSku, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionSubscribedSku) DoPaging(method string, obj interface{}) ([]SubscribedSku, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionSubscribedSku) GetWithPath(path string) ([]SubscribedSku, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionSubscribedSku) Get() ([]SubscribedSku, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionSubscribedSku) PostWithPath(path string, obj interface{}) (*SubscribedSku, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionSubscribedSku) Post(obj interface{}) (*SubscribedSku, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for Subscription
func (s *ServiceSubscription) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceSubscription) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for Subscription
func (s *ServiceSubscription) DoRequestWithPath(method, path string, obj interface{}) (*Subscription, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *Subscription
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceSubscription) DoRequest(method string, obj interface{}) (*Subscription, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceSubscription) GetWithPath(path string) (*Subscription, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceSubscription) Get() (*Subscription, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceSubscription) PostWithPath(path string) (*Subscription, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceSubscription) Post() (*Subscription, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for Subscription collection with addtional path
func (s *ServiceCollectionSubscription) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionSubscription) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for Subscription
func (s *ServiceCollectionSubscription) DoRequestWithPath(method, path string, obj interface{}) (*Subscription, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *Subscription
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionSubscription) DoRequest(method string, obj interface{}) (*Subscription, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for Subscription collection
func (s *ServiceCollectionSubscription) DoPagingNext(res *http.Response) ([]Subscription, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []Subscription
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for Subscription collection
func (s *ServiceCollectionSubscription) DoPagingWithPath(method, path string, obj interface{}) ([]Subscription, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionSubscription) DoPaging(method string, obj interface{}) ([]Subscription, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionSubscription) GetWithPath(path string) ([]Subscription, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionSubscription) Get() ([]Subscription, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionSubscription) PostWithPath(path string, obj interface{}) (*Subscription, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionSubscription) Post(obj interface{}) (*Subscription, error) {
	return s.PostWithPath("", obj)
}

// Apps returns service endpoint for CollectionManagedMobileApp
func (s *ServiceTargetedManagedAppConfiguration) Apps() *ServiceCollectionManagedMobileApp {
	ss := &ServiceCollectionManagedMobileApp{ServiceBase: s.ServiceBase}
	ss.baseURL += "/apps"
	return ss
}

// Assignments returns service endpoint for CollectionTargetedManagedAppPolicyAssignment
func (s *ServiceTargetedManagedAppConfiguration) Assignments() *ServiceCollectionTargetedManagedAppPolicyAssignment {
	ss := &ServiceCollectionTargetedManagedAppPolicyAssignment{ServiceBase: s.ServiceBase}
	ss.baseURL += "/assignments"
	return ss
}

// DeploymentSummary returns service endpoint for ManagedAppPolicyDeploymentSummary
func (s *ServiceTargetedManagedAppConfiguration) DeploymentSummary() *ServiceManagedAppPolicyDeploymentSummary {
	ss := &ServiceManagedAppPolicyDeploymentSummary{ServiceBase: s.ServiceBase}
	ss.baseURL += "/deploymentSummary"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for TargetedManagedAppConfiguration
func (s *ServiceTargetedManagedAppConfiguration) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceTargetedManagedAppConfiguration) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for TargetedManagedAppConfiguration
func (s *ServiceTargetedManagedAppConfiguration) DoRequestWithPath(method, path string, obj interface{}) (*TargetedManagedAppConfiguration, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *TargetedManagedAppConfiguration
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceTargetedManagedAppConfiguration) DoRequest(method string, obj interface{}) (*TargetedManagedAppConfiguration, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceTargetedManagedAppConfiguration) GetWithPath(path string) (*TargetedManagedAppConfiguration, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceTargetedManagedAppConfiguration) Get() (*TargetedManagedAppConfiguration, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceTargetedManagedAppConfiguration) PostWithPath(path string) (*TargetedManagedAppConfiguration, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceTargetedManagedAppConfiguration) Post() (*TargetedManagedAppConfiguration, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for TargetedManagedAppConfiguration collection with addtional path
func (s *ServiceCollectionTargetedManagedAppConfiguration) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionTargetedManagedAppConfiguration) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for TargetedManagedAppConfiguration
func (s *ServiceCollectionTargetedManagedAppConfiguration) DoRequestWithPath(method, path string, obj interface{}) (*TargetedManagedAppConfiguration, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *TargetedManagedAppConfiguration
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionTargetedManagedAppConfiguration) DoRequest(method string, obj interface{}) (*TargetedManagedAppConfiguration, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for TargetedManagedAppConfiguration collection
func (s *ServiceCollectionTargetedManagedAppConfiguration) DoPagingNext(res *http.Response) ([]TargetedManagedAppConfiguration, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []TargetedManagedAppConfiguration
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for TargetedManagedAppConfiguration collection
func (s *ServiceCollectionTargetedManagedAppConfiguration) DoPagingWithPath(method, path string, obj interface{}) ([]TargetedManagedAppConfiguration, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionTargetedManagedAppConfiguration) DoPaging(method string, obj interface{}) ([]TargetedManagedAppConfiguration, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionTargetedManagedAppConfiguration) GetWithPath(path string) ([]TargetedManagedAppConfiguration, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionTargetedManagedAppConfiguration) Get() ([]TargetedManagedAppConfiguration, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionTargetedManagedAppConfiguration) PostWithPath(path string, obj interface{}) (*TargetedManagedAppConfiguration, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionTargetedManagedAppConfiguration) Post(obj interface{}) (*TargetedManagedAppConfiguration, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for TargetedManagedAppPolicyAssignment collection with addtional path
func (s *ServiceCollectionTargetedManagedAppPolicyAssignment) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionTargetedManagedAppPolicyAssignment) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for TargetedManagedAppPolicyAssignment
func (s *ServiceCollectionTargetedManagedAppPolicyAssignment) DoRequestWithPath(method, path string, obj interface{}) (*TargetedManagedAppPolicyAssignment, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *TargetedManagedAppPolicyAssignment
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionTargetedManagedAppPolicyAssignment) DoRequest(method string, obj interface{}) (*TargetedManagedAppPolicyAssignment, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for TargetedManagedAppPolicyAssignment collection
func (s *ServiceCollectionTargetedManagedAppPolicyAssignment) DoPagingNext(res *http.Response) ([]TargetedManagedAppPolicyAssignment, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []TargetedManagedAppPolicyAssignment
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for TargetedManagedAppPolicyAssignment collection
func (s *ServiceCollectionTargetedManagedAppPolicyAssignment) DoPagingWithPath(method, path string, obj interface{}) ([]TargetedManagedAppPolicyAssignment, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionTargetedManagedAppPolicyAssignment) DoPaging(method string, obj interface{}) ([]TargetedManagedAppPolicyAssignment, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionTargetedManagedAppPolicyAssignment) GetWithPath(path string) ([]TargetedManagedAppPolicyAssignment, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionTargetedManagedAppPolicyAssignment) Get() ([]TargetedManagedAppPolicyAssignment, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionTargetedManagedAppPolicyAssignment) PostWithPath(path string, obj interface{}) (*TargetedManagedAppPolicyAssignment, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionTargetedManagedAppPolicyAssignment) Post(obj interface{}) (*TargetedManagedAppPolicyAssignment, error) {
	return s.PostWithPath("", obj)
}

// Assignments returns service endpoint for CollectionTargetedManagedAppPolicyAssignment
func (s *ServiceTargetedManagedAppProtection) Assignments() *ServiceCollectionTargetedManagedAppPolicyAssignment {
	ss := &ServiceCollectionTargetedManagedAppPolicyAssignment{ServiceBase: s.ServiceBase}
	ss.baseURL += "/assignments"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for TargetedManagedAppProtection
func (s *ServiceTargetedManagedAppProtection) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceTargetedManagedAppProtection) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for TargetedManagedAppProtection
func (s *ServiceTargetedManagedAppProtection) DoRequestWithPath(method, path string, obj interface{}) (*TargetedManagedAppProtection, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *TargetedManagedAppProtection
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceTargetedManagedAppProtection) DoRequest(method string, obj interface{}) (*TargetedManagedAppProtection, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceTargetedManagedAppProtection) GetWithPath(path string) (*TargetedManagedAppProtection, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceTargetedManagedAppProtection) Get() (*TargetedManagedAppProtection, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceTargetedManagedAppProtection) PostWithPath(path string) (*TargetedManagedAppProtection, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceTargetedManagedAppProtection) Post() (*TargetedManagedAppProtection, error) {
	return s.PostWithPath("")
}

// Channels returns service endpoint for CollectionChannel
func (s *ServiceTeam) Channels() *ServiceCollectionChannel {
	ss := &ServiceCollectionChannel{ServiceBase: s.ServiceBase}
	ss.baseURL += "/channels"
	return ss
}

// InstalledApps returns service endpoint for CollectionTeamsAppInstallation
func (s *ServiceTeam) InstalledApps() *ServiceCollectionTeamsAppInstallation {
	ss := &ServiceCollectionTeamsAppInstallation{ServiceBase: s.ServiceBase}
	ss.baseURL += "/installedApps"
	return ss
}

// Operations returns service endpoint for CollectionTeamsAsyncOperation
func (s *ServiceTeam) Operations() *ServiceCollectionTeamsAsyncOperation {
	ss := &ServiceCollectionTeamsAsyncOperation{ServiceBase: s.ServiceBase}
	ss.baseURL += "/operations"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for Team
func (s *ServiceTeam) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceTeam) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for Team
func (s *ServiceTeam) DoRequestWithPath(method, path string, obj interface{}) (*Team, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *Team
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceTeam) DoRequest(method string, obj interface{}) (*Team, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceTeam) GetWithPath(path string) (*Team, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceTeam) Get() (*Team, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceTeam) PostWithPath(path string) (*Team, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceTeam) Post() (*Team, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for Team collection with addtional path
func (s *ServiceCollectionTeam) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionTeam) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for Team
func (s *ServiceCollectionTeam) DoRequestWithPath(method, path string, obj interface{}) (*Team, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *Team
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionTeam) DoRequest(method string, obj interface{}) (*Team, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for Team collection
func (s *ServiceCollectionTeam) DoPagingNext(res *http.Response) ([]Team, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []Team
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for Team collection
func (s *ServiceCollectionTeam) DoPagingWithPath(method, path string, obj interface{}) ([]Team, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionTeam) DoPaging(method string, obj interface{}) ([]Team, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionTeam) GetWithPath(path string) ([]Team, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionTeam) Get() ([]Team, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionTeam) PostWithPath(path string, obj interface{}) (*Team, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionTeam) Post(obj interface{}) (*Team, error) {
	return s.PostWithPath("", obj)
}

// AppDefinitions returns service endpoint for CollectionTeamsAppDefinition
func (s *ServiceTeamsApp) AppDefinitions() *ServiceCollectionTeamsAppDefinition {
	ss := &ServiceCollectionTeamsAppDefinition{ServiceBase: s.ServiceBase}
	ss.baseURL += "/appDefinitions"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for TeamsApp
func (s *ServiceTeamsApp) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceTeamsApp) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for TeamsApp
func (s *ServiceTeamsApp) DoRequestWithPath(method, path string, obj interface{}) (*TeamsApp, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *TeamsApp
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceTeamsApp) DoRequest(method string, obj interface{}) (*TeamsApp, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceTeamsApp) GetWithPath(path string) (*TeamsApp, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceTeamsApp) Get() (*TeamsApp, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceTeamsApp) PostWithPath(path string) (*TeamsApp, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceTeamsApp) Post() (*TeamsApp, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for TeamsApp collection with addtional path
func (s *ServiceCollectionTeamsApp) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionTeamsApp) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for TeamsApp
func (s *ServiceCollectionTeamsApp) DoRequestWithPath(method, path string, obj interface{}) (*TeamsApp, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *TeamsApp
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionTeamsApp) DoRequest(method string, obj interface{}) (*TeamsApp, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for TeamsApp collection
func (s *ServiceCollectionTeamsApp) DoPagingNext(res *http.Response) ([]TeamsApp, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []TeamsApp
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for TeamsApp collection
func (s *ServiceCollectionTeamsApp) DoPagingWithPath(method, path string, obj interface{}) ([]TeamsApp, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionTeamsApp) DoPaging(method string, obj interface{}) ([]TeamsApp, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionTeamsApp) GetWithPath(path string) ([]TeamsApp, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionTeamsApp) Get() ([]TeamsApp, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionTeamsApp) PostWithPath(path string, obj interface{}) (*TeamsApp, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionTeamsApp) Post(obj interface{}) (*TeamsApp, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for TeamsAppDefinition
func (s *ServiceTeamsAppDefinition) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceTeamsAppDefinition) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for TeamsAppDefinition
func (s *ServiceTeamsAppDefinition) DoRequestWithPath(method, path string, obj interface{}) (*TeamsAppDefinition, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *TeamsAppDefinition
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceTeamsAppDefinition) DoRequest(method string, obj interface{}) (*TeamsAppDefinition, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceTeamsAppDefinition) GetWithPath(path string) (*TeamsAppDefinition, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceTeamsAppDefinition) Get() (*TeamsAppDefinition, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceTeamsAppDefinition) PostWithPath(path string) (*TeamsAppDefinition, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceTeamsAppDefinition) Post() (*TeamsAppDefinition, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for TeamsAppDefinition collection with addtional path
func (s *ServiceCollectionTeamsAppDefinition) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionTeamsAppDefinition) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for TeamsAppDefinition
func (s *ServiceCollectionTeamsAppDefinition) DoRequestWithPath(method, path string, obj interface{}) (*TeamsAppDefinition, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *TeamsAppDefinition
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionTeamsAppDefinition) DoRequest(method string, obj interface{}) (*TeamsAppDefinition, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for TeamsAppDefinition collection
func (s *ServiceCollectionTeamsAppDefinition) DoPagingNext(res *http.Response) ([]TeamsAppDefinition, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []TeamsAppDefinition
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for TeamsAppDefinition collection
func (s *ServiceCollectionTeamsAppDefinition) DoPagingWithPath(method, path string, obj interface{}) ([]TeamsAppDefinition, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionTeamsAppDefinition) DoPaging(method string, obj interface{}) ([]TeamsAppDefinition, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionTeamsAppDefinition) GetWithPath(path string) ([]TeamsAppDefinition, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionTeamsAppDefinition) Get() ([]TeamsAppDefinition, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionTeamsAppDefinition) PostWithPath(path string, obj interface{}) (*TeamsAppDefinition, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionTeamsAppDefinition) Post(obj interface{}) (*TeamsAppDefinition, error) {
	return s.PostWithPath("", obj)
}

// TeamsApp returns service endpoint for TeamsApp
func (s *ServiceTeamsAppInstallation) TeamsApp() *ServiceTeamsApp {
	ss := &ServiceTeamsApp{ServiceBase: s.ServiceBase}
	ss.baseURL += "/teamsApp"
	return ss
}

// TeamsAppDefinition returns service endpoint for TeamsAppDefinition
func (s *ServiceTeamsAppInstallation) TeamsAppDefinition() *ServiceTeamsAppDefinition {
	ss := &ServiceTeamsAppDefinition{ServiceBase: s.ServiceBase}
	ss.baseURL += "/teamsAppDefinition"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for TeamsAppInstallation
func (s *ServiceTeamsAppInstallation) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceTeamsAppInstallation) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for TeamsAppInstallation
func (s *ServiceTeamsAppInstallation) DoRequestWithPath(method, path string, obj interface{}) (*TeamsAppInstallation, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *TeamsAppInstallation
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceTeamsAppInstallation) DoRequest(method string, obj interface{}) (*TeamsAppInstallation, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceTeamsAppInstallation) GetWithPath(path string) (*TeamsAppInstallation, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceTeamsAppInstallation) Get() (*TeamsAppInstallation, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceTeamsAppInstallation) PostWithPath(path string) (*TeamsAppInstallation, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceTeamsAppInstallation) Post() (*TeamsAppInstallation, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for TeamsAppInstallation collection with addtional path
func (s *ServiceCollectionTeamsAppInstallation) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionTeamsAppInstallation) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for TeamsAppInstallation
func (s *ServiceCollectionTeamsAppInstallation) DoRequestWithPath(method, path string, obj interface{}) (*TeamsAppInstallation, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *TeamsAppInstallation
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionTeamsAppInstallation) DoRequest(method string, obj interface{}) (*TeamsAppInstallation, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for TeamsAppInstallation collection
func (s *ServiceCollectionTeamsAppInstallation) DoPagingNext(res *http.Response) ([]TeamsAppInstallation, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []TeamsAppInstallation
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for TeamsAppInstallation collection
func (s *ServiceCollectionTeamsAppInstallation) DoPagingWithPath(method, path string, obj interface{}) ([]TeamsAppInstallation, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionTeamsAppInstallation) DoPaging(method string, obj interface{}) ([]TeamsAppInstallation, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionTeamsAppInstallation) GetWithPath(path string) ([]TeamsAppInstallation, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionTeamsAppInstallation) Get() ([]TeamsAppInstallation, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionTeamsAppInstallation) PostWithPath(path string, obj interface{}) (*TeamsAppInstallation, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionTeamsAppInstallation) Post(obj interface{}) (*TeamsAppInstallation, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for TeamsAsyncOperation collection with addtional path
func (s *ServiceCollectionTeamsAsyncOperation) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionTeamsAsyncOperation) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for TeamsAsyncOperation
func (s *ServiceCollectionTeamsAsyncOperation) DoRequestWithPath(method, path string, obj interface{}) (*TeamsAsyncOperation, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *TeamsAsyncOperation
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionTeamsAsyncOperation) DoRequest(method string, obj interface{}) (*TeamsAsyncOperation, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for TeamsAsyncOperation collection
func (s *ServiceCollectionTeamsAsyncOperation) DoPagingNext(res *http.Response) ([]TeamsAsyncOperation, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []TeamsAsyncOperation
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for TeamsAsyncOperation collection
func (s *ServiceCollectionTeamsAsyncOperation) DoPagingWithPath(method, path string, obj interface{}) ([]TeamsAsyncOperation, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionTeamsAsyncOperation) DoPaging(method string, obj interface{}) ([]TeamsAsyncOperation, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionTeamsAsyncOperation) GetWithPath(path string) ([]TeamsAsyncOperation, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionTeamsAsyncOperation) Get() ([]TeamsAsyncOperation, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionTeamsAsyncOperation) PostWithPath(path string, obj interface{}) (*TeamsAsyncOperation, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionTeamsAsyncOperation) Post(obj interface{}) (*TeamsAsyncOperation, error) {
	return s.PostWithPath("", obj)
}

// TeamsApp returns service endpoint for TeamsApp
func (s *ServiceTeamsTab) TeamsApp() *ServiceTeamsApp {
	ss := &ServiceTeamsApp{ServiceBase: s.ServiceBase}
	ss.baseURL += "/teamsApp"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for TeamsTab
func (s *ServiceTeamsTab) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceTeamsTab) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for TeamsTab
func (s *ServiceTeamsTab) DoRequestWithPath(method, path string, obj interface{}) (*TeamsTab, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *TeamsTab
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceTeamsTab) DoRequest(method string, obj interface{}) (*TeamsTab, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceTeamsTab) GetWithPath(path string) (*TeamsTab, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceTeamsTab) Get() (*TeamsTab, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceTeamsTab) PostWithPath(path string) (*TeamsTab, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceTeamsTab) Post() (*TeamsTab, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for TeamsTab collection with addtional path
func (s *ServiceCollectionTeamsTab) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionTeamsTab) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for TeamsTab
func (s *ServiceCollectionTeamsTab) DoRequestWithPath(method, path string, obj interface{}) (*TeamsTab, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *TeamsTab
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionTeamsTab) DoRequest(method string, obj interface{}) (*TeamsTab, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for TeamsTab collection
func (s *ServiceCollectionTeamsTab) DoPagingNext(res *http.Response) ([]TeamsTab, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []TeamsTab
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for TeamsTab collection
func (s *ServiceCollectionTeamsTab) DoPagingWithPath(method, path string, obj interface{}) ([]TeamsTab, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionTeamsTab) DoPaging(method string, obj interface{}) ([]TeamsTab, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionTeamsTab) GetWithPath(path string) ([]TeamsTab, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionTeamsTab) Get() ([]TeamsTab, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionTeamsTab) PostWithPath(path string, obj interface{}) (*TeamsTab, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionTeamsTab) Post(obj interface{}) (*TeamsTab, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for TelecomExpenseManagementPartner collection with addtional path
func (s *ServiceCollectionTelecomExpenseManagementPartner) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionTelecomExpenseManagementPartner) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for TelecomExpenseManagementPartner
func (s *ServiceCollectionTelecomExpenseManagementPartner) DoRequestWithPath(method, path string, obj interface{}) (*TelecomExpenseManagementPartner, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *TelecomExpenseManagementPartner
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionTelecomExpenseManagementPartner) DoRequest(method string, obj interface{}) (*TelecomExpenseManagementPartner, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for TelecomExpenseManagementPartner collection
func (s *ServiceCollectionTelecomExpenseManagementPartner) DoPagingNext(res *http.Response) ([]TelecomExpenseManagementPartner, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []TelecomExpenseManagementPartner
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for TelecomExpenseManagementPartner collection
func (s *ServiceCollectionTelecomExpenseManagementPartner) DoPagingWithPath(method, path string, obj interface{}) ([]TelecomExpenseManagementPartner, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionTelecomExpenseManagementPartner) DoPaging(method string, obj interface{}) ([]TelecomExpenseManagementPartner, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionTelecomExpenseManagementPartner) GetWithPath(path string) ([]TelecomExpenseManagementPartner, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionTelecomExpenseManagementPartner) Get() ([]TelecomExpenseManagementPartner, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionTelecomExpenseManagementPartner) PostWithPath(path string, obj interface{}) (*TelecomExpenseManagementPartner, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionTelecomExpenseManagementPartner) Post(obj interface{}) (*TelecomExpenseManagementPartner, error) {
	return s.PostWithPath("", obj)
}

// AcceptanceStatuses returns service endpoint for CollectionTermsAndConditionsAcceptanceStatus
func (s *ServiceTermsAndConditions) AcceptanceStatuses() *ServiceCollectionTermsAndConditionsAcceptanceStatus {
	ss := &ServiceCollectionTermsAndConditionsAcceptanceStatus{ServiceBase: s.ServiceBase}
	ss.baseURL += "/acceptanceStatuses"
	return ss
}

// Assignments returns service endpoint for CollectionTermsAndConditionsAssignment
func (s *ServiceTermsAndConditions) Assignments() *ServiceCollectionTermsAndConditionsAssignment {
	ss := &ServiceCollectionTermsAndConditionsAssignment{ServiceBase: s.ServiceBase}
	ss.baseURL += "/assignments"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for TermsAndConditions
func (s *ServiceTermsAndConditions) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceTermsAndConditions) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for TermsAndConditions
func (s *ServiceTermsAndConditions) DoRequestWithPath(method, path string, obj interface{}) (*TermsAndConditions, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *TermsAndConditions
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceTermsAndConditions) DoRequest(method string, obj interface{}) (*TermsAndConditions, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceTermsAndConditions) GetWithPath(path string) (*TermsAndConditions, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceTermsAndConditions) Get() (*TermsAndConditions, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceTermsAndConditions) PostWithPath(path string) (*TermsAndConditions, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceTermsAndConditions) Post() (*TermsAndConditions, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for TermsAndConditions collection with addtional path
func (s *ServiceCollectionTermsAndConditions) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionTermsAndConditions) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for TermsAndConditions
func (s *ServiceCollectionTermsAndConditions) DoRequestWithPath(method, path string, obj interface{}) (*TermsAndConditions, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *TermsAndConditions
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionTermsAndConditions) DoRequest(method string, obj interface{}) (*TermsAndConditions, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for TermsAndConditions collection
func (s *ServiceCollectionTermsAndConditions) DoPagingNext(res *http.Response) ([]TermsAndConditions, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []TermsAndConditions
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for TermsAndConditions collection
func (s *ServiceCollectionTermsAndConditions) DoPagingWithPath(method, path string, obj interface{}) ([]TermsAndConditions, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionTermsAndConditions) DoPaging(method string, obj interface{}) ([]TermsAndConditions, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionTermsAndConditions) GetWithPath(path string) ([]TermsAndConditions, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionTermsAndConditions) Get() ([]TermsAndConditions, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionTermsAndConditions) PostWithPath(path string, obj interface{}) (*TermsAndConditions, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionTermsAndConditions) Post(obj interface{}) (*TermsAndConditions, error) {
	return s.PostWithPath("", obj)
}

// TermsAndConditions returns service endpoint for TermsAndConditions
func (s *ServiceTermsAndConditionsAcceptanceStatus) TermsAndConditions() *ServiceTermsAndConditions {
	ss := &ServiceTermsAndConditions{ServiceBase: s.ServiceBase}
	ss.baseURL += "/termsAndConditions"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for TermsAndConditionsAcceptanceStatus
func (s *ServiceTermsAndConditionsAcceptanceStatus) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceTermsAndConditionsAcceptanceStatus) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for TermsAndConditionsAcceptanceStatus
func (s *ServiceTermsAndConditionsAcceptanceStatus) DoRequestWithPath(method, path string, obj interface{}) (*TermsAndConditionsAcceptanceStatus, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *TermsAndConditionsAcceptanceStatus
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceTermsAndConditionsAcceptanceStatus) DoRequest(method string, obj interface{}) (*TermsAndConditionsAcceptanceStatus, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceTermsAndConditionsAcceptanceStatus) GetWithPath(path string) (*TermsAndConditionsAcceptanceStatus, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceTermsAndConditionsAcceptanceStatus) Get() (*TermsAndConditionsAcceptanceStatus, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceTermsAndConditionsAcceptanceStatus) PostWithPath(path string) (*TermsAndConditionsAcceptanceStatus, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceTermsAndConditionsAcceptanceStatus) Post() (*TermsAndConditionsAcceptanceStatus, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for TermsAndConditionsAcceptanceStatus collection with addtional path
func (s *ServiceCollectionTermsAndConditionsAcceptanceStatus) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionTermsAndConditionsAcceptanceStatus) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for TermsAndConditionsAcceptanceStatus
func (s *ServiceCollectionTermsAndConditionsAcceptanceStatus) DoRequestWithPath(method, path string, obj interface{}) (*TermsAndConditionsAcceptanceStatus, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *TermsAndConditionsAcceptanceStatus
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionTermsAndConditionsAcceptanceStatus) DoRequest(method string, obj interface{}) (*TermsAndConditionsAcceptanceStatus, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for TermsAndConditionsAcceptanceStatus collection
func (s *ServiceCollectionTermsAndConditionsAcceptanceStatus) DoPagingNext(res *http.Response) ([]TermsAndConditionsAcceptanceStatus, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []TermsAndConditionsAcceptanceStatus
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for TermsAndConditionsAcceptanceStatus collection
func (s *ServiceCollectionTermsAndConditionsAcceptanceStatus) DoPagingWithPath(method, path string, obj interface{}) ([]TermsAndConditionsAcceptanceStatus, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionTermsAndConditionsAcceptanceStatus) DoPaging(method string, obj interface{}) ([]TermsAndConditionsAcceptanceStatus, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionTermsAndConditionsAcceptanceStatus) GetWithPath(path string) ([]TermsAndConditionsAcceptanceStatus, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionTermsAndConditionsAcceptanceStatus) Get() ([]TermsAndConditionsAcceptanceStatus, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionTermsAndConditionsAcceptanceStatus) PostWithPath(path string, obj interface{}) (*TermsAndConditionsAcceptanceStatus, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionTermsAndConditionsAcceptanceStatus) Post(obj interface{}) (*TermsAndConditionsAcceptanceStatus, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for TermsAndConditionsAssignment collection with addtional path
func (s *ServiceCollectionTermsAndConditionsAssignment) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionTermsAndConditionsAssignment) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for TermsAndConditionsAssignment
func (s *ServiceCollectionTermsAndConditionsAssignment) DoRequestWithPath(method, path string, obj interface{}) (*TermsAndConditionsAssignment, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *TermsAndConditionsAssignment
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionTermsAndConditionsAssignment) DoRequest(method string, obj interface{}) (*TermsAndConditionsAssignment, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for TermsAndConditionsAssignment collection
func (s *ServiceCollectionTermsAndConditionsAssignment) DoPagingNext(res *http.Response) ([]TermsAndConditionsAssignment, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []TermsAndConditionsAssignment
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for TermsAndConditionsAssignment collection
func (s *ServiceCollectionTermsAndConditionsAssignment) DoPagingWithPath(method, path string, obj interface{}) ([]TermsAndConditionsAssignment, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionTermsAndConditionsAssignment) DoPaging(method string, obj interface{}) ([]TermsAndConditionsAssignment, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionTermsAndConditionsAssignment) GetWithPath(path string) ([]TermsAndConditionsAssignment, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionTermsAndConditionsAssignment) Get() ([]TermsAndConditionsAssignment, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionTermsAndConditionsAssignment) PostWithPath(path string, obj interface{}) (*TermsAndConditionsAssignment, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionTermsAndConditionsAssignment) Post(obj interface{}) (*TermsAndConditionsAssignment, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for ThumbnailSet collection with addtional path
func (s *ServiceCollectionThumbnailSet) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionThumbnailSet) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for ThumbnailSet
func (s *ServiceCollectionThumbnailSet) DoRequestWithPath(method, path string, obj interface{}) (*ThumbnailSet, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *ThumbnailSet
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionThumbnailSet) DoRequest(method string, obj interface{}) (*ThumbnailSet, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for ThumbnailSet collection
func (s *ServiceCollectionThumbnailSet) DoPagingNext(res *http.Response) ([]ThumbnailSet, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []ThumbnailSet
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for ThumbnailSet collection
func (s *ServiceCollectionThumbnailSet) DoPagingWithPath(method, path string, obj interface{}) ([]ThumbnailSet, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionThumbnailSet) DoPaging(method string, obj interface{}) ([]ThumbnailSet, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionThumbnailSet) GetWithPath(path string) ([]ThumbnailSet, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionThumbnailSet) Get() ([]ThumbnailSet, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionThumbnailSet) PostWithPath(path string, obj interface{}) (*ThumbnailSet, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionThumbnailSet) Post(obj interface{}) (*ThumbnailSet, error) {
	return s.PostWithPath("", obj)
}

// Resource returns service endpoint for Entity
func (s *ServiceTrending) Resource() *ServiceEntity {
	ss := &ServiceEntity{ServiceBase: s.ServiceBase}
	ss.baseURL += "/resource"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for Trending
func (s *ServiceTrending) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceTrending) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for Trending
func (s *ServiceTrending) DoRequestWithPath(method, path string, obj interface{}) (*Trending, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *Trending
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceTrending) DoRequest(method string, obj interface{}) (*Trending, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceTrending) GetWithPath(path string) (*Trending, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceTrending) Get() (*Trending, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceTrending) PostWithPath(path string) (*Trending, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceTrending) Post() (*Trending, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for Trending collection with addtional path
func (s *ServiceCollectionTrending) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionTrending) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for Trending
func (s *ServiceCollectionTrending) DoRequestWithPath(method, path string, obj interface{}) (*Trending, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *Trending
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionTrending) DoRequest(method string, obj interface{}) (*Trending, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for Trending collection
func (s *ServiceCollectionTrending) DoPagingNext(res *http.Response) ([]Trending, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []Trending
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for Trending collection
func (s *ServiceCollectionTrending) DoPagingWithPath(method, path string, obj interface{}) ([]Trending, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionTrending) DoPaging(method string, obj interface{}) ([]Trending, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionTrending) GetWithPath(path string) ([]Trending, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionTrending) Get() ([]Trending, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionTrending) PostWithPath(path string, obj interface{}) (*Trending, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionTrending) Post(obj interface{}) (*Trending, error) {
	return s.PostWithPath("", obj)
}

// Resource returns service endpoint for Entity
func (s *ServiceUsedInsight) Resource() *ServiceEntity {
	ss := &ServiceEntity{ServiceBase: s.ServiceBase}
	ss.baseURL += "/resource"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for UsedInsight
func (s *ServiceUsedInsight) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceUsedInsight) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for UsedInsight
func (s *ServiceUsedInsight) DoRequestWithPath(method, path string, obj interface{}) (*UsedInsight, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *UsedInsight
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceUsedInsight) DoRequest(method string, obj interface{}) (*UsedInsight, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceUsedInsight) GetWithPath(path string) (*UsedInsight, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceUsedInsight) Get() (*UsedInsight, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceUsedInsight) PostWithPath(path string) (*UsedInsight, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceUsedInsight) Post() (*UsedInsight, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for UsedInsight collection with addtional path
func (s *ServiceCollectionUsedInsight) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionUsedInsight) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for UsedInsight
func (s *ServiceCollectionUsedInsight) DoRequestWithPath(method, path string, obj interface{}) (*UsedInsight, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *UsedInsight
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionUsedInsight) DoRequest(method string, obj interface{}) (*UsedInsight, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for UsedInsight collection
func (s *ServiceCollectionUsedInsight) DoPagingNext(res *http.Response) ([]UsedInsight, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []UsedInsight
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for UsedInsight collection
func (s *ServiceCollectionUsedInsight) DoPagingWithPath(method, path string, obj interface{}) ([]UsedInsight, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionUsedInsight) DoPaging(method string, obj interface{}) ([]UsedInsight, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionUsedInsight) GetWithPath(path string) ([]UsedInsight, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionUsedInsight) Get() ([]UsedInsight, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionUsedInsight) PostWithPath(path string, obj interface{}) (*UsedInsight, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionUsedInsight) Post(obj interface{}) (*UsedInsight, error) {
	return s.PostWithPath("", obj)
}

// Activities returns service endpoint for CollectionUserActivity
func (s *ServiceUser) Activities() *ServiceCollectionUserActivity {
	ss := &ServiceCollectionUserActivity{ServiceBase: s.ServiceBase}
	ss.baseURL += "/activities"
	return ss
}

// Calendar returns service endpoint for Calendar
func (s *ServiceUser) Calendar() *ServiceCalendar {
	ss := &ServiceCalendar{ServiceBase: s.ServiceBase}
	ss.baseURL += "/calendar"
	return ss
}

// CalendarGroups returns service endpoint for CollectionCalendarGroup
func (s *ServiceUser) CalendarGroups() *ServiceCollectionCalendarGroup {
	ss := &ServiceCollectionCalendarGroup{ServiceBase: s.ServiceBase}
	ss.baseURL += "/calendarGroups"
	return ss
}

// CalendarView returns service endpoint for CollectionEvent
func (s *ServiceUser) CalendarView() *ServiceCollectionEvent {
	ss := &ServiceCollectionEvent{ServiceBase: s.ServiceBase}
	ss.baseURL += "/calendarView"
	return ss
}

// Calendars returns service endpoint for CollectionCalendar
func (s *ServiceUser) Calendars() *ServiceCollectionCalendar {
	ss := &ServiceCollectionCalendar{ServiceBase: s.ServiceBase}
	ss.baseURL += "/calendars"
	return ss
}

// ContactFolders returns service endpoint for CollectionContactFolder
func (s *ServiceUser) ContactFolders() *ServiceCollectionContactFolder {
	ss := &ServiceCollectionContactFolder{ServiceBase: s.ServiceBase}
	ss.baseURL += "/contactFolders"
	return ss
}

// Contacts returns service endpoint for CollectionContact
func (s *ServiceUser) Contacts() *ServiceCollectionContact {
	ss := &ServiceCollectionContact{ServiceBase: s.ServiceBase}
	ss.baseURL += "/contacts"
	return ss
}

// CreatedObjects returns service endpoint for CollectionDirectoryObject
func (s *ServiceUser) CreatedObjects() *ServiceCollectionDirectoryObject {
	ss := &ServiceCollectionDirectoryObject{ServiceBase: s.ServiceBase}
	ss.baseURL += "/createdObjects"
	return ss
}

// DeviceManagementTroubleshootingEvents returns service endpoint for CollectionDeviceManagementTroubleshootingEvent
func (s *ServiceUser) DeviceManagementTroubleshootingEvents() *ServiceCollectionDeviceManagementTroubleshootingEvent {
	ss := &ServiceCollectionDeviceManagementTroubleshootingEvent{ServiceBase: s.ServiceBase}
	ss.baseURL += "/deviceManagementTroubleshootingEvents"
	return ss
}

// DirectReports returns service endpoint for CollectionDirectoryObject
func (s *ServiceUser) DirectReports() *ServiceCollectionDirectoryObject {
	ss := &ServiceCollectionDirectoryObject{ServiceBase: s.ServiceBase}
	ss.baseURL += "/directReports"
	return ss
}

// Drive returns service endpoint for Drive
func (s *ServiceUser) Drive() *ServiceDrive {
	ss := &ServiceDrive{ServiceBase: s.ServiceBase}
	ss.baseURL += "/drive"
	return ss
}

// Drives returns service endpoint for CollectionDrive
func (s *ServiceUser) Drives() *ServiceCollectionDrive {
	ss := &ServiceCollectionDrive{ServiceBase: s.ServiceBase}
	ss.baseURL += "/drives"
	return ss
}

// Events returns service endpoint for CollectionEvent
func (s *ServiceUser) Events() *ServiceCollectionEvent {
	ss := &ServiceCollectionEvent{ServiceBase: s.ServiceBase}
	ss.baseURL += "/events"
	return ss
}

// Extensions returns service endpoint for CollectionExtension
func (s *ServiceUser) Extensions() *ServiceCollectionExtension {
	ss := &ServiceCollectionExtension{ServiceBase: s.ServiceBase}
	ss.baseURL += "/extensions"
	return ss
}

// InferenceClassification returns service endpoint for InferenceClassification
func (s *ServiceUser) InferenceClassification() *ServiceInferenceClassification {
	ss := &ServiceInferenceClassification{ServiceBase: s.ServiceBase}
	ss.baseURL += "/inferenceClassification"
	return ss
}

// Insights returns service endpoint for OfficeGraphInsights
func (s *ServiceUser) Insights() *ServiceOfficeGraphInsights {
	ss := &ServiceOfficeGraphInsights{ServiceBase: s.ServiceBase}
	ss.baseURL += "/insights"
	return ss
}

// JoinedTeams returns service endpoint for CollectionGroup
func (s *ServiceUser) JoinedTeams() *ServiceCollectionGroup {
	ss := &ServiceCollectionGroup{ServiceBase: s.ServiceBase}
	ss.baseURL += "/joinedTeams"
	return ss
}

// LicenseDetails returns service endpoint for CollectionLicenseDetails
func (s *ServiceUser) LicenseDetails() *ServiceCollectionLicenseDetails {
	ss := &ServiceCollectionLicenseDetails{ServiceBase: s.ServiceBase}
	ss.baseURL += "/licenseDetails"
	return ss
}

// MailFolders returns service endpoint for CollectionMailFolder
func (s *ServiceUser) MailFolders() *ServiceCollectionMailFolder {
	ss := &ServiceCollectionMailFolder{ServiceBase: s.ServiceBase}
	ss.baseURL += "/mailFolders"
	return ss
}

// ManagedAppRegistrations returns service endpoint for CollectionManagedAppRegistration
func (s *ServiceUser) ManagedAppRegistrations() *ServiceCollectionManagedAppRegistration {
	ss := &ServiceCollectionManagedAppRegistration{ServiceBase: s.ServiceBase}
	ss.baseURL += "/managedAppRegistrations"
	return ss
}

// ManagedDevices returns service endpoint for CollectionManagedDevice
func (s *ServiceUser) ManagedDevices() *ServiceCollectionManagedDevice {
	ss := &ServiceCollectionManagedDevice{ServiceBase: s.ServiceBase}
	ss.baseURL += "/managedDevices"
	return ss
}

// Manager returns service endpoint for DirectoryObject
func (s *ServiceUser) Manager() *ServiceDirectoryObject {
	ss := &ServiceDirectoryObject{ServiceBase: s.ServiceBase}
	ss.baseURL += "/manager"
	return ss
}

// MemberOf returns service endpoint for CollectionDirectoryObject
func (s *ServiceUser) MemberOf() *ServiceCollectionDirectoryObject {
	ss := &ServiceCollectionDirectoryObject{ServiceBase: s.ServiceBase}
	ss.baseURL += "/memberOf"
	return ss
}

// Messages returns service endpoint for CollectionMessage
func (s *ServiceUser) Messages() *ServiceCollectionMessage {
	ss := &ServiceCollectionMessage{ServiceBase: s.ServiceBase}
	ss.baseURL += "/messages"
	return ss
}

// Onenote returns service endpoint for Onenote
func (s *ServiceUser) Onenote() *ServiceOnenote {
	ss := &ServiceOnenote{ServiceBase: s.ServiceBase}
	ss.baseURL += "/onenote"
	return ss
}

// Outlook returns service endpoint for OutlookUser
func (s *ServiceUser) Outlook() *ServiceOutlookUser {
	ss := &ServiceOutlookUser{ServiceBase: s.ServiceBase}
	ss.baseURL += "/outlook"
	return ss
}

// OwnedDevices returns service endpoint for CollectionDirectoryObject
func (s *ServiceUser) OwnedDevices() *ServiceCollectionDirectoryObject {
	ss := &ServiceCollectionDirectoryObject{ServiceBase: s.ServiceBase}
	ss.baseURL += "/ownedDevices"
	return ss
}

// OwnedObjects returns service endpoint for CollectionDirectoryObject
func (s *ServiceUser) OwnedObjects() *ServiceCollectionDirectoryObject {
	ss := &ServiceCollectionDirectoryObject{ServiceBase: s.ServiceBase}
	ss.baseURL += "/ownedObjects"
	return ss
}

// People returns service endpoint for CollectionPerson
func (s *ServiceUser) People() *ServiceCollectionPerson {
	ss := &ServiceCollectionPerson{ServiceBase: s.ServiceBase}
	ss.baseURL += "/people"
	return ss
}

// Photo returns service endpoint for ProfilePhoto
func (s *ServiceUser) Photo() *ServiceProfilePhoto {
	ss := &ServiceProfilePhoto{ServiceBase: s.ServiceBase}
	ss.baseURL += "/photo"
	return ss
}

// Photos returns service endpoint for CollectionProfilePhoto
func (s *ServiceUser) Photos() *ServiceCollectionProfilePhoto {
	ss := &ServiceCollectionProfilePhoto{ServiceBase: s.ServiceBase}
	ss.baseURL += "/photos"
	return ss
}

// Planner returns service endpoint for PlannerUser
func (s *ServiceUser) Planner() *ServicePlannerUser {
	ss := &ServicePlannerUser{ServiceBase: s.ServiceBase}
	ss.baseURL += "/planner"
	return ss
}

// RegisteredDevices returns service endpoint for CollectionDirectoryObject
func (s *ServiceUser) RegisteredDevices() *ServiceCollectionDirectoryObject {
	ss := &ServiceCollectionDirectoryObject{ServiceBase: s.ServiceBase}
	ss.baseURL += "/registeredDevices"
	return ss
}

// Settings returns service endpoint for UserSettings
func (s *ServiceUser) Settings() *ServiceUserSettings {
	ss := &ServiceUserSettings{ServiceBase: s.ServiceBase}
	ss.baseURL += "/settings"
	return ss
}

// TransitiveMemberOf returns service endpoint for CollectionDirectoryObject
func (s *ServiceUser) TransitiveMemberOf() *ServiceCollectionDirectoryObject {
	ss := &ServiceCollectionDirectoryObject{ServiceBase: s.ServiceBase}
	ss.baseURL += "/transitiveMemberOf"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for User
func (s *ServiceUser) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceUser) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for User
func (s *ServiceUser) DoRequestWithPath(method, path string, obj interface{}) (*User, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *User
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceUser) DoRequest(method string, obj interface{}) (*User, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceUser) GetWithPath(path string) (*User, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceUser) Get() (*User, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceUser) PostWithPath(path string) (*User, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceUser) Post() (*User, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for User collection with addtional path
func (s *ServiceCollectionUser) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionUser) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for User
func (s *ServiceCollectionUser) DoRequestWithPath(method, path string, obj interface{}) (*User, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *User
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionUser) DoRequest(method string, obj interface{}) (*User, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for User collection
func (s *ServiceCollectionUser) DoPagingNext(res *http.Response) ([]User, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []User
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for User collection
func (s *ServiceCollectionUser) DoPagingWithPath(method, path string, obj interface{}) ([]User, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionUser) DoPaging(method string, obj interface{}) ([]User, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionUser) GetWithPath(path string) ([]User, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionUser) Get() ([]User, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionUser) PostWithPath(path string, obj interface{}) (*User, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionUser) Post(obj interface{}) (*User, error) {
	return s.PostWithPath("", obj)
}

// HistoryItems returns service endpoint for CollectionActivityHistoryItem
func (s *ServiceUserActivity) HistoryItems() *ServiceCollectionActivityHistoryItem {
	ss := &ServiceCollectionActivityHistoryItem{ServiceBase: s.ServiceBase}
	ss.baseURL += "/historyItems"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for UserActivity
func (s *ServiceUserActivity) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceUserActivity) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for UserActivity
func (s *ServiceUserActivity) DoRequestWithPath(method, path string, obj interface{}) (*UserActivity, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *UserActivity
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceUserActivity) DoRequest(method string, obj interface{}) (*UserActivity, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceUserActivity) GetWithPath(path string) (*UserActivity, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceUserActivity) Get() (*UserActivity, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceUserActivity) PostWithPath(path string) (*UserActivity, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceUserActivity) Post() (*UserActivity, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for UserActivity collection with addtional path
func (s *ServiceCollectionUserActivity) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionUserActivity) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for UserActivity
func (s *ServiceCollectionUserActivity) DoRequestWithPath(method, path string, obj interface{}) (*UserActivity, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *UserActivity
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionUserActivity) DoRequest(method string, obj interface{}) (*UserActivity, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for UserActivity collection
func (s *ServiceCollectionUserActivity) DoPagingNext(res *http.Response) ([]UserActivity, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []UserActivity
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for UserActivity collection
func (s *ServiceCollectionUserActivity) DoPagingWithPath(method, path string, obj interface{}) ([]UserActivity, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionUserActivity) DoPaging(method string, obj interface{}) ([]UserActivity, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionUserActivity) GetWithPath(path string) ([]UserActivity, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionUserActivity) Get() ([]UserActivity, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionUserActivity) PostWithPath(path string, obj interface{}) (*UserActivity, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionUserActivity) Post(obj interface{}) (*UserActivity, error) {
	return s.PostWithPath("", obj)
}

// DeviceStates returns service endpoint for CollectionDeviceInstallState
func (s *ServiceUserInstallStateSummary) DeviceStates() *ServiceCollectionDeviceInstallState {
	ss := &ServiceCollectionDeviceInstallState{ServiceBase: s.ServiceBase}
	ss.baseURL += "/deviceStates"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for UserInstallStateSummary
func (s *ServiceUserInstallStateSummary) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceUserInstallStateSummary) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for UserInstallStateSummary
func (s *ServiceUserInstallStateSummary) DoRequestWithPath(method, path string, obj interface{}) (*UserInstallStateSummary, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *UserInstallStateSummary
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceUserInstallStateSummary) DoRequest(method string, obj interface{}) (*UserInstallStateSummary, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceUserInstallStateSummary) GetWithPath(path string) (*UserInstallStateSummary, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceUserInstallStateSummary) Get() (*UserInstallStateSummary, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceUserInstallStateSummary) PostWithPath(path string) (*UserInstallStateSummary, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceUserInstallStateSummary) Post() (*UserInstallStateSummary, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for UserInstallStateSummary collection with addtional path
func (s *ServiceCollectionUserInstallStateSummary) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionUserInstallStateSummary) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for UserInstallStateSummary
func (s *ServiceCollectionUserInstallStateSummary) DoRequestWithPath(method, path string, obj interface{}) (*UserInstallStateSummary, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *UserInstallStateSummary
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionUserInstallStateSummary) DoRequest(method string, obj interface{}) (*UserInstallStateSummary, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for UserInstallStateSummary collection
func (s *ServiceCollectionUserInstallStateSummary) DoPagingNext(res *http.Response) ([]UserInstallStateSummary, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []UserInstallStateSummary
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for UserInstallStateSummary collection
func (s *ServiceCollectionUserInstallStateSummary) DoPagingWithPath(method, path string, obj interface{}) ([]UserInstallStateSummary, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionUserInstallStateSummary) DoPaging(method string, obj interface{}) ([]UserInstallStateSummary, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionUserInstallStateSummary) GetWithPath(path string) ([]UserInstallStateSummary, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionUserInstallStateSummary) Get() ([]UserInstallStateSummary, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionUserInstallStateSummary) PostWithPath(path string, obj interface{}) (*UserInstallStateSummary, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionUserInstallStateSummary) Post(obj interface{}) (*UserInstallStateSummary, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for UserSettings
func (s *ServiceUserSettings) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceUserSettings) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for UserSettings
func (s *ServiceUserSettings) DoRequestWithPath(method, path string, obj interface{}) (*UserSettings, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *UserSettings
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceUserSettings) DoRequest(method string, obj interface{}) (*UserSettings, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceUserSettings) GetWithPath(path string) (*UserSettings, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceUserSettings) Get() (*UserSettings, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceUserSettings) PostWithPath(path string) (*UserSettings, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceUserSettings) Post() (*UserSettings, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for VppToken collection with addtional path
func (s *ServiceCollectionVppToken) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionVppToken) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for VppToken
func (s *ServiceCollectionVppToken) DoRequestWithPath(method, path string, obj interface{}) (*VppToken, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *VppToken
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionVppToken) DoRequest(method string, obj interface{}) (*VppToken, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for VppToken collection
func (s *ServiceCollectionVppToken) DoPagingNext(res *http.Response) ([]VppToken, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []VppToken
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for VppToken collection
func (s *ServiceCollectionVppToken) DoPagingWithPath(method, path string, obj interface{}) ([]VppToken, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionVppToken) DoPaging(method string, obj interface{}) ([]VppToken, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionVppToken) GetWithPath(path string) ([]VppToken, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionVppToken) Get() ([]VppToken, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionVppToken) PostWithPath(path string, obj interface{}) (*VppToken, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionVppToken) Post(obj interface{}) (*VppToken, error) {
	return s.PostWithPath("", obj)
}

// Assignments returns service endpoint for CollectionTargetedManagedAppPolicyAssignment
func (s *ServiceWindowsInformationProtection) Assignments() *ServiceCollectionTargetedManagedAppPolicyAssignment {
	ss := &ServiceCollectionTargetedManagedAppPolicyAssignment{ServiceBase: s.ServiceBase}
	ss.baseURL += "/assignments"
	return ss
}

// ExemptAppLockerFiles returns service endpoint for CollectionWindowsInformationProtectionAppLockerFile
func (s *ServiceWindowsInformationProtection) ExemptAppLockerFiles() *ServiceCollectionWindowsInformationProtectionAppLockerFile {
	ss := &ServiceCollectionWindowsInformationProtectionAppLockerFile{ServiceBase: s.ServiceBase}
	ss.baseURL += "/exemptAppLockerFiles"
	return ss
}

// ProtectedAppLockerFiles returns service endpoint for CollectionWindowsInformationProtectionAppLockerFile
func (s *ServiceWindowsInformationProtection) ProtectedAppLockerFiles() *ServiceCollectionWindowsInformationProtectionAppLockerFile {
	ss := &ServiceCollectionWindowsInformationProtectionAppLockerFile{ServiceBase: s.ServiceBase}
	ss.baseURL += "/protectedAppLockerFiles"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for WindowsInformationProtection
func (s *ServiceWindowsInformationProtection) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceWindowsInformationProtection) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for WindowsInformationProtection
func (s *ServiceWindowsInformationProtection) DoRequestWithPath(method, path string, obj interface{}) (*WindowsInformationProtection, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *WindowsInformationProtection
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceWindowsInformationProtection) DoRequest(method string, obj interface{}) (*WindowsInformationProtection, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceWindowsInformationProtection) GetWithPath(path string) (*WindowsInformationProtection, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceWindowsInformationProtection) Get() (*WindowsInformationProtection, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceWindowsInformationProtection) PostWithPath(path string) (*WindowsInformationProtection, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceWindowsInformationProtection) Post() (*WindowsInformationProtection, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for WindowsInformationProtectionAppLearningSummary collection with addtional path
func (s *ServiceCollectionWindowsInformationProtectionAppLearningSummary) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionWindowsInformationProtectionAppLearningSummary) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for WindowsInformationProtectionAppLearningSummary
func (s *ServiceCollectionWindowsInformationProtectionAppLearningSummary) DoRequestWithPath(method, path string, obj interface{}) (*WindowsInformationProtectionAppLearningSummary, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *WindowsInformationProtectionAppLearningSummary
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionWindowsInformationProtectionAppLearningSummary) DoRequest(method string, obj interface{}) (*WindowsInformationProtectionAppLearningSummary, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for WindowsInformationProtectionAppLearningSummary collection
func (s *ServiceCollectionWindowsInformationProtectionAppLearningSummary) DoPagingNext(res *http.Response) ([]WindowsInformationProtectionAppLearningSummary, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []WindowsInformationProtectionAppLearningSummary
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for WindowsInformationProtectionAppLearningSummary collection
func (s *ServiceCollectionWindowsInformationProtectionAppLearningSummary) DoPagingWithPath(method, path string, obj interface{}) ([]WindowsInformationProtectionAppLearningSummary, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionWindowsInformationProtectionAppLearningSummary) DoPaging(method string, obj interface{}) ([]WindowsInformationProtectionAppLearningSummary, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionWindowsInformationProtectionAppLearningSummary) GetWithPath(path string) ([]WindowsInformationProtectionAppLearningSummary, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionWindowsInformationProtectionAppLearningSummary) Get() ([]WindowsInformationProtectionAppLearningSummary, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionWindowsInformationProtectionAppLearningSummary) PostWithPath(path string, obj interface{}) (*WindowsInformationProtectionAppLearningSummary, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionWindowsInformationProtectionAppLearningSummary) Post(obj interface{}) (*WindowsInformationProtectionAppLearningSummary, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for WindowsInformationProtectionAppLockerFile collection with addtional path
func (s *ServiceCollectionWindowsInformationProtectionAppLockerFile) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionWindowsInformationProtectionAppLockerFile) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for WindowsInformationProtectionAppLockerFile
func (s *ServiceCollectionWindowsInformationProtectionAppLockerFile) DoRequestWithPath(method, path string, obj interface{}) (*WindowsInformationProtectionAppLockerFile, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *WindowsInformationProtectionAppLockerFile
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionWindowsInformationProtectionAppLockerFile) DoRequest(method string, obj interface{}) (*WindowsInformationProtectionAppLockerFile, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for WindowsInformationProtectionAppLockerFile collection
func (s *ServiceCollectionWindowsInformationProtectionAppLockerFile) DoPagingNext(res *http.Response) ([]WindowsInformationProtectionAppLockerFile, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []WindowsInformationProtectionAppLockerFile
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for WindowsInformationProtectionAppLockerFile collection
func (s *ServiceCollectionWindowsInformationProtectionAppLockerFile) DoPagingWithPath(method, path string, obj interface{}) ([]WindowsInformationProtectionAppLockerFile, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionWindowsInformationProtectionAppLockerFile) DoPaging(method string, obj interface{}) ([]WindowsInformationProtectionAppLockerFile, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionWindowsInformationProtectionAppLockerFile) GetWithPath(path string) ([]WindowsInformationProtectionAppLockerFile, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionWindowsInformationProtectionAppLockerFile) Get() ([]WindowsInformationProtectionAppLockerFile, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionWindowsInformationProtectionAppLockerFile) PostWithPath(path string, obj interface{}) (*WindowsInformationProtectionAppLockerFile, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionWindowsInformationProtectionAppLockerFile) Post(obj interface{}) (*WindowsInformationProtectionAppLockerFile, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for WindowsInformationProtectionNetworkLearningSummary collection with addtional path
func (s *ServiceCollectionWindowsInformationProtectionNetworkLearningSummary) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionWindowsInformationProtectionNetworkLearningSummary) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for WindowsInformationProtectionNetworkLearningSummary
func (s *ServiceCollectionWindowsInformationProtectionNetworkLearningSummary) DoRequestWithPath(method, path string, obj interface{}) (*WindowsInformationProtectionNetworkLearningSummary, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *WindowsInformationProtectionNetworkLearningSummary
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionWindowsInformationProtectionNetworkLearningSummary) DoRequest(method string, obj interface{}) (*WindowsInformationProtectionNetworkLearningSummary, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for WindowsInformationProtectionNetworkLearningSummary collection
func (s *ServiceCollectionWindowsInformationProtectionNetworkLearningSummary) DoPagingNext(res *http.Response) ([]WindowsInformationProtectionNetworkLearningSummary, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []WindowsInformationProtectionNetworkLearningSummary
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for WindowsInformationProtectionNetworkLearningSummary collection
func (s *ServiceCollectionWindowsInformationProtectionNetworkLearningSummary) DoPagingWithPath(method, path string, obj interface{}) ([]WindowsInformationProtectionNetworkLearningSummary, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionWindowsInformationProtectionNetworkLearningSummary) DoPaging(method string, obj interface{}) ([]WindowsInformationProtectionNetworkLearningSummary, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionWindowsInformationProtectionNetworkLearningSummary) GetWithPath(path string) ([]WindowsInformationProtectionNetworkLearningSummary, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionWindowsInformationProtectionNetworkLearningSummary) Get() ([]WindowsInformationProtectionNetworkLearningSummary, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionWindowsInformationProtectionNetworkLearningSummary) PostWithPath(path string, obj interface{}) (*WindowsInformationProtectionNetworkLearningSummary, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionWindowsInformationProtectionNetworkLearningSummary) Post(obj interface{}) (*WindowsInformationProtectionNetworkLearningSummary, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for WindowsInformationProtectionPolicy collection with addtional path
func (s *ServiceCollectionWindowsInformationProtectionPolicy) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionWindowsInformationProtectionPolicy) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for WindowsInformationProtectionPolicy
func (s *ServiceCollectionWindowsInformationProtectionPolicy) DoRequestWithPath(method, path string, obj interface{}) (*WindowsInformationProtectionPolicy, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *WindowsInformationProtectionPolicy
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionWindowsInformationProtectionPolicy) DoRequest(method string, obj interface{}) (*WindowsInformationProtectionPolicy, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for WindowsInformationProtectionPolicy collection
func (s *ServiceCollectionWindowsInformationProtectionPolicy) DoPagingNext(res *http.Response) ([]WindowsInformationProtectionPolicy, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []WindowsInformationProtectionPolicy
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for WindowsInformationProtectionPolicy collection
func (s *ServiceCollectionWindowsInformationProtectionPolicy) DoPagingWithPath(method, path string, obj interface{}) ([]WindowsInformationProtectionPolicy, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionWindowsInformationProtectionPolicy) DoPaging(method string, obj interface{}) ([]WindowsInformationProtectionPolicy, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionWindowsInformationProtectionPolicy) GetWithPath(path string) ([]WindowsInformationProtectionPolicy, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionWindowsInformationProtectionPolicy) Get() ([]WindowsInformationProtectionPolicy, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionWindowsInformationProtectionPolicy) PostWithPath(path string, obj interface{}) (*WindowsInformationProtectionPolicy, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionWindowsInformationProtectionPolicy) Post(obj interface{}) (*WindowsInformationProtectionPolicy, error) {
	return s.PostWithPath("", obj)
}

// Application returns service endpoint for WorkbookApplication
func (s *ServiceWorkbook) Application() *ServiceWorkbookApplication {
	ss := &ServiceWorkbookApplication{ServiceBase: s.ServiceBase}
	ss.baseURL += "/application"
	return ss
}

// Comments returns service endpoint for CollectionWorkbookComment
func (s *ServiceWorkbook) Comments() *ServiceCollectionWorkbookComment {
	ss := &ServiceCollectionWorkbookComment{ServiceBase: s.ServiceBase}
	ss.baseURL += "/comments"
	return ss
}

// Functions returns service endpoint for WorkbookFunctions
func (s *ServiceWorkbook) Functions() *ServiceWorkbookFunctions {
	ss := &ServiceWorkbookFunctions{ServiceBase: s.ServiceBase}
	ss.baseURL += "/functions"
	return ss
}

// Names returns service endpoint for CollectionWorkbookNamedItem
func (s *ServiceWorkbook) Names() *ServiceCollectionWorkbookNamedItem {
	ss := &ServiceCollectionWorkbookNamedItem{ServiceBase: s.ServiceBase}
	ss.baseURL += "/names"
	return ss
}

// Tables returns service endpoint for CollectionWorkbookTable
func (s *ServiceWorkbook) Tables() *ServiceCollectionWorkbookTable {
	ss := &ServiceCollectionWorkbookTable{ServiceBase: s.ServiceBase}
	ss.baseURL += "/tables"
	return ss
}

// Worksheets returns service endpoint for CollectionWorkbookWorksheet
func (s *ServiceWorkbook) Worksheets() *ServiceCollectionWorkbookWorksheet {
	ss := &ServiceCollectionWorkbookWorksheet{ServiceBase: s.ServiceBase}
	ss.baseURL += "/worksheets"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for Workbook
func (s *ServiceWorkbook) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceWorkbook) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for Workbook
func (s *ServiceWorkbook) DoRequestWithPath(method, path string, obj interface{}) (*Workbook, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *Workbook
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceWorkbook) DoRequest(method string, obj interface{}) (*Workbook, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceWorkbook) GetWithPath(path string) (*Workbook, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceWorkbook) Get() (*Workbook, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceWorkbook) PostWithPath(path string) (*Workbook, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceWorkbook) Post() (*Workbook, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for WorkbookApplication
func (s *ServiceWorkbookApplication) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceWorkbookApplication) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for WorkbookApplication
func (s *ServiceWorkbookApplication) DoRequestWithPath(method, path string, obj interface{}) (*WorkbookApplication, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *WorkbookApplication
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceWorkbookApplication) DoRequest(method string, obj interface{}) (*WorkbookApplication, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceWorkbookApplication) GetWithPath(path string) (*WorkbookApplication, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceWorkbookApplication) Get() (*WorkbookApplication, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceWorkbookApplication) PostWithPath(path string) (*WorkbookApplication, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceWorkbookApplication) Post() (*WorkbookApplication, error) {
	return s.PostWithPath("")
}

// Axes returns service endpoint for WorkbookChartAxes
func (s *ServiceWorkbookChart) Axes() *ServiceWorkbookChartAxes {
	ss := &ServiceWorkbookChartAxes{ServiceBase: s.ServiceBase}
	ss.baseURL += "/axes"
	return ss
}

// DataLabels returns service endpoint for WorkbookChartDataLabels
func (s *ServiceWorkbookChart) DataLabels() *ServiceWorkbookChartDataLabels {
	ss := &ServiceWorkbookChartDataLabels{ServiceBase: s.ServiceBase}
	ss.baseURL += "/dataLabels"
	return ss
}

// Format returns service endpoint for WorkbookChartAreaFormat
func (s *ServiceWorkbookChart) Format() *ServiceWorkbookChartAreaFormat {
	ss := &ServiceWorkbookChartAreaFormat{ServiceBase: s.ServiceBase}
	ss.baseURL += "/format"
	return ss
}

// Legend returns service endpoint for WorkbookChartLegend
func (s *ServiceWorkbookChart) Legend() *ServiceWorkbookChartLegend {
	ss := &ServiceWorkbookChartLegend{ServiceBase: s.ServiceBase}
	ss.baseURL += "/legend"
	return ss
}

// Series returns service endpoint for CollectionWorkbookChartSeries
func (s *ServiceWorkbookChart) Series() *ServiceCollectionWorkbookChartSeries {
	ss := &ServiceCollectionWorkbookChartSeries{ServiceBase: s.ServiceBase}
	ss.baseURL += "/series"
	return ss
}

// Title returns service endpoint for WorkbookChartTitle
func (s *ServiceWorkbookChart) Title() *ServiceWorkbookChartTitle {
	ss := &ServiceWorkbookChartTitle{ServiceBase: s.ServiceBase}
	ss.baseURL += "/title"
	return ss
}

// Worksheet returns service endpoint for WorkbookWorksheet
func (s *ServiceWorkbookChart) Worksheet() *ServiceWorkbookWorksheet {
	ss := &ServiceWorkbookWorksheet{ServiceBase: s.ServiceBase}
	ss.baseURL += "/worksheet"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for WorkbookChart
func (s *ServiceWorkbookChart) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceWorkbookChart) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for WorkbookChart
func (s *ServiceWorkbookChart) DoRequestWithPath(method, path string, obj interface{}) (*WorkbookChart, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *WorkbookChart
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceWorkbookChart) DoRequest(method string, obj interface{}) (*WorkbookChart, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceWorkbookChart) GetWithPath(path string) (*WorkbookChart, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceWorkbookChart) Get() (*WorkbookChart, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceWorkbookChart) PostWithPath(path string) (*WorkbookChart, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceWorkbookChart) Post() (*WorkbookChart, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for WorkbookChart collection with addtional path
func (s *ServiceCollectionWorkbookChart) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionWorkbookChart) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for WorkbookChart
func (s *ServiceCollectionWorkbookChart) DoRequestWithPath(method, path string, obj interface{}) (*WorkbookChart, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *WorkbookChart
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionWorkbookChart) DoRequest(method string, obj interface{}) (*WorkbookChart, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for WorkbookChart collection
func (s *ServiceCollectionWorkbookChart) DoPagingNext(res *http.Response) ([]WorkbookChart, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []WorkbookChart
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for WorkbookChart collection
func (s *ServiceCollectionWorkbookChart) DoPagingWithPath(method, path string, obj interface{}) ([]WorkbookChart, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionWorkbookChart) DoPaging(method string, obj interface{}) ([]WorkbookChart, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionWorkbookChart) GetWithPath(path string) ([]WorkbookChart, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionWorkbookChart) Get() ([]WorkbookChart, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionWorkbookChart) PostWithPath(path string, obj interface{}) (*WorkbookChart, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionWorkbookChart) Post(obj interface{}) (*WorkbookChart, error) {
	return s.PostWithPath("", obj)
}

// Fill returns service endpoint for WorkbookChartFill
func (s *ServiceWorkbookChartAreaFormat) Fill() *ServiceWorkbookChartFill {
	ss := &ServiceWorkbookChartFill{ServiceBase: s.ServiceBase}
	ss.baseURL += "/fill"
	return ss
}

// Font returns service endpoint for WorkbookChartFont
func (s *ServiceWorkbookChartAreaFormat) Font() *ServiceWorkbookChartFont {
	ss := &ServiceWorkbookChartFont{ServiceBase: s.ServiceBase}
	ss.baseURL += "/font"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for WorkbookChartAreaFormat
func (s *ServiceWorkbookChartAreaFormat) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceWorkbookChartAreaFormat) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for WorkbookChartAreaFormat
func (s *ServiceWorkbookChartAreaFormat) DoRequestWithPath(method, path string, obj interface{}) (*WorkbookChartAreaFormat, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *WorkbookChartAreaFormat
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceWorkbookChartAreaFormat) DoRequest(method string, obj interface{}) (*WorkbookChartAreaFormat, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceWorkbookChartAreaFormat) GetWithPath(path string) (*WorkbookChartAreaFormat, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceWorkbookChartAreaFormat) Get() (*WorkbookChartAreaFormat, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceWorkbookChartAreaFormat) PostWithPath(path string) (*WorkbookChartAreaFormat, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceWorkbookChartAreaFormat) Post() (*WorkbookChartAreaFormat, error) {
	return s.PostWithPath("")
}

// CategoryAxis returns service endpoint for WorkbookChartAxis
func (s *ServiceWorkbookChartAxes) CategoryAxis() *ServiceWorkbookChartAxis {
	ss := &ServiceWorkbookChartAxis{ServiceBase: s.ServiceBase}
	ss.baseURL += "/categoryAxis"
	return ss
}

// SeriesAxis returns service endpoint for WorkbookChartAxis
func (s *ServiceWorkbookChartAxes) SeriesAxis() *ServiceWorkbookChartAxis {
	ss := &ServiceWorkbookChartAxis{ServiceBase: s.ServiceBase}
	ss.baseURL += "/seriesAxis"
	return ss
}

// ValueAxis returns service endpoint for WorkbookChartAxis
func (s *ServiceWorkbookChartAxes) ValueAxis() *ServiceWorkbookChartAxis {
	ss := &ServiceWorkbookChartAxis{ServiceBase: s.ServiceBase}
	ss.baseURL += "/valueAxis"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for WorkbookChartAxes
func (s *ServiceWorkbookChartAxes) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceWorkbookChartAxes) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for WorkbookChartAxes
func (s *ServiceWorkbookChartAxes) DoRequestWithPath(method, path string, obj interface{}) (*WorkbookChartAxes, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *WorkbookChartAxes
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceWorkbookChartAxes) DoRequest(method string, obj interface{}) (*WorkbookChartAxes, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceWorkbookChartAxes) GetWithPath(path string) (*WorkbookChartAxes, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceWorkbookChartAxes) Get() (*WorkbookChartAxes, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceWorkbookChartAxes) PostWithPath(path string) (*WorkbookChartAxes, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceWorkbookChartAxes) Post() (*WorkbookChartAxes, error) {
	return s.PostWithPath("")
}

// Format returns service endpoint for WorkbookChartAxisFormat
func (s *ServiceWorkbookChartAxis) Format() *ServiceWorkbookChartAxisFormat {
	ss := &ServiceWorkbookChartAxisFormat{ServiceBase: s.ServiceBase}
	ss.baseURL += "/format"
	return ss
}

// MajorGridlines returns service endpoint for WorkbookChartGridlines
func (s *ServiceWorkbookChartAxis) MajorGridlines() *ServiceWorkbookChartGridlines {
	ss := &ServiceWorkbookChartGridlines{ServiceBase: s.ServiceBase}
	ss.baseURL += "/majorGridlines"
	return ss
}

// MinorGridlines returns service endpoint for WorkbookChartGridlines
func (s *ServiceWorkbookChartAxis) MinorGridlines() *ServiceWorkbookChartGridlines {
	ss := &ServiceWorkbookChartGridlines{ServiceBase: s.ServiceBase}
	ss.baseURL += "/minorGridlines"
	return ss
}

// Title returns service endpoint for WorkbookChartAxisTitle
func (s *ServiceWorkbookChartAxis) Title() *ServiceWorkbookChartAxisTitle {
	ss := &ServiceWorkbookChartAxisTitle{ServiceBase: s.ServiceBase}
	ss.baseURL += "/title"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for WorkbookChartAxis
func (s *ServiceWorkbookChartAxis) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceWorkbookChartAxis) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for WorkbookChartAxis
func (s *ServiceWorkbookChartAxis) DoRequestWithPath(method, path string, obj interface{}) (*WorkbookChartAxis, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *WorkbookChartAxis
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceWorkbookChartAxis) DoRequest(method string, obj interface{}) (*WorkbookChartAxis, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceWorkbookChartAxis) GetWithPath(path string) (*WorkbookChartAxis, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceWorkbookChartAxis) Get() (*WorkbookChartAxis, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceWorkbookChartAxis) PostWithPath(path string) (*WorkbookChartAxis, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceWorkbookChartAxis) Post() (*WorkbookChartAxis, error) {
	return s.PostWithPath("")
}

// Font returns service endpoint for WorkbookChartFont
func (s *ServiceWorkbookChartAxisFormat) Font() *ServiceWorkbookChartFont {
	ss := &ServiceWorkbookChartFont{ServiceBase: s.ServiceBase}
	ss.baseURL += "/font"
	return ss
}

// Line returns service endpoint for WorkbookChartLineFormat
func (s *ServiceWorkbookChartAxisFormat) Line() *ServiceWorkbookChartLineFormat {
	ss := &ServiceWorkbookChartLineFormat{ServiceBase: s.ServiceBase}
	ss.baseURL += "/line"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for WorkbookChartAxisFormat
func (s *ServiceWorkbookChartAxisFormat) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceWorkbookChartAxisFormat) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for WorkbookChartAxisFormat
func (s *ServiceWorkbookChartAxisFormat) DoRequestWithPath(method, path string, obj interface{}) (*WorkbookChartAxisFormat, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *WorkbookChartAxisFormat
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceWorkbookChartAxisFormat) DoRequest(method string, obj interface{}) (*WorkbookChartAxisFormat, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceWorkbookChartAxisFormat) GetWithPath(path string) (*WorkbookChartAxisFormat, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceWorkbookChartAxisFormat) Get() (*WorkbookChartAxisFormat, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceWorkbookChartAxisFormat) PostWithPath(path string) (*WorkbookChartAxisFormat, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceWorkbookChartAxisFormat) Post() (*WorkbookChartAxisFormat, error) {
	return s.PostWithPath("")
}

// Format returns service endpoint for WorkbookChartAxisTitleFormat
func (s *ServiceWorkbookChartAxisTitle) Format() *ServiceWorkbookChartAxisTitleFormat {
	ss := &ServiceWorkbookChartAxisTitleFormat{ServiceBase: s.ServiceBase}
	ss.baseURL += "/format"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for WorkbookChartAxisTitle
func (s *ServiceWorkbookChartAxisTitle) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceWorkbookChartAxisTitle) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for WorkbookChartAxisTitle
func (s *ServiceWorkbookChartAxisTitle) DoRequestWithPath(method, path string, obj interface{}) (*WorkbookChartAxisTitle, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *WorkbookChartAxisTitle
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceWorkbookChartAxisTitle) DoRequest(method string, obj interface{}) (*WorkbookChartAxisTitle, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceWorkbookChartAxisTitle) GetWithPath(path string) (*WorkbookChartAxisTitle, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceWorkbookChartAxisTitle) Get() (*WorkbookChartAxisTitle, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceWorkbookChartAxisTitle) PostWithPath(path string) (*WorkbookChartAxisTitle, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceWorkbookChartAxisTitle) Post() (*WorkbookChartAxisTitle, error) {
	return s.PostWithPath("")
}

// Font returns service endpoint for WorkbookChartFont
func (s *ServiceWorkbookChartAxisTitleFormat) Font() *ServiceWorkbookChartFont {
	ss := &ServiceWorkbookChartFont{ServiceBase: s.ServiceBase}
	ss.baseURL += "/font"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for WorkbookChartAxisTitleFormat
func (s *ServiceWorkbookChartAxisTitleFormat) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceWorkbookChartAxisTitleFormat) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for WorkbookChartAxisTitleFormat
func (s *ServiceWorkbookChartAxisTitleFormat) DoRequestWithPath(method, path string, obj interface{}) (*WorkbookChartAxisTitleFormat, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *WorkbookChartAxisTitleFormat
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceWorkbookChartAxisTitleFormat) DoRequest(method string, obj interface{}) (*WorkbookChartAxisTitleFormat, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceWorkbookChartAxisTitleFormat) GetWithPath(path string) (*WorkbookChartAxisTitleFormat, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceWorkbookChartAxisTitleFormat) Get() (*WorkbookChartAxisTitleFormat, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceWorkbookChartAxisTitleFormat) PostWithPath(path string) (*WorkbookChartAxisTitleFormat, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceWorkbookChartAxisTitleFormat) Post() (*WorkbookChartAxisTitleFormat, error) {
	return s.PostWithPath("")
}

// Fill returns service endpoint for WorkbookChartFill
func (s *ServiceWorkbookChartDataLabelFormat) Fill() *ServiceWorkbookChartFill {
	ss := &ServiceWorkbookChartFill{ServiceBase: s.ServiceBase}
	ss.baseURL += "/fill"
	return ss
}

// Font returns service endpoint for WorkbookChartFont
func (s *ServiceWorkbookChartDataLabelFormat) Font() *ServiceWorkbookChartFont {
	ss := &ServiceWorkbookChartFont{ServiceBase: s.ServiceBase}
	ss.baseURL += "/font"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for WorkbookChartDataLabelFormat
func (s *ServiceWorkbookChartDataLabelFormat) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceWorkbookChartDataLabelFormat) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for WorkbookChartDataLabelFormat
func (s *ServiceWorkbookChartDataLabelFormat) DoRequestWithPath(method, path string, obj interface{}) (*WorkbookChartDataLabelFormat, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *WorkbookChartDataLabelFormat
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceWorkbookChartDataLabelFormat) DoRequest(method string, obj interface{}) (*WorkbookChartDataLabelFormat, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceWorkbookChartDataLabelFormat) GetWithPath(path string) (*WorkbookChartDataLabelFormat, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceWorkbookChartDataLabelFormat) Get() (*WorkbookChartDataLabelFormat, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceWorkbookChartDataLabelFormat) PostWithPath(path string) (*WorkbookChartDataLabelFormat, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceWorkbookChartDataLabelFormat) Post() (*WorkbookChartDataLabelFormat, error) {
	return s.PostWithPath("")
}

// Format returns service endpoint for WorkbookChartDataLabelFormat
func (s *ServiceWorkbookChartDataLabels) Format() *ServiceWorkbookChartDataLabelFormat {
	ss := &ServiceWorkbookChartDataLabelFormat{ServiceBase: s.ServiceBase}
	ss.baseURL += "/format"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for WorkbookChartDataLabels
func (s *ServiceWorkbookChartDataLabels) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceWorkbookChartDataLabels) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for WorkbookChartDataLabels
func (s *ServiceWorkbookChartDataLabels) DoRequestWithPath(method, path string, obj interface{}) (*WorkbookChartDataLabels, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *WorkbookChartDataLabels
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceWorkbookChartDataLabels) DoRequest(method string, obj interface{}) (*WorkbookChartDataLabels, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceWorkbookChartDataLabels) GetWithPath(path string) (*WorkbookChartDataLabels, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceWorkbookChartDataLabels) Get() (*WorkbookChartDataLabels, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceWorkbookChartDataLabels) PostWithPath(path string) (*WorkbookChartDataLabels, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceWorkbookChartDataLabels) Post() (*WorkbookChartDataLabels, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for WorkbookChartFill
func (s *ServiceWorkbookChartFill) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceWorkbookChartFill) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for WorkbookChartFill
func (s *ServiceWorkbookChartFill) DoRequestWithPath(method, path string, obj interface{}) (*WorkbookChartFill, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *WorkbookChartFill
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceWorkbookChartFill) DoRequest(method string, obj interface{}) (*WorkbookChartFill, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceWorkbookChartFill) GetWithPath(path string) (*WorkbookChartFill, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceWorkbookChartFill) Get() (*WorkbookChartFill, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceWorkbookChartFill) PostWithPath(path string) (*WorkbookChartFill, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceWorkbookChartFill) Post() (*WorkbookChartFill, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for WorkbookChartFont
func (s *ServiceWorkbookChartFont) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceWorkbookChartFont) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for WorkbookChartFont
func (s *ServiceWorkbookChartFont) DoRequestWithPath(method, path string, obj interface{}) (*WorkbookChartFont, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *WorkbookChartFont
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceWorkbookChartFont) DoRequest(method string, obj interface{}) (*WorkbookChartFont, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceWorkbookChartFont) GetWithPath(path string) (*WorkbookChartFont, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceWorkbookChartFont) Get() (*WorkbookChartFont, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceWorkbookChartFont) PostWithPath(path string) (*WorkbookChartFont, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceWorkbookChartFont) Post() (*WorkbookChartFont, error) {
	return s.PostWithPath("")
}

// Format returns service endpoint for WorkbookChartGridlinesFormat
func (s *ServiceWorkbookChartGridlines) Format() *ServiceWorkbookChartGridlinesFormat {
	ss := &ServiceWorkbookChartGridlinesFormat{ServiceBase: s.ServiceBase}
	ss.baseURL += "/format"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for WorkbookChartGridlines
func (s *ServiceWorkbookChartGridlines) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceWorkbookChartGridlines) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for WorkbookChartGridlines
func (s *ServiceWorkbookChartGridlines) DoRequestWithPath(method, path string, obj interface{}) (*WorkbookChartGridlines, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *WorkbookChartGridlines
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceWorkbookChartGridlines) DoRequest(method string, obj interface{}) (*WorkbookChartGridlines, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceWorkbookChartGridlines) GetWithPath(path string) (*WorkbookChartGridlines, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceWorkbookChartGridlines) Get() (*WorkbookChartGridlines, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceWorkbookChartGridlines) PostWithPath(path string) (*WorkbookChartGridlines, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceWorkbookChartGridlines) Post() (*WorkbookChartGridlines, error) {
	return s.PostWithPath("")
}

// Line returns service endpoint for WorkbookChartLineFormat
func (s *ServiceWorkbookChartGridlinesFormat) Line() *ServiceWorkbookChartLineFormat {
	ss := &ServiceWorkbookChartLineFormat{ServiceBase: s.ServiceBase}
	ss.baseURL += "/line"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for WorkbookChartGridlinesFormat
func (s *ServiceWorkbookChartGridlinesFormat) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceWorkbookChartGridlinesFormat) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for WorkbookChartGridlinesFormat
func (s *ServiceWorkbookChartGridlinesFormat) DoRequestWithPath(method, path string, obj interface{}) (*WorkbookChartGridlinesFormat, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *WorkbookChartGridlinesFormat
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceWorkbookChartGridlinesFormat) DoRequest(method string, obj interface{}) (*WorkbookChartGridlinesFormat, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceWorkbookChartGridlinesFormat) GetWithPath(path string) (*WorkbookChartGridlinesFormat, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceWorkbookChartGridlinesFormat) Get() (*WorkbookChartGridlinesFormat, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceWorkbookChartGridlinesFormat) PostWithPath(path string) (*WorkbookChartGridlinesFormat, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceWorkbookChartGridlinesFormat) Post() (*WorkbookChartGridlinesFormat, error) {
	return s.PostWithPath("")
}

// Format returns service endpoint for WorkbookChartLegendFormat
func (s *ServiceWorkbookChartLegend) Format() *ServiceWorkbookChartLegendFormat {
	ss := &ServiceWorkbookChartLegendFormat{ServiceBase: s.ServiceBase}
	ss.baseURL += "/format"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for WorkbookChartLegend
func (s *ServiceWorkbookChartLegend) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceWorkbookChartLegend) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for WorkbookChartLegend
func (s *ServiceWorkbookChartLegend) DoRequestWithPath(method, path string, obj interface{}) (*WorkbookChartLegend, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *WorkbookChartLegend
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceWorkbookChartLegend) DoRequest(method string, obj interface{}) (*WorkbookChartLegend, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceWorkbookChartLegend) GetWithPath(path string) (*WorkbookChartLegend, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceWorkbookChartLegend) Get() (*WorkbookChartLegend, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceWorkbookChartLegend) PostWithPath(path string) (*WorkbookChartLegend, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceWorkbookChartLegend) Post() (*WorkbookChartLegend, error) {
	return s.PostWithPath("")
}

// Fill returns service endpoint for WorkbookChartFill
func (s *ServiceWorkbookChartLegendFormat) Fill() *ServiceWorkbookChartFill {
	ss := &ServiceWorkbookChartFill{ServiceBase: s.ServiceBase}
	ss.baseURL += "/fill"
	return ss
}

// Font returns service endpoint for WorkbookChartFont
func (s *ServiceWorkbookChartLegendFormat) Font() *ServiceWorkbookChartFont {
	ss := &ServiceWorkbookChartFont{ServiceBase: s.ServiceBase}
	ss.baseURL += "/font"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for WorkbookChartLegendFormat
func (s *ServiceWorkbookChartLegendFormat) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceWorkbookChartLegendFormat) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for WorkbookChartLegendFormat
func (s *ServiceWorkbookChartLegendFormat) DoRequestWithPath(method, path string, obj interface{}) (*WorkbookChartLegendFormat, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *WorkbookChartLegendFormat
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceWorkbookChartLegendFormat) DoRequest(method string, obj interface{}) (*WorkbookChartLegendFormat, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceWorkbookChartLegendFormat) GetWithPath(path string) (*WorkbookChartLegendFormat, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceWorkbookChartLegendFormat) Get() (*WorkbookChartLegendFormat, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceWorkbookChartLegendFormat) PostWithPath(path string) (*WorkbookChartLegendFormat, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceWorkbookChartLegendFormat) Post() (*WorkbookChartLegendFormat, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for WorkbookChartLineFormat
func (s *ServiceWorkbookChartLineFormat) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceWorkbookChartLineFormat) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for WorkbookChartLineFormat
func (s *ServiceWorkbookChartLineFormat) DoRequestWithPath(method, path string, obj interface{}) (*WorkbookChartLineFormat, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *WorkbookChartLineFormat
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceWorkbookChartLineFormat) DoRequest(method string, obj interface{}) (*WorkbookChartLineFormat, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceWorkbookChartLineFormat) GetWithPath(path string) (*WorkbookChartLineFormat, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceWorkbookChartLineFormat) Get() (*WorkbookChartLineFormat, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceWorkbookChartLineFormat) PostWithPath(path string) (*WorkbookChartLineFormat, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceWorkbookChartLineFormat) Post() (*WorkbookChartLineFormat, error) {
	return s.PostWithPath("")
}

// Format returns service endpoint for WorkbookChartPointFormat
func (s *ServiceWorkbookChartPoint) Format() *ServiceWorkbookChartPointFormat {
	ss := &ServiceWorkbookChartPointFormat{ServiceBase: s.ServiceBase}
	ss.baseURL += "/format"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for WorkbookChartPoint
func (s *ServiceWorkbookChartPoint) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceWorkbookChartPoint) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for WorkbookChartPoint
func (s *ServiceWorkbookChartPoint) DoRequestWithPath(method, path string, obj interface{}) (*WorkbookChartPoint, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *WorkbookChartPoint
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceWorkbookChartPoint) DoRequest(method string, obj interface{}) (*WorkbookChartPoint, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceWorkbookChartPoint) GetWithPath(path string) (*WorkbookChartPoint, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceWorkbookChartPoint) Get() (*WorkbookChartPoint, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceWorkbookChartPoint) PostWithPath(path string) (*WorkbookChartPoint, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceWorkbookChartPoint) Post() (*WorkbookChartPoint, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for WorkbookChartPoint collection with addtional path
func (s *ServiceCollectionWorkbookChartPoint) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionWorkbookChartPoint) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for WorkbookChartPoint
func (s *ServiceCollectionWorkbookChartPoint) DoRequestWithPath(method, path string, obj interface{}) (*WorkbookChartPoint, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *WorkbookChartPoint
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionWorkbookChartPoint) DoRequest(method string, obj interface{}) (*WorkbookChartPoint, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for WorkbookChartPoint collection
func (s *ServiceCollectionWorkbookChartPoint) DoPagingNext(res *http.Response) ([]WorkbookChartPoint, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []WorkbookChartPoint
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for WorkbookChartPoint collection
func (s *ServiceCollectionWorkbookChartPoint) DoPagingWithPath(method, path string, obj interface{}) ([]WorkbookChartPoint, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionWorkbookChartPoint) DoPaging(method string, obj interface{}) ([]WorkbookChartPoint, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionWorkbookChartPoint) GetWithPath(path string) ([]WorkbookChartPoint, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionWorkbookChartPoint) Get() ([]WorkbookChartPoint, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionWorkbookChartPoint) PostWithPath(path string, obj interface{}) (*WorkbookChartPoint, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionWorkbookChartPoint) Post(obj interface{}) (*WorkbookChartPoint, error) {
	return s.PostWithPath("", obj)
}

// Fill returns service endpoint for WorkbookChartFill
func (s *ServiceWorkbookChartPointFormat) Fill() *ServiceWorkbookChartFill {
	ss := &ServiceWorkbookChartFill{ServiceBase: s.ServiceBase}
	ss.baseURL += "/fill"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for WorkbookChartPointFormat
func (s *ServiceWorkbookChartPointFormat) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceWorkbookChartPointFormat) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for WorkbookChartPointFormat
func (s *ServiceWorkbookChartPointFormat) DoRequestWithPath(method, path string, obj interface{}) (*WorkbookChartPointFormat, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *WorkbookChartPointFormat
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceWorkbookChartPointFormat) DoRequest(method string, obj interface{}) (*WorkbookChartPointFormat, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceWorkbookChartPointFormat) GetWithPath(path string) (*WorkbookChartPointFormat, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceWorkbookChartPointFormat) Get() (*WorkbookChartPointFormat, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceWorkbookChartPointFormat) PostWithPath(path string) (*WorkbookChartPointFormat, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceWorkbookChartPointFormat) Post() (*WorkbookChartPointFormat, error) {
	return s.PostWithPath("")
}

// Format returns service endpoint for WorkbookChartSeriesFormat
func (s *ServiceWorkbookChartSeries) Format() *ServiceWorkbookChartSeriesFormat {
	ss := &ServiceWorkbookChartSeriesFormat{ServiceBase: s.ServiceBase}
	ss.baseURL += "/format"
	return ss
}

// Points returns service endpoint for CollectionWorkbookChartPoint
func (s *ServiceWorkbookChartSeries) Points() *ServiceCollectionWorkbookChartPoint {
	ss := &ServiceCollectionWorkbookChartPoint{ServiceBase: s.ServiceBase}
	ss.baseURL += "/points"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for WorkbookChartSeries
func (s *ServiceWorkbookChartSeries) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceWorkbookChartSeries) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for WorkbookChartSeries
func (s *ServiceWorkbookChartSeries) DoRequestWithPath(method, path string, obj interface{}) (*WorkbookChartSeries, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *WorkbookChartSeries
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceWorkbookChartSeries) DoRequest(method string, obj interface{}) (*WorkbookChartSeries, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceWorkbookChartSeries) GetWithPath(path string) (*WorkbookChartSeries, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceWorkbookChartSeries) Get() (*WorkbookChartSeries, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceWorkbookChartSeries) PostWithPath(path string) (*WorkbookChartSeries, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceWorkbookChartSeries) Post() (*WorkbookChartSeries, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for WorkbookChartSeries collection with addtional path
func (s *ServiceCollectionWorkbookChartSeries) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionWorkbookChartSeries) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for WorkbookChartSeries
func (s *ServiceCollectionWorkbookChartSeries) DoRequestWithPath(method, path string, obj interface{}) (*WorkbookChartSeries, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *WorkbookChartSeries
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionWorkbookChartSeries) DoRequest(method string, obj interface{}) (*WorkbookChartSeries, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for WorkbookChartSeries collection
func (s *ServiceCollectionWorkbookChartSeries) DoPagingNext(res *http.Response) ([]WorkbookChartSeries, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []WorkbookChartSeries
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for WorkbookChartSeries collection
func (s *ServiceCollectionWorkbookChartSeries) DoPagingWithPath(method, path string, obj interface{}) ([]WorkbookChartSeries, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionWorkbookChartSeries) DoPaging(method string, obj interface{}) ([]WorkbookChartSeries, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionWorkbookChartSeries) GetWithPath(path string) ([]WorkbookChartSeries, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionWorkbookChartSeries) Get() ([]WorkbookChartSeries, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionWorkbookChartSeries) PostWithPath(path string, obj interface{}) (*WorkbookChartSeries, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionWorkbookChartSeries) Post(obj interface{}) (*WorkbookChartSeries, error) {
	return s.PostWithPath("", obj)
}

// Fill returns service endpoint for WorkbookChartFill
func (s *ServiceWorkbookChartSeriesFormat) Fill() *ServiceWorkbookChartFill {
	ss := &ServiceWorkbookChartFill{ServiceBase: s.ServiceBase}
	ss.baseURL += "/fill"
	return ss
}

// Line returns service endpoint for WorkbookChartLineFormat
func (s *ServiceWorkbookChartSeriesFormat) Line() *ServiceWorkbookChartLineFormat {
	ss := &ServiceWorkbookChartLineFormat{ServiceBase: s.ServiceBase}
	ss.baseURL += "/line"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for WorkbookChartSeriesFormat
func (s *ServiceWorkbookChartSeriesFormat) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceWorkbookChartSeriesFormat) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for WorkbookChartSeriesFormat
func (s *ServiceWorkbookChartSeriesFormat) DoRequestWithPath(method, path string, obj interface{}) (*WorkbookChartSeriesFormat, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *WorkbookChartSeriesFormat
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceWorkbookChartSeriesFormat) DoRequest(method string, obj interface{}) (*WorkbookChartSeriesFormat, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceWorkbookChartSeriesFormat) GetWithPath(path string) (*WorkbookChartSeriesFormat, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceWorkbookChartSeriesFormat) Get() (*WorkbookChartSeriesFormat, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceWorkbookChartSeriesFormat) PostWithPath(path string) (*WorkbookChartSeriesFormat, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceWorkbookChartSeriesFormat) Post() (*WorkbookChartSeriesFormat, error) {
	return s.PostWithPath("")
}

// Format returns service endpoint for WorkbookChartTitleFormat
func (s *ServiceWorkbookChartTitle) Format() *ServiceWorkbookChartTitleFormat {
	ss := &ServiceWorkbookChartTitleFormat{ServiceBase: s.ServiceBase}
	ss.baseURL += "/format"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for WorkbookChartTitle
func (s *ServiceWorkbookChartTitle) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceWorkbookChartTitle) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for WorkbookChartTitle
func (s *ServiceWorkbookChartTitle) DoRequestWithPath(method, path string, obj interface{}) (*WorkbookChartTitle, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *WorkbookChartTitle
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceWorkbookChartTitle) DoRequest(method string, obj interface{}) (*WorkbookChartTitle, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceWorkbookChartTitle) GetWithPath(path string) (*WorkbookChartTitle, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceWorkbookChartTitle) Get() (*WorkbookChartTitle, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceWorkbookChartTitle) PostWithPath(path string) (*WorkbookChartTitle, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceWorkbookChartTitle) Post() (*WorkbookChartTitle, error) {
	return s.PostWithPath("")
}

// Fill returns service endpoint for WorkbookChartFill
func (s *ServiceWorkbookChartTitleFormat) Fill() *ServiceWorkbookChartFill {
	ss := &ServiceWorkbookChartFill{ServiceBase: s.ServiceBase}
	ss.baseURL += "/fill"
	return ss
}

// Font returns service endpoint for WorkbookChartFont
func (s *ServiceWorkbookChartTitleFormat) Font() *ServiceWorkbookChartFont {
	ss := &ServiceWorkbookChartFont{ServiceBase: s.ServiceBase}
	ss.baseURL += "/font"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for WorkbookChartTitleFormat
func (s *ServiceWorkbookChartTitleFormat) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceWorkbookChartTitleFormat) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for WorkbookChartTitleFormat
func (s *ServiceWorkbookChartTitleFormat) DoRequestWithPath(method, path string, obj interface{}) (*WorkbookChartTitleFormat, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *WorkbookChartTitleFormat
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceWorkbookChartTitleFormat) DoRequest(method string, obj interface{}) (*WorkbookChartTitleFormat, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceWorkbookChartTitleFormat) GetWithPath(path string) (*WorkbookChartTitleFormat, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceWorkbookChartTitleFormat) Get() (*WorkbookChartTitleFormat, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceWorkbookChartTitleFormat) PostWithPath(path string) (*WorkbookChartTitleFormat, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceWorkbookChartTitleFormat) Post() (*WorkbookChartTitleFormat, error) {
	return s.PostWithPath("")
}

// Replies returns service endpoint for CollectionWorkbookCommentReply
func (s *ServiceWorkbookComment) Replies() *ServiceCollectionWorkbookCommentReply {
	ss := &ServiceCollectionWorkbookCommentReply{ServiceBase: s.ServiceBase}
	ss.baseURL += "/replies"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for WorkbookComment
func (s *ServiceWorkbookComment) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceWorkbookComment) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for WorkbookComment
func (s *ServiceWorkbookComment) DoRequestWithPath(method, path string, obj interface{}) (*WorkbookComment, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *WorkbookComment
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceWorkbookComment) DoRequest(method string, obj interface{}) (*WorkbookComment, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceWorkbookComment) GetWithPath(path string) (*WorkbookComment, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceWorkbookComment) Get() (*WorkbookComment, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceWorkbookComment) PostWithPath(path string) (*WorkbookComment, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceWorkbookComment) Post() (*WorkbookComment, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for WorkbookComment collection with addtional path
func (s *ServiceCollectionWorkbookComment) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionWorkbookComment) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for WorkbookComment
func (s *ServiceCollectionWorkbookComment) DoRequestWithPath(method, path string, obj interface{}) (*WorkbookComment, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *WorkbookComment
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionWorkbookComment) DoRequest(method string, obj interface{}) (*WorkbookComment, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for WorkbookComment collection
func (s *ServiceCollectionWorkbookComment) DoPagingNext(res *http.Response) ([]WorkbookComment, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []WorkbookComment
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for WorkbookComment collection
func (s *ServiceCollectionWorkbookComment) DoPagingWithPath(method, path string, obj interface{}) ([]WorkbookComment, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionWorkbookComment) DoPaging(method string, obj interface{}) ([]WorkbookComment, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionWorkbookComment) GetWithPath(path string) ([]WorkbookComment, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionWorkbookComment) Get() ([]WorkbookComment, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionWorkbookComment) PostWithPath(path string, obj interface{}) (*WorkbookComment, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionWorkbookComment) Post(obj interface{}) (*WorkbookComment, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for WorkbookCommentReply collection with addtional path
func (s *ServiceCollectionWorkbookCommentReply) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionWorkbookCommentReply) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for WorkbookCommentReply
func (s *ServiceCollectionWorkbookCommentReply) DoRequestWithPath(method, path string, obj interface{}) (*WorkbookCommentReply, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *WorkbookCommentReply
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionWorkbookCommentReply) DoRequest(method string, obj interface{}) (*WorkbookCommentReply, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for WorkbookCommentReply collection
func (s *ServiceCollectionWorkbookCommentReply) DoPagingNext(res *http.Response) ([]WorkbookCommentReply, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []WorkbookCommentReply
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for WorkbookCommentReply collection
func (s *ServiceCollectionWorkbookCommentReply) DoPagingWithPath(method, path string, obj interface{}) ([]WorkbookCommentReply, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionWorkbookCommentReply) DoPaging(method string, obj interface{}) ([]WorkbookCommentReply, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionWorkbookCommentReply) GetWithPath(path string) ([]WorkbookCommentReply, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionWorkbookCommentReply) Get() ([]WorkbookCommentReply, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionWorkbookCommentReply) PostWithPath(path string, obj interface{}) (*WorkbookCommentReply, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionWorkbookCommentReply) Post(obj interface{}) (*WorkbookCommentReply, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for WorkbookFilter
func (s *ServiceWorkbookFilter) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceWorkbookFilter) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for WorkbookFilter
func (s *ServiceWorkbookFilter) DoRequestWithPath(method, path string, obj interface{}) (*WorkbookFilter, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *WorkbookFilter
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceWorkbookFilter) DoRequest(method string, obj interface{}) (*WorkbookFilter, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceWorkbookFilter) GetWithPath(path string) (*WorkbookFilter, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceWorkbookFilter) Get() (*WorkbookFilter, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceWorkbookFilter) PostWithPath(path string) (*WorkbookFilter, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceWorkbookFilter) Post() (*WorkbookFilter, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for WorkbookFormatProtection
func (s *ServiceWorkbookFormatProtection) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceWorkbookFormatProtection) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for WorkbookFormatProtection
func (s *ServiceWorkbookFormatProtection) DoRequestWithPath(method, path string, obj interface{}) (*WorkbookFormatProtection, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *WorkbookFormatProtection
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceWorkbookFormatProtection) DoRequest(method string, obj interface{}) (*WorkbookFormatProtection, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceWorkbookFormatProtection) GetWithPath(path string) (*WorkbookFormatProtection, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceWorkbookFormatProtection) Get() (*WorkbookFormatProtection, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceWorkbookFormatProtection) PostWithPath(path string) (*WorkbookFormatProtection, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceWorkbookFormatProtection) Post() (*WorkbookFormatProtection, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for WorkbookFunctions
func (s *ServiceWorkbookFunctions) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceWorkbookFunctions) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for WorkbookFunctions
func (s *ServiceWorkbookFunctions) DoRequestWithPath(method, path string, obj interface{}) (*WorkbookFunctions, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *WorkbookFunctions
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceWorkbookFunctions) DoRequest(method string, obj interface{}) (*WorkbookFunctions, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceWorkbookFunctions) GetWithPath(path string) (*WorkbookFunctions, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceWorkbookFunctions) Get() (*WorkbookFunctions, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceWorkbookFunctions) PostWithPath(path string) (*WorkbookFunctions, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceWorkbookFunctions) Post() (*WorkbookFunctions, error) {
	return s.PostWithPath("")
}

// Worksheet returns service endpoint for WorkbookWorksheet
func (s *ServiceWorkbookNamedItem) Worksheet() *ServiceWorkbookWorksheet {
	ss := &ServiceWorkbookWorksheet{ServiceBase: s.ServiceBase}
	ss.baseURL += "/worksheet"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for WorkbookNamedItem
func (s *ServiceWorkbookNamedItem) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceWorkbookNamedItem) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for WorkbookNamedItem
func (s *ServiceWorkbookNamedItem) DoRequestWithPath(method, path string, obj interface{}) (*WorkbookNamedItem, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *WorkbookNamedItem
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceWorkbookNamedItem) DoRequest(method string, obj interface{}) (*WorkbookNamedItem, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceWorkbookNamedItem) GetWithPath(path string) (*WorkbookNamedItem, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceWorkbookNamedItem) Get() (*WorkbookNamedItem, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceWorkbookNamedItem) PostWithPath(path string) (*WorkbookNamedItem, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceWorkbookNamedItem) Post() (*WorkbookNamedItem, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for WorkbookNamedItem collection with addtional path
func (s *ServiceCollectionWorkbookNamedItem) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionWorkbookNamedItem) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for WorkbookNamedItem
func (s *ServiceCollectionWorkbookNamedItem) DoRequestWithPath(method, path string, obj interface{}) (*WorkbookNamedItem, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *WorkbookNamedItem
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionWorkbookNamedItem) DoRequest(method string, obj interface{}) (*WorkbookNamedItem, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for WorkbookNamedItem collection
func (s *ServiceCollectionWorkbookNamedItem) DoPagingNext(res *http.Response) ([]WorkbookNamedItem, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []WorkbookNamedItem
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for WorkbookNamedItem collection
func (s *ServiceCollectionWorkbookNamedItem) DoPagingWithPath(method, path string, obj interface{}) ([]WorkbookNamedItem, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionWorkbookNamedItem) DoPaging(method string, obj interface{}) ([]WorkbookNamedItem, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionWorkbookNamedItem) GetWithPath(path string) ([]WorkbookNamedItem, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionWorkbookNamedItem) Get() ([]WorkbookNamedItem, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionWorkbookNamedItem) PostWithPath(path string, obj interface{}) (*WorkbookNamedItem, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionWorkbookNamedItem) Post(obj interface{}) (*WorkbookNamedItem, error) {
	return s.PostWithPath("", obj)
}

// Worksheet returns service endpoint for WorkbookWorksheet
func (s *ServiceWorkbookPivotTable) Worksheet() *ServiceWorkbookWorksheet {
	ss := &ServiceWorkbookWorksheet{ServiceBase: s.ServiceBase}
	ss.baseURL += "/worksheet"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for WorkbookPivotTable
func (s *ServiceWorkbookPivotTable) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceWorkbookPivotTable) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for WorkbookPivotTable
func (s *ServiceWorkbookPivotTable) DoRequestWithPath(method, path string, obj interface{}) (*WorkbookPivotTable, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *WorkbookPivotTable
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceWorkbookPivotTable) DoRequest(method string, obj interface{}) (*WorkbookPivotTable, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceWorkbookPivotTable) GetWithPath(path string) (*WorkbookPivotTable, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceWorkbookPivotTable) Get() (*WorkbookPivotTable, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceWorkbookPivotTable) PostWithPath(path string) (*WorkbookPivotTable, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceWorkbookPivotTable) Post() (*WorkbookPivotTable, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for WorkbookPivotTable collection with addtional path
func (s *ServiceCollectionWorkbookPivotTable) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionWorkbookPivotTable) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for WorkbookPivotTable
func (s *ServiceCollectionWorkbookPivotTable) DoRequestWithPath(method, path string, obj interface{}) (*WorkbookPivotTable, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *WorkbookPivotTable
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionWorkbookPivotTable) DoRequest(method string, obj interface{}) (*WorkbookPivotTable, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for WorkbookPivotTable collection
func (s *ServiceCollectionWorkbookPivotTable) DoPagingNext(res *http.Response) ([]WorkbookPivotTable, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []WorkbookPivotTable
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for WorkbookPivotTable collection
func (s *ServiceCollectionWorkbookPivotTable) DoPagingWithPath(method, path string, obj interface{}) ([]WorkbookPivotTable, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionWorkbookPivotTable) DoPaging(method string, obj interface{}) ([]WorkbookPivotTable, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionWorkbookPivotTable) GetWithPath(path string) ([]WorkbookPivotTable, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionWorkbookPivotTable) Get() ([]WorkbookPivotTable, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionWorkbookPivotTable) PostWithPath(path string, obj interface{}) (*WorkbookPivotTable, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionWorkbookPivotTable) Post(obj interface{}) (*WorkbookPivotTable, error) {
	return s.PostWithPath("", obj)
}

// Format returns service endpoint for WorkbookRangeFormat
func (s *ServiceWorkbookRange) Format() *ServiceWorkbookRangeFormat {
	ss := &ServiceWorkbookRangeFormat{ServiceBase: s.ServiceBase}
	ss.baseURL += "/format"
	return ss
}

// Sort returns service endpoint for WorkbookRangeSort
func (s *ServiceWorkbookRange) Sort() *ServiceWorkbookRangeSort {
	ss := &ServiceWorkbookRangeSort{ServiceBase: s.ServiceBase}
	ss.baseURL += "/sort"
	return ss
}

// Worksheet returns service endpoint for WorkbookWorksheet
func (s *ServiceWorkbookRange) Worksheet() *ServiceWorkbookWorksheet {
	ss := &ServiceWorkbookWorksheet{ServiceBase: s.ServiceBase}
	ss.baseURL += "/worksheet"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for WorkbookRange
func (s *ServiceWorkbookRange) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceWorkbookRange) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for WorkbookRange
func (s *ServiceWorkbookRange) DoRequestWithPath(method, path string, obj interface{}) (*WorkbookRange, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *WorkbookRange
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceWorkbookRange) DoRequest(method string, obj interface{}) (*WorkbookRange, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceWorkbookRange) GetWithPath(path string) (*WorkbookRange, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceWorkbookRange) Get() (*WorkbookRange, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceWorkbookRange) PostWithPath(path string) (*WorkbookRange, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceWorkbookRange) Post() (*WorkbookRange, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for WorkbookRangeBorder collection with addtional path
func (s *ServiceCollectionWorkbookRangeBorder) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionWorkbookRangeBorder) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for WorkbookRangeBorder
func (s *ServiceCollectionWorkbookRangeBorder) DoRequestWithPath(method, path string, obj interface{}) (*WorkbookRangeBorder, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *WorkbookRangeBorder
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionWorkbookRangeBorder) DoRequest(method string, obj interface{}) (*WorkbookRangeBorder, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for WorkbookRangeBorder collection
func (s *ServiceCollectionWorkbookRangeBorder) DoPagingNext(res *http.Response) ([]WorkbookRangeBorder, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []WorkbookRangeBorder
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for WorkbookRangeBorder collection
func (s *ServiceCollectionWorkbookRangeBorder) DoPagingWithPath(method, path string, obj interface{}) ([]WorkbookRangeBorder, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionWorkbookRangeBorder) DoPaging(method string, obj interface{}) ([]WorkbookRangeBorder, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionWorkbookRangeBorder) GetWithPath(path string) ([]WorkbookRangeBorder, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionWorkbookRangeBorder) Get() ([]WorkbookRangeBorder, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionWorkbookRangeBorder) PostWithPath(path string, obj interface{}) (*WorkbookRangeBorder, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionWorkbookRangeBorder) Post(obj interface{}) (*WorkbookRangeBorder, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for WorkbookRangeFill
func (s *ServiceWorkbookRangeFill) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceWorkbookRangeFill) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for WorkbookRangeFill
func (s *ServiceWorkbookRangeFill) DoRequestWithPath(method, path string, obj interface{}) (*WorkbookRangeFill, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *WorkbookRangeFill
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceWorkbookRangeFill) DoRequest(method string, obj interface{}) (*WorkbookRangeFill, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceWorkbookRangeFill) GetWithPath(path string) (*WorkbookRangeFill, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceWorkbookRangeFill) Get() (*WorkbookRangeFill, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceWorkbookRangeFill) PostWithPath(path string) (*WorkbookRangeFill, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceWorkbookRangeFill) Post() (*WorkbookRangeFill, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for WorkbookRangeFont
func (s *ServiceWorkbookRangeFont) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceWorkbookRangeFont) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for WorkbookRangeFont
func (s *ServiceWorkbookRangeFont) DoRequestWithPath(method, path string, obj interface{}) (*WorkbookRangeFont, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *WorkbookRangeFont
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceWorkbookRangeFont) DoRequest(method string, obj interface{}) (*WorkbookRangeFont, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceWorkbookRangeFont) GetWithPath(path string) (*WorkbookRangeFont, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceWorkbookRangeFont) Get() (*WorkbookRangeFont, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceWorkbookRangeFont) PostWithPath(path string) (*WorkbookRangeFont, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceWorkbookRangeFont) Post() (*WorkbookRangeFont, error) {
	return s.PostWithPath("")
}

// Borders returns service endpoint for CollectionWorkbookRangeBorder
func (s *ServiceWorkbookRangeFormat) Borders() *ServiceCollectionWorkbookRangeBorder {
	ss := &ServiceCollectionWorkbookRangeBorder{ServiceBase: s.ServiceBase}
	ss.baseURL += "/borders"
	return ss
}

// Fill returns service endpoint for WorkbookRangeFill
func (s *ServiceWorkbookRangeFormat) Fill() *ServiceWorkbookRangeFill {
	ss := &ServiceWorkbookRangeFill{ServiceBase: s.ServiceBase}
	ss.baseURL += "/fill"
	return ss
}

// Font returns service endpoint for WorkbookRangeFont
func (s *ServiceWorkbookRangeFormat) Font() *ServiceWorkbookRangeFont {
	ss := &ServiceWorkbookRangeFont{ServiceBase: s.ServiceBase}
	ss.baseURL += "/font"
	return ss
}

// Protection returns service endpoint for WorkbookFormatProtection
func (s *ServiceWorkbookRangeFormat) Protection() *ServiceWorkbookFormatProtection {
	ss := &ServiceWorkbookFormatProtection{ServiceBase: s.ServiceBase}
	ss.baseURL += "/protection"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for WorkbookRangeFormat
func (s *ServiceWorkbookRangeFormat) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceWorkbookRangeFormat) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for WorkbookRangeFormat
func (s *ServiceWorkbookRangeFormat) DoRequestWithPath(method, path string, obj interface{}) (*WorkbookRangeFormat, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *WorkbookRangeFormat
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceWorkbookRangeFormat) DoRequest(method string, obj interface{}) (*WorkbookRangeFormat, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceWorkbookRangeFormat) GetWithPath(path string) (*WorkbookRangeFormat, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceWorkbookRangeFormat) Get() (*WorkbookRangeFormat, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceWorkbookRangeFormat) PostWithPath(path string) (*WorkbookRangeFormat, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceWorkbookRangeFormat) Post() (*WorkbookRangeFormat, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for WorkbookRangeSort
func (s *ServiceWorkbookRangeSort) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceWorkbookRangeSort) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for WorkbookRangeSort
func (s *ServiceWorkbookRangeSort) DoRequestWithPath(method, path string, obj interface{}) (*WorkbookRangeSort, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *WorkbookRangeSort
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceWorkbookRangeSort) DoRequest(method string, obj interface{}) (*WorkbookRangeSort, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceWorkbookRangeSort) GetWithPath(path string) (*WorkbookRangeSort, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceWorkbookRangeSort) Get() (*WorkbookRangeSort, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceWorkbookRangeSort) PostWithPath(path string) (*WorkbookRangeSort, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceWorkbookRangeSort) Post() (*WorkbookRangeSort, error) {
	return s.PostWithPath("")
}

// Rows returns service endpoint for CollectionWorkbookRangeView
func (s *ServiceWorkbookRangeView) Rows() *ServiceCollectionWorkbookRangeView {
	ss := &ServiceCollectionWorkbookRangeView{ServiceBase: s.ServiceBase}
	ss.baseURL += "/rows"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for WorkbookRangeView
func (s *ServiceWorkbookRangeView) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceWorkbookRangeView) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for WorkbookRangeView
func (s *ServiceWorkbookRangeView) DoRequestWithPath(method, path string, obj interface{}) (*WorkbookRangeView, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *WorkbookRangeView
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceWorkbookRangeView) DoRequest(method string, obj interface{}) (*WorkbookRangeView, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceWorkbookRangeView) GetWithPath(path string) (*WorkbookRangeView, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceWorkbookRangeView) Get() (*WorkbookRangeView, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceWorkbookRangeView) PostWithPath(path string) (*WorkbookRangeView, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceWorkbookRangeView) Post() (*WorkbookRangeView, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for WorkbookRangeView collection with addtional path
func (s *ServiceCollectionWorkbookRangeView) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionWorkbookRangeView) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for WorkbookRangeView
func (s *ServiceCollectionWorkbookRangeView) DoRequestWithPath(method, path string, obj interface{}) (*WorkbookRangeView, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *WorkbookRangeView
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionWorkbookRangeView) DoRequest(method string, obj interface{}) (*WorkbookRangeView, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for WorkbookRangeView collection
func (s *ServiceCollectionWorkbookRangeView) DoPagingNext(res *http.Response) ([]WorkbookRangeView, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []WorkbookRangeView
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for WorkbookRangeView collection
func (s *ServiceCollectionWorkbookRangeView) DoPagingWithPath(method, path string, obj interface{}) ([]WorkbookRangeView, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionWorkbookRangeView) DoPaging(method string, obj interface{}) ([]WorkbookRangeView, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionWorkbookRangeView) GetWithPath(path string) ([]WorkbookRangeView, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionWorkbookRangeView) Get() ([]WorkbookRangeView, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionWorkbookRangeView) PostWithPath(path string, obj interface{}) (*WorkbookRangeView, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionWorkbookRangeView) Post(obj interface{}) (*WorkbookRangeView, error) {
	return s.PostWithPath("", obj)
}

// Columns returns service endpoint for CollectionWorkbookTableColumn
func (s *ServiceWorkbookTable) Columns() *ServiceCollectionWorkbookTableColumn {
	ss := &ServiceCollectionWorkbookTableColumn{ServiceBase: s.ServiceBase}
	ss.baseURL += "/columns"
	return ss
}

// Rows returns service endpoint for CollectionWorkbookTableRow
func (s *ServiceWorkbookTable) Rows() *ServiceCollectionWorkbookTableRow {
	ss := &ServiceCollectionWorkbookTableRow{ServiceBase: s.ServiceBase}
	ss.baseURL += "/rows"
	return ss
}

// Sort returns service endpoint for WorkbookTableSort
func (s *ServiceWorkbookTable) Sort() *ServiceWorkbookTableSort {
	ss := &ServiceWorkbookTableSort{ServiceBase: s.ServiceBase}
	ss.baseURL += "/sort"
	return ss
}

// Worksheet returns service endpoint for WorkbookWorksheet
func (s *ServiceWorkbookTable) Worksheet() *ServiceWorkbookWorksheet {
	ss := &ServiceWorkbookWorksheet{ServiceBase: s.ServiceBase}
	ss.baseURL += "/worksheet"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for WorkbookTable
func (s *ServiceWorkbookTable) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceWorkbookTable) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for WorkbookTable
func (s *ServiceWorkbookTable) DoRequestWithPath(method, path string, obj interface{}) (*WorkbookTable, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *WorkbookTable
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceWorkbookTable) DoRequest(method string, obj interface{}) (*WorkbookTable, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceWorkbookTable) GetWithPath(path string) (*WorkbookTable, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceWorkbookTable) Get() (*WorkbookTable, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceWorkbookTable) PostWithPath(path string) (*WorkbookTable, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceWorkbookTable) Post() (*WorkbookTable, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for WorkbookTable collection with addtional path
func (s *ServiceCollectionWorkbookTable) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionWorkbookTable) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for WorkbookTable
func (s *ServiceCollectionWorkbookTable) DoRequestWithPath(method, path string, obj interface{}) (*WorkbookTable, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *WorkbookTable
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionWorkbookTable) DoRequest(method string, obj interface{}) (*WorkbookTable, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for WorkbookTable collection
func (s *ServiceCollectionWorkbookTable) DoPagingNext(res *http.Response) ([]WorkbookTable, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []WorkbookTable
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for WorkbookTable collection
func (s *ServiceCollectionWorkbookTable) DoPagingWithPath(method, path string, obj interface{}) ([]WorkbookTable, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionWorkbookTable) DoPaging(method string, obj interface{}) ([]WorkbookTable, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionWorkbookTable) GetWithPath(path string) ([]WorkbookTable, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionWorkbookTable) Get() ([]WorkbookTable, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionWorkbookTable) PostWithPath(path string, obj interface{}) (*WorkbookTable, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionWorkbookTable) Post(obj interface{}) (*WorkbookTable, error) {
	return s.PostWithPath("", obj)
}

// Filter returns service endpoint for WorkbookFilter
func (s *ServiceWorkbookTableColumn) Filter() *ServiceWorkbookFilter {
	ss := &ServiceWorkbookFilter{ServiceBase: s.ServiceBase}
	ss.baseURL += "/filter"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for WorkbookTableColumn
func (s *ServiceWorkbookTableColumn) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceWorkbookTableColumn) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for WorkbookTableColumn
func (s *ServiceWorkbookTableColumn) DoRequestWithPath(method, path string, obj interface{}) (*WorkbookTableColumn, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *WorkbookTableColumn
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceWorkbookTableColumn) DoRequest(method string, obj interface{}) (*WorkbookTableColumn, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceWorkbookTableColumn) GetWithPath(path string) (*WorkbookTableColumn, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceWorkbookTableColumn) Get() (*WorkbookTableColumn, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceWorkbookTableColumn) PostWithPath(path string) (*WorkbookTableColumn, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceWorkbookTableColumn) Post() (*WorkbookTableColumn, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for WorkbookTableColumn collection with addtional path
func (s *ServiceCollectionWorkbookTableColumn) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionWorkbookTableColumn) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for WorkbookTableColumn
func (s *ServiceCollectionWorkbookTableColumn) DoRequestWithPath(method, path string, obj interface{}) (*WorkbookTableColumn, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *WorkbookTableColumn
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionWorkbookTableColumn) DoRequest(method string, obj interface{}) (*WorkbookTableColumn, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for WorkbookTableColumn collection
func (s *ServiceCollectionWorkbookTableColumn) DoPagingNext(res *http.Response) ([]WorkbookTableColumn, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []WorkbookTableColumn
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for WorkbookTableColumn collection
func (s *ServiceCollectionWorkbookTableColumn) DoPagingWithPath(method, path string, obj interface{}) ([]WorkbookTableColumn, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionWorkbookTableColumn) DoPaging(method string, obj interface{}) ([]WorkbookTableColumn, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionWorkbookTableColumn) GetWithPath(path string) ([]WorkbookTableColumn, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionWorkbookTableColumn) Get() ([]WorkbookTableColumn, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionWorkbookTableColumn) PostWithPath(path string, obj interface{}) (*WorkbookTableColumn, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionWorkbookTableColumn) Post(obj interface{}) (*WorkbookTableColumn, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for WorkbookTableRow collection with addtional path
func (s *ServiceCollectionWorkbookTableRow) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionWorkbookTableRow) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for WorkbookTableRow
func (s *ServiceCollectionWorkbookTableRow) DoRequestWithPath(method, path string, obj interface{}) (*WorkbookTableRow, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *WorkbookTableRow
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionWorkbookTableRow) DoRequest(method string, obj interface{}) (*WorkbookTableRow, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for WorkbookTableRow collection
func (s *ServiceCollectionWorkbookTableRow) DoPagingNext(res *http.Response) ([]WorkbookTableRow, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []WorkbookTableRow
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for WorkbookTableRow collection
func (s *ServiceCollectionWorkbookTableRow) DoPagingWithPath(method, path string, obj interface{}) ([]WorkbookTableRow, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionWorkbookTableRow) DoPaging(method string, obj interface{}) ([]WorkbookTableRow, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionWorkbookTableRow) GetWithPath(path string) ([]WorkbookTableRow, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionWorkbookTableRow) Get() ([]WorkbookTableRow, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionWorkbookTableRow) PostWithPath(path string, obj interface{}) (*WorkbookTableRow, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionWorkbookTableRow) Post(obj interface{}) (*WorkbookTableRow, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for WorkbookTableSort
func (s *ServiceWorkbookTableSort) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceWorkbookTableSort) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for WorkbookTableSort
func (s *ServiceWorkbookTableSort) DoRequestWithPath(method, path string, obj interface{}) (*WorkbookTableSort, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *WorkbookTableSort
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceWorkbookTableSort) DoRequest(method string, obj interface{}) (*WorkbookTableSort, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceWorkbookTableSort) GetWithPath(path string) (*WorkbookTableSort, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceWorkbookTableSort) Get() (*WorkbookTableSort, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceWorkbookTableSort) PostWithPath(path string) (*WorkbookTableSort, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceWorkbookTableSort) Post() (*WorkbookTableSort, error) {
	return s.PostWithPath("")
}

// Charts returns service endpoint for CollectionWorkbookChart
func (s *ServiceWorkbookWorksheet) Charts() *ServiceCollectionWorkbookChart {
	ss := &ServiceCollectionWorkbookChart{ServiceBase: s.ServiceBase}
	ss.baseURL += "/charts"
	return ss
}

// Names returns service endpoint for CollectionWorkbookNamedItem
func (s *ServiceWorkbookWorksheet) Names() *ServiceCollectionWorkbookNamedItem {
	ss := &ServiceCollectionWorkbookNamedItem{ServiceBase: s.ServiceBase}
	ss.baseURL += "/names"
	return ss
}

// PivotTables returns service endpoint for CollectionWorkbookPivotTable
func (s *ServiceWorkbookWorksheet) PivotTables() *ServiceCollectionWorkbookPivotTable {
	ss := &ServiceCollectionWorkbookPivotTable{ServiceBase: s.ServiceBase}
	ss.baseURL += "/pivotTables"
	return ss
}

// Protection returns service endpoint for WorkbookWorksheetProtection
func (s *ServiceWorkbookWorksheet) Protection() *ServiceWorkbookWorksheetProtection {
	ss := &ServiceWorkbookWorksheetProtection{ServiceBase: s.ServiceBase}
	ss.baseURL += "/protection"
	return ss
}

// Tables returns service endpoint for CollectionWorkbookTable
func (s *ServiceWorkbookWorksheet) Tables() *ServiceCollectionWorkbookTable {
	ss := &ServiceCollectionWorkbookTable{ServiceBase: s.ServiceBase}
	ss.baseURL += "/tables"
	return ss
}

// NewRequestWithPath returns a new HTTP Request for WorkbookWorksheet
func (s *ServiceWorkbookWorksheet) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceWorkbookWorksheet) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for WorkbookWorksheet
func (s *ServiceWorkbookWorksheet) DoRequestWithPath(method, path string, obj interface{}) (*WorkbookWorksheet, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *WorkbookWorksheet
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceWorkbookWorksheet) DoRequest(method string, obj interface{}) (*WorkbookWorksheet, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceWorkbookWorksheet) GetWithPath(path string) (*WorkbookWorksheet, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceWorkbookWorksheet) Get() (*WorkbookWorksheet, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceWorkbookWorksheet) PostWithPath(path string) (*WorkbookWorksheet, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceWorkbookWorksheet) Post() (*WorkbookWorksheet, error) {
	return s.PostWithPath("")
}

// NewRequestWithPath returns a new HTTP Request for WorkbookWorksheet collection with addtional path
func (s *ServiceCollectionWorkbookWorksheet) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceCollectionWorkbookWorksheet) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for WorkbookWorksheet
func (s *ServiceCollectionWorkbookWorksheet) DoRequestWithPath(method, path string, obj interface{}) (*WorkbookWorksheet, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *WorkbookWorksheet
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceCollectionWorkbookWorksheet) DoRequest(method string, obj interface{}) (*WorkbookWorksheet, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// DoPagingNext handles paging for WorkbookWorksheet collection
func (s *ServiceCollectionWorkbookWorksheet) DoPagingNext(res *http.Response) ([]WorkbookWorksheet, error) {
	if res.StatusCode != http.StatusOK {
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
	var (
		obj              Paging
		value, nextValue []WorkbookWorksheet
	)
	err := json.NewDecoder(res.Body).Decode(&obj)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(obj.Value, &value)
	if err != nil {
		return nil, err
	}
	if len(obj.NextLink) > 0 {
		res, err := s.client.Get(obj.NextLink)
		if err != nil {
			return nil, err
		}
		nextValue, err = s.DoPagingNext(res)
		if err != nil {
			return nil, err
		}
	}
	return append(value, nextValue...), nil
}

// DoPagingWithPath issues an HTTP request for WorkbookWorksheet collection
func (s *ServiceCollectionWorkbookWorksheet) DoPagingWithPath(method, path string, obj interface{}) ([]WorkbookWorksheet, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	return s.DoPagingNext(res)
}

// DoPaging wraps DoPagingWithPath with empty path
func (s *ServiceCollectionWorkbookWorksheet) DoPaging(method string, obj interface{}) ([]WorkbookWorksheet, error) {
	return s.DoPagingWithPath(method, "", obj)
}

// GetWithPath warps DoPagingWithPath with GET method and nil object
func (s *ServiceCollectionWorkbookWorksheet) GetWithPath(path string) ([]WorkbookWorksheet, error) {
	return s.DoPagingWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceCollectionWorkbookWorksheet) Get() ([]WorkbookWorksheet, error) {
	return s.GetWithPath("")
}

// PostWithPath warps DoRequestWithPath with POST method
func (s *ServiceCollectionWorkbookWorksheet) PostWithPath(path string, obj interface{}) (*WorkbookWorksheet, error) {
	return s.DoRequestWithPath("POST", path, obj)
}

// Post wraps PostWithPath with empty path
func (s *ServiceCollectionWorkbookWorksheet) Post(obj interface{}) (*WorkbookWorksheet, error) {
	return s.PostWithPath("", obj)
}

// NewRequestWithPath returns a new HTTP Request for WorkbookWorksheetProtection
func (s *ServiceWorkbookWorksheetProtection) NewRequestWithPath(method, path string, body io.Reader) (*http.Request, error) {
	return http.NewRequest(method, s.baseURL+path, body)
}

// NewRequest wraps NewRequestWithPath with empty path
func (s *ServiceWorkbookWorksheetProtection) NewRequest(method string, body io.Reader) (*http.Request, error) {
	return s.NewRequestWithPath(method, "", body)
}

// DoRequestWithPath issues an HTTP request for WorkbookWorksheetProtection
func (s *ServiceWorkbookWorksheetProtection) DoRequestWithPath(method, path string, obj interface{}) (*WorkbookWorksheetProtection, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := json.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := s.NewRequestWithPath(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	switch res.StatusCode {
	case http.StatusOK:
		var obj *WorkbookWorksheetProtection
		err := json.NewDecoder(res.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case http.StatusNoContent:
		return nil, nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		return nil, fmt.Errorf("%s: %s", res.Status, string(b))
	}
}

// DoRequest wraps DoRequestWithPath with empty path
func (s *ServiceWorkbookWorksheetProtection) DoRequest(method string, obj interface{}) (*WorkbookWorksheetProtection, error) {
	return s.DoRequestWithPath(method, "", obj)
}

// GetWithPath wraps DoRequestWithPath with GET method
func (s *ServiceWorkbookWorksheetProtection) GetWithPath(path string) (*WorkbookWorksheetProtection, error) {
	return s.DoRequestWithPath("GET", path, nil)
}

// Get wraps GetWithPath with empty path
func (s *ServiceWorkbookWorksheetProtection) Get() (*WorkbookWorksheetProtection, error) {
	return s.GetWithPath("")
}

// PostWithPath wraps DoRequestWithPath with POST method
func (s *ServiceWorkbookWorksheetProtection) PostWithPath(path string) (*WorkbookWorksheetProtection, error) {
	return s.DoRequestWithPath("POST", path, nil)
}

// Post wraps PostWithPath with empty path
func (s *ServiceWorkbookWorksheetProtection) Post() (*WorkbookWorksheetProtection, error) {
	return s.PostWithPath("")
}

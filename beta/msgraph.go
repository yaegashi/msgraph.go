// Code generated by msgraph-generate.go DO NOT EDIT.

package msgraph

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strconv"
	"time"

	"github.com/rickb777/date/period"
	"github.com/yaegashi/msgraph.go/jsonx"
)

const (
	defaultBaseURL = "https://graph.microsoft.com/beta"
)

// Binary is type alias for Edm.Binary
type Binary []byte

// Stream is type alias for Edm.Stream
type Stream []byte

// UUID is type alias for Edm.Guid
type UUID string

// Date is type alias for Edm.Date
type Date string

// NewDate creates Date from time.Time
func NewDate(t time.Time) *Date {
	s := t.Format("2006-01-02")
	return (*Date)(&s)
}

// Time converts Date to time.Time
func (d *Date) Time() (time.Time, error) {
	return time.Parse("2006-01-02", string(*d))
}

// TimeOfDay is type alis for Edm.TimeOfDay
type TimeOfDay string

// NewTimeOfDay creates NewTimeOfDay from time.Time
func NewTimeOfDay(t time.Time) *TimeOfDay {
	s := t.Format("15:04:05")
	return (*TimeOfDay)(&s)
}

// Time converts TimeOfDay to time.Time
func (t *TimeOfDay) Time() (time.Time, error) {
	return time.Parse("15:04:05", string(*t))
}

// Duration is type alias for Edm.Duration
type Duration string

// NewDuration creates Duration from time.Duration
func NewDuration(d time.Duration) *Duration {
	p, _ := period.NewOf(d)
	s := p.String()
	return (*Duration)(&s)
}

// Time converts Duration to time.Duration
func (d *Duration) Time() (time.Duration, error) {
	p, err := period.Parse(string(*d))
	if err != nil {
		return 0, err
	}
	return p.DurationApprox(), nil
}

// Object is the common ancestor of all models
type Object struct {
	// AdditionalData contains all other fields not defined above
	AdditionalData map[string]interface{} `json:"-" jsonx:"true"`
}

// SetAdditionalData sets object's additional data
func (o *Object) SetAdditionalData(key string, val interface{}) {
	if o.AdditionalData == nil {
		o.AdditionalData = map[string]interface{}{key: val}
	} else {
		o.AdditionalData[key] = val
	}
}

// GetAdditionalData gets object's additional data
func (o *Object) GetAdditionalData(key string) (interface{}, bool) {
	if o.AdditionalData == nil {
		return nil, false
	} else {
		val, ok := o.AdditionalData[key]
		return val, ok
	}
}

// ErrorObject is common error object
type ErrorObject struct {
	Code    string `json:"code"`
	Message string `json:"message"`
	Object
}

// ErrorResponse is common error response
type ErrorResponse struct {
	ErrorObject ErrorObject    `json:"error"`
	Response    *http.Response `json:"-"`
	Object
}

// Error implements error interface
func (r *ErrorResponse) Error() string {
	b, _ := jsonx.Marshal(r)
	return fmt.Sprintf("%s: %s", r.Status(), string(b))
}

// Status returns status, "000 Unknown" if response is nil
func (r *ErrorResponse) Status() string {
	if r.Response == nil {
		return "000 Unknown"
	}
	return r.Response.Status
}

// StatusCode returns status code, 0 if response is nil
func (r *ErrorResponse) StatusCode() int {
	if r.Response == nil {
		return 0
	}
	return r.Response.StatusCode
}

// Paging is sturct returned to paging requests
type Paging struct {
	NextLink string          `json:"@odata.nextLink"`
	Value    json.RawMessage `json:"value"`
}

// BaseRequestBuilder is base reuqest builder
type BaseRequestBuilder struct {
	baseURL       string
	client        *http.Client
	requestObject interface{}
}

// URL returns URL
func (r *BaseRequestBuilder) URL() string {
	return r.baseURL
}

// SetURL sets the baseURL
func (r *BaseRequestBuilder) SetURL(baseURL string) {
	r.baseURL = baseURL
}

// BaseRequest is base request
type BaseRequest struct {
	baseURL       string
	client        *http.Client
	requestObject interface{}
	header        http.Header
	query         url.Values
}

// URL returns URL with queries
func (r *BaseRequest) URL() string {
	var query string
	if r.query != nil {
		query = "?" + r.query.Encode()
	}
	return r.baseURL + query
}

// Client returns HTTP client
func (r *BaseRequest) Client() *http.Client {
	return r.client
}

// Header returns headers of the request
func (r *BaseRequest) Header() http.Header {
	if r.header == nil {
		r.header = http.Header{}
	}
	return r.header
}

// Query returns queries of the request
func (r *BaseRequest) Query() url.Values {
	if r.query == nil {
		r.query = url.Values{}
	}
	return r.query
}

// Expand adds $expand query
func (r *BaseRequest) Expand(value string) {
	if r.query == nil {
		r.query = url.Values{}
	}
	r.query.Add("$expand", value)
}

// Select adds $select query
func (r *BaseRequest) Select(value string) {
	if r.query == nil {
		r.query = url.Values{}
	}
	r.query.Add("$select", value)
}

// Top adds $top query
func (r *BaseRequest) Top(value int) {
	if r.query == nil {
		r.query = url.Values{}
	}
	r.query.Add("$top", strconv.Itoa(value))
}

// Filter adds $filter query
func (r *BaseRequest) Filter(value string) {
	if r.query == nil {
		r.query = url.Values{}
	}
	r.query.Add("$filter", value)
}

// Skip adds $skip query
func (r *BaseRequest) Skip(value int) {
	if r.query == nil {
		r.query = url.Values{}
	}
	r.query.Add("$skip", strconv.Itoa(value))
}

// OrderBy adds $orderby query
func (r *BaseRequest) OrderBy(value string) {
	if r.query == nil {
		r.query = url.Values{}
	}
	r.query.Add("$orderby", value)
}

// NewRequest returns new HTTP request
func (r *BaseRequest) NewRequest(method, path string, body io.Reader) (*http.Request, error) {
	req, err := http.NewRequest(method, r.baseURL+path, body)
	if err != nil {
		return nil, err
	}
	if r.header != nil {
		for key, values := range r.header {
			for _, value := range values {
				req.Header.Add(key, value)
			}
		}
	}
	return req, nil
}

// NewJSONRequest returns new HTTP request with JSON payload
func (r *BaseRequest) NewJSONRequest(method, path string, obj interface{}) (*http.Request, error) {
	buf := &bytes.Buffer{}
	if obj != nil {
		err := jsonx.NewEncoder(buf).Encode(obj)
		if err != nil {
			return nil, err
		}
	}
	req, err := r.NewRequest(method, path, buf)
	if err != nil {
		return nil, err
	}
	if obj != nil {
		req.Header.Add("Content-Type", "application/json")
	}
	return req, nil
}

// DecodeJSONResponse decodes HTTP response with JSON payload
func (r *BaseRequest) DecodeJSONResponse(res *http.Response, obj interface{}) error {
	switch res.StatusCode {
	case http.StatusOK, http.StatusCreated:
		if obj != nil {
			err := jsonx.NewDecoder(res.Body).Decode(obj)
			if err != nil {
				return err
			}
		}
		return nil
	case http.StatusNoContent:
		return nil
	default:
		b, _ := ioutil.ReadAll(res.Body)
		errRes := &ErrorResponse{Response: res}
		err := jsonx.Unmarshal(b, errRes)
		if err != nil {
			return fmt.Errorf("%s: %s", res.Status, string(b))
		}
		return errRes
	}
}

// JSONRequest issues HTTP request with JSON payload
func (r *BaseRequest) JSONRequest(ctx context.Context, method, path string, reqObj, resObj interface{}) error {
	req, err := r.NewJSONRequest(method, path, reqObj)
	if err != nil {
		return err
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}
	res, err := r.client.Do(req)
	if err != nil {
		return err
	}
	defer res.Body.Close()
	return r.DecodeJSONResponse(res, resObj)
}

// GraphServiceRequestBuilder is GraphService reuqest builder
type GraphServiceRequestBuilder struct {
	BaseRequestBuilder
}

// NewClient returns GraphService request builder with default base URL
func NewClient(cli *http.Client) *GraphServiceRequestBuilder {
	return &GraphServiceRequestBuilder{
		BaseRequestBuilder: BaseRequestBuilder{baseURL: defaultBaseURL, client: cli},
	}
}

// BatchRequest is a batch request
type BatchRequest struct {
	BaseRequest
	request batchRequest
	results []BatchResult
}

// batchOneRequest is one request included in the batch request
type batchOneRequest struct {
	Id     string      `json:"id"`
	Method string      `json:"method"`
	Path   string      `json:"url"`
	Header BatchHeader `json:"headers"`
	Body   interface{} `json:"body,omitempty"`
}

// BatchHeader is the header of the individual request in Batch Request
type BatchHeader struct {
	ContentType string `json:"Content-Type"`
}

// batchRequest is the batch request
type batchRequest struct {
	Requests []batchOneRequest `json:"requests,omitempty"`
}

// batchOneResponse is one response included in the batch response
type batchOneResponse struct {
	Id     string `json:"id"`
	Status int    `json:"status"`
	Body   []byte `json:"body"`
}

// batchResponse is the batch response
type batchResponse struct {
	NextLink  string             `json:"nextLink"`
	Responses []batchOneResponse `json:"responses,omitempty"`
}

// BatchResult is the one result derived from one response included in the batch response
type BatchResult struct {
	Error  error // Error might be non-200 http status code error or Unmarshal response error
	Result interface{}
}

// Add adds a request into the BatchRequest
func (r *BatchRequest) Add(method, path string, reqObj, resObj interface{}) error {
	oneRequest := batchOneRequest{Id: strconv.Itoa(len(r.request.Requests)), Method: method, Path: path, Body: reqObj}
	if reqObj != nil {
		oneRequest.Header.ContentType = "application/json"
	}
	r.request.Requests = append(r.request.Requests, oneRequest)
	r.results = append(r.results, BatchResult{Result: resObj})
	return nil
}

// Run invokes the batch request
func (r *BatchRequest) Run(ctx context.Context) ([]BatchResult, error) {
	// Batch size is limited to 20 individual requests: https://docs.microsoft.com/en-us/graph/known-issues#limit-on-batch-size
	const size = 20
	for offset := 0; offset < (len(r.request.Requests)+size-1)/size; offset += size {
		if err := r.run(ctx, offset, size); err != nil {
			return nil, err
		}
	}
	return r.results, nil
}

// run composes up to "size" individual requests from "offset" of the containing requests queue of the Batch and update its results internally.
func (r *BatchRequest) run(ctx context.Context, offset int, size int) error {
	if offset > len(r.request.Requests) {
		return nil
	}

	stop := offset + size
	if offset+size > len(r.request.Requests) {
		stop = len(r.request.Requests)
	}

	var request batchRequest
	for i := offset; i < stop; i++ {
		request.Requests = append(request.Requests, r.request.Requests[i])
	}

	req, err := r.NewJSONRequest("POST", "", request)
	if err != nil {
		return err
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}
	res, err := r.client.Do(req)
	if err != nil {
		return err
	}

	for {
		defer res.Body.Close()
		if res.StatusCode != http.StatusOK {
			b, _ := ioutil.ReadAll(res.Body)
			errRes := &ErrorResponse{Response: res}
			err := jsonx.Unmarshal(b, errRes)
			if err != nil {
				return err
			}
			return errRes
		}
		var paging batchResponse
		err := jsonx.NewDecoder(res.Body).Decode(&paging)
		if err != nil {
			return err
		}
		for _, response := range paging.Responses {
			id, err := strconv.Atoi(response.Id)
			if err != nil {
				return fmt.Errorf("converting ID %s: %v", response.Id, err)
			}
			result := r.results[id]
			if response.Status != http.StatusOK {
				b, _ := ioutil.ReadAll(res.Body)
				errRes := &ErrorResponse{Response: res}
				err := jsonx.Unmarshal(b, errRes)
				if err != nil {
					result.Error = fmt.Errorf("%s: %s", res.Status, string(b))
					continue
				}
				result.Error = errRes
				continue
			}
			if result.Result != nil {
				if err := jsonx.Unmarshal(response.Body, &result.Result); err != nil {
					result.Error = fmt.Errorf("unmarshalling response: %v", err)
					continue
				}
			}
		}
		if len(paging.NextLink) == 0 {
			return nil
		}
		req, err = http.NewRequest("POST", paging.NextLink, nil)
		if ctx != nil {
			req = req.WithContext(ctx)
		}
		res, err = r.client.Do(req)
		if err != nil {
			return err
		}
	}
}

// Rest resets the batch request
func (r *BatchRequest) Reset() {
	r.request.Requests = []batchOneRequest{}
	r.results = []BatchResult{}
}

// BatchRequestBuilder is BatchRequest request builder
type BatchRequestBuilder struct {
	BaseRequestBuilder
}

// Request returns BatchRequest
func (b *BatchRequestBuilder) Request() *BatchRequest {
	return &BatchRequest{BaseRequest: BaseRequest{baseURL: b.baseURL, client: b.client}}
}

// NewBatch returns BatchRequestBuilder
func NewBatch(cli *http.Client) *BatchRequestBuilder {
	return &BatchRequestBuilder{BaseRequestBuilder: BaseRequestBuilder{baseURL: defaultBaseURL + "/$batch", client: cli}}
}
